
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model auditoria
 * 
 */
export type auditoria = $Result.DefaultSelection<Prisma.$auditoriaPayload>
/**
 * Model beneficiosCursos
 * 
 */
export type beneficiosCursos = $Result.DefaultSelection<Prisma.$beneficiosCursosPayload>
/**
 * Model calificaciones
 * 
 */
export type calificaciones = $Result.DefaultSelection<Prisma.$calificacionesPayload>
/**
 * Model categorias
 * 
 */
export type categorias = $Result.DefaultSelection<Prisma.$categoriasPayload>
/**
 * Model categoriasCursos
 * 
 */
export type categoriasCursos = $Result.DefaultSelection<Prisma.$categoriasCursosPayload>
/**
 * Model certificados
 * 
 */
export type certificados = $Result.DefaultSelection<Prisma.$certificadosPayload>
/**
 * Model clases
 * 
 */
export type clases = $Result.DefaultSelection<Prisma.$clasesPayload>
/**
 * Model compras
 * 
 */
export type compras = $Result.DefaultSelection<Prisma.$comprasPayload>
/**
 * Model cursos
 * 
 */
export type cursos = $Result.DefaultSelection<Prisma.$cursosPayload>
/**
 * Model docente
 * 
 */
export type docente = $Result.DefaultSelection<Prisma.$docentePayload>
/**
 * Model edicionesCursos
 * 
 */
export type edicionesCursos = $Result.DefaultSelection<Prisma.$edicionesCursosPayload>
/**
 * Model estudiantes
 * 
 */
export type estudiantes = $Result.DefaultSelection<Prisma.$estudiantesPayload>
/**
 * Model temas
 * 
 */
export type temas = $Result.DefaultSelection<Prisma.$temasPayload>
/**
 * Model examenes
 * 
 */
export type examenes = $Result.DefaultSelection<Prisma.$examenesPayload>
/**
 * Model grabaciones
 * 
 */
export type grabaciones = $Result.DefaultSelection<Prisma.$grabacionesPayload>
/**
 * Model inscripciones
 * 
 */
export type inscripciones = $Result.DefaultSelection<Prisma.$inscripcionesPayload>
/**
 * Model materiales
 * 
 */
export type materiales = $Result.DefaultSelection<Prisma.$materialesPayload>
/**
 * Model objetivosCursos
 * 
 */
export type objetivosCursos = $Result.DefaultSelection<Prisma.$objetivosCursosPayload>
/**
 * Model pagosDocentes
 * 
 */
export type pagosDocentes = $Result.DefaultSelection<Prisma.$pagosDocentesPayload>
/**
 * Model preciosCursos
 * 
 */
export type preciosCursos = $Result.DefaultSelection<Prisma.$preciosCursosPayload>
/**
 * Model preguntas
 * 
 */
export type preguntas = $Result.DefaultSelection<Prisma.$preguntasPayload>
/**
 * Model reaccionesPreguntas
 * 
 */
export type reaccionesPreguntas = $Result.DefaultSelection<Prisma.$reaccionesPreguntasPayload>
/**
 * Model requisitosCursos
 * 
 */
export type requisitosCursos = $Result.DefaultSelection<Prisma.$requisitosCursosPayload>
/**
 * Model reviewsCursos
 * 
 */
export type reviewsCursos = $Result.DefaultSelection<Prisma.$reviewsCursosPayload>
/**
 * Model usuariosAdministradores
 * 
 */
export type usuariosAdministradores = $Result.DefaultSelection<Prisma.$usuariosAdministradoresPayload>
/**
 * Model usuariosEstudiantes
 * 
 */
export type usuariosEstudiantes = $Result.DefaultSelection<Prisma.$usuariosEstudiantesPayload>
/**
 * Model areas
 * 
 */
export type areas = $Result.DefaultSelection<Prisma.$areasPayload>
/**
 * Model banqueo
 * 
 */
export type banqueo = $Result.DefaultSelection<Prisma.$banqueoPayload>
/**
 * Model capitulos
 * 
 */
export type capitulos = $Result.DefaultSelection<Prisma.$capitulosPayload>
/**
 * Model intentos
 * 
 */
export type intentos = $Result.DefaultSelection<Prisma.$intentosPayload>
/**
 * Model respuestasIntentos
 * 
 */
export type respuestasIntentos = $Result.DefaultSelection<Prisma.$respuestasIntentosPayload>
/**
 * Model repasoRegistros
 * 
 */
export type repasoRegistros = $Result.DefaultSelection<Prisma.$repasoRegistrosPayload>
/**
 * Model suscripciones
 * 
 */
export type suscripciones = $Result.DefaultSelection<Prisma.$suscripcionesPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AccionAuditoria: {
  CREAR: 'CREAR',
  ACTUALIZAR: 'ACTUALIZAR',
  ESTADO: 'ESTADO',
  ELIMINAR: 'ELIMINAR'
};

export type AccionAuditoria = (typeof AccionAuditoria)[keyof typeof AccionAuditoria]


export const EdicionEstado: {
  ESPERA: 'ESPERA',
  ACTIVA: 'ACTIVA',
  FINALIZADA: 'FINALIZADA'
};

export type EdicionEstado = (typeof EdicionEstado)[keyof typeof EdicionEstado]


export const EstadoPago: {
  PENDIENTE: 'PENDIENTE',
  COMPLETADO: 'COMPLETADO',
  RECHAZADO: 'RECHAZADO',
  REEMBOLSADO: 'REEMBOLSADO'
};

export type EstadoPago = (typeof EstadoPago)[keyof typeof EstadoPago]


export const MetodoPago: {
  YAPE: 'YAPE',
  PLIN: 'PLIN',
  PAYPAL: 'PAYPAL',
  BINANCE: 'BINANCE',
  WESTER_UNION: 'WESTER_UNION',
  TRANSFERENCIA: 'TRANSFERENCIA',
  TRANSFERENCIA_DOLARES: 'TRANSFERENCIA_DOLARES',
  EFECTIVO: 'EFECTIVO',
  OTRO: 'OTRO'
};

export type MetodoPago = (typeof MetodoPago)[keyof typeof MetodoPago]


export const Pais: {
  PE: 'PE',
  BO: 'BO',
  AR: 'AR',
  CL: 'CL',
  CO: 'CO',
  EC: 'EC',
  MX: 'MX',
  VE: 'VE',
  ES: 'ES',
  US: 'US'
};

export type Pais = (typeof Pais)[keyof typeof Pais]


export const PreguntaEstado: {
  BORRADOR: 'BORRADOR',
  DISPONIBLE: 'DISPONIBLE',
  ARCHIVADO: 'ARCHIVADO'
};

export type PreguntaEstado = (typeof PreguntaEstado)[keyof typeof PreguntaEstado]


export const Tabla: {
  AUDITORIA: 'AUDITORIA',
  CATEGORIAS: 'CATEGORIAS',
  USUARIOS_ESTUDIANTES: 'USUARIOS_ESTUDIANTES',
  ESTUDIANTES: 'ESTUDIANTES',
  USUARIOS_ADMINISTRADORES: 'USUARIOS_ADMINISTRADORES',
  DOCENTE: 'DOCENTE',
  CURSOS: 'CURSOS',
  CATEGORIAS_CURSOS: 'CATEGORIAS_CURSOS',
  REVIEWS_CURSOS: 'REVIEWS_CURSOS',
  EDICIONES_CURSOS: 'EDICIONES_CURSOS',
  BENEFICIOS_CURSOS: 'BENEFICIOS_CURSOS',
  OBJETIVOS_CURSOS: 'OBJETIVOS_CURSOS',
  REQUISITOS_CURSOS: 'REQUISITOS_CURSOS',
  CLASES: 'CLASES',
  MATERIALES: 'MATERIALES',
  EXAMENES: 'EXAMENES',
  CALIFICACIONES: 'CALIFICACIONES',
  INSCRIPCIONES: 'INSCRIPCIONES',
  CERTIFICADOS: 'CERTIFICADOS',
  PRECIOS_CURSOS: 'PRECIOS_CURSOS',
  COMPRAS: 'COMPRAS',
  GRABACIONES: 'GRABACIONES',
  BANQUEO: 'BANQUEO',
  AREA: 'AREA',
  CAPITULO: 'CAPITULO',
  TEMA: 'TEMA',
  PREGUNTA: 'PREGUNTA',
  SUSCRIPCION: 'SUSCRIPCION',
  PAGOS_DOCENTE: 'PAGOS_DOCENTE'
};

export type Tabla = (typeof Tabla)[keyof typeof Tabla]


export const TipoCertificado: {
  PARTICIPACION: 'PARTICIPACION',
  APROBACION: 'APROBACION'
};

export type TipoCertificado = (typeof TipoCertificado)[keyof typeof TipoCertificado]


export const TipoCuenta: {
  ADMINISTRADOR: 'ADMINISTRADOR',
  MODERADOR: 'MODERADOR',
  DOCENTE: 'DOCENTE'
};

export type TipoCuenta = (typeof TipoCuenta)[keyof typeof TipoCuenta]


export const TipoGenero: {
  HOMBRE: 'HOMBRE',
  MUJER: 'MUJER'
};

export type TipoGenero = (typeof TipoGenero)[keyof typeof TipoGenero]


export const TipoMaterial: {
  PDF: 'PDF',
  DOCUMENTO: 'DOCUMENTO',
  PRESENTACION: 'PRESENTACION',
  HOJA_DE_CALCULO: 'HOJA_DE_CALCULO',
  VIDEO: 'VIDEO',
  AUDIO: 'AUDIO',
  IMAGEN: 'IMAGEN',
  ENLACE: 'ENLACE',
  CODIGO: 'CODIGO',
  ZIP: 'ZIP',
  TAREA: 'TAREA',
  CUESTIONARIO: 'CUESTIONARIO',
  EXAMEN: 'EXAMEN',
  FORMULARIO: 'FORMULARIO',
  LIBRO: 'LIBRO',
  ARTICULO: 'ARTICULO',
  PLANTILLA: 'PLANTILLA',
  INFORME: 'INFORME',
  GUIA: 'GUIA',
  TUTORIAL: 'TUTORIAL',
  EJERCICIO: 'EJERCICIO',
  SOLUCION: 'SOLUCION',
  OTRO: 'OTRO'
};

export type TipoMaterial = (typeof TipoMaterial)[keyof typeof TipoMaterial]


export const BanqueoTipo: {
  PRO: 'PRO',
  FREE: 'FREE'
};

export type BanqueoTipo = (typeof BanqueoTipo)[keyof typeof BanqueoTipo]


export const BanqueoTipoCreado: {
  ADMIN: 'ADMIN',
  ESTUDIANTE: 'ESTUDIANTE'
};

export type BanqueoTipoCreado = (typeof BanqueoTipoCreado)[keyof typeof BanqueoTipoCreado]


export const EstadoSuscripcion: {
  ACTIVA: 'ACTIVA',
  INACTIVA: 'INACTIVA'
};

export type EstadoSuscripcion = (typeof EstadoSuscripcion)[keyof typeof EstadoSuscripcion]


export const ResultadoRespuesta: {
  BIEN: 'BIEN',
  MAL: 'MAL',
  OMITIDA: 'OMITIDA'
};

export type ResultadoRespuesta = (typeof ResultadoRespuesta)[keyof typeof ResultadoRespuesta]


export const PreguntaDificultad: {
  DIFICIL: 'DIFICIL',
  MEDIO: 'MEDIO',
  SENCILLO: 'SENCILLO'
};

export type PreguntaDificultad = (typeof PreguntaDificultad)[keyof typeof PreguntaDificultad]


export const EstadoIntento: {
  EN_PROGRESO: 'EN_PROGRESO',
  FINALIZADO: 'FINALIZADO',
  ABANDONADO: 'ABANDONADO'
};

export type EstadoIntento = (typeof EstadoIntento)[keyof typeof EstadoIntento]


export const TipoReaccion: {
  LIKE: 'LIKE',
  DISLIKE: 'DISLIKE'
};

export type TipoReaccion = (typeof TipoReaccion)[keyof typeof TipoReaccion]

}

export type AccionAuditoria = $Enums.AccionAuditoria

export const AccionAuditoria: typeof $Enums.AccionAuditoria

export type EdicionEstado = $Enums.EdicionEstado

export const EdicionEstado: typeof $Enums.EdicionEstado

export type EstadoPago = $Enums.EstadoPago

export const EstadoPago: typeof $Enums.EstadoPago

export type MetodoPago = $Enums.MetodoPago

export const MetodoPago: typeof $Enums.MetodoPago

export type Pais = $Enums.Pais

export const Pais: typeof $Enums.Pais

export type PreguntaEstado = $Enums.PreguntaEstado

export const PreguntaEstado: typeof $Enums.PreguntaEstado

export type Tabla = $Enums.Tabla

export const Tabla: typeof $Enums.Tabla

export type TipoCertificado = $Enums.TipoCertificado

export const TipoCertificado: typeof $Enums.TipoCertificado

export type TipoCuenta = $Enums.TipoCuenta

export const TipoCuenta: typeof $Enums.TipoCuenta

export type TipoGenero = $Enums.TipoGenero

export const TipoGenero: typeof $Enums.TipoGenero

export type TipoMaterial = $Enums.TipoMaterial

export const TipoMaterial: typeof $Enums.TipoMaterial

export type BanqueoTipo = $Enums.BanqueoTipo

export const BanqueoTipo: typeof $Enums.BanqueoTipo

export type BanqueoTipoCreado = $Enums.BanqueoTipoCreado

export const BanqueoTipoCreado: typeof $Enums.BanqueoTipoCreado

export type EstadoSuscripcion = $Enums.EstadoSuscripcion

export const EstadoSuscripcion: typeof $Enums.EstadoSuscripcion

export type ResultadoRespuesta = $Enums.ResultadoRespuesta

export const ResultadoRespuesta: typeof $Enums.ResultadoRespuesta

export type PreguntaDificultad = $Enums.PreguntaDificultad

export const PreguntaDificultad: typeof $Enums.PreguntaDificultad

export type EstadoIntento = $Enums.EstadoIntento

export const EstadoIntento: typeof $Enums.EstadoIntento

export type TipoReaccion = $Enums.TipoReaccion

export const TipoReaccion: typeof $Enums.TipoReaccion

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Auditorias
 * const auditorias = await prisma.auditoria.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Auditorias
   * const auditorias = await prisma.auditoria.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.auditoria`: Exposes CRUD operations for the **auditoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auditorias
    * const auditorias = await prisma.auditoria.findMany()
    * ```
    */
  get auditoria(): Prisma.auditoriaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.beneficiosCursos`: Exposes CRUD operations for the **beneficiosCursos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BeneficiosCursos
    * const beneficiosCursos = await prisma.beneficiosCursos.findMany()
    * ```
    */
  get beneficiosCursos(): Prisma.beneficiosCursosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.calificaciones`: Exposes CRUD operations for the **calificaciones** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Calificaciones
    * const calificaciones = await prisma.calificaciones.findMany()
    * ```
    */
  get calificaciones(): Prisma.calificacionesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categorias`: Exposes CRUD operations for the **categorias** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categorias
    * const categorias = await prisma.categorias.findMany()
    * ```
    */
  get categorias(): Prisma.categoriasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categoriasCursos`: Exposes CRUD operations for the **categoriasCursos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CategoriasCursos
    * const categoriasCursos = await prisma.categoriasCursos.findMany()
    * ```
    */
  get categoriasCursos(): Prisma.categoriasCursosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.certificados`: Exposes CRUD operations for the **certificados** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certificados
    * const certificados = await prisma.certificados.findMany()
    * ```
    */
  get certificados(): Prisma.certificadosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clases`: Exposes CRUD operations for the **clases** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clases
    * const clases = await prisma.clases.findMany()
    * ```
    */
  get clases(): Prisma.clasesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.compras`: Exposes CRUD operations for the **compras** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Compras
    * const compras = await prisma.compras.findMany()
    * ```
    */
  get compras(): Prisma.comprasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cursos`: Exposes CRUD operations for the **cursos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cursos
    * const cursos = await prisma.cursos.findMany()
    * ```
    */
  get cursos(): Prisma.cursosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.docente`: Exposes CRUD operations for the **docente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Docentes
    * const docentes = await prisma.docente.findMany()
    * ```
    */
  get docente(): Prisma.docenteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.edicionesCursos`: Exposes CRUD operations for the **edicionesCursos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EdicionesCursos
    * const edicionesCursos = await prisma.edicionesCursos.findMany()
    * ```
    */
  get edicionesCursos(): Prisma.edicionesCursosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.estudiantes`: Exposes CRUD operations for the **estudiantes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estudiantes
    * const estudiantes = await prisma.estudiantes.findMany()
    * ```
    */
  get estudiantes(): Prisma.estudiantesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.temas`: Exposes CRUD operations for the **temas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Temas
    * const temas = await prisma.temas.findMany()
    * ```
    */
  get temas(): Prisma.temasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.examenes`: Exposes CRUD operations for the **examenes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Examenes
    * const examenes = await prisma.examenes.findMany()
    * ```
    */
  get examenes(): Prisma.examenesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.grabaciones`: Exposes CRUD operations for the **grabaciones** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grabaciones
    * const grabaciones = await prisma.grabaciones.findMany()
    * ```
    */
  get grabaciones(): Prisma.grabacionesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inscripciones`: Exposes CRUD operations for the **inscripciones** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inscripciones
    * const inscripciones = await prisma.inscripciones.findMany()
    * ```
    */
  get inscripciones(): Prisma.inscripcionesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.materiales`: Exposes CRUD operations for the **materiales** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materiales
    * const materiales = await prisma.materiales.findMany()
    * ```
    */
  get materiales(): Prisma.materialesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.objetivosCursos`: Exposes CRUD operations for the **objetivosCursos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ObjetivosCursos
    * const objetivosCursos = await prisma.objetivosCursos.findMany()
    * ```
    */
  get objetivosCursos(): Prisma.objetivosCursosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pagosDocentes`: Exposes CRUD operations for the **pagosDocentes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PagosDocentes
    * const pagosDocentes = await prisma.pagosDocentes.findMany()
    * ```
    */
  get pagosDocentes(): Prisma.pagosDocentesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.preciosCursos`: Exposes CRUD operations for the **preciosCursos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PreciosCursos
    * const preciosCursos = await prisma.preciosCursos.findMany()
    * ```
    */
  get preciosCursos(): Prisma.preciosCursosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.preguntas`: Exposes CRUD operations for the **preguntas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Preguntas
    * const preguntas = await prisma.preguntas.findMany()
    * ```
    */
  get preguntas(): Prisma.preguntasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reaccionesPreguntas`: Exposes CRUD operations for the **reaccionesPreguntas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReaccionesPreguntas
    * const reaccionesPreguntas = await prisma.reaccionesPreguntas.findMany()
    * ```
    */
  get reaccionesPreguntas(): Prisma.reaccionesPreguntasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requisitosCursos`: Exposes CRUD operations for the **requisitosCursos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequisitosCursos
    * const requisitosCursos = await prisma.requisitosCursos.findMany()
    * ```
    */
  get requisitosCursos(): Prisma.requisitosCursosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviewsCursos`: Exposes CRUD operations for the **reviewsCursos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewsCursos
    * const reviewsCursos = await prisma.reviewsCursos.findMany()
    * ```
    */
  get reviewsCursos(): Prisma.reviewsCursosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuariosAdministradores`: Exposes CRUD operations for the **usuariosAdministradores** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsuariosAdministradores
    * const usuariosAdministradores = await prisma.usuariosAdministradores.findMany()
    * ```
    */
  get usuariosAdministradores(): Prisma.usuariosAdministradoresDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuariosEstudiantes`: Exposes CRUD operations for the **usuariosEstudiantes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsuariosEstudiantes
    * const usuariosEstudiantes = await prisma.usuariosEstudiantes.findMany()
    * ```
    */
  get usuariosEstudiantes(): Prisma.usuariosEstudiantesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.areas`: Exposes CRUD operations for the **areas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Areas
    * const areas = await prisma.areas.findMany()
    * ```
    */
  get areas(): Prisma.areasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.banqueo`: Exposes CRUD operations for the **banqueo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banqueos
    * const banqueos = await prisma.banqueo.findMany()
    * ```
    */
  get banqueo(): Prisma.banqueoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.capitulos`: Exposes CRUD operations for the **capitulos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Capitulos
    * const capitulos = await prisma.capitulos.findMany()
    * ```
    */
  get capitulos(): Prisma.capitulosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.intentos`: Exposes CRUD operations for the **intentos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Intentos
    * const intentos = await prisma.intentos.findMany()
    * ```
    */
  get intentos(): Prisma.intentosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.respuestasIntentos`: Exposes CRUD operations for the **respuestasIntentos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RespuestasIntentos
    * const respuestasIntentos = await prisma.respuestasIntentos.findMany()
    * ```
    */
  get respuestasIntentos(): Prisma.respuestasIntentosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.repasoRegistros`: Exposes CRUD operations for the **repasoRegistros** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RepasoRegistros
    * const repasoRegistros = await prisma.repasoRegistros.findMany()
    * ```
    */
  get repasoRegistros(): Prisma.repasoRegistrosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.suscripciones`: Exposes CRUD operations for the **suscripciones** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suscripciones
    * const suscripciones = await prisma.suscripciones.findMany()
    * ```
    */
  get suscripciones(): Prisma.suscripcionesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.3.0
   * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    auditoria: 'auditoria',
    beneficiosCursos: 'beneficiosCursos',
    calificaciones: 'calificaciones',
    categorias: 'categorias',
    categoriasCursos: 'categoriasCursos',
    certificados: 'certificados',
    clases: 'clases',
    compras: 'compras',
    cursos: 'cursos',
    docente: 'docente',
    edicionesCursos: 'edicionesCursos',
    estudiantes: 'estudiantes',
    temas: 'temas',
    examenes: 'examenes',
    grabaciones: 'grabaciones',
    inscripciones: 'inscripciones',
    materiales: 'materiales',
    objetivosCursos: 'objetivosCursos',
    pagosDocentes: 'pagosDocentes',
    preciosCursos: 'preciosCursos',
    preguntas: 'preguntas',
    reaccionesPreguntas: 'reaccionesPreguntas',
    requisitosCursos: 'requisitosCursos',
    reviewsCursos: 'reviewsCursos',
    usuariosAdministradores: 'usuariosAdministradores',
    usuariosEstudiantes: 'usuariosEstudiantes',
    areas: 'areas',
    banqueo: 'banqueo',
    capitulos: 'capitulos',
    intentos: 'intentos',
    respuestasIntentos: 'respuestasIntentos',
    repasoRegistros: 'repasoRegistros',
    suscripciones: 'suscripciones'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "auditoria" | "beneficiosCursos" | "calificaciones" | "categorias" | "categoriasCursos" | "certificados" | "clases" | "compras" | "cursos" | "docente" | "edicionesCursos" | "estudiantes" | "temas" | "examenes" | "grabaciones" | "inscripciones" | "materiales" | "objetivosCursos" | "pagosDocentes" | "preciosCursos" | "preguntas" | "reaccionesPreguntas" | "requisitosCursos" | "reviewsCursos" | "usuariosAdministradores" | "usuariosEstudiantes" | "areas" | "banqueo" | "capitulos" | "intentos" | "respuestasIntentos" | "repasoRegistros" | "suscripciones"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      auditoria: {
        payload: Prisma.$auditoriaPayload<ExtArgs>
        fields: Prisma.auditoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.auditoriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.auditoriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>
          }
          findFirst: {
            args: Prisma.auditoriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.auditoriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>
          }
          findMany: {
            args: Prisma.auditoriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>[]
          }
          create: {
            args: Prisma.auditoriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>
          }
          createMany: {
            args: Prisma.auditoriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.auditoriaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>[]
          }
          delete: {
            args: Prisma.auditoriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>
          }
          update: {
            args: Prisma.auditoriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>
          }
          deleteMany: {
            args: Prisma.auditoriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.auditoriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.auditoriaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>[]
          }
          upsert: {
            args: Prisma.auditoriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditoriaPayload>
          }
          aggregate: {
            args: Prisma.AuditoriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditoria>
          }
          groupBy: {
            args: Prisma.auditoriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.auditoriaCountArgs<ExtArgs>
            result: $Utils.Optional<AuditoriaCountAggregateOutputType> | number
          }
        }
      }
      beneficiosCursos: {
        payload: Prisma.$beneficiosCursosPayload<ExtArgs>
        fields: Prisma.beneficiosCursosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.beneficiosCursosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beneficiosCursosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.beneficiosCursosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beneficiosCursosPayload>
          }
          findFirst: {
            args: Prisma.beneficiosCursosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beneficiosCursosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.beneficiosCursosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beneficiosCursosPayload>
          }
          findMany: {
            args: Prisma.beneficiosCursosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beneficiosCursosPayload>[]
          }
          create: {
            args: Prisma.beneficiosCursosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beneficiosCursosPayload>
          }
          createMany: {
            args: Prisma.beneficiosCursosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.beneficiosCursosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beneficiosCursosPayload>[]
          }
          delete: {
            args: Prisma.beneficiosCursosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beneficiosCursosPayload>
          }
          update: {
            args: Prisma.beneficiosCursosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beneficiosCursosPayload>
          }
          deleteMany: {
            args: Prisma.beneficiosCursosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.beneficiosCursosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.beneficiosCursosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beneficiosCursosPayload>[]
          }
          upsert: {
            args: Prisma.beneficiosCursosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$beneficiosCursosPayload>
          }
          aggregate: {
            args: Prisma.BeneficiosCursosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBeneficiosCursos>
          }
          groupBy: {
            args: Prisma.beneficiosCursosGroupByArgs<ExtArgs>
            result: $Utils.Optional<BeneficiosCursosGroupByOutputType>[]
          }
          count: {
            args: Prisma.beneficiosCursosCountArgs<ExtArgs>
            result: $Utils.Optional<BeneficiosCursosCountAggregateOutputType> | number
          }
        }
      }
      calificaciones: {
        payload: Prisma.$calificacionesPayload<ExtArgs>
        fields: Prisma.calificacionesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.calificacionesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calificacionesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.calificacionesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calificacionesPayload>
          }
          findFirst: {
            args: Prisma.calificacionesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calificacionesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.calificacionesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calificacionesPayload>
          }
          findMany: {
            args: Prisma.calificacionesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calificacionesPayload>[]
          }
          create: {
            args: Prisma.calificacionesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calificacionesPayload>
          }
          createMany: {
            args: Prisma.calificacionesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.calificacionesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calificacionesPayload>[]
          }
          delete: {
            args: Prisma.calificacionesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calificacionesPayload>
          }
          update: {
            args: Prisma.calificacionesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calificacionesPayload>
          }
          deleteMany: {
            args: Prisma.calificacionesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.calificacionesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.calificacionesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calificacionesPayload>[]
          }
          upsert: {
            args: Prisma.calificacionesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calificacionesPayload>
          }
          aggregate: {
            args: Prisma.CalificacionesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalificaciones>
          }
          groupBy: {
            args: Prisma.calificacionesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalificacionesGroupByOutputType>[]
          }
          count: {
            args: Prisma.calificacionesCountArgs<ExtArgs>
            result: $Utils.Optional<CalificacionesCountAggregateOutputType> | number
          }
        }
      }
      categorias: {
        payload: Prisma.$categoriasPayload<ExtArgs>
        fields: Prisma.categoriasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoriasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoriasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>
          }
          findFirst: {
            args: Prisma.categoriasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoriasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>
          }
          findMany: {
            args: Prisma.categoriasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>[]
          }
          create: {
            args: Prisma.categoriasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>
          }
          createMany: {
            args: Prisma.categoriasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.categoriasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>[]
          }
          delete: {
            args: Prisma.categoriasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>
          }
          update: {
            args: Prisma.categoriasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>
          }
          deleteMany: {
            args: Prisma.categoriasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.categoriasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.categoriasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>[]
          }
          upsert: {
            args: Prisma.categoriasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasPayload>
          }
          aggregate: {
            args: Prisma.CategoriasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategorias>
          }
          groupBy: {
            args: Prisma.categoriasGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriasGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoriasCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriasCountAggregateOutputType> | number
          }
        }
      }
      categoriasCursos: {
        payload: Prisma.$categoriasCursosPayload<ExtArgs>
        fields: Prisma.categoriasCursosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoriasCursosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasCursosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoriasCursosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasCursosPayload>
          }
          findFirst: {
            args: Prisma.categoriasCursosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasCursosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoriasCursosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasCursosPayload>
          }
          findMany: {
            args: Prisma.categoriasCursosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasCursosPayload>[]
          }
          create: {
            args: Prisma.categoriasCursosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasCursosPayload>
          }
          createMany: {
            args: Prisma.categoriasCursosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.categoriasCursosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasCursosPayload>[]
          }
          delete: {
            args: Prisma.categoriasCursosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasCursosPayload>
          }
          update: {
            args: Prisma.categoriasCursosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasCursosPayload>
          }
          deleteMany: {
            args: Prisma.categoriasCursosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.categoriasCursosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.categoriasCursosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasCursosPayload>[]
          }
          upsert: {
            args: Prisma.categoriasCursosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriasCursosPayload>
          }
          aggregate: {
            args: Prisma.CategoriasCursosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategoriasCursos>
          }
          groupBy: {
            args: Prisma.categoriasCursosGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriasCursosGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoriasCursosCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriasCursosCountAggregateOutputType> | number
          }
        }
      }
      certificados: {
        payload: Prisma.$certificadosPayload<ExtArgs>
        fields: Prisma.certificadosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.certificadosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificadosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.certificadosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificadosPayload>
          }
          findFirst: {
            args: Prisma.certificadosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificadosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.certificadosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificadosPayload>
          }
          findMany: {
            args: Prisma.certificadosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificadosPayload>[]
          }
          create: {
            args: Prisma.certificadosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificadosPayload>
          }
          createMany: {
            args: Prisma.certificadosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.certificadosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificadosPayload>[]
          }
          delete: {
            args: Prisma.certificadosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificadosPayload>
          }
          update: {
            args: Prisma.certificadosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificadosPayload>
          }
          deleteMany: {
            args: Prisma.certificadosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.certificadosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.certificadosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificadosPayload>[]
          }
          upsert: {
            args: Prisma.certificadosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificadosPayload>
          }
          aggregate: {
            args: Prisma.CertificadosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificados>
          }
          groupBy: {
            args: Prisma.certificadosGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificadosGroupByOutputType>[]
          }
          count: {
            args: Prisma.certificadosCountArgs<ExtArgs>
            result: $Utils.Optional<CertificadosCountAggregateOutputType> | number
          }
        }
      }
      clases: {
        payload: Prisma.$clasesPayload<ExtArgs>
        fields: Prisma.clasesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clasesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clasesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clasesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clasesPayload>
          }
          findFirst: {
            args: Prisma.clasesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clasesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clasesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clasesPayload>
          }
          findMany: {
            args: Prisma.clasesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clasesPayload>[]
          }
          create: {
            args: Prisma.clasesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clasesPayload>
          }
          createMany: {
            args: Prisma.clasesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.clasesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clasesPayload>[]
          }
          delete: {
            args: Prisma.clasesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clasesPayload>
          }
          update: {
            args: Prisma.clasesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clasesPayload>
          }
          deleteMany: {
            args: Prisma.clasesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clasesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.clasesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clasesPayload>[]
          }
          upsert: {
            args: Prisma.clasesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clasesPayload>
          }
          aggregate: {
            args: Prisma.ClasesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClases>
          }
          groupBy: {
            args: Prisma.clasesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClasesGroupByOutputType>[]
          }
          count: {
            args: Prisma.clasesCountArgs<ExtArgs>
            result: $Utils.Optional<ClasesCountAggregateOutputType> | number
          }
        }
      }
      compras: {
        payload: Prisma.$comprasPayload<ExtArgs>
        fields: Prisma.comprasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.comprasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.comprasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprasPayload>
          }
          findFirst: {
            args: Prisma.comprasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.comprasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprasPayload>
          }
          findMany: {
            args: Prisma.comprasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprasPayload>[]
          }
          create: {
            args: Prisma.comprasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprasPayload>
          }
          createMany: {
            args: Prisma.comprasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.comprasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprasPayload>[]
          }
          delete: {
            args: Prisma.comprasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprasPayload>
          }
          update: {
            args: Prisma.comprasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprasPayload>
          }
          deleteMany: {
            args: Prisma.comprasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.comprasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.comprasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprasPayload>[]
          }
          upsert: {
            args: Prisma.comprasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comprasPayload>
          }
          aggregate: {
            args: Prisma.ComprasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompras>
          }
          groupBy: {
            args: Prisma.comprasGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComprasGroupByOutputType>[]
          }
          count: {
            args: Prisma.comprasCountArgs<ExtArgs>
            result: $Utils.Optional<ComprasCountAggregateOutputType> | number
          }
        }
      }
      cursos: {
        payload: Prisma.$cursosPayload<ExtArgs>
        fields: Prisma.cursosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cursosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cursosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cursosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cursosPayload>
          }
          findFirst: {
            args: Prisma.cursosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cursosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cursosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cursosPayload>
          }
          findMany: {
            args: Prisma.cursosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cursosPayload>[]
          }
          create: {
            args: Prisma.cursosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cursosPayload>
          }
          createMany: {
            args: Prisma.cursosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.cursosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cursosPayload>[]
          }
          delete: {
            args: Prisma.cursosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cursosPayload>
          }
          update: {
            args: Prisma.cursosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cursosPayload>
          }
          deleteMany: {
            args: Prisma.cursosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cursosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.cursosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cursosPayload>[]
          }
          upsert: {
            args: Prisma.cursosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cursosPayload>
          }
          aggregate: {
            args: Prisma.CursosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCursos>
          }
          groupBy: {
            args: Prisma.cursosGroupByArgs<ExtArgs>
            result: $Utils.Optional<CursosGroupByOutputType>[]
          }
          count: {
            args: Prisma.cursosCountArgs<ExtArgs>
            result: $Utils.Optional<CursosCountAggregateOutputType> | number
          }
        }
      }
      docente: {
        payload: Prisma.$docentePayload<ExtArgs>
        fields: Prisma.docenteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.docenteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docentePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.docenteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docentePayload>
          }
          findFirst: {
            args: Prisma.docenteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docentePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.docenteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docentePayload>
          }
          findMany: {
            args: Prisma.docenteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docentePayload>[]
          }
          create: {
            args: Prisma.docenteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docentePayload>
          }
          createMany: {
            args: Prisma.docenteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.docenteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docentePayload>[]
          }
          delete: {
            args: Prisma.docenteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docentePayload>
          }
          update: {
            args: Prisma.docenteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docentePayload>
          }
          deleteMany: {
            args: Prisma.docenteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.docenteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.docenteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docentePayload>[]
          }
          upsert: {
            args: Prisma.docenteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docentePayload>
          }
          aggregate: {
            args: Prisma.DocenteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocente>
          }
          groupBy: {
            args: Prisma.docenteGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocenteGroupByOutputType>[]
          }
          count: {
            args: Prisma.docenteCountArgs<ExtArgs>
            result: $Utils.Optional<DocenteCountAggregateOutputType> | number
          }
        }
      }
      edicionesCursos: {
        payload: Prisma.$edicionesCursosPayload<ExtArgs>
        fields: Prisma.edicionesCursosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.edicionesCursosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edicionesCursosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.edicionesCursosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edicionesCursosPayload>
          }
          findFirst: {
            args: Prisma.edicionesCursosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edicionesCursosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.edicionesCursosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edicionesCursosPayload>
          }
          findMany: {
            args: Prisma.edicionesCursosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edicionesCursosPayload>[]
          }
          create: {
            args: Prisma.edicionesCursosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edicionesCursosPayload>
          }
          createMany: {
            args: Prisma.edicionesCursosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.edicionesCursosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edicionesCursosPayload>[]
          }
          delete: {
            args: Prisma.edicionesCursosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edicionesCursosPayload>
          }
          update: {
            args: Prisma.edicionesCursosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edicionesCursosPayload>
          }
          deleteMany: {
            args: Prisma.edicionesCursosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.edicionesCursosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.edicionesCursosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edicionesCursosPayload>[]
          }
          upsert: {
            args: Prisma.edicionesCursosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$edicionesCursosPayload>
          }
          aggregate: {
            args: Prisma.EdicionesCursosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEdicionesCursos>
          }
          groupBy: {
            args: Prisma.edicionesCursosGroupByArgs<ExtArgs>
            result: $Utils.Optional<EdicionesCursosGroupByOutputType>[]
          }
          count: {
            args: Prisma.edicionesCursosCountArgs<ExtArgs>
            result: $Utils.Optional<EdicionesCursosCountAggregateOutputType> | number
          }
        }
      }
      estudiantes: {
        payload: Prisma.$estudiantesPayload<ExtArgs>
        fields: Prisma.estudiantesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.estudiantesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estudiantesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.estudiantesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estudiantesPayload>
          }
          findFirst: {
            args: Prisma.estudiantesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estudiantesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.estudiantesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estudiantesPayload>
          }
          findMany: {
            args: Prisma.estudiantesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estudiantesPayload>[]
          }
          create: {
            args: Prisma.estudiantesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estudiantesPayload>
          }
          createMany: {
            args: Prisma.estudiantesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.estudiantesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estudiantesPayload>[]
          }
          delete: {
            args: Prisma.estudiantesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estudiantesPayload>
          }
          update: {
            args: Prisma.estudiantesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estudiantesPayload>
          }
          deleteMany: {
            args: Prisma.estudiantesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.estudiantesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.estudiantesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estudiantesPayload>[]
          }
          upsert: {
            args: Prisma.estudiantesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estudiantesPayload>
          }
          aggregate: {
            args: Prisma.EstudiantesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstudiantes>
          }
          groupBy: {
            args: Prisma.estudiantesGroupByArgs<ExtArgs>
            result: $Utils.Optional<EstudiantesGroupByOutputType>[]
          }
          count: {
            args: Prisma.estudiantesCountArgs<ExtArgs>
            result: $Utils.Optional<EstudiantesCountAggregateOutputType> | number
          }
        }
      }
      temas: {
        payload: Prisma.$temasPayload<ExtArgs>
        fields: Prisma.temasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.temasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$temasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.temasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$temasPayload>
          }
          findFirst: {
            args: Prisma.temasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$temasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.temasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$temasPayload>
          }
          findMany: {
            args: Prisma.temasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$temasPayload>[]
          }
          create: {
            args: Prisma.temasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$temasPayload>
          }
          createMany: {
            args: Prisma.temasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.temasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$temasPayload>[]
          }
          delete: {
            args: Prisma.temasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$temasPayload>
          }
          update: {
            args: Prisma.temasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$temasPayload>
          }
          deleteMany: {
            args: Prisma.temasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.temasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.temasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$temasPayload>[]
          }
          upsert: {
            args: Prisma.temasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$temasPayload>
          }
          aggregate: {
            args: Prisma.TemasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemas>
          }
          groupBy: {
            args: Prisma.temasGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemasGroupByOutputType>[]
          }
          count: {
            args: Prisma.temasCountArgs<ExtArgs>
            result: $Utils.Optional<TemasCountAggregateOutputType> | number
          }
        }
      }
      examenes: {
        payload: Prisma.$examenesPayload<ExtArgs>
        fields: Prisma.examenesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.examenesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.examenesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenesPayload>
          }
          findFirst: {
            args: Prisma.examenesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.examenesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenesPayload>
          }
          findMany: {
            args: Prisma.examenesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenesPayload>[]
          }
          create: {
            args: Prisma.examenesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenesPayload>
          }
          createMany: {
            args: Prisma.examenesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.examenesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenesPayload>[]
          }
          delete: {
            args: Prisma.examenesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenesPayload>
          }
          update: {
            args: Prisma.examenesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenesPayload>
          }
          deleteMany: {
            args: Prisma.examenesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.examenesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.examenesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenesPayload>[]
          }
          upsert: {
            args: Prisma.examenesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examenesPayload>
          }
          aggregate: {
            args: Prisma.ExamenesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamenes>
          }
          groupBy: {
            args: Prisma.examenesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamenesGroupByOutputType>[]
          }
          count: {
            args: Prisma.examenesCountArgs<ExtArgs>
            result: $Utils.Optional<ExamenesCountAggregateOutputType> | number
          }
        }
      }
      grabaciones: {
        payload: Prisma.$grabacionesPayload<ExtArgs>
        fields: Prisma.grabacionesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.grabacionesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grabacionesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.grabacionesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grabacionesPayload>
          }
          findFirst: {
            args: Prisma.grabacionesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grabacionesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.grabacionesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grabacionesPayload>
          }
          findMany: {
            args: Prisma.grabacionesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grabacionesPayload>[]
          }
          create: {
            args: Prisma.grabacionesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grabacionesPayload>
          }
          createMany: {
            args: Prisma.grabacionesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.grabacionesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grabacionesPayload>[]
          }
          delete: {
            args: Prisma.grabacionesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grabacionesPayload>
          }
          update: {
            args: Prisma.grabacionesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grabacionesPayload>
          }
          deleteMany: {
            args: Prisma.grabacionesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.grabacionesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.grabacionesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grabacionesPayload>[]
          }
          upsert: {
            args: Prisma.grabacionesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$grabacionesPayload>
          }
          aggregate: {
            args: Prisma.GrabacionesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrabaciones>
          }
          groupBy: {
            args: Prisma.grabacionesGroupByArgs<ExtArgs>
            result: $Utils.Optional<GrabacionesGroupByOutputType>[]
          }
          count: {
            args: Prisma.grabacionesCountArgs<ExtArgs>
            result: $Utils.Optional<GrabacionesCountAggregateOutputType> | number
          }
        }
      }
      inscripciones: {
        payload: Prisma.$inscripcionesPayload<ExtArgs>
        fields: Prisma.inscripcionesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inscripcionesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscripcionesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inscripcionesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscripcionesPayload>
          }
          findFirst: {
            args: Prisma.inscripcionesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscripcionesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inscripcionesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscripcionesPayload>
          }
          findMany: {
            args: Prisma.inscripcionesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscripcionesPayload>[]
          }
          create: {
            args: Prisma.inscripcionesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscripcionesPayload>
          }
          createMany: {
            args: Prisma.inscripcionesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.inscripcionesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscripcionesPayload>[]
          }
          delete: {
            args: Prisma.inscripcionesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscripcionesPayload>
          }
          update: {
            args: Prisma.inscripcionesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscripcionesPayload>
          }
          deleteMany: {
            args: Prisma.inscripcionesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.inscripcionesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.inscripcionesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscripcionesPayload>[]
          }
          upsert: {
            args: Prisma.inscripcionesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inscripcionesPayload>
          }
          aggregate: {
            args: Prisma.InscripcionesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInscripciones>
          }
          groupBy: {
            args: Prisma.inscripcionesGroupByArgs<ExtArgs>
            result: $Utils.Optional<InscripcionesGroupByOutputType>[]
          }
          count: {
            args: Prisma.inscripcionesCountArgs<ExtArgs>
            result: $Utils.Optional<InscripcionesCountAggregateOutputType> | number
          }
        }
      }
      materiales: {
        payload: Prisma.$materialesPayload<ExtArgs>
        fields: Prisma.materialesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.materialesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.materialesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialesPayload>
          }
          findFirst: {
            args: Prisma.materialesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.materialesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialesPayload>
          }
          findMany: {
            args: Prisma.materialesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialesPayload>[]
          }
          create: {
            args: Prisma.materialesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialesPayload>
          }
          createMany: {
            args: Prisma.materialesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.materialesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialesPayload>[]
          }
          delete: {
            args: Prisma.materialesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialesPayload>
          }
          update: {
            args: Prisma.materialesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialesPayload>
          }
          deleteMany: {
            args: Prisma.materialesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.materialesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.materialesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialesPayload>[]
          }
          upsert: {
            args: Prisma.materialesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialesPayload>
          }
          aggregate: {
            args: Prisma.MaterialesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMateriales>
          }
          groupBy: {
            args: Prisma.materialesGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialesGroupByOutputType>[]
          }
          count: {
            args: Prisma.materialesCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialesCountAggregateOutputType> | number
          }
        }
      }
      objetivosCursos: {
        payload: Prisma.$objetivosCursosPayload<ExtArgs>
        fields: Prisma.objetivosCursosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.objetivosCursosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$objetivosCursosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.objetivosCursosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$objetivosCursosPayload>
          }
          findFirst: {
            args: Prisma.objetivosCursosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$objetivosCursosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.objetivosCursosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$objetivosCursosPayload>
          }
          findMany: {
            args: Prisma.objetivosCursosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$objetivosCursosPayload>[]
          }
          create: {
            args: Prisma.objetivosCursosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$objetivosCursosPayload>
          }
          createMany: {
            args: Prisma.objetivosCursosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.objetivosCursosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$objetivosCursosPayload>[]
          }
          delete: {
            args: Prisma.objetivosCursosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$objetivosCursosPayload>
          }
          update: {
            args: Prisma.objetivosCursosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$objetivosCursosPayload>
          }
          deleteMany: {
            args: Prisma.objetivosCursosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.objetivosCursosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.objetivosCursosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$objetivosCursosPayload>[]
          }
          upsert: {
            args: Prisma.objetivosCursosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$objetivosCursosPayload>
          }
          aggregate: {
            args: Prisma.ObjetivosCursosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateObjetivosCursos>
          }
          groupBy: {
            args: Prisma.objetivosCursosGroupByArgs<ExtArgs>
            result: $Utils.Optional<ObjetivosCursosGroupByOutputType>[]
          }
          count: {
            args: Prisma.objetivosCursosCountArgs<ExtArgs>
            result: $Utils.Optional<ObjetivosCursosCountAggregateOutputType> | number
          }
        }
      }
      pagosDocentes: {
        payload: Prisma.$pagosDocentesPayload<ExtArgs>
        fields: Prisma.pagosDocentesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pagosDocentesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagosDocentesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pagosDocentesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagosDocentesPayload>
          }
          findFirst: {
            args: Prisma.pagosDocentesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagosDocentesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pagosDocentesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagosDocentesPayload>
          }
          findMany: {
            args: Prisma.pagosDocentesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagosDocentesPayload>[]
          }
          create: {
            args: Prisma.pagosDocentesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagosDocentesPayload>
          }
          createMany: {
            args: Prisma.pagosDocentesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pagosDocentesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagosDocentesPayload>[]
          }
          delete: {
            args: Prisma.pagosDocentesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagosDocentesPayload>
          }
          update: {
            args: Prisma.pagosDocentesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagosDocentesPayload>
          }
          deleteMany: {
            args: Prisma.pagosDocentesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pagosDocentesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.pagosDocentesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagosDocentesPayload>[]
          }
          upsert: {
            args: Prisma.pagosDocentesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagosDocentesPayload>
          }
          aggregate: {
            args: Prisma.PagosDocentesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePagosDocentes>
          }
          groupBy: {
            args: Prisma.pagosDocentesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PagosDocentesGroupByOutputType>[]
          }
          count: {
            args: Prisma.pagosDocentesCountArgs<ExtArgs>
            result: $Utils.Optional<PagosDocentesCountAggregateOutputType> | number
          }
        }
      }
      preciosCursos: {
        payload: Prisma.$preciosCursosPayload<ExtArgs>
        fields: Prisma.preciosCursosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.preciosCursosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preciosCursosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.preciosCursosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preciosCursosPayload>
          }
          findFirst: {
            args: Prisma.preciosCursosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preciosCursosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.preciosCursosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preciosCursosPayload>
          }
          findMany: {
            args: Prisma.preciosCursosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preciosCursosPayload>[]
          }
          create: {
            args: Prisma.preciosCursosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preciosCursosPayload>
          }
          createMany: {
            args: Prisma.preciosCursosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.preciosCursosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preciosCursosPayload>[]
          }
          delete: {
            args: Prisma.preciosCursosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preciosCursosPayload>
          }
          update: {
            args: Prisma.preciosCursosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preciosCursosPayload>
          }
          deleteMany: {
            args: Prisma.preciosCursosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.preciosCursosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.preciosCursosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preciosCursosPayload>[]
          }
          upsert: {
            args: Prisma.preciosCursosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preciosCursosPayload>
          }
          aggregate: {
            args: Prisma.PreciosCursosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePreciosCursos>
          }
          groupBy: {
            args: Prisma.preciosCursosGroupByArgs<ExtArgs>
            result: $Utils.Optional<PreciosCursosGroupByOutputType>[]
          }
          count: {
            args: Prisma.preciosCursosCountArgs<ExtArgs>
            result: $Utils.Optional<PreciosCursosCountAggregateOutputType> | number
          }
        }
      }
      preguntas: {
        payload: Prisma.$preguntasPayload<ExtArgs>
        fields: Prisma.preguntasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.preguntasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preguntasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.preguntasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preguntasPayload>
          }
          findFirst: {
            args: Prisma.preguntasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preguntasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.preguntasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preguntasPayload>
          }
          findMany: {
            args: Prisma.preguntasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preguntasPayload>[]
          }
          create: {
            args: Prisma.preguntasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preguntasPayload>
          }
          createMany: {
            args: Prisma.preguntasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.preguntasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preguntasPayload>[]
          }
          delete: {
            args: Prisma.preguntasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preguntasPayload>
          }
          update: {
            args: Prisma.preguntasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preguntasPayload>
          }
          deleteMany: {
            args: Prisma.preguntasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.preguntasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.preguntasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preguntasPayload>[]
          }
          upsert: {
            args: Prisma.preguntasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$preguntasPayload>
          }
          aggregate: {
            args: Prisma.PreguntasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePreguntas>
          }
          groupBy: {
            args: Prisma.preguntasGroupByArgs<ExtArgs>
            result: $Utils.Optional<PreguntasGroupByOutputType>[]
          }
          count: {
            args: Prisma.preguntasCountArgs<ExtArgs>
            result: $Utils.Optional<PreguntasCountAggregateOutputType> | number
          }
        }
      }
      reaccionesPreguntas: {
        payload: Prisma.$reaccionesPreguntasPayload<ExtArgs>
        fields: Prisma.reaccionesPreguntasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reaccionesPreguntasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reaccionesPreguntasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reaccionesPreguntasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reaccionesPreguntasPayload>
          }
          findFirst: {
            args: Prisma.reaccionesPreguntasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reaccionesPreguntasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reaccionesPreguntasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reaccionesPreguntasPayload>
          }
          findMany: {
            args: Prisma.reaccionesPreguntasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reaccionesPreguntasPayload>[]
          }
          create: {
            args: Prisma.reaccionesPreguntasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reaccionesPreguntasPayload>
          }
          createMany: {
            args: Prisma.reaccionesPreguntasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.reaccionesPreguntasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reaccionesPreguntasPayload>[]
          }
          delete: {
            args: Prisma.reaccionesPreguntasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reaccionesPreguntasPayload>
          }
          update: {
            args: Prisma.reaccionesPreguntasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reaccionesPreguntasPayload>
          }
          deleteMany: {
            args: Prisma.reaccionesPreguntasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reaccionesPreguntasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.reaccionesPreguntasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reaccionesPreguntasPayload>[]
          }
          upsert: {
            args: Prisma.reaccionesPreguntasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reaccionesPreguntasPayload>
          }
          aggregate: {
            args: Prisma.ReaccionesPreguntasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReaccionesPreguntas>
          }
          groupBy: {
            args: Prisma.reaccionesPreguntasGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReaccionesPreguntasGroupByOutputType>[]
          }
          count: {
            args: Prisma.reaccionesPreguntasCountArgs<ExtArgs>
            result: $Utils.Optional<ReaccionesPreguntasCountAggregateOutputType> | number
          }
        }
      }
      requisitosCursos: {
        payload: Prisma.$requisitosCursosPayload<ExtArgs>
        fields: Prisma.requisitosCursosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.requisitosCursosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requisitosCursosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.requisitosCursosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requisitosCursosPayload>
          }
          findFirst: {
            args: Prisma.requisitosCursosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requisitosCursosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.requisitosCursosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requisitosCursosPayload>
          }
          findMany: {
            args: Prisma.requisitosCursosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requisitosCursosPayload>[]
          }
          create: {
            args: Prisma.requisitosCursosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requisitosCursosPayload>
          }
          createMany: {
            args: Prisma.requisitosCursosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.requisitosCursosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requisitosCursosPayload>[]
          }
          delete: {
            args: Prisma.requisitosCursosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requisitosCursosPayload>
          }
          update: {
            args: Prisma.requisitosCursosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requisitosCursosPayload>
          }
          deleteMany: {
            args: Prisma.requisitosCursosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.requisitosCursosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.requisitosCursosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requisitosCursosPayload>[]
          }
          upsert: {
            args: Prisma.requisitosCursosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$requisitosCursosPayload>
          }
          aggregate: {
            args: Prisma.RequisitosCursosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequisitosCursos>
          }
          groupBy: {
            args: Prisma.requisitosCursosGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequisitosCursosGroupByOutputType>[]
          }
          count: {
            args: Prisma.requisitosCursosCountArgs<ExtArgs>
            result: $Utils.Optional<RequisitosCursosCountAggregateOutputType> | number
          }
        }
      }
      reviewsCursos: {
        payload: Prisma.$reviewsCursosPayload<ExtArgs>
        fields: Prisma.reviewsCursosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reviewsCursosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsCursosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reviewsCursosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsCursosPayload>
          }
          findFirst: {
            args: Prisma.reviewsCursosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsCursosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reviewsCursosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsCursosPayload>
          }
          findMany: {
            args: Prisma.reviewsCursosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsCursosPayload>[]
          }
          create: {
            args: Prisma.reviewsCursosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsCursosPayload>
          }
          createMany: {
            args: Prisma.reviewsCursosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.reviewsCursosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsCursosPayload>[]
          }
          delete: {
            args: Prisma.reviewsCursosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsCursosPayload>
          }
          update: {
            args: Prisma.reviewsCursosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsCursosPayload>
          }
          deleteMany: {
            args: Prisma.reviewsCursosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reviewsCursosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.reviewsCursosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsCursosPayload>[]
          }
          upsert: {
            args: Prisma.reviewsCursosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsCursosPayload>
          }
          aggregate: {
            args: Prisma.ReviewsCursosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewsCursos>
          }
          groupBy: {
            args: Prisma.reviewsCursosGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewsCursosGroupByOutputType>[]
          }
          count: {
            args: Prisma.reviewsCursosCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewsCursosCountAggregateOutputType> | number
          }
        }
      }
      usuariosAdministradores: {
        payload: Prisma.$usuariosAdministradoresPayload<ExtArgs>
        fields: Prisma.usuariosAdministradoresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usuariosAdministradoresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosAdministradoresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usuariosAdministradoresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosAdministradoresPayload>
          }
          findFirst: {
            args: Prisma.usuariosAdministradoresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosAdministradoresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usuariosAdministradoresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosAdministradoresPayload>
          }
          findMany: {
            args: Prisma.usuariosAdministradoresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosAdministradoresPayload>[]
          }
          create: {
            args: Prisma.usuariosAdministradoresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosAdministradoresPayload>
          }
          createMany: {
            args: Prisma.usuariosAdministradoresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usuariosAdministradoresCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosAdministradoresPayload>[]
          }
          delete: {
            args: Prisma.usuariosAdministradoresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosAdministradoresPayload>
          }
          update: {
            args: Prisma.usuariosAdministradoresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosAdministradoresPayload>
          }
          deleteMany: {
            args: Prisma.usuariosAdministradoresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usuariosAdministradoresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usuariosAdministradoresUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosAdministradoresPayload>[]
          }
          upsert: {
            args: Prisma.usuariosAdministradoresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosAdministradoresPayload>
          }
          aggregate: {
            args: Prisma.UsuariosAdministradoresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuariosAdministradores>
          }
          groupBy: {
            args: Prisma.usuariosAdministradoresGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuariosAdministradoresGroupByOutputType>[]
          }
          count: {
            args: Prisma.usuariosAdministradoresCountArgs<ExtArgs>
            result: $Utils.Optional<UsuariosAdministradoresCountAggregateOutputType> | number
          }
        }
      }
      usuariosEstudiantes: {
        payload: Prisma.$usuariosEstudiantesPayload<ExtArgs>
        fields: Prisma.usuariosEstudiantesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usuariosEstudiantesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosEstudiantesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usuariosEstudiantesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosEstudiantesPayload>
          }
          findFirst: {
            args: Prisma.usuariosEstudiantesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosEstudiantesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usuariosEstudiantesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosEstudiantesPayload>
          }
          findMany: {
            args: Prisma.usuariosEstudiantesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosEstudiantesPayload>[]
          }
          create: {
            args: Prisma.usuariosEstudiantesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosEstudiantesPayload>
          }
          createMany: {
            args: Prisma.usuariosEstudiantesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usuariosEstudiantesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosEstudiantesPayload>[]
          }
          delete: {
            args: Prisma.usuariosEstudiantesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosEstudiantesPayload>
          }
          update: {
            args: Prisma.usuariosEstudiantesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosEstudiantesPayload>
          }
          deleteMany: {
            args: Prisma.usuariosEstudiantesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usuariosEstudiantesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usuariosEstudiantesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosEstudiantesPayload>[]
          }
          upsert: {
            args: Prisma.usuariosEstudiantesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuariosEstudiantesPayload>
          }
          aggregate: {
            args: Prisma.UsuariosEstudiantesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuariosEstudiantes>
          }
          groupBy: {
            args: Prisma.usuariosEstudiantesGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuariosEstudiantesGroupByOutputType>[]
          }
          count: {
            args: Prisma.usuariosEstudiantesCountArgs<ExtArgs>
            result: $Utils.Optional<UsuariosEstudiantesCountAggregateOutputType> | number
          }
        }
      }
      areas: {
        payload: Prisma.$areasPayload<ExtArgs>
        fields: Prisma.areasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.areasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$areasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.areasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$areasPayload>
          }
          findFirst: {
            args: Prisma.areasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$areasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.areasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$areasPayload>
          }
          findMany: {
            args: Prisma.areasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$areasPayload>[]
          }
          create: {
            args: Prisma.areasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$areasPayload>
          }
          createMany: {
            args: Prisma.areasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.areasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$areasPayload>[]
          }
          delete: {
            args: Prisma.areasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$areasPayload>
          }
          update: {
            args: Prisma.areasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$areasPayload>
          }
          deleteMany: {
            args: Prisma.areasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.areasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.areasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$areasPayload>[]
          }
          upsert: {
            args: Prisma.areasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$areasPayload>
          }
          aggregate: {
            args: Prisma.AreasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAreas>
          }
          groupBy: {
            args: Prisma.areasGroupByArgs<ExtArgs>
            result: $Utils.Optional<AreasGroupByOutputType>[]
          }
          count: {
            args: Prisma.areasCountArgs<ExtArgs>
            result: $Utils.Optional<AreasCountAggregateOutputType> | number
          }
        }
      }
      banqueo: {
        payload: Prisma.$banqueoPayload<ExtArgs>
        fields: Prisma.banqueoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.banqueoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$banqueoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.banqueoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$banqueoPayload>
          }
          findFirst: {
            args: Prisma.banqueoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$banqueoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.banqueoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$banqueoPayload>
          }
          findMany: {
            args: Prisma.banqueoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$banqueoPayload>[]
          }
          create: {
            args: Prisma.banqueoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$banqueoPayload>
          }
          createMany: {
            args: Prisma.banqueoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.banqueoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$banqueoPayload>[]
          }
          delete: {
            args: Prisma.banqueoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$banqueoPayload>
          }
          update: {
            args: Prisma.banqueoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$banqueoPayload>
          }
          deleteMany: {
            args: Prisma.banqueoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.banqueoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.banqueoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$banqueoPayload>[]
          }
          upsert: {
            args: Prisma.banqueoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$banqueoPayload>
          }
          aggregate: {
            args: Prisma.BanqueoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBanqueo>
          }
          groupBy: {
            args: Prisma.banqueoGroupByArgs<ExtArgs>
            result: $Utils.Optional<BanqueoGroupByOutputType>[]
          }
          count: {
            args: Prisma.banqueoCountArgs<ExtArgs>
            result: $Utils.Optional<BanqueoCountAggregateOutputType> | number
          }
        }
      }
      capitulos: {
        payload: Prisma.$capitulosPayload<ExtArgs>
        fields: Prisma.capitulosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.capitulosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capitulosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.capitulosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capitulosPayload>
          }
          findFirst: {
            args: Prisma.capitulosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capitulosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.capitulosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capitulosPayload>
          }
          findMany: {
            args: Prisma.capitulosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capitulosPayload>[]
          }
          create: {
            args: Prisma.capitulosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capitulosPayload>
          }
          createMany: {
            args: Prisma.capitulosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.capitulosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capitulosPayload>[]
          }
          delete: {
            args: Prisma.capitulosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capitulosPayload>
          }
          update: {
            args: Prisma.capitulosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capitulosPayload>
          }
          deleteMany: {
            args: Prisma.capitulosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.capitulosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.capitulosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capitulosPayload>[]
          }
          upsert: {
            args: Prisma.capitulosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$capitulosPayload>
          }
          aggregate: {
            args: Prisma.CapitulosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCapitulos>
          }
          groupBy: {
            args: Prisma.capitulosGroupByArgs<ExtArgs>
            result: $Utils.Optional<CapitulosGroupByOutputType>[]
          }
          count: {
            args: Prisma.capitulosCountArgs<ExtArgs>
            result: $Utils.Optional<CapitulosCountAggregateOutputType> | number
          }
        }
      }
      intentos: {
        payload: Prisma.$intentosPayload<ExtArgs>
        fields: Prisma.intentosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.intentosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intentosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.intentosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intentosPayload>
          }
          findFirst: {
            args: Prisma.intentosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intentosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.intentosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intentosPayload>
          }
          findMany: {
            args: Prisma.intentosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intentosPayload>[]
          }
          create: {
            args: Prisma.intentosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intentosPayload>
          }
          createMany: {
            args: Prisma.intentosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.intentosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intentosPayload>[]
          }
          delete: {
            args: Prisma.intentosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intentosPayload>
          }
          update: {
            args: Prisma.intentosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intentosPayload>
          }
          deleteMany: {
            args: Prisma.intentosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.intentosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.intentosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intentosPayload>[]
          }
          upsert: {
            args: Prisma.intentosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intentosPayload>
          }
          aggregate: {
            args: Prisma.IntentosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntentos>
          }
          groupBy: {
            args: Prisma.intentosGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntentosGroupByOutputType>[]
          }
          count: {
            args: Prisma.intentosCountArgs<ExtArgs>
            result: $Utils.Optional<IntentosCountAggregateOutputType> | number
          }
        }
      }
      respuestasIntentos: {
        payload: Prisma.$respuestasIntentosPayload<ExtArgs>
        fields: Prisma.respuestasIntentosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.respuestasIntentosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$respuestasIntentosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.respuestasIntentosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$respuestasIntentosPayload>
          }
          findFirst: {
            args: Prisma.respuestasIntentosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$respuestasIntentosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.respuestasIntentosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$respuestasIntentosPayload>
          }
          findMany: {
            args: Prisma.respuestasIntentosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$respuestasIntentosPayload>[]
          }
          create: {
            args: Prisma.respuestasIntentosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$respuestasIntentosPayload>
          }
          createMany: {
            args: Prisma.respuestasIntentosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.respuestasIntentosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$respuestasIntentosPayload>[]
          }
          delete: {
            args: Prisma.respuestasIntentosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$respuestasIntentosPayload>
          }
          update: {
            args: Prisma.respuestasIntentosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$respuestasIntentosPayload>
          }
          deleteMany: {
            args: Prisma.respuestasIntentosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.respuestasIntentosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.respuestasIntentosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$respuestasIntentosPayload>[]
          }
          upsert: {
            args: Prisma.respuestasIntentosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$respuestasIntentosPayload>
          }
          aggregate: {
            args: Prisma.RespuestasIntentosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRespuestasIntentos>
          }
          groupBy: {
            args: Prisma.respuestasIntentosGroupByArgs<ExtArgs>
            result: $Utils.Optional<RespuestasIntentosGroupByOutputType>[]
          }
          count: {
            args: Prisma.respuestasIntentosCountArgs<ExtArgs>
            result: $Utils.Optional<RespuestasIntentosCountAggregateOutputType> | number
          }
        }
      }
      repasoRegistros: {
        payload: Prisma.$repasoRegistrosPayload<ExtArgs>
        fields: Prisma.repasoRegistrosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.repasoRegistrosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repasoRegistrosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.repasoRegistrosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repasoRegistrosPayload>
          }
          findFirst: {
            args: Prisma.repasoRegistrosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repasoRegistrosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.repasoRegistrosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repasoRegistrosPayload>
          }
          findMany: {
            args: Prisma.repasoRegistrosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repasoRegistrosPayload>[]
          }
          create: {
            args: Prisma.repasoRegistrosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repasoRegistrosPayload>
          }
          createMany: {
            args: Prisma.repasoRegistrosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.repasoRegistrosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repasoRegistrosPayload>[]
          }
          delete: {
            args: Prisma.repasoRegistrosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repasoRegistrosPayload>
          }
          update: {
            args: Prisma.repasoRegistrosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repasoRegistrosPayload>
          }
          deleteMany: {
            args: Prisma.repasoRegistrosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.repasoRegistrosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.repasoRegistrosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repasoRegistrosPayload>[]
          }
          upsert: {
            args: Prisma.repasoRegistrosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repasoRegistrosPayload>
          }
          aggregate: {
            args: Prisma.RepasoRegistrosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRepasoRegistros>
          }
          groupBy: {
            args: Prisma.repasoRegistrosGroupByArgs<ExtArgs>
            result: $Utils.Optional<RepasoRegistrosGroupByOutputType>[]
          }
          count: {
            args: Prisma.repasoRegistrosCountArgs<ExtArgs>
            result: $Utils.Optional<RepasoRegistrosCountAggregateOutputType> | number
          }
        }
      }
      suscripciones: {
        payload: Prisma.$suscripcionesPayload<ExtArgs>
        fields: Prisma.suscripcionesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.suscripcionesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suscripcionesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.suscripcionesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suscripcionesPayload>
          }
          findFirst: {
            args: Prisma.suscripcionesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suscripcionesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.suscripcionesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suscripcionesPayload>
          }
          findMany: {
            args: Prisma.suscripcionesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suscripcionesPayload>[]
          }
          create: {
            args: Prisma.suscripcionesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suscripcionesPayload>
          }
          createMany: {
            args: Prisma.suscripcionesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.suscripcionesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suscripcionesPayload>[]
          }
          delete: {
            args: Prisma.suscripcionesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suscripcionesPayload>
          }
          update: {
            args: Prisma.suscripcionesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suscripcionesPayload>
          }
          deleteMany: {
            args: Prisma.suscripcionesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.suscripcionesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.suscripcionesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suscripcionesPayload>[]
          }
          upsert: {
            args: Prisma.suscripcionesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$suscripcionesPayload>
          }
          aggregate: {
            args: Prisma.SuscripcionesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuscripciones>
          }
          groupBy: {
            args: Prisma.suscripcionesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SuscripcionesGroupByOutputType>[]
          }
          count: {
            args: Prisma.suscripcionesCountArgs<ExtArgs>
            result: $Utils.Optional<SuscripcionesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    auditoria?: auditoriaOmit
    beneficiosCursos?: beneficiosCursosOmit
    calificaciones?: calificacionesOmit
    categorias?: categoriasOmit
    categoriasCursos?: categoriasCursosOmit
    certificados?: certificadosOmit
    clases?: clasesOmit
    compras?: comprasOmit
    cursos?: cursosOmit
    docente?: docenteOmit
    edicionesCursos?: edicionesCursosOmit
    estudiantes?: estudiantesOmit
    temas?: temasOmit
    examenes?: examenesOmit
    grabaciones?: grabacionesOmit
    inscripciones?: inscripcionesOmit
    materiales?: materialesOmit
    objetivosCursos?: objetivosCursosOmit
    pagosDocentes?: pagosDocentesOmit
    preciosCursos?: preciosCursosOmit
    preguntas?: preguntasOmit
    reaccionesPreguntas?: reaccionesPreguntasOmit
    requisitosCursos?: requisitosCursosOmit
    reviewsCursos?: reviewsCursosOmit
    usuariosAdministradores?: usuariosAdministradoresOmit
    usuariosEstudiantes?: usuariosEstudiantesOmit
    areas?: areasOmit
    banqueo?: banqueoOmit
    capitulos?: capitulosOmit
    intentos?: intentosOmit
    respuestasIntentos?: respuestasIntentosOmit
    repasoRegistros?: repasoRegistrosOmit
    suscripciones?: suscripcionesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CategoriasCountOutputType
   */

  export type CategoriasCountOutputType = {
    categoriasCursos: number
  }

  export type CategoriasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categoriasCursos?: boolean | CategoriasCountOutputTypeCountCategoriasCursosArgs
  }

  // Custom InputTypes
  /**
   * CategoriasCountOutputType without action
   */
  export type CategoriasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriasCountOutputType
     */
    select?: CategoriasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriasCountOutputType without action
   */
  export type CategoriasCountOutputTypeCountCategoriasCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriasCursosWhereInput
  }


  /**
   * Count Type ClasesCountOutputType
   */

  export type ClasesCountOutputType = {
    grabaciones: number
    materiales: number
  }

  export type ClasesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grabaciones?: boolean | ClasesCountOutputTypeCountGrabacionesArgs
    materiales?: boolean | ClasesCountOutputTypeCountMaterialesArgs
  }

  // Custom InputTypes
  /**
   * ClasesCountOutputType without action
   */
  export type ClasesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClasesCountOutputType
     */
    select?: ClasesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClasesCountOutputType without action
   */
  export type ClasesCountOutputTypeCountGrabacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: grabacionesWhereInput
  }

  /**
   * ClasesCountOutputType without action
   */
  export type ClasesCountOutputTypeCountMaterialesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: materialesWhereInput
  }


  /**
   * Count Type CursosCountOutputType
   */

  export type CursosCountOutputType = {
    beneficiosCursos: number
    categoriasCursos: number
    edicionesCursos: number
    objetivosCursos: number
    requisitosCursos: number
    reviewsCursos: number
  }

  export type CursosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    beneficiosCursos?: boolean | CursosCountOutputTypeCountBeneficiosCursosArgs
    categoriasCursos?: boolean | CursosCountOutputTypeCountCategoriasCursosArgs
    edicionesCursos?: boolean | CursosCountOutputTypeCountEdicionesCursosArgs
    objetivosCursos?: boolean | CursosCountOutputTypeCountObjetivosCursosArgs
    requisitosCursos?: boolean | CursosCountOutputTypeCountRequisitosCursosArgs
    reviewsCursos?: boolean | CursosCountOutputTypeCountReviewsCursosArgs
  }

  // Custom InputTypes
  /**
   * CursosCountOutputType without action
   */
  export type CursosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursosCountOutputType
     */
    select?: CursosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CursosCountOutputType without action
   */
  export type CursosCountOutputTypeCountBeneficiosCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: beneficiosCursosWhereInput
  }

  /**
   * CursosCountOutputType without action
   */
  export type CursosCountOutputTypeCountCategoriasCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriasCursosWhereInput
  }

  /**
   * CursosCountOutputType without action
   */
  export type CursosCountOutputTypeCountEdicionesCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: edicionesCursosWhereInput
  }

  /**
   * CursosCountOutputType without action
   */
  export type CursosCountOutputTypeCountObjetivosCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: objetivosCursosWhereInput
  }

  /**
   * CursosCountOutputType without action
   */
  export type CursosCountOutputTypeCountRequisitosCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: requisitosCursosWhereInput
  }

  /**
   * CursosCountOutputType without action
   */
  export type CursosCountOutputTypeCountReviewsCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewsCursosWhereInput
  }


  /**
   * Count Type DocenteCountOutputType
   */

  export type DocenteCountOutputType = {
    edicionesCursos: number
    pagosDocentes: number
  }

  export type DocenteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicionesCursos?: boolean | DocenteCountOutputTypeCountEdicionesCursosArgs
    pagosDocentes?: boolean | DocenteCountOutputTypeCountPagosDocentesArgs
  }

  // Custom InputTypes
  /**
   * DocenteCountOutputType without action
   */
  export type DocenteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocenteCountOutputType
     */
    select?: DocenteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocenteCountOutputType without action
   */
  export type DocenteCountOutputTypeCountEdicionesCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: edicionesCursosWhereInput
  }

  /**
   * DocenteCountOutputType without action
   */
  export type DocenteCountOutputTypeCountPagosDocentesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pagosDocentesWhereInput
  }


  /**
   * Count Type EdicionesCursosCountOutputType
   */

  export type EdicionesCursosCountOutputType = {
    certificados: number
    clases: number
    compras: number
    examenes: number
    inscripciones: number
    preciosCursos: number
  }

  export type EdicionesCursosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certificados?: boolean | EdicionesCursosCountOutputTypeCountCertificadosArgs
    clases?: boolean | EdicionesCursosCountOutputTypeCountClasesArgs
    compras?: boolean | EdicionesCursosCountOutputTypeCountComprasArgs
    examenes?: boolean | EdicionesCursosCountOutputTypeCountExamenesArgs
    inscripciones?: boolean | EdicionesCursosCountOutputTypeCountInscripcionesArgs
    preciosCursos?: boolean | EdicionesCursosCountOutputTypeCountPreciosCursosArgs
  }

  // Custom InputTypes
  /**
   * EdicionesCursosCountOutputType without action
   */
  export type EdicionesCursosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EdicionesCursosCountOutputType
     */
    select?: EdicionesCursosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EdicionesCursosCountOutputType without action
   */
  export type EdicionesCursosCountOutputTypeCountCertificadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: certificadosWhereInput
  }

  /**
   * EdicionesCursosCountOutputType without action
   */
  export type EdicionesCursosCountOutputTypeCountClasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clasesWhereInput
  }

  /**
   * EdicionesCursosCountOutputType without action
   */
  export type EdicionesCursosCountOutputTypeCountComprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comprasWhereInput
  }

  /**
   * EdicionesCursosCountOutputType without action
   */
  export type EdicionesCursosCountOutputTypeCountExamenesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: examenesWhereInput
  }

  /**
   * EdicionesCursosCountOutputType without action
   */
  export type EdicionesCursosCountOutputTypeCountInscripcionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inscripcionesWhereInput
  }

  /**
   * EdicionesCursosCountOutputType without action
   */
  export type EdicionesCursosCountOutputTypeCountPreciosCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: preciosCursosWhereInput
  }


  /**
   * Count Type EstudiantesCountOutputType
   */

  export type EstudiantesCountOutputType = {
    calificaciones: number
    certificados: number
    inscripciones: number
  }

  export type EstudiantesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calificaciones?: boolean | EstudiantesCountOutputTypeCountCalificacionesArgs
    certificados?: boolean | EstudiantesCountOutputTypeCountCertificadosArgs
    inscripciones?: boolean | EstudiantesCountOutputTypeCountInscripcionesArgs
  }

  // Custom InputTypes
  /**
   * EstudiantesCountOutputType without action
   */
  export type EstudiantesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstudiantesCountOutputType
     */
    select?: EstudiantesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EstudiantesCountOutputType without action
   */
  export type EstudiantesCountOutputTypeCountCalificacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: calificacionesWhereInput
  }

  /**
   * EstudiantesCountOutputType without action
   */
  export type EstudiantesCountOutputTypeCountCertificadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: certificadosWhereInput
  }

  /**
   * EstudiantesCountOutputType without action
   */
  export type EstudiantesCountOutputTypeCountInscripcionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inscripcionesWhereInput
  }


  /**
   * Count Type TemasCountOutputType
   */

  export type TemasCountOutputType = {
    preguntas: number
  }

  export type TemasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    preguntas?: boolean | TemasCountOutputTypeCountPreguntasArgs
  }

  // Custom InputTypes
  /**
   * TemasCountOutputType without action
   */
  export type TemasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemasCountOutputType
     */
    select?: TemasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TemasCountOutputType without action
   */
  export type TemasCountOutputTypeCountPreguntasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: preguntasWhereInput
  }


  /**
   * Count Type ExamenesCountOutputType
   */

  export type ExamenesCountOutputType = {
    calificaciones: number
  }

  export type ExamenesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calificaciones?: boolean | ExamenesCountOutputTypeCountCalificacionesArgs
  }

  // Custom InputTypes
  /**
   * ExamenesCountOutputType without action
   */
  export type ExamenesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamenesCountOutputType
     */
    select?: ExamenesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamenesCountOutputType without action
   */
  export type ExamenesCountOutputTypeCountCalificacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: calificacionesWhereInput
  }


  /**
   * Count Type PreguntasCountOutputType
   */

  export type PreguntasCountOutputType = {
    reaccionesPreguntas: number
    repasoRegistros: number
    respuestasIntentos: number
    areas: number
    banqueo: number
    capitulos: number
    temas: number
  }

  export type PreguntasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reaccionesPreguntas?: boolean | PreguntasCountOutputTypeCountReaccionesPreguntasArgs
    repasoRegistros?: boolean | PreguntasCountOutputTypeCountRepasoRegistrosArgs
    respuestasIntentos?: boolean | PreguntasCountOutputTypeCountRespuestasIntentosArgs
    areas?: boolean | PreguntasCountOutputTypeCountAreasArgs
    banqueo?: boolean | PreguntasCountOutputTypeCountBanqueoArgs
    capitulos?: boolean | PreguntasCountOutputTypeCountCapitulosArgs
    temas?: boolean | PreguntasCountOutputTypeCountTemasArgs
  }

  // Custom InputTypes
  /**
   * PreguntasCountOutputType without action
   */
  export type PreguntasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreguntasCountOutputType
     */
    select?: PreguntasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PreguntasCountOutputType without action
   */
  export type PreguntasCountOutputTypeCountReaccionesPreguntasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reaccionesPreguntasWhereInput
  }

  /**
   * PreguntasCountOutputType without action
   */
  export type PreguntasCountOutputTypeCountRepasoRegistrosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: repasoRegistrosWhereInput
  }

  /**
   * PreguntasCountOutputType without action
   */
  export type PreguntasCountOutputTypeCountRespuestasIntentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: respuestasIntentosWhereInput
  }

  /**
   * PreguntasCountOutputType without action
   */
  export type PreguntasCountOutputTypeCountAreasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: areasWhereInput
  }

  /**
   * PreguntasCountOutputType without action
   */
  export type PreguntasCountOutputTypeCountBanqueoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: banqueoWhereInput
  }

  /**
   * PreguntasCountOutputType without action
   */
  export type PreguntasCountOutputTypeCountCapitulosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: capitulosWhereInput
  }

  /**
   * PreguntasCountOutputType without action
   */
  export type PreguntasCountOutputTypeCountTemasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: temasWhereInput
  }


  /**
   * Count Type UsuariosAdministradoresCountOutputType
   */

  export type UsuariosAdministradoresCountOutputType = {
    auditoria: number
    grabaciones: number
  }

  export type UsuariosAdministradoresCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditoria?: boolean | UsuariosAdministradoresCountOutputTypeCountAuditoriaArgs
    grabaciones?: boolean | UsuariosAdministradoresCountOutputTypeCountGrabacionesArgs
  }

  // Custom InputTypes
  /**
   * UsuariosAdministradoresCountOutputType without action
   */
  export type UsuariosAdministradoresCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosAdministradoresCountOutputType
     */
    select?: UsuariosAdministradoresCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuariosAdministradoresCountOutputType without action
   */
  export type UsuariosAdministradoresCountOutputTypeCountAuditoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auditoriaWhereInput
  }

  /**
   * UsuariosAdministradoresCountOutputType without action
   */
  export type UsuariosAdministradoresCountOutputTypeCountGrabacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: grabacionesWhereInput
  }


  /**
   * Count Type UsuariosEstudiantesCountOutputType
   */

  export type UsuariosEstudiantesCountOutputType = {
    compras: number
    intentos: number
    reaccionesPreguntas: number
    repasoRegistros: number
    reviewsCursos: number
    suscripciones: number
  }

  export type UsuariosEstudiantesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    compras?: boolean | UsuariosEstudiantesCountOutputTypeCountComprasArgs
    intentos?: boolean | UsuariosEstudiantesCountOutputTypeCountIntentosArgs
    reaccionesPreguntas?: boolean | UsuariosEstudiantesCountOutputTypeCountReaccionesPreguntasArgs
    repasoRegistros?: boolean | UsuariosEstudiantesCountOutputTypeCountRepasoRegistrosArgs
    reviewsCursos?: boolean | UsuariosEstudiantesCountOutputTypeCountReviewsCursosArgs
    suscripciones?: boolean | UsuariosEstudiantesCountOutputTypeCountSuscripcionesArgs
  }

  // Custom InputTypes
  /**
   * UsuariosEstudiantesCountOutputType without action
   */
  export type UsuariosEstudiantesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosEstudiantesCountOutputType
     */
    select?: UsuariosEstudiantesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuariosEstudiantesCountOutputType without action
   */
  export type UsuariosEstudiantesCountOutputTypeCountComprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comprasWhereInput
  }

  /**
   * UsuariosEstudiantesCountOutputType without action
   */
  export type UsuariosEstudiantesCountOutputTypeCountIntentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: intentosWhereInput
  }

  /**
   * UsuariosEstudiantesCountOutputType without action
   */
  export type UsuariosEstudiantesCountOutputTypeCountReaccionesPreguntasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reaccionesPreguntasWhereInput
  }

  /**
   * UsuariosEstudiantesCountOutputType without action
   */
  export type UsuariosEstudiantesCountOutputTypeCountRepasoRegistrosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: repasoRegistrosWhereInput
  }

  /**
   * UsuariosEstudiantesCountOutputType without action
   */
  export type UsuariosEstudiantesCountOutputTypeCountReviewsCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewsCursosWhereInput
  }

  /**
   * UsuariosEstudiantesCountOutputType without action
   */
  export type UsuariosEstudiantesCountOutputTypeCountSuscripcionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: suscripcionesWhereInput
  }


  /**
   * Count Type AreasCountOutputType
   */

  export type AreasCountOutputType = {
    capitulos: number
    preguntas: number
  }

  export type AreasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capitulos?: boolean | AreasCountOutputTypeCountCapitulosArgs
    preguntas?: boolean | AreasCountOutputTypeCountPreguntasArgs
  }

  // Custom InputTypes
  /**
   * AreasCountOutputType without action
   */
  export type AreasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreasCountOutputType
     */
    select?: AreasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AreasCountOutputType without action
   */
  export type AreasCountOutputTypeCountCapitulosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: capitulosWhereInput
  }

  /**
   * AreasCountOutputType without action
   */
  export type AreasCountOutputTypeCountPreguntasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: preguntasWhereInput
  }


  /**
   * Count Type BanqueoCountOutputType
   */

  export type BanqueoCountOutputType = {
    intentos: number
    repasoRegistros: number
    preguntas: number
  }

  export type BanqueoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    intentos?: boolean | BanqueoCountOutputTypeCountIntentosArgs
    repasoRegistros?: boolean | BanqueoCountOutputTypeCountRepasoRegistrosArgs
    preguntas?: boolean | BanqueoCountOutputTypeCountPreguntasArgs
  }

  // Custom InputTypes
  /**
   * BanqueoCountOutputType without action
   */
  export type BanqueoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanqueoCountOutputType
     */
    select?: BanqueoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BanqueoCountOutputType without action
   */
  export type BanqueoCountOutputTypeCountIntentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: intentosWhereInput
  }

  /**
   * BanqueoCountOutputType without action
   */
  export type BanqueoCountOutputTypeCountRepasoRegistrosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: repasoRegistrosWhereInput
  }

  /**
   * BanqueoCountOutputType without action
   */
  export type BanqueoCountOutputTypeCountPreguntasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: preguntasWhereInput
  }


  /**
   * Count Type CapitulosCountOutputType
   */

  export type CapitulosCountOutputType = {
    temas: number
    preguntas: number
  }

  export type CapitulosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    temas?: boolean | CapitulosCountOutputTypeCountTemasArgs
    preguntas?: boolean | CapitulosCountOutputTypeCountPreguntasArgs
  }

  // Custom InputTypes
  /**
   * CapitulosCountOutputType without action
   */
  export type CapitulosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapitulosCountOutputType
     */
    select?: CapitulosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CapitulosCountOutputType without action
   */
  export type CapitulosCountOutputTypeCountTemasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: temasWhereInput
  }

  /**
   * CapitulosCountOutputType without action
   */
  export type CapitulosCountOutputTypeCountPreguntasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: preguntasWhereInput
  }


  /**
   * Count Type IntentosCountOutputType
   */

  export type IntentosCountOutputType = {
    respuestasIntentos: number
  }

  export type IntentosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    respuestasIntentos?: boolean | IntentosCountOutputTypeCountRespuestasIntentosArgs
  }

  // Custom InputTypes
  /**
   * IntentosCountOutputType without action
   */
  export type IntentosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntentosCountOutputType
     */
    select?: IntentosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IntentosCountOutputType without action
   */
  export type IntentosCountOutputTypeCountRespuestasIntentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: respuestasIntentosWhereInput
  }


  /**
   * Models
   */

  /**
   * Model auditoria
   */

  export type AggregateAuditoria = {
    _count: AuditoriaCountAggregateOutputType | null
    _min: AuditoriaMinAggregateOutputType | null
    _max: AuditoriaMaxAggregateOutputType | null
  }

  export type AuditoriaMinAggregateOutputType = {
    id: string | null
    tabla: $Enums.Tabla | null
    registroId: string | null
    accion: $Enums.AccionAuditoria | null
    usuarioId: string | null
    creadoEn: Date | null
  }

  export type AuditoriaMaxAggregateOutputType = {
    id: string | null
    tabla: $Enums.Tabla | null
    registroId: string | null
    accion: $Enums.AccionAuditoria | null
    usuarioId: string | null
    creadoEn: Date | null
  }

  export type AuditoriaCountAggregateOutputType = {
    id: number
    tabla: number
    registroId: number
    accion: number
    detalles: number
    usuarioId: number
    creadoEn: number
    _all: number
  }


  export type AuditoriaMinAggregateInputType = {
    id?: true
    tabla?: true
    registroId?: true
    accion?: true
    usuarioId?: true
    creadoEn?: true
  }

  export type AuditoriaMaxAggregateInputType = {
    id?: true
    tabla?: true
    registroId?: true
    accion?: true
    usuarioId?: true
    creadoEn?: true
  }

  export type AuditoriaCountAggregateInputType = {
    id?: true
    tabla?: true
    registroId?: true
    accion?: true
    detalles?: true
    usuarioId?: true
    creadoEn?: true
    _all?: true
  }

  export type AuditoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auditoria to aggregate.
     */
    where?: auditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditorias to fetch.
     */
    orderBy?: auditoriaOrderByWithRelationInput | auditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auditorias
    **/
    _count?: true | AuditoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditoriaMaxAggregateInputType
  }

  export type GetAuditoriaAggregateType<T extends AuditoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditoria[P]>
      : GetScalarType<T[P], AggregateAuditoria[P]>
  }




  export type auditoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auditoriaWhereInput
    orderBy?: auditoriaOrderByWithAggregationInput | auditoriaOrderByWithAggregationInput[]
    by: AuditoriaScalarFieldEnum[] | AuditoriaScalarFieldEnum
    having?: auditoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditoriaCountAggregateInputType | true
    _min?: AuditoriaMinAggregateInputType
    _max?: AuditoriaMaxAggregateInputType
  }

  export type AuditoriaGroupByOutputType = {
    id: string
    tabla: $Enums.Tabla
    registroId: string | null
    accion: $Enums.AccionAuditoria
    detalles: JsonValue | null
    usuarioId: string
    creadoEn: Date
    _count: AuditoriaCountAggregateOutputType | null
    _min: AuditoriaMinAggregateOutputType | null
    _max: AuditoriaMaxAggregateOutputType | null
  }

  type GetAuditoriaGroupByPayload<T extends auditoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditoriaGroupByOutputType[P]>
            : GetScalarType<T[P], AuditoriaGroupByOutputType[P]>
        }
      >
    >


  export type auditoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tabla?: boolean
    registroId?: boolean
    accion?: boolean
    detalles?: boolean
    usuarioId?: boolean
    creadoEn?: boolean
    usuariosAdministradores?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditoria"]>

  export type auditoriaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tabla?: boolean
    registroId?: boolean
    accion?: boolean
    detalles?: boolean
    usuarioId?: boolean
    creadoEn?: boolean
    usuariosAdministradores?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditoria"]>

  export type auditoriaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tabla?: boolean
    registroId?: boolean
    accion?: boolean
    detalles?: boolean
    usuarioId?: boolean
    creadoEn?: boolean
    usuariosAdministradores?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditoria"]>

  export type auditoriaSelectScalar = {
    id?: boolean
    tabla?: boolean
    registroId?: boolean
    accion?: boolean
    detalles?: boolean
    usuarioId?: boolean
    creadoEn?: boolean
  }

  export type auditoriaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tabla" | "registroId" | "accion" | "detalles" | "usuarioId" | "creadoEn", ExtArgs["result"]["auditoria"]>
  export type auditoriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuariosAdministradores?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }
  export type auditoriaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuariosAdministradores?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }
  export type auditoriaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuariosAdministradores?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }

  export type $auditoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "auditoria"
    objects: {
      usuariosAdministradores: Prisma.$usuariosAdministradoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tabla: $Enums.Tabla
      registroId: string | null
      accion: $Enums.AccionAuditoria
      detalles: Prisma.JsonValue | null
      usuarioId: string
      creadoEn: Date
    }, ExtArgs["result"]["auditoria"]>
    composites: {}
  }

  type auditoriaGetPayload<S extends boolean | null | undefined | auditoriaDefaultArgs> = $Result.GetResult<Prisma.$auditoriaPayload, S>

  type auditoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<auditoriaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditoriaCountAggregateInputType | true
    }

  export interface auditoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['auditoria'], meta: { name: 'auditoria' } }
    /**
     * Find zero or one Auditoria that matches the filter.
     * @param {auditoriaFindUniqueArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends auditoriaFindUniqueArgs>(args: SelectSubset<T, auditoriaFindUniqueArgs<ExtArgs>>): Prisma__auditoriaClient<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Auditoria that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {auditoriaFindUniqueOrThrowArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends auditoriaFindUniqueOrThrowArgs>(args: SelectSubset<T, auditoriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__auditoriaClient<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auditoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaFindFirstArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends auditoriaFindFirstArgs>(args?: SelectSubset<T, auditoriaFindFirstArgs<ExtArgs>>): Prisma__auditoriaClient<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auditoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaFindFirstOrThrowArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends auditoriaFindFirstOrThrowArgs>(args?: SelectSubset<T, auditoriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__auditoriaClient<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Auditorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auditorias
     * const auditorias = await prisma.auditoria.findMany()
     * 
     * // Get first 10 Auditorias
     * const auditorias = await prisma.auditoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditoriaWithIdOnly = await prisma.auditoria.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends auditoriaFindManyArgs>(args?: SelectSubset<T, auditoriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Auditoria.
     * @param {auditoriaCreateArgs} args - Arguments to create a Auditoria.
     * @example
     * // Create one Auditoria
     * const Auditoria = await prisma.auditoria.create({
     *   data: {
     *     // ... data to create a Auditoria
     *   }
     * })
     * 
     */
    create<T extends auditoriaCreateArgs>(args: SelectSubset<T, auditoriaCreateArgs<ExtArgs>>): Prisma__auditoriaClient<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Auditorias.
     * @param {auditoriaCreateManyArgs} args - Arguments to create many Auditorias.
     * @example
     * // Create many Auditorias
     * const auditoria = await prisma.auditoria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends auditoriaCreateManyArgs>(args?: SelectSubset<T, auditoriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Auditorias and returns the data saved in the database.
     * @param {auditoriaCreateManyAndReturnArgs} args - Arguments to create many Auditorias.
     * @example
     * // Create many Auditorias
     * const auditoria = await prisma.auditoria.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Auditorias and only return the `id`
     * const auditoriaWithIdOnly = await prisma.auditoria.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends auditoriaCreateManyAndReturnArgs>(args?: SelectSubset<T, auditoriaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Auditoria.
     * @param {auditoriaDeleteArgs} args - Arguments to delete one Auditoria.
     * @example
     * // Delete one Auditoria
     * const Auditoria = await prisma.auditoria.delete({
     *   where: {
     *     // ... filter to delete one Auditoria
     *   }
     * })
     * 
     */
    delete<T extends auditoriaDeleteArgs>(args: SelectSubset<T, auditoriaDeleteArgs<ExtArgs>>): Prisma__auditoriaClient<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Auditoria.
     * @param {auditoriaUpdateArgs} args - Arguments to update one Auditoria.
     * @example
     * // Update one Auditoria
     * const auditoria = await prisma.auditoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends auditoriaUpdateArgs>(args: SelectSubset<T, auditoriaUpdateArgs<ExtArgs>>): Prisma__auditoriaClient<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Auditorias.
     * @param {auditoriaDeleteManyArgs} args - Arguments to filter Auditorias to delete.
     * @example
     * // Delete a few Auditorias
     * const { count } = await prisma.auditoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends auditoriaDeleteManyArgs>(args?: SelectSubset<T, auditoriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auditorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auditorias
     * const auditoria = await prisma.auditoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends auditoriaUpdateManyArgs>(args: SelectSubset<T, auditoriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auditorias and returns the data updated in the database.
     * @param {auditoriaUpdateManyAndReturnArgs} args - Arguments to update many Auditorias.
     * @example
     * // Update many Auditorias
     * const auditoria = await prisma.auditoria.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Auditorias and only return the `id`
     * const auditoriaWithIdOnly = await prisma.auditoria.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends auditoriaUpdateManyAndReturnArgs>(args: SelectSubset<T, auditoriaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Auditoria.
     * @param {auditoriaUpsertArgs} args - Arguments to update or create a Auditoria.
     * @example
     * // Update or create a Auditoria
     * const auditoria = await prisma.auditoria.upsert({
     *   create: {
     *     // ... data to create a Auditoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auditoria we want to update
     *   }
     * })
     */
    upsert<T extends auditoriaUpsertArgs>(args: SelectSubset<T, auditoriaUpsertArgs<ExtArgs>>): Prisma__auditoriaClient<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Auditorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaCountArgs} args - Arguments to filter Auditorias to count.
     * @example
     * // Count the number of Auditorias
     * const count = await prisma.auditoria.count({
     *   where: {
     *     // ... the filter for the Auditorias we want to count
     *   }
     * })
    **/
    count<T extends auditoriaCountArgs>(
      args?: Subset<T, auditoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auditoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditoriaAggregateArgs>(args: Subset<T, AuditoriaAggregateArgs>): Prisma.PrismaPromise<GetAuditoriaAggregateType<T>>

    /**
     * Group by Auditoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends auditoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: auditoriaGroupByArgs['orderBy'] }
        : { orderBy?: auditoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, auditoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the auditoria model
   */
  readonly fields: auditoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for auditoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__auditoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuariosAdministradores<T extends usuariosAdministradoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usuariosAdministradoresDefaultArgs<ExtArgs>>): Prisma__usuariosAdministradoresClient<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the auditoria model
   */
  interface auditoriaFieldRefs {
    readonly id: FieldRef<"auditoria", 'String'>
    readonly tabla: FieldRef<"auditoria", 'Tabla'>
    readonly registroId: FieldRef<"auditoria", 'String'>
    readonly accion: FieldRef<"auditoria", 'AccionAuditoria'>
    readonly detalles: FieldRef<"auditoria", 'Json'>
    readonly usuarioId: FieldRef<"auditoria", 'String'>
    readonly creadoEn: FieldRef<"auditoria", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * auditoria findUnique
   */
  export type auditoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * Filter, which auditoria to fetch.
     */
    where: auditoriaWhereUniqueInput
  }

  /**
   * auditoria findUniqueOrThrow
   */
  export type auditoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * Filter, which auditoria to fetch.
     */
    where: auditoriaWhereUniqueInput
  }

  /**
   * auditoria findFirst
   */
  export type auditoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * Filter, which auditoria to fetch.
     */
    where?: auditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditorias to fetch.
     */
    orderBy?: auditoriaOrderByWithRelationInput | auditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auditorias.
     */
    cursor?: auditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auditorias.
     */
    distinct?: AuditoriaScalarFieldEnum | AuditoriaScalarFieldEnum[]
  }

  /**
   * auditoria findFirstOrThrow
   */
  export type auditoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * Filter, which auditoria to fetch.
     */
    where?: auditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditorias to fetch.
     */
    orderBy?: auditoriaOrderByWithRelationInput | auditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auditorias.
     */
    cursor?: auditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auditorias.
     */
    distinct?: AuditoriaScalarFieldEnum | AuditoriaScalarFieldEnum[]
  }

  /**
   * auditoria findMany
   */
  export type auditoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * Filter, which auditorias to fetch.
     */
    where?: auditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditorias to fetch.
     */
    orderBy?: auditoriaOrderByWithRelationInput | auditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auditorias.
     */
    cursor?: auditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditorias.
     */
    skip?: number
    distinct?: AuditoriaScalarFieldEnum | AuditoriaScalarFieldEnum[]
  }

  /**
   * auditoria create
   */
  export type auditoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * The data needed to create a auditoria.
     */
    data: XOR<auditoriaCreateInput, auditoriaUncheckedCreateInput>
  }

  /**
   * auditoria createMany
   */
  export type auditoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many auditorias.
     */
    data: auditoriaCreateManyInput | auditoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * auditoria createManyAndReturn
   */
  export type auditoriaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * The data used to create many auditorias.
     */
    data: auditoriaCreateManyInput | auditoriaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * auditoria update
   */
  export type auditoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * The data needed to update a auditoria.
     */
    data: XOR<auditoriaUpdateInput, auditoriaUncheckedUpdateInput>
    /**
     * Choose, which auditoria to update.
     */
    where: auditoriaWhereUniqueInput
  }

  /**
   * auditoria updateMany
   */
  export type auditoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update auditorias.
     */
    data: XOR<auditoriaUpdateManyMutationInput, auditoriaUncheckedUpdateManyInput>
    /**
     * Filter which auditorias to update
     */
    where?: auditoriaWhereInput
    /**
     * Limit how many auditorias to update.
     */
    limit?: number
  }

  /**
   * auditoria updateManyAndReturn
   */
  export type auditoriaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * The data used to update auditorias.
     */
    data: XOR<auditoriaUpdateManyMutationInput, auditoriaUncheckedUpdateManyInput>
    /**
     * Filter which auditorias to update
     */
    where?: auditoriaWhereInput
    /**
     * Limit how many auditorias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * auditoria upsert
   */
  export type auditoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * The filter to search for the auditoria to update in case it exists.
     */
    where: auditoriaWhereUniqueInput
    /**
     * In case the auditoria found by the `where` argument doesn't exist, create a new auditoria with this data.
     */
    create: XOR<auditoriaCreateInput, auditoriaUncheckedCreateInput>
    /**
     * In case the auditoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auditoriaUpdateInput, auditoriaUncheckedUpdateInput>
  }

  /**
   * auditoria delete
   */
  export type auditoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    /**
     * Filter which auditoria to delete.
     */
    where: auditoriaWhereUniqueInput
  }

  /**
   * auditoria deleteMany
   */
  export type auditoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auditorias to delete
     */
    where?: auditoriaWhereInput
    /**
     * Limit how many auditorias to delete.
     */
    limit?: number
  }

  /**
   * auditoria without action
   */
  export type auditoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
  }


  /**
   * Model beneficiosCursos
   */

  export type AggregateBeneficiosCursos = {
    _count: BeneficiosCursosCountAggregateOutputType | null
    _avg: BeneficiosCursosAvgAggregateOutputType | null
    _sum: BeneficiosCursosSumAggregateOutputType | null
    _min: BeneficiosCursosMinAggregateOutputType | null
    _max: BeneficiosCursosMaxAggregateOutputType | null
  }

  export type BeneficiosCursosAvgAggregateOutputType = {
    orden: number | null
  }

  export type BeneficiosCursosSumAggregateOutputType = {
    orden: number | null
  }

  export type BeneficiosCursosMinAggregateOutputType = {
    id: string | null
    cursoId: string | null
    descripcion: string | null
    orden: number | null
    creadoEn: Date | null
  }

  export type BeneficiosCursosMaxAggregateOutputType = {
    id: string | null
    cursoId: string | null
    descripcion: string | null
    orden: number | null
    creadoEn: Date | null
  }

  export type BeneficiosCursosCountAggregateOutputType = {
    id: number
    cursoId: number
    descripcion: number
    orden: number
    creadoEn: number
    _all: number
  }


  export type BeneficiosCursosAvgAggregateInputType = {
    orden?: true
  }

  export type BeneficiosCursosSumAggregateInputType = {
    orden?: true
  }

  export type BeneficiosCursosMinAggregateInputType = {
    id?: true
    cursoId?: true
    descripcion?: true
    orden?: true
    creadoEn?: true
  }

  export type BeneficiosCursosMaxAggregateInputType = {
    id?: true
    cursoId?: true
    descripcion?: true
    orden?: true
    creadoEn?: true
  }

  export type BeneficiosCursosCountAggregateInputType = {
    id?: true
    cursoId?: true
    descripcion?: true
    orden?: true
    creadoEn?: true
    _all?: true
  }

  export type BeneficiosCursosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which beneficiosCursos to aggregate.
     */
    where?: beneficiosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of beneficiosCursos to fetch.
     */
    orderBy?: beneficiosCursosOrderByWithRelationInput | beneficiosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: beneficiosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` beneficiosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` beneficiosCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned beneficiosCursos
    **/
    _count?: true | BeneficiosCursosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BeneficiosCursosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BeneficiosCursosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BeneficiosCursosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BeneficiosCursosMaxAggregateInputType
  }

  export type GetBeneficiosCursosAggregateType<T extends BeneficiosCursosAggregateArgs> = {
        [P in keyof T & keyof AggregateBeneficiosCursos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBeneficiosCursos[P]>
      : GetScalarType<T[P], AggregateBeneficiosCursos[P]>
  }




  export type beneficiosCursosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: beneficiosCursosWhereInput
    orderBy?: beneficiosCursosOrderByWithAggregationInput | beneficiosCursosOrderByWithAggregationInput[]
    by: BeneficiosCursosScalarFieldEnum[] | BeneficiosCursosScalarFieldEnum
    having?: beneficiosCursosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BeneficiosCursosCountAggregateInputType | true
    _avg?: BeneficiosCursosAvgAggregateInputType
    _sum?: BeneficiosCursosSumAggregateInputType
    _min?: BeneficiosCursosMinAggregateInputType
    _max?: BeneficiosCursosMaxAggregateInputType
  }

  export type BeneficiosCursosGroupByOutputType = {
    id: string
    cursoId: string
    descripcion: string
    orden: number
    creadoEn: Date
    _count: BeneficiosCursosCountAggregateOutputType | null
    _avg: BeneficiosCursosAvgAggregateOutputType | null
    _sum: BeneficiosCursosSumAggregateOutputType | null
    _min: BeneficiosCursosMinAggregateOutputType | null
    _max: BeneficiosCursosMaxAggregateOutputType | null
  }

  type GetBeneficiosCursosGroupByPayload<T extends beneficiosCursosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BeneficiosCursosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BeneficiosCursosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BeneficiosCursosGroupByOutputType[P]>
            : GetScalarType<T[P], BeneficiosCursosGroupByOutputType[P]>
        }
      >
    >


  export type beneficiosCursosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    descripcion?: boolean
    orden?: boolean
    creadoEn?: boolean
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["beneficiosCursos"]>

  export type beneficiosCursosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    descripcion?: boolean
    orden?: boolean
    creadoEn?: boolean
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["beneficiosCursos"]>

  export type beneficiosCursosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    descripcion?: boolean
    orden?: boolean
    creadoEn?: boolean
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["beneficiosCursos"]>

  export type beneficiosCursosSelectScalar = {
    id?: boolean
    cursoId?: boolean
    descripcion?: boolean
    orden?: boolean
    creadoEn?: boolean
  }

  export type beneficiosCursosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cursoId" | "descripcion" | "orden" | "creadoEn", ExtArgs["result"]["beneficiosCursos"]>
  export type beneficiosCursosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
  }
  export type beneficiosCursosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
  }
  export type beneficiosCursosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
  }

  export type $beneficiosCursosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "beneficiosCursos"
    objects: {
      cursos: Prisma.$cursosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cursoId: string
      descripcion: string
      orden: number
      creadoEn: Date
    }, ExtArgs["result"]["beneficiosCursos"]>
    composites: {}
  }

  type beneficiosCursosGetPayload<S extends boolean | null | undefined | beneficiosCursosDefaultArgs> = $Result.GetResult<Prisma.$beneficiosCursosPayload, S>

  type beneficiosCursosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<beneficiosCursosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BeneficiosCursosCountAggregateInputType | true
    }

  export interface beneficiosCursosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['beneficiosCursos'], meta: { name: 'beneficiosCursos' } }
    /**
     * Find zero or one BeneficiosCursos that matches the filter.
     * @param {beneficiosCursosFindUniqueArgs} args - Arguments to find a BeneficiosCursos
     * @example
     * // Get one BeneficiosCursos
     * const beneficiosCursos = await prisma.beneficiosCursos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends beneficiosCursosFindUniqueArgs>(args: SelectSubset<T, beneficiosCursosFindUniqueArgs<ExtArgs>>): Prisma__beneficiosCursosClient<$Result.GetResult<Prisma.$beneficiosCursosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BeneficiosCursos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {beneficiosCursosFindUniqueOrThrowArgs} args - Arguments to find a BeneficiosCursos
     * @example
     * // Get one BeneficiosCursos
     * const beneficiosCursos = await prisma.beneficiosCursos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends beneficiosCursosFindUniqueOrThrowArgs>(args: SelectSubset<T, beneficiosCursosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__beneficiosCursosClient<$Result.GetResult<Prisma.$beneficiosCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BeneficiosCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beneficiosCursosFindFirstArgs} args - Arguments to find a BeneficiosCursos
     * @example
     * // Get one BeneficiosCursos
     * const beneficiosCursos = await prisma.beneficiosCursos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends beneficiosCursosFindFirstArgs>(args?: SelectSubset<T, beneficiosCursosFindFirstArgs<ExtArgs>>): Prisma__beneficiosCursosClient<$Result.GetResult<Prisma.$beneficiosCursosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BeneficiosCursos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beneficiosCursosFindFirstOrThrowArgs} args - Arguments to find a BeneficiosCursos
     * @example
     * // Get one BeneficiosCursos
     * const beneficiosCursos = await prisma.beneficiosCursos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends beneficiosCursosFindFirstOrThrowArgs>(args?: SelectSubset<T, beneficiosCursosFindFirstOrThrowArgs<ExtArgs>>): Prisma__beneficiosCursosClient<$Result.GetResult<Prisma.$beneficiosCursosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BeneficiosCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beneficiosCursosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BeneficiosCursos
     * const beneficiosCursos = await prisma.beneficiosCursos.findMany()
     * 
     * // Get first 10 BeneficiosCursos
     * const beneficiosCursos = await prisma.beneficiosCursos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const beneficiosCursosWithIdOnly = await prisma.beneficiosCursos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends beneficiosCursosFindManyArgs>(args?: SelectSubset<T, beneficiosCursosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$beneficiosCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BeneficiosCursos.
     * @param {beneficiosCursosCreateArgs} args - Arguments to create a BeneficiosCursos.
     * @example
     * // Create one BeneficiosCursos
     * const BeneficiosCursos = await prisma.beneficiosCursos.create({
     *   data: {
     *     // ... data to create a BeneficiosCursos
     *   }
     * })
     * 
     */
    create<T extends beneficiosCursosCreateArgs>(args: SelectSubset<T, beneficiosCursosCreateArgs<ExtArgs>>): Prisma__beneficiosCursosClient<$Result.GetResult<Prisma.$beneficiosCursosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BeneficiosCursos.
     * @param {beneficiosCursosCreateManyArgs} args - Arguments to create many BeneficiosCursos.
     * @example
     * // Create many BeneficiosCursos
     * const beneficiosCursos = await prisma.beneficiosCursos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends beneficiosCursosCreateManyArgs>(args?: SelectSubset<T, beneficiosCursosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BeneficiosCursos and returns the data saved in the database.
     * @param {beneficiosCursosCreateManyAndReturnArgs} args - Arguments to create many BeneficiosCursos.
     * @example
     * // Create many BeneficiosCursos
     * const beneficiosCursos = await prisma.beneficiosCursos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BeneficiosCursos and only return the `id`
     * const beneficiosCursosWithIdOnly = await prisma.beneficiosCursos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends beneficiosCursosCreateManyAndReturnArgs>(args?: SelectSubset<T, beneficiosCursosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$beneficiosCursosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BeneficiosCursos.
     * @param {beneficiosCursosDeleteArgs} args - Arguments to delete one BeneficiosCursos.
     * @example
     * // Delete one BeneficiosCursos
     * const BeneficiosCursos = await prisma.beneficiosCursos.delete({
     *   where: {
     *     // ... filter to delete one BeneficiosCursos
     *   }
     * })
     * 
     */
    delete<T extends beneficiosCursosDeleteArgs>(args: SelectSubset<T, beneficiosCursosDeleteArgs<ExtArgs>>): Prisma__beneficiosCursosClient<$Result.GetResult<Prisma.$beneficiosCursosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BeneficiosCursos.
     * @param {beneficiosCursosUpdateArgs} args - Arguments to update one BeneficiosCursos.
     * @example
     * // Update one BeneficiosCursos
     * const beneficiosCursos = await prisma.beneficiosCursos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends beneficiosCursosUpdateArgs>(args: SelectSubset<T, beneficiosCursosUpdateArgs<ExtArgs>>): Prisma__beneficiosCursosClient<$Result.GetResult<Prisma.$beneficiosCursosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BeneficiosCursos.
     * @param {beneficiosCursosDeleteManyArgs} args - Arguments to filter BeneficiosCursos to delete.
     * @example
     * // Delete a few BeneficiosCursos
     * const { count } = await prisma.beneficiosCursos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends beneficiosCursosDeleteManyArgs>(args?: SelectSubset<T, beneficiosCursosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BeneficiosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beneficiosCursosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BeneficiosCursos
     * const beneficiosCursos = await prisma.beneficiosCursos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends beneficiosCursosUpdateManyArgs>(args: SelectSubset<T, beneficiosCursosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BeneficiosCursos and returns the data updated in the database.
     * @param {beneficiosCursosUpdateManyAndReturnArgs} args - Arguments to update many BeneficiosCursos.
     * @example
     * // Update many BeneficiosCursos
     * const beneficiosCursos = await prisma.beneficiosCursos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BeneficiosCursos and only return the `id`
     * const beneficiosCursosWithIdOnly = await prisma.beneficiosCursos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends beneficiosCursosUpdateManyAndReturnArgs>(args: SelectSubset<T, beneficiosCursosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$beneficiosCursosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BeneficiosCursos.
     * @param {beneficiosCursosUpsertArgs} args - Arguments to update or create a BeneficiosCursos.
     * @example
     * // Update or create a BeneficiosCursos
     * const beneficiosCursos = await prisma.beneficiosCursos.upsert({
     *   create: {
     *     // ... data to create a BeneficiosCursos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BeneficiosCursos we want to update
     *   }
     * })
     */
    upsert<T extends beneficiosCursosUpsertArgs>(args: SelectSubset<T, beneficiosCursosUpsertArgs<ExtArgs>>): Prisma__beneficiosCursosClient<$Result.GetResult<Prisma.$beneficiosCursosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BeneficiosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beneficiosCursosCountArgs} args - Arguments to filter BeneficiosCursos to count.
     * @example
     * // Count the number of BeneficiosCursos
     * const count = await prisma.beneficiosCursos.count({
     *   where: {
     *     // ... the filter for the BeneficiosCursos we want to count
     *   }
     * })
    **/
    count<T extends beneficiosCursosCountArgs>(
      args?: Subset<T, beneficiosCursosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BeneficiosCursosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BeneficiosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BeneficiosCursosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BeneficiosCursosAggregateArgs>(args: Subset<T, BeneficiosCursosAggregateArgs>): Prisma.PrismaPromise<GetBeneficiosCursosAggregateType<T>>

    /**
     * Group by BeneficiosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {beneficiosCursosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends beneficiosCursosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: beneficiosCursosGroupByArgs['orderBy'] }
        : { orderBy?: beneficiosCursosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, beneficiosCursosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBeneficiosCursosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the beneficiosCursos model
   */
  readonly fields: beneficiosCursosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for beneficiosCursos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__beneficiosCursosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cursos<T extends cursosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, cursosDefaultArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the beneficiosCursos model
   */
  interface beneficiosCursosFieldRefs {
    readonly id: FieldRef<"beneficiosCursos", 'String'>
    readonly cursoId: FieldRef<"beneficiosCursos", 'String'>
    readonly descripcion: FieldRef<"beneficiosCursos", 'String'>
    readonly orden: FieldRef<"beneficiosCursos", 'Int'>
    readonly creadoEn: FieldRef<"beneficiosCursos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * beneficiosCursos findUnique
   */
  export type beneficiosCursosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosInclude<ExtArgs> | null
    /**
     * Filter, which beneficiosCursos to fetch.
     */
    where: beneficiosCursosWhereUniqueInput
  }

  /**
   * beneficiosCursos findUniqueOrThrow
   */
  export type beneficiosCursosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosInclude<ExtArgs> | null
    /**
     * Filter, which beneficiosCursos to fetch.
     */
    where: beneficiosCursosWhereUniqueInput
  }

  /**
   * beneficiosCursos findFirst
   */
  export type beneficiosCursosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosInclude<ExtArgs> | null
    /**
     * Filter, which beneficiosCursos to fetch.
     */
    where?: beneficiosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of beneficiosCursos to fetch.
     */
    orderBy?: beneficiosCursosOrderByWithRelationInput | beneficiosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for beneficiosCursos.
     */
    cursor?: beneficiosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` beneficiosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` beneficiosCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of beneficiosCursos.
     */
    distinct?: BeneficiosCursosScalarFieldEnum | BeneficiosCursosScalarFieldEnum[]
  }

  /**
   * beneficiosCursos findFirstOrThrow
   */
  export type beneficiosCursosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosInclude<ExtArgs> | null
    /**
     * Filter, which beneficiosCursos to fetch.
     */
    where?: beneficiosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of beneficiosCursos to fetch.
     */
    orderBy?: beneficiosCursosOrderByWithRelationInput | beneficiosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for beneficiosCursos.
     */
    cursor?: beneficiosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` beneficiosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` beneficiosCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of beneficiosCursos.
     */
    distinct?: BeneficiosCursosScalarFieldEnum | BeneficiosCursosScalarFieldEnum[]
  }

  /**
   * beneficiosCursos findMany
   */
  export type beneficiosCursosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosInclude<ExtArgs> | null
    /**
     * Filter, which beneficiosCursos to fetch.
     */
    where?: beneficiosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of beneficiosCursos to fetch.
     */
    orderBy?: beneficiosCursosOrderByWithRelationInput | beneficiosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing beneficiosCursos.
     */
    cursor?: beneficiosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` beneficiosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` beneficiosCursos.
     */
    skip?: number
    distinct?: BeneficiosCursosScalarFieldEnum | BeneficiosCursosScalarFieldEnum[]
  }

  /**
   * beneficiosCursos create
   */
  export type beneficiosCursosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosInclude<ExtArgs> | null
    /**
     * The data needed to create a beneficiosCursos.
     */
    data: XOR<beneficiosCursosCreateInput, beneficiosCursosUncheckedCreateInput>
  }

  /**
   * beneficiosCursos createMany
   */
  export type beneficiosCursosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many beneficiosCursos.
     */
    data: beneficiosCursosCreateManyInput | beneficiosCursosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * beneficiosCursos createManyAndReturn
   */
  export type beneficiosCursosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * The data used to create many beneficiosCursos.
     */
    data: beneficiosCursosCreateManyInput | beneficiosCursosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * beneficiosCursos update
   */
  export type beneficiosCursosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosInclude<ExtArgs> | null
    /**
     * The data needed to update a beneficiosCursos.
     */
    data: XOR<beneficiosCursosUpdateInput, beneficiosCursosUncheckedUpdateInput>
    /**
     * Choose, which beneficiosCursos to update.
     */
    where: beneficiosCursosWhereUniqueInput
  }

  /**
   * beneficiosCursos updateMany
   */
  export type beneficiosCursosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update beneficiosCursos.
     */
    data: XOR<beneficiosCursosUpdateManyMutationInput, beneficiosCursosUncheckedUpdateManyInput>
    /**
     * Filter which beneficiosCursos to update
     */
    where?: beneficiosCursosWhereInput
    /**
     * Limit how many beneficiosCursos to update.
     */
    limit?: number
  }

  /**
   * beneficiosCursos updateManyAndReturn
   */
  export type beneficiosCursosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * The data used to update beneficiosCursos.
     */
    data: XOR<beneficiosCursosUpdateManyMutationInput, beneficiosCursosUncheckedUpdateManyInput>
    /**
     * Filter which beneficiosCursos to update
     */
    where?: beneficiosCursosWhereInput
    /**
     * Limit how many beneficiosCursos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * beneficiosCursos upsert
   */
  export type beneficiosCursosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosInclude<ExtArgs> | null
    /**
     * The filter to search for the beneficiosCursos to update in case it exists.
     */
    where: beneficiosCursosWhereUniqueInput
    /**
     * In case the beneficiosCursos found by the `where` argument doesn't exist, create a new beneficiosCursos with this data.
     */
    create: XOR<beneficiosCursosCreateInput, beneficiosCursosUncheckedCreateInput>
    /**
     * In case the beneficiosCursos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<beneficiosCursosUpdateInput, beneficiosCursosUncheckedUpdateInput>
  }

  /**
   * beneficiosCursos delete
   */
  export type beneficiosCursosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosInclude<ExtArgs> | null
    /**
     * Filter which beneficiosCursos to delete.
     */
    where: beneficiosCursosWhereUniqueInput
  }

  /**
   * beneficiosCursos deleteMany
   */
  export type beneficiosCursosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which beneficiosCursos to delete
     */
    where?: beneficiosCursosWhereInput
    /**
     * Limit how many beneficiosCursos to delete.
     */
    limit?: number
  }

  /**
   * beneficiosCursos without action
   */
  export type beneficiosCursosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosInclude<ExtArgs> | null
  }


  /**
   * Model calificaciones
   */

  export type AggregateCalificaciones = {
    _count: CalificacionesCountAggregateOutputType | null
    _avg: CalificacionesAvgAggregateOutputType | null
    _sum: CalificacionesSumAggregateOutputType | null
    _min: CalificacionesMinAggregateOutputType | null
    _max: CalificacionesMaxAggregateOutputType | null
  }

  export type CalificacionesAvgAggregateOutputType = {
    nota: number | null
  }

  export type CalificacionesSumAggregateOutputType = {
    nota: number | null
  }

  export type CalificacionesMinAggregateOutputType = {
    id: string | null
    aprobado: boolean | null
    comentarios: string | null
    estudianteId: string | null
    examenId: string | null
    nota: number | null
    creadoEn: Date | null
  }

  export type CalificacionesMaxAggregateOutputType = {
    id: string | null
    aprobado: boolean | null
    comentarios: string | null
    estudianteId: string | null
    examenId: string | null
    nota: number | null
    creadoEn: Date | null
  }

  export type CalificacionesCountAggregateOutputType = {
    id: number
    aprobado: number
    comentarios: number
    estudianteId: number
    examenId: number
    nota: number
    creadoEn: number
    _all: number
  }


  export type CalificacionesAvgAggregateInputType = {
    nota?: true
  }

  export type CalificacionesSumAggregateInputType = {
    nota?: true
  }

  export type CalificacionesMinAggregateInputType = {
    id?: true
    aprobado?: true
    comentarios?: true
    estudianteId?: true
    examenId?: true
    nota?: true
    creadoEn?: true
  }

  export type CalificacionesMaxAggregateInputType = {
    id?: true
    aprobado?: true
    comentarios?: true
    estudianteId?: true
    examenId?: true
    nota?: true
    creadoEn?: true
  }

  export type CalificacionesCountAggregateInputType = {
    id?: true
    aprobado?: true
    comentarios?: true
    estudianteId?: true
    examenId?: true
    nota?: true
    creadoEn?: true
    _all?: true
  }

  export type CalificacionesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which calificaciones to aggregate.
     */
    where?: calificacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of calificaciones to fetch.
     */
    orderBy?: calificacionesOrderByWithRelationInput | calificacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: calificacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` calificaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` calificaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned calificaciones
    **/
    _count?: true | CalificacionesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CalificacionesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CalificacionesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalificacionesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalificacionesMaxAggregateInputType
  }

  export type GetCalificacionesAggregateType<T extends CalificacionesAggregateArgs> = {
        [P in keyof T & keyof AggregateCalificaciones]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalificaciones[P]>
      : GetScalarType<T[P], AggregateCalificaciones[P]>
  }




  export type calificacionesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: calificacionesWhereInput
    orderBy?: calificacionesOrderByWithAggregationInput | calificacionesOrderByWithAggregationInput[]
    by: CalificacionesScalarFieldEnum[] | CalificacionesScalarFieldEnum
    having?: calificacionesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalificacionesCountAggregateInputType | true
    _avg?: CalificacionesAvgAggregateInputType
    _sum?: CalificacionesSumAggregateInputType
    _min?: CalificacionesMinAggregateInputType
    _max?: CalificacionesMaxAggregateInputType
  }

  export type CalificacionesGroupByOutputType = {
    id: string
    aprobado: boolean
    comentarios: string | null
    estudianteId: string
    examenId: string
    nota: number
    creadoEn: Date
    _count: CalificacionesCountAggregateOutputType | null
    _avg: CalificacionesAvgAggregateOutputType | null
    _sum: CalificacionesSumAggregateOutputType | null
    _min: CalificacionesMinAggregateOutputType | null
    _max: CalificacionesMaxAggregateOutputType | null
  }

  type GetCalificacionesGroupByPayload<T extends calificacionesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalificacionesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalificacionesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalificacionesGroupByOutputType[P]>
            : GetScalarType<T[P], CalificacionesGroupByOutputType[P]>
        }
      >
    >


  export type calificacionesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    aprobado?: boolean
    comentarios?: boolean
    estudianteId?: boolean
    examenId?: boolean
    nota?: boolean
    creadoEn?: boolean
    estudiantes?: boolean | estudiantesDefaultArgs<ExtArgs>
    examenes?: boolean | examenesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calificaciones"]>

  export type calificacionesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    aprobado?: boolean
    comentarios?: boolean
    estudianteId?: boolean
    examenId?: boolean
    nota?: boolean
    creadoEn?: boolean
    estudiantes?: boolean | estudiantesDefaultArgs<ExtArgs>
    examenes?: boolean | examenesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calificaciones"]>

  export type calificacionesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    aprobado?: boolean
    comentarios?: boolean
    estudianteId?: boolean
    examenId?: boolean
    nota?: boolean
    creadoEn?: boolean
    estudiantes?: boolean | estudiantesDefaultArgs<ExtArgs>
    examenes?: boolean | examenesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calificaciones"]>

  export type calificacionesSelectScalar = {
    id?: boolean
    aprobado?: boolean
    comentarios?: boolean
    estudianteId?: boolean
    examenId?: boolean
    nota?: boolean
    creadoEn?: boolean
  }

  export type calificacionesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "aprobado" | "comentarios" | "estudianteId" | "examenId" | "nota" | "creadoEn", ExtArgs["result"]["calificaciones"]>
  export type calificacionesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiantes?: boolean | estudiantesDefaultArgs<ExtArgs>
    examenes?: boolean | examenesDefaultArgs<ExtArgs>
  }
  export type calificacionesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiantes?: boolean | estudiantesDefaultArgs<ExtArgs>
    examenes?: boolean | examenesDefaultArgs<ExtArgs>
  }
  export type calificacionesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiantes?: boolean | estudiantesDefaultArgs<ExtArgs>
    examenes?: boolean | examenesDefaultArgs<ExtArgs>
  }

  export type $calificacionesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "calificaciones"
    objects: {
      estudiantes: Prisma.$estudiantesPayload<ExtArgs>
      examenes: Prisma.$examenesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      aprobado: boolean
      comentarios: string | null
      estudianteId: string
      examenId: string
      nota: number
      creadoEn: Date
    }, ExtArgs["result"]["calificaciones"]>
    composites: {}
  }

  type calificacionesGetPayload<S extends boolean | null | undefined | calificacionesDefaultArgs> = $Result.GetResult<Prisma.$calificacionesPayload, S>

  type calificacionesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<calificacionesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CalificacionesCountAggregateInputType | true
    }

  export interface calificacionesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['calificaciones'], meta: { name: 'calificaciones' } }
    /**
     * Find zero or one Calificaciones that matches the filter.
     * @param {calificacionesFindUniqueArgs} args - Arguments to find a Calificaciones
     * @example
     * // Get one Calificaciones
     * const calificaciones = await prisma.calificaciones.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends calificacionesFindUniqueArgs>(args: SelectSubset<T, calificacionesFindUniqueArgs<ExtArgs>>): Prisma__calificacionesClient<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Calificaciones that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {calificacionesFindUniqueOrThrowArgs} args - Arguments to find a Calificaciones
     * @example
     * // Get one Calificaciones
     * const calificaciones = await prisma.calificaciones.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends calificacionesFindUniqueOrThrowArgs>(args: SelectSubset<T, calificacionesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__calificacionesClient<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Calificaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {calificacionesFindFirstArgs} args - Arguments to find a Calificaciones
     * @example
     * // Get one Calificaciones
     * const calificaciones = await prisma.calificaciones.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends calificacionesFindFirstArgs>(args?: SelectSubset<T, calificacionesFindFirstArgs<ExtArgs>>): Prisma__calificacionesClient<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Calificaciones that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {calificacionesFindFirstOrThrowArgs} args - Arguments to find a Calificaciones
     * @example
     * // Get one Calificaciones
     * const calificaciones = await prisma.calificaciones.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends calificacionesFindFirstOrThrowArgs>(args?: SelectSubset<T, calificacionesFindFirstOrThrowArgs<ExtArgs>>): Prisma__calificacionesClient<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Calificaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {calificacionesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Calificaciones
     * const calificaciones = await prisma.calificaciones.findMany()
     * 
     * // Get first 10 Calificaciones
     * const calificaciones = await prisma.calificaciones.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calificacionesWithIdOnly = await prisma.calificaciones.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends calificacionesFindManyArgs>(args?: SelectSubset<T, calificacionesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Calificaciones.
     * @param {calificacionesCreateArgs} args - Arguments to create a Calificaciones.
     * @example
     * // Create one Calificaciones
     * const Calificaciones = await prisma.calificaciones.create({
     *   data: {
     *     // ... data to create a Calificaciones
     *   }
     * })
     * 
     */
    create<T extends calificacionesCreateArgs>(args: SelectSubset<T, calificacionesCreateArgs<ExtArgs>>): Prisma__calificacionesClient<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Calificaciones.
     * @param {calificacionesCreateManyArgs} args - Arguments to create many Calificaciones.
     * @example
     * // Create many Calificaciones
     * const calificaciones = await prisma.calificaciones.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends calificacionesCreateManyArgs>(args?: SelectSubset<T, calificacionesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Calificaciones and returns the data saved in the database.
     * @param {calificacionesCreateManyAndReturnArgs} args - Arguments to create many Calificaciones.
     * @example
     * // Create many Calificaciones
     * const calificaciones = await prisma.calificaciones.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Calificaciones and only return the `id`
     * const calificacionesWithIdOnly = await prisma.calificaciones.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends calificacionesCreateManyAndReturnArgs>(args?: SelectSubset<T, calificacionesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Calificaciones.
     * @param {calificacionesDeleteArgs} args - Arguments to delete one Calificaciones.
     * @example
     * // Delete one Calificaciones
     * const Calificaciones = await prisma.calificaciones.delete({
     *   where: {
     *     // ... filter to delete one Calificaciones
     *   }
     * })
     * 
     */
    delete<T extends calificacionesDeleteArgs>(args: SelectSubset<T, calificacionesDeleteArgs<ExtArgs>>): Prisma__calificacionesClient<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Calificaciones.
     * @param {calificacionesUpdateArgs} args - Arguments to update one Calificaciones.
     * @example
     * // Update one Calificaciones
     * const calificaciones = await prisma.calificaciones.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends calificacionesUpdateArgs>(args: SelectSubset<T, calificacionesUpdateArgs<ExtArgs>>): Prisma__calificacionesClient<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Calificaciones.
     * @param {calificacionesDeleteManyArgs} args - Arguments to filter Calificaciones to delete.
     * @example
     * // Delete a few Calificaciones
     * const { count } = await prisma.calificaciones.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends calificacionesDeleteManyArgs>(args?: SelectSubset<T, calificacionesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Calificaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {calificacionesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Calificaciones
     * const calificaciones = await prisma.calificaciones.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends calificacionesUpdateManyArgs>(args: SelectSubset<T, calificacionesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Calificaciones and returns the data updated in the database.
     * @param {calificacionesUpdateManyAndReturnArgs} args - Arguments to update many Calificaciones.
     * @example
     * // Update many Calificaciones
     * const calificaciones = await prisma.calificaciones.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Calificaciones and only return the `id`
     * const calificacionesWithIdOnly = await prisma.calificaciones.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends calificacionesUpdateManyAndReturnArgs>(args: SelectSubset<T, calificacionesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Calificaciones.
     * @param {calificacionesUpsertArgs} args - Arguments to update or create a Calificaciones.
     * @example
     * // Update or create a Calificaciones
     * const calificaciones = await prisma.calificaciones.upsert({
     *   create: {
     *     // ... data to create a Calificaciones
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Calificaciones we want to update
     *   }
     * })
     */
    upsert<T extends calificacionesUpsertArgs>(args: SelectSubset<T, calificacionesUpsertArgs<ExtArgs>>): Prisma__calificacionesClient<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Calificaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {calificacionesCountArgs} args - Arguments to filter Calificaciones to count.
     * @example
     * // Count the number of Calificaciones
     * const count = await prisma.calificaciones.count({
     *   where: {
     *     // ... the filter for the Calificaciones we want to count
     *   }
     * })
    **/
    count<T extends calificacionesCountArgs>(
      args?: Subset<T, calificacionesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalificacionesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Calificaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalificacionesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalificacionesAggregateArgs>(args: Subset<T, CalificacionesAggregateArgs>): Prisma.PrismaPromise<GetCalificacionesAggregateType<T>>

    /**
     * Group by Calificaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {calificacionesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends calificacionesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: calificacionesGroupByArgs['orderBy'] }
        : { orderBy?: calificacionesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, calificacionesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalificacionesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the calificaciones model
   */
  readonly fields: calificacionesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for calificaciones.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__calificacionesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estudiantes<T extends estudiantesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, estudiantesDefaultArgs<ExtArgs>>): Prisma__estudiantesClient<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    examenes<T extends examenesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, examenesDefaultArgs<ExtArgs>>): Prisma__examenesClient<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the calificaciones model
   */
  interface calificacionesFieldRefs {
    readonly id: FieldRef<"calificaciones", 'String'>
    readonly aprobado: FieldRef<"calificaciones", 'Boolean'>
    readonly comentarios: FieldRef<"calificaciones", 'String'>
    readonly estudianteId: FieldRef<"calificaciones", 'String'>
    readonly examenId: FieldRef<"calificaciones", 'String'>
    readonly nota: FieldRef<"calificaciones", 'Float'>
    readonly creadoEn: FieldRef<"calificaciones", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * calificaciones findUnique
   */
  export type calificacionesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesInclude<ExtArgs> | null
    /**
     * Filter, which calificaciones to fetch.
     */
    where: calificacionesWhereUniqueInput
  }

  /**
   * calificaciones findUniqueOrThrow
   */
  export type calificacionesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesInclude<ExtArgs> | null
    /**
     * Filter, which calificaciones to fetch.
     */
    where: calificacionesWhereUniqueInput
  }

  /**
   * calificaciones findFirst
   */
  export type calificacionesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesInclude<ExtArgs> | null
    /**
     * Filter, which calificaciones to fetch.
     */
    where?: calificacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of calificaciones to fetch.
     */
    orderBy?: calificacionesOrderByWithRelationInput | calificacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for calificaciones.
     */
    cursor?: calificacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` calificaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` calificaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of calificaciones.
     */
    distinct?: CalificacionesScalarFieldEnum | CalificacionesScalarFieldEnum[]
  }

  /**
   * calificaciones findFirstOrThrow
   */
  export type calificacionesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesInclude<ExtArgs> | null
    /**
     * Filter, which calificaciones to fetch.
     */
    where?: calificacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of calificaciones to fetch.
     */
    orderBy?: calificacionesOrderByWithRelationInput | calificacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for calificaciones.
     */
    cursor?: calificacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` calificaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` calificaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of calificaciones.
     */
    distinct?: CalificacionesScalarFieldEnum | CalificacionesScalarFieldEnum[]
  }

  /**
   * calificaciones findMany
   */
  export type calificacionesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesInclude<ExtArgs> | null
    /**
     * Filter, which calificaciones to fetch.
     */
    where?: calificacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of calificaciones to fetch.
     */
    orderBy?: calificacionesOrderByWithRelationInput | calificacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing calificaciones.
     */
    cursor?: calificacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` calificaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` calificaciones.
     */
    skip?: number
    distinct?: CalificacionesScalarFieldEnum | CalificacionesScalarFieldEnum[]
  }

  /**
   * calificaciones create
   */
  export type calificacionesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesInclude<ExtArgs> | null
    /**
     * The data needed to create a calificaciones.
     */
    data: XOR<calificacionesCreateInput, calificacionesUncheckedCreateInput>
  }

  /**
   * calificaciones createMany
   */
  export type calificacionesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many calificaciones.
     */
    data: calificacionesCreateManyInput | calificacionesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * calificaciones createManyAndReturn
   */
  export type calificacionesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * The data used to create many calificaciones.
     */
    data: calificacionesCreateManyInput | calificacionesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * calificaciones update
   */
  export type calificacionesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesInclude<ExtArgs> | null
    /**
     * The data needed to update a calificaciones.
     */
    data: XOR<calificacionesUpdateInput, calificacionesUncheckedUpdateInput>
    /**
     * Choose, which calificaciones to update.
     */
    where: calificacionesWhereUniqueInput
  }

  /**
   * calificaciones updateMany
   */
  export type calificacionesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update calificaciones.
     */
    data: XOR<calificacionesUpdateManyMutationInput, calificacionesUncheckedUpdateManyInput>
    /**
     * Filter which calificaciones to update
     */
    where?: calificacionesWhereInput
    /**
     * Limit how many calificaciones to update.
     */
    limit?: number
  }

  /**
   * calificaciones updateManyAndReturn
   */
  export type calificacionesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * The data used to update calificaciones.
     */
    data: XOR<calificacionesUpdateManyMutationInput, calificacionesUncheckedUpdateManyInput>
    /**
     * Filter which calificaciones to update
     */
    where?: calificacionesWhereInput
    /**
     * Limit how many calificaciones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * calificaciones upsert
   */
  export type calificacionesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesInclude<ExtArgs> | null
    /**
     * The filter to search for the calificaciones to update in case it exists.
     */
    where: calificacionesWhereUniqueInput
    /**
     * In case the calificaciones found by the `where` argument doesn't exist, create a new calificaciones with this data.
     */
    create: XOR<calificacionesCreateInput, calificacionesUncheckedCreateInput>
    /**
     * In case the calificaciones was found with the provided `where` argument, update it with this data.
     */
    update: XOR<calificacionesUpdateInput, calificacionesUncheckedUpdateInput>
  }

  /**
   * calificaciones delete
   */
  export type calificacionesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesInclude<ExtArgs> | null
    /**
     * Filter which calificaciones to delete.
     */
    where: calificacionesWhereUniqueInput
  }

  /**
   * calificaciones deleteMany
   */
  export type calificacionesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which calificaciones to delete
     */
    where?: calificacionesWhereInput
    /**
     * Limit how many calificaciones to delete.
     */
    limit?: number
  }

  /**
   * calificaciones without action
   */
  export type calificacionesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesInclude<ExtArgs> | null
  }


  /**
   * Model categorias
   */

  export type AggregateCategorias = {
    _count: CategoriasCountAggregateOutputType | null
    _min: CategoriasMinAggregateOutputType | null
    _max: CategoriasMaxAggregateOutputType | null
  }

  export type CategoriasMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type CategoriasMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type CategoriasCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    creadoEn: number
    actualizadoEn: number
    _all: number
  }


  export type CategoriasMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type CategoriasMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type CategoriasCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    creadoEn?: true
    actualizadoEn?: true
    _all?: true
  }

  export type CategoriasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categorias to aggregate.
     */
    where?: categoriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: categoriasOrderByWithRelationInput | categoriasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categorias
    **/
    _count?: true | CategoriasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriasMaxAggregateInputType
  }

  export type GetCategoriasAggregateType<T extends CategoriasAggregateArgs> = {
        [P in keyof T & keyof AggregateCategorias]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategorias[P]>
      : GetScalarType<T[P], AggregateCategorias[P]>
  }




  export type categoriasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriasWhereInput
    orderBy?: categoriasOrderByWithAggregationInput | categoriasOrderByWithAggregationInput[]
    by: CategoriasScalarFieldEnum[] | CategoriasScalarFieldEnum
    having?: categoriasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriasCountAggregateInputType | true
    _min?: CategoriasMinAggregateInputType
    _max?: CategoriasMaxAggregateInputType
  }

  export type CategoriasGroupByOutputType = {
    id: string
    nombre: string
    descripcion: string | null
    creadoEn: Date
    actualizadoEn: Date
    _count: CategoriasCountAggregateOutputType | null
    _min: CategoriasMinAggregateOutputType | null
    _max: CategoriasMaxAggregateOutputType | null
  }

  type GetCategoriasGroupByPayload<T extends categoriasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriasGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriasGroupByOutputType[P]>
        }
      >
    >


  export type categoriasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    categoriasCursos?: boolean | categorias$categoriasCursosArgs<ExtArgs>
    _count?: boolean | CategoriasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categorias"]>

  export type categoriasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }, ExtArgs["result"]["categorias"]>

  export type categoriasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }, ExtArgs["result"]["categorias"]>

  export type categoriasSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }

  export type categoriasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "descripcion" | "creadoEn" | "actualizadoEn", ExtArgs["result"]["categorias"]>
  export type categoriasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categoriasCursos?: boolean | categorias$categoriasCursosArgs<ExtArgs>
    _count?: boolean | CategoriasCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type categoriasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type categoriasIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $categoriasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "categorias"
    objects: {
      categoriasCursos: Prisma.$categoriasCursosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      descripcion: string | null
      creadoEn: Date
      actualizadoEn: Date
    }, ExtArgs["result"]["categorias"]>
    composites: {}
  }

  type categoriasGetPayload<S extends boolean | null | undefined | categoriasDefaultArgs> = $Result.GetResult<Prisma.$categoriasPayload, S>

  type categoriasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<categoriasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoriasCountAggregateInputType | true
    }

  export interface categoriasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['categorias'], meta: { name: 'categorias' } }
    /**
     * Find zero or one Categorias that matches the filter.
     * @param {categoriasFindUniqueArgs} args - Arguments to find a Categorias
     * @example
     * // Get one Categorias
     * const categorias = await prisma.categorias.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends categoriasFindUniqueArgs>(args: SelectSubset<T, categoriasFindUniqueArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Categorias that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {categoriasFindUniqueOrThrowArgs} args - Arguments to find a Categorias
     * @example
     * // Get one Categorias
     * const categorias = await prisma.categorias.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends categoriasFindUniqueOrThrowArgs>(args: SelectSubset<T, categoriasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasFindFirstArgs} args - Arguments to find a Categorias
     * @example
     * // Get one Categorias
     * const categorias = await prisma.categorias.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends categoriasFindFirstArgs>(args?: SelectSubset<T, categoriasFindFirstArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categorias that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasFindFirstOrThrowArgs} args - Arguments to find a Categorias
     * @example
     * // Get one Categorias
     * const categorias = await prisma.categorias.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends categoriasFindFirstOrThrowArgs>(args?: SelectSubset<T, categoriasFindFirstOrThrowArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categorias
     * const categorias = await prisma.categorias.findMany()
     * 
     * // Get first 10 Categorias
     * const categorias = await prisma.categorias.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriasWithIdOnly = await prisma.categorias.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends categoriasFindManyArgs>(args?: SelectSubset<T, categoriasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Categorias.
     * @param {categoriasCreateArgs} args - Arguments to create a Categorias.
     * @example
     * // Create one Categorias
     * const Categorias = await prisma.categorias.create({
     *   data: {
     *     // ... data to create a Categorias
     *   }
     * })
     * 
     */
    create<T extends categoriasCreateArgs>(args: SelectSubset<T, categoriasCreateArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categorias.
     * @param {categoriasCreateManyArgs} args - Arguments to create many Categorias.
     * @example
     * // Create many Categorias
     * const categorias = await prisma.categorias.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends categoriasCreateManyArgs>(args?: SelectSubset<T, categoriasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categorias and returns the data saved in the database.
     * @param {categoriasCreateManyAndReturnArgs} args - Arguments to create many Categorias.
     * @example
     * // Create many Categorias
     * const categorias = await prisma.categorias.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categorias and only return the `id`
     * const categoriasWithIdOnly = await prisma.categorias.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends categoriasCreateManyAndReturnArgs>(args?: SelectSubset<T, categoriasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Categorias.
     * @param {categoriasDeleteArgs} args - Arguments to delete one Categorias.
     * @example
     * // Delete one Categorias
     * const Categorias = await prisma.categorias.delete({
     *   where: {
     *     // ... filter to delete one Categorias
     *   }
     * })
     * 
     */
    delete<T extends categoriasDeleteArgs>(args: SelectSubset<T, categoriasDeleteArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Categorias.
     * @param {categoriasUpdateArgs} args - Arguments to update one Categorias.
     * @example
     * // Update one Categorias
     * const categorias = await prisma.categorias.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends categoriasUpdateArgs>(args: SelectSubset<T, categoriasUpdateArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categorias.
     * @param {categoriasDeleteManyArgs} args - Arguments to filter Categorias to delete.
     * @example
     * // Delete a few Categorias
     * const { count } = await prisma.categorias.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends categoriasDeleteManyArgs>(args?: SelectSubset<T, categoriasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categorias
     * const categorias = await prisma.categorias.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends categoriasUpdateManyArgs>(args: SelectSubset<T, categoriasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categorias and returns the data updated in the database.
     * @param {categoriasUpdateManyAndReturnArgs} args - Arguments to update many Categorias.
     * @example
     * // Update many Categorias
     * const categorias = await prisma.categorias.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categorias and only return the `id`
     * const categoriasWithIdOnly = await prisma.categorias.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends categoriasUpdateManyAndReturnArgs>(args: SelectSubset<T, categoriasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Categorias.
     * @param {categoriasUpsertArgs} args - Arguments to update or create a Categorias.
     * @example
     * // Update or create a Categorias
     * const categorias = await prisma.categorias.upsert({
     *   create: {
     *     // ... data to create a Categorias
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categorias we want to update
     *   }
     * })
     */
    upsert<T extends categoriasUpsertArgs>(args: SelectSubset<T, categoriasUpsertArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasCountArgs} args - Arguments to filter Categorias to count.
     * @example
     * // Count the number of Categorias
     * const count = await prisma.categorias.count({
     *   where: {
     *     // ... the filter for the Categorias we want to count
     *   }
     * })
    **/
    count<T extends categoriasCountArgs>(
      args?: Subset<T, categoriasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriasAggregateArgs>(args: Subset<T, CategoriasAggregateArgs>): Prisma.PrismaPromise<GetCategoriasAggregateType<T>>

    /**
     * Group by Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoriasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoriasGroupByArgs['orderBy'] }
        : { orderBy?: categoriasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoriasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the categorias model
   */
  readonly fields: categoriasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for categorias.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoriasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categoriasCursos<T extends categorias$categoriasCursosArgs<ExtArgs> = {}>(args?: Subset<T, categorias$categoriasCursosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the categorias model
   */
  interface categoriasFieldRefs {
    readonly id: FieldRef<"categorias", 'String'>
    readonly nombre: FieldRef<"categorias", 'String'>
    readonly descripcion: FieldRef<"categorias", 'String'>
    readonly creadoEn: FieldRef<"categorias", 'DateTime'>
    readonly actualizadoEn: FieldRef<"categorias", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * categorias findUnique
   */
  export type categoriasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categorias
     */
    omit?: categoriasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * Filter, which categorias to fetch.
     */
    where: categoriasWhereUniqueInput
  }

  /**
   * categorias findUniqueOrThrow
   */
  export type categoriasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categorias
     */
    omit?: categoriasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * Filter, which categorias to fetch.
     */
    where: categoriasWhereUniqueInput
  }

  /**
   * categorias findFirst
   */
  export type categoriasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categorias
     */
    omit?: categoriasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * Filter, which categorias to fetch.
     */
    where?: categoriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: categoriasOrderByWithRelationInput | categoriasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categorias.
     */
    cursor?: categoriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categorias.
     */
    distinct?: CategoriasScalarFieldEnum | CategoriasScalarFieldEnum[]
  }

  /**
   * categorias findFirstOrThrow
   */
  export type categoriasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categorias
     */
    omit?: categoriasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * Filter, which categorias to fetch.
     */
    where?: categoriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: categoriasOrderByWithRelationInput | categoriasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categorias.
     */
    cursor?: categoriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categorias.
     */
    distinct?: CategoriasScalarFieldEnum | CategoriasScalarFieldEnum[]
  }

  /**
   * categorias findMany
   */
  export type categoriasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categorias
     */
    omit?: categoriasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * Filter, which categorias to fetch.
     */
    where?: categoriasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: categoriasOrderByWithRelationInput | categoriasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categorias.
     */
    cursor?: categoriasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    distinct?: CategoriasScalarFieldEnum | CategoriasScalarFieldEnum[]
  }

  /**
   * categorias create
   */
  export type categoriasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categorias
     */
    omit?: categoriasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * The data needed to create a categorias.
     */
    data: XOR<categoriasCreateInput, categoriasUncheckedCreateInput>
  }

  /**
   * categorias createMany
   */
  export type categoriasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categorias.
     */
    data: categoriasCreateManyInput | categoriasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * categorias createManyAndReturn
   */
  export type categoriasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the categorias
     */
    omit?: categoriasOmit<ExtArgs> | null
    /**
     * The data used to create many categorias.
     */
    data: categoriasCreateManyInput | categoriasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * categorias update
   */
  export type categoriasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categorias
     */
    omit?: categoriasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * The data needed to update a categorias.
     */
    data: XOR<categoriasUpdateInput, categoriasUncheckedUpdateInput>
    /**
     * Choose, which categorias to update.
     */
    where: categoriasWhereUniqueInput
  }

  /**
   * categorias updateMany
   */
  export type categoriasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categorias.
     */
    data: XOR<categoriasUpdateManyMutationInput, categoriasUncheckedUpdateManyInput>
    /**
     * Filter which categorias to update
     */
    where?: categoriasWhereInput
    /**
     * Limit how many categorias to update.
     */
    limit?: number
  }

  /**
   * categorias updateManyAndReturn
   */
  export type categoriasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the categorias
     */
    omit?: categoriasOmit<ExtArgs> | null
    /**
     * The data used to update categorias.
     */
    data: XOR<categoriasUpdateManyMutationInput, categoriasUncheckedUpdateManyInput>
    /**
     * Filter which categorias to update
     */
    where?: categoriasWhereInput
    /**
     * Limit how many categorias to update.
     */
    limit?: number
  }

  /**
   * categorias upsert
   */
  export type categoriasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categorias
     */
    omit?: categoriasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * The filter to search for the categorias to update in case it exists.
     */
    where: categoriasWhereUniqueInput
    /**
     * In case the categorias found by the `where` argument doesn't exist, create a new categorias with this data.
     */
    create: XOR<categoriasCreateInput, categoriasUncheckedCreateInput>
    /**
     * In case the categorias was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoriasUpdateInput, categoriasUncheckedUpdateInput>
  }

  /**
   * categorias delete
   */
  export type categoriasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categorias
     */
    omit?: categoriasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
    /**
     * Filter which categorias to delete.
     */
    where: categoriasWhereUniqueInput
  }

  /**
   * categorias deleteMany
   */
  export type categoriasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categorias to delete
     */
    where?: categoriasWhereInput
    /**
     * Limit how many categorias to delete.
     */
    limit?: number
  }

  /**
   * categorias.categoriasCursos
   */
  export type categorias$categoriasCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosInclude<ExtArgs> | null
    where?: categoriasCursosWhereInput
    orderBy?: categoriasCursosOrderByWithRelationInput | categoriasCursosOrderByWithRelationInput[]
    cursor?: categoriasCursosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoriasCursosScalarFieldEnum | CategoriasCursosScalarFieldEnum[]
  }

  /**
   * categorias without action
   */
  export type categoriasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categorias
     */
    select?: categoriasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categorias
     */
    omit?: categoriasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasInclude<ExtArgs> | null
  }


  /**
   * Model categoriasCursos
   */

  export type AggregateCategoriasCursos = {
    _count: CategoriasCursosCountAggregateOutputType | null
    _min: CategoriasCursosMinAggregateOutputType | null
    _max: CategoriasCursosMaxAggregateOutputType | null
  }

  export type CategoriasCursosMinAggregateOutputType = {
    id: string | null
    categoriaId: string | null
    cursoId: string | null
  }

  export type CategoriasCursosMaxAggregateOutputType = {
    id: string | null
    categoriaId: string | null
    cursoId: string | null
  }

  export type CategoriasCursosCountAggregateOutputType = {
    id: number
    categoriaId: number
    cursoId: number
    _all: number
  }


  export type CategoriasCursosMinAggregateInputType = {
    id?: true
    categoriaId?: true
    cursoId?: true
  }

  export type CategoriasCursosMaxAggregateInputType = {
    id?: true
    categoriaId?: true
    cursoId?: true
  }

  export type CategoriasCursosCountAggregateInputType = {
    id?: true
    categoriaId?: true
    cursoId?: true
    _all?: true
  }

  export type CategoriasCursosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categoriasCursos to aggregate.
     */
    where?: categoriasCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categoriasCursos to fetch.
     */
    orderBy?: categoriasCursosOrderByWithRelationInput | categoriasCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoriasCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categoriasCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categoriasCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categoriasCursos
    **/
    _count?: true | CategoriasCursosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriasCursosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriasCursosMaxAggregateInputType
  }

  export type GetCategoriasCursosAggregateType<T extends CategoriasCursosAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoriasCursos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoriasCursos[P]>
      : GetScalarType<T[P], AggregateCategoriasCursos[P]>
  }




  export type categoriasCursosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriasCursosWhereInput
    orderBy?: categoriasCursosOrderByWithAggregationInput | categoriasCursosOrderByWithAggregationInput[]
    by: CategoriasCursosScalarFieldEnum[] | CategoriasCursosScalarFieldEnum
    having?: categoriasCursosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriasCursosCountAggregateInputType | true
    _min?: CategoriasCursosMinAggregateInputType
    _max?: CategoriasCursosMaxAggregateInputType
  }

  export type CategoriasCursosGroupByOutputType = {
    id: string
    categoriaId: string
    cursoId: string
    _count: CategoriasCursosCountAggregateOutputType | null
    _min: CategoriasCursosMinAggregateOutputType | null
    _max: CategoriasCursosMaxAggregateOutputType | null
  }

  type GetCategoriasCursosGroupByPayload<T extends categoriasCursosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriasCursosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriasCursosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriasCursosGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriasCursosGroupByOutputType[P]>
        }
      >
    >


  export type categoriasCursosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoriaId?: boolean
    cursoId?: boolean
    categorias?: boolean | categoriasDefaultArgs<ExtArgs>
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoriasCursos"]>

  export type categoriasCursosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoriaId?: boolean
    cursoId?: boolean
    categorias?: boolean | categoriasDefaultArgs<ExtArgs>
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoriasCursos"]>

  export type categoriasCursosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoriaId?: boolean
    cursoId?: boolean
    categorias?: boolean | categoriasDefaultArgs<ExtArgs>
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoriasCursos"]>

  export type categoriasCursosSelectScalar = {
    id?: boolean
    categoriaId?: boolean
    cursoId?: boolean
  }

  export type categoriasCursosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "categoriaId" | "cursoId", ExtArgs["result"]["categoriasCursos"]>
  export type categoriasCursosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categorias?: boolean | categoriasDefaultArgs<ExtArgs>
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
  }
  export type categoriasCursosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categorias?: boolean | categoriasDefaultArgs<ExtArgs>
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
  }
  export type categoriasCursosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categorias?: boolean | categoriasDefaultArgs<ExtArgs>
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
  }

  export type $categoriasCursosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "categoriasCursos"
    objects: {
      categorias: Prisma.$categoriasPayload<ExtArgs>
      cursos: Prisma.$cursosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      categoriaId: string
      cursoId: string
    }, ExtArgs["result"]["categoriasCursos"]>
    composites: {}
  }

  type categoriasCursosGetPayload<S extends boolean | null | undefined | categoriasCursosDefaultArgs> = $Result.GetResult<Prisma.$categoriasCursosPayload, S>

  type categoriasCursosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<categoriasCursosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoriasCursosCountAggregateInputType | true
    }

  export interface categoriasCursosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['categoriasCursos'], meta: { name: 'categoriasCursos' } }
    /**
     * Find zero or one CategoriasCursos that matches the filter.
     * @param {categoriasCursosFindUniqueArgs} args - Arguments to find a CategoriasCursos
     * @example
     * // Get one CategoriasCursos
     * const categoriasCursos = await prisma.categoriasCursos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends categoriasCursosFindUniqueArgs>(args: SelectSubset<T, categoriasCursosFindUniqueArgs<ExtArgs>>): Prisma__categoriasCursosClient<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CategoriasCursos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {categoriasCursosFindUniqueOrThrowArgs} args - Arguments to find a CategoriasCursos
     * @example
     * // Get one CategoriasCursos
     * const categoriasCursos = await prisma.categoriasCursos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends categoriasCursosFindUniqueOrThrowArgs>(args: SelectSubset<T, categoriasCursosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__categoriasCursosClient<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CategoriasCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasCursosFindFirstArgs} args - Arguments to find a CategoriasCursos
     * @example
     * // Get one CategoriasCursos
     * const categoriasCursos = await prisma.categoriasCursos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends categoriasCursosFindFirstArgs>(args?: SelectSubset<T, categoriasCursosFindFirstArgs<ExtArgs>>): Prisma__categoriasCursosClient<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CategoriasCursos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasCursosFindFirstOrThrowArgs} args - Arguments to find a CategoriasCursos
     * @example
     * // Get one CategoriasCursos
     * const categoriasCursos = await prisma.categoriasCursos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends categoriasCursosFindFirstOrThrowArgs>(args?: SelectSubset<T, categoriasCursosFindFirstOrThrowArgs<ExtArgs>>): Prisma__categoriasCursosClient<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CategoriasCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasCursosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CategoriasCursos
     * const categoriasCursos = await prisma.categoriasCursos.findMany()
     * 
     * // Get first 10 CategoriasCursos
     * const categoriasCursos = await prisma.categoriasCursos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriasCursosWithIdOnly = await prisma.categoriasCursos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends categoriasCursosFindManyArgs>(args?: SelectSubset<T, categoriasCursosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CategoriasCursos.
     * @param {categoriasCursosCreateArgs} args - Arguments to create a CategoriasCursos.
     * @example
     * // Create one CategoriasCursos
     * const CategoriasCursos = await prisma.categoriasCursos.create({
     *   data: {
     *     // ... data to create a CategoriasCursos
     *   }
     * })
     * 
     */
    create<T extends categoriasCursosCreateArgs>(args: SelectSubset<T, categoriasCursosCreateArgs<ExtArgs>>): Prisma__categoriasCursosClient<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CategoriasCursos.
     * @param {categoriasCursosCreateManyArgs} args - Arguments to create many CategoriasCursos.
     * @example
     * // Create many CategoriasCursos
     * const categoriasCursos = await prisma.categoriasCursos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends categoriasCursosCreateManyArgs>(args?: SelectSubset<T, categoriasCursosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CategoriasCursos and returns the data saved in the database.
     * @param {categoriasCursosCreateManyAndReturnArgs} args - Arguments to create many CategoriasCursos.
     * @example
     * // Create many CategoriasCursos
     * const categoriasCursos = await prisma.categoriasCursos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CategoriasCursos and only return the `id`
     * const categoriasCursosWithIdOnly = await prisma.categoriasCursos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends categoriasCursosCreateManyAndReturnArgs>(args?: SelectSubset<T, categoriasCursosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CategoriasCursos.
     * @param {categoriasCursosDeleteArgs} args - Arguments to delete one CategoriasCursos.
     * @example
     * // Delete one CategoriasCursos
     * const CategoriasCursos = await prisma.categoriasCursos.delete({
     *   where: {
     *     // ... filter to delete one CategoriasCursos
     *   }
     * })
     * 
     */
    delete<T extends categoriasCursosDeleteArgs>(args: SelectSubset<T, categoriasCursosDeleteArgs<ExtArgs>>): Prisma__categoriasCursosClient<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CategoriasCursos.
     * @param {categoriasCursosUpdateArgs} args - Arguments to update one CategoriasCursos.
     * @example
     * // Update one CategoriasCursos
     * const categoriasCursos = await prisma.categoriasCursos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends categoriasCursosUpdateArgs>(args: SelectSubset<T, categoriasCursosUpdateArgs<ExtArgs>>): Prisma__categoriasCursosClient<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CategoriasCursos.
     * @param {categoriasCursosDeleteManyArgs} args - Arguments to filter CategoriasCursos to delete.
     * @example
     * // Delete a few CategoriasCursos
     * const { count } = await prisma.categoriasCursos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends categoriasCursosDeleteManyArgs>(args?: SelectSubset<T, categoriasCursosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoriasCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasCursosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CategoriasCursos
     * const categoriasCursos = await prisma.categoriasCursos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends categoriasCursosUpdateManyArgs>(args: SelectSubset<T, categoriasCursosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CategoriasCursos and returns the data updated in the database.
     * @param {categoriasCursosUpdateManyAndReturnArgs} args - Arguments to update many CategoriasCursos.
     * @example
     * // Update many CategoriasCursos
     * const categoriasCursos = await prisma.categoriasCursos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CategoriasCursos and only return the `id`
     * const categoriasCursosWithIdOnly = await prisma.categoriasCursos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends categoriasCursosUpdateManyAndReturnArgs>(args: SelectSubset<T, categoriasCursosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CategoriasCursos.
     * @param {categoriasCursosUpsertArgs} args - Arguments to update or create a CategoriasCursos.
     * @example
     * // Update or create a CategoriasCursos
     * const categoriasCursos = await prisma.categoriasCursos.upsert({
     *   create: {
     *     // ... data to create a CategoriasCursos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CategoriasCursos we want to update
     *   }
     * })
     */
    upsert<T extends categoriasCursosUpsertArgs>(args: SelectSubset<T, categoriasCursosUpsertArgs<ExtArgs>>): Prisma__categoriasCursosClient<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CategoriasCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasCursosCountArgs} args - Arguments to filter CategoriasCursos to count.
     * @example
     * // Count the number of CategoriasCursos
     * const count = await prisma.categoriasCursos.count({
     *   where: {
     *     // ... the filter for the CategoriasCursos we want to count
     *   }
     * })
    **/
    count<T extends categoriasCursosCountArgs>(
      args?: Subset<T, categoriasCursosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriasCursosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CategoriasCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriasCursosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriasCursosAggregateArgs>(args: Subset<T, CategoriasCursosAggregateArgs>): Prisma.PrismaPromise<GetCategoriasCursosAggregateType<T>>

    /**
     * Group by CategoriasCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriasCursosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoriasCursosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoriasCursosGroupByArgs['orderBy'] }
        : { orderBy?: categoriasCursosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoriasCursosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriasCursosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the categoriasCursos model
   */
  readonly fields: categoriasCursosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for categoriasCursos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoriasCursosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categorias<T extends categoriasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, categoriasDefaultArgs<ExtArgs>>): Prisma__categoriasClient<$Result.GetResult<Prisma.$categoriasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cursos<T extends cursosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, cursosDefaultArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the categoriasCursos model
   */
  interface categoriasCursosFieldRefs {
    readonly id: FieldRef<"categoriasCursos", 'String'>
    readonly categoriaId: FieldRef<"categoriasCursos", 'String'>
    readonly cursoId: FieldRef<"categoriasCursos", 'String'>
  }
    

  // Custom InputTypes
  /**
   * categoriasCursos findUnique
   */
  export type categoriasCursosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosInclude<ExtArgs> | null
    /**
     * Filter, which categoriasCursos to fetch.
     */
    where: categoriasCursosWhereUniqueInput
  }

  /**
   * categoriasCursos findUniqueOrThrow
   */
  export type categoriasCursosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosInclude<ExtArgs> | null
    /**
     * Filter, which categoriasCursos to fetch.
     */
    where: categoriasCursosWhereUniqueInput
  }

  /**
   * categoriasCursos findFirst
   */
  export type categoriasCursosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosInclude<ExtArgs> | null
    /**
     * Filter, which categoriasCursos to fetch.
     */
    where?: categoriasCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categoriasCursos to fetch.
     */
    orderBy?: categoriasCursosOrderByWithRelationInput | categoriasCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categoriasCursos.
     */
    cursor?: categoriasCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categoriasCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categoriasCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categoriasCursos.
     */
    distinct?: CategoriasCursosScalarFieldEnum | CategoriasCursosScalarFieldEnum[]
  }

  /**
   * categoriasCursos findFirstOrThrow
   */
  export type categoriasCursosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosInclude<ExtArgs> | null
    /**
     * Filter, which categoriasCursos to fetch.
     */
    where?: categoriasCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categoriasCursos to fetch.
     */
    orderBy?: categoriasCursosOrderByWithRelationInput | categoriasCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categoriasCursos.
     */
    cursor?: categoriasCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categoriasCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categoriasCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categoriasCursos.
     */
    distinct?: CategoriasCursosScalarFieldEnum | CategoriasCursosScalarFieldEnum[]
  }

  /**
   * categoriasCursos findMany
   */
  export type categoriasCursosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosInclude<ExtArgs> | null
    /**
     * Filter, which categoriasCursos to fetch.
     */
    where?: categoriasCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categoriasCursos to fetch.
     */
    orderBy?: categoriasCursosOrderByWithRelationInput | categoriasCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categoriasCursos.
     */
    cursor?: categoriasCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categoriasCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categoriasCursos.
     */
    skip?: number
    distinct?: CategoriasCursosScalarFieldEnum | CategoriasCursosScalarFieldEnum[]
  }

  /**
   * categoriasCursos create
   */
  export type categoriasCursosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosInclude<ExtArgs> | null
    /**
     * The data needed to create a categoriasCursos.
     */
    data: XOR<categoriasCursosCreateInput, categoriasCursosUncheckedCreateInput>
  }

  /**
   * categoriasCursos createMany
   */
  export type categoriasCursosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categoriasCursos.
     */
    data: categoriasCursosCreateManyInput | categoriasCursosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * categoriasCursos createManyAndReturn
   */
  export type categoriasCursosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * The data used to create many categoriasCursos.
     */
    data: categoriasCursosCreateManyInput | categoriasCursosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * categoriasCursos update
   */
  export type categoriasCursosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosInclude<ExtArgs> | null
    /**
     * The data needed to update a categoriasCursos.
     */
    data: XOR<categoriasCursosUpdateInput, categoriasCursosUncheckedUpdateInput>
    /**
     * Choose, which categoriasCursos to update.
     */
    where: categoriasCursosWhereUniqueInput
  }

  /**
   * categoriasCursos updateMany
   */
  export type categoriasCursosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categoriasCursos.
     */
    data: XOR<categoriasCursosUpdateManyMutationInput, categoriasCursosUncheckedUpdateManyInput>
    /**
     * Filter which categoriasCursos to update
     */
    where?: categoriasCursosWhereInput
    /**
     * Limit how many categoriasCursos to update.
     */
    limit?: number
  }

  /**
   * categoriasCursos updateManyAndReturn
   */
  export type categoriasCursosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * The data used to update categoriasCursos.
     */
    data: XOR<categoriasCursosUpdateManyMutationInput, categoriasCursosUncheckedUpdateManyInput>
    /**
     * Filter which categoriasCursos to update
     */
    where?: categoriasCursosWhereInput
    /**
     * Limit how many categoriasCursos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * categoriasCursos upsert
   */
  export type categoriasCursosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosInclude<ExtArgs> | null
    /**
     * The filter to search for the categoriasCursos to update in case it exists.
     */
    where: categoriasCursosWhereUniqueInput
    /**
     * In case the categoriasCursos found by the `where` argument doesn't exist, create a new categoriasCursos with this data.
     */
    create: XOR<categoriasCursosCreateInput, categoriasCursosUncheckedCreateInput>
    /**
     * In case the categoriasCursos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoriasCursosUpdateInput, categoriasCursosUncheckedUpdateInput>
  }

  /**
   * categoriasCursos delete
   */
  export type categoriasCursosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosInclude<ExtArgs> | null
    /**
     * Filter which categoriasCursos to delete.
     */
    where: categoriasCursosWhereUniqueInput
  }

  /**
   * categoriasCursos deleteMany
   */
  export type categoriasCursosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categoriasCursos to delete
     */
    where?: categoriasCursosWhereInput
    /**
     * Limit how many categoriasCursos to delete.
     */
    limit?: number
  }

  /**
   * categoriasCursos without action
   */
  export type categoriasCursosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosInclude<ExtArgs> | null
  }


  /**
   * Model certificados
   */

  export type AggregateCertificados = {
    _count: CertificadosCountAggregateOutputType | null
    _avg: CertificadosAvgAggregateOutputType | null
    _sum: CertificadosSumAggregateOutputType | null
    _min: CertificadosMinAggregateOutputType | null
    _max: CertificadosMaxAggregateOutputType | null
  }

  export type CertificadosAvgAggregateOutputType = {
    notaFinal: number | null
  }

  export type CertificadosSumAggregateOutputType = {
    notaFinal: number | null
  }

  export type CertificadosMinAggregateOutputType = {
    id: string | null
    codigoUnico: string | null
    edicionId: string | null
    estudianteId: string | null
    fechaEmision: Date | null
    tipo: $Enums.TipoCertificado | null
    notaFinal: number | null
    urlCertificado: string | null
    creadoEn: Date | null
  }

  export type CertificadosMaxAggregateOutputType = {
    id: string | null
    codigoUnico: string | null
    edicionId: string | null
    estudianteId: string | null
    fechaEmision: Date | null
    tipo: $Enums.TipoCertificado | null
    notaFinal: number | null
    urlCertificado: string | null
    creadoEn: Date | null
  }

  export type CertificadosCountAggregateOutputType = {
    id: number
    codigoUnico: number
    edicionId: number
    estudianteId: number
    fechaEmision: number
    tipo: number
    notaFinal: number
    urlCertificado: number
    creadoEn: number
    _all: number
  }


  export type CertificadosAvgAggregateInputType = {
    notaFinal?: true
  }

  export type CertificadosSumAggregateInputType = {
    notaFinal?: true
  }

  export type CertificadosMinAggregateInputType = {
    id?: true
    codigoUnico?: true
    edicionId?: true
    estudianteId?: true
    fechaEmision?: true
    tipo?: true
    notaFinal?: true
    urlCertificado?: true
    creadoEn?: true
  }

  export type CertificadosMaxAggregateInputType = {
    id?: true
    codigoUnico?: true
    edicionId?: true
    estudianteId?: true
    fechaEmision?: true
    tipo?: true
    notaFinal?: true
    urlCertificado?: true
    creadoEn?: true
  }

  export type CertificadosCountAggregateInputType = {
    id?: true
    codigoUnico?: true
    edicionId?: true
    estudianteId?: true
    fechaEmision?: true
    tipo?: true
    notaFinal?: true
    urlCertificado?: true
    creadoEn?: true
    _all?: true
  }

  export type CertificadosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which certificados to aggregate.
     */
    where?: certificadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificados to fetch.
     */
    orderBy?: certificadosOrderByWithRelationInput | certificadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: certificadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned certificados
    **/
    _count?: true | CertificadosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertificadosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertificadosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificadosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificadosMaxAggregateInputType
  }

  export type GetCertificadosAggregateType<T extends CertificadosAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificados]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificados[P]>
      : GetScalarType<T[P], AggregateCertificados[P]>
  }




  export type certificadosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: certificadosWhereInput
    orderBy?: certificadosOrderByWithAggregationInput | certificadosOrderByWithAggregationInput[]
    by: CertificadosScalarFieldEnum[] | CertificadosScalarFieldEnum
    having?: certificadosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificadosCountAggregateInputType | true
    _avg?: CertificadosAvgAggregateInputType
    _sum?: CertificadosSumAggregateInputType
    _min?: CertificadosMinAggregateInputType
    _max?: CertificadosMaxAggregateInputType
  }

  export type CertificadosGroupByOutputType = {
    id: string
    codigoUnico: string
    edicionId: string
    estudianteId: string
    fechaEmision: Date
    tipo: $Enums.TipoCertificado
    notaFinal: number | null
    urlCertificado: string | null
    creadoEn: Date
    _count: CertificadosCountAggregateOutputType | null
    _avg: CertificadosAvgAggregateOutputType | null
    _sum: CertificadosSumAggregateOutputType | null
    _min: CertificadosMinAggregateOutputType | null
    _max: CertificadosMaxAggregateOutputType | null
  }

  type GetCertificadosGroupByPayload<T extends certificadosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificadosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificadosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificadosGroupByOutputType[P]>
            : GetScalarType<T[P], CertificadosGroupByOutputType[P]>
        }
      >
    >


  export type certificadosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigoUnico?: boolean
    edicionId?: boolean
    estudianteId?: boolean
    fechaEmision?: boolean
    tipo?: boolean
    notaFinal?: boolean
    urlCertificado?: boolean
    creadoEn?: boolean
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    estudiantes?: boolean | estudiantesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificados"]>

  export type certificadosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigoUnico?: boolean
    edicionId?: boolean
    estudianteId?: boolean
    fechaEmision?: boolean
    tipo?: boolean
    notaFinal?: boolean
    urlCertificado?: boolean
    creadoEn?: boolean
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    estudiantes?: boolean | estudiantesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificados"]>

  export type certificadosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigoUnico?: boolean
    edicionId?: boolean
    estudianteId?: boolean
    fechaEmision?: boolean
    tipo?: boolean
    notaFinal?: boolean
    urlCertificado?: boolean
    creadoEn?: boolean
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    estudiantes?: boolean | estudiantesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificados"]>

  export type certificadosSelectScalar = {
    id?: boolean
    codigoUnico?: boolean
    edicionId?: boolean
    estudianteId?: boolean
    fechaEmision?: boolean
    tipo?: boolean
    notaFinal?: boolean
    urlCertificado?: boolean
    creadoEn?: boolean
  }

  export type certificadosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "codigoUnico" | "edicionId" | "estudianteId" | "fechaEmision" | "tipo" | "notaFinal" | "urlCertificado" | "creadoEn", ExtArgs["result"]["certificados"]>
  export type certificadosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    estudiantes?: boolean | estudiantesDefaultArgs<ExtArgs>
  }
  export type certificadosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    estudiantes?: boolean | estudiantesDefaultArgs<ExtArgs>
  }
  export type certificadosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    estudiantes?: boolean | estudiantesDefaultArgs<ExtArgs>
  }

  export type $certificadosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "certificados"
    objects: {
      edicionesCursos: Prisma.$edicionesCursosPayload<ExtArgs>
      estudiantes: Prisma.$estudiantesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      codigoUnico: string
      edicionId: string
      estudianteId: string
      fechaEmision: Date
      tipo: $Enums.TipoCertificado
      notaFinal: number | null
      urlCertificado: string | null
      creadoEn: Date
    }, ExtArgs["result"]["certificados"]>
    composites: {}
  }

  type certificadosGetPayload<S extends boolean | null | undefined | certificadosDefaultArgs> = $Result.GetResult<Prisma.$certificadosPayload, S>

  type certificadosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<certificadosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CertificadosCountAggregateInputType | true
    }

  export interface certificadosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['certificados'], meta: { name: 'certificados' } }
    /**
     * Find zero or one Certificados that matches the filter.
     * @param {certificadosFindUniqueArgs} args - Arguments to find a Certificados
     * @example
     * // Get one Certificados
     * const certificados = await prisma.certificados.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends certificadosFindUniqueArgs>(args: SelectSubset<T, certificadosFindUniqueArgs<ExtArgs>>): Prisma__certificadosClient<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Certificados that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {certificadosFindUniqueOrThrowArgs} args - Arguments to find a Certificados
     * @example
     * // Get one Certificados
     * const certificados = await prisma.certificados.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends certificadosFindUniqueOrThrowArgs>(args: SelectSubset<T, certificadosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__certificadosClient<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certificados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificadosFindFirstArgs} args - Arguments to find a Certificados
     * @example
     * // Get one Certificados
     * const certificados = await prisma.certificados.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends certificadosFindFirstArgs>(args?: SelectSubset<T, certificadosFindFirstArgs<ExtArgs>>): Prisma__certificadosClient<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certificados that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificadosFindFirstOrThrowArgs} args - Arguments to find a Certificados
     * @example
     * // Get one Certificados
     * const certificados = await prisma.certificados.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends certificadosFindFirstOrThrowArgs>(args?: SelectSubset<T, certificadosFindFirstOrThrowArgs<ExtArgs>>): Prisma__certificadosClient<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Certificados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificadosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certificados
     * const certificados = await prisma.certificados.findMany()
     * 
     * // Get first 10 Certificados
     * const certificados = await prisma.certificados.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificadosWithIdOnly = await prisma.certificados.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends certificadosFindManyArgs>(args?: SelectSubset<T, certificadosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Certificados.
     * @param {certificadosCreateArgs} args - Arguments to create a Certificados.
     * @example
     * // Create one Certificados
     * const Certificados = await prisma.certificados.create({
     *   data: {
     *     // ... data to create a Certificados
     *   }
     * })
     * 
     */
    create<T extends certificadosCreateArgs>(args: SelectSubset<T, certificadosCreateArgs<ExtArgs>>): Prisma__certificadosClient<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Certificados.
     * @param {certificadosCreateManyArgs} args - Arguments to create many Certificados.
     * @example
     * // Create many Certificados
     * const certificados = await prisma.certificados.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends certificadosCreateManyArgs>(args?: SelectSubset<T, certificadosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certificados and returns the data saved in the database.
     * @param {certificadosCreateManyAndReturnArgs} args - Arguments to create many Certificados.
     * @example
     * // Create many Certificados
     * const certificados = await prisma.certificados.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certificados and only return the `id`
     * const certificadosWithIdOnly = await prisma.certificados.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends certificadosCreateManyAndReturnArgs>(args?: SelectSubset<T, certificadosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Certificados.
     * @param {certificadosDeleteArgs} args - Arguments to delete one Certificados.
     * @example
     * // Delete one Certificados
     * const Certificados = await prisma.certificados.delete({
     *   where: {
     *     // ... filter to delete one Certificados
     *   }
     * })
     * 
     */
    delete<T extends certificadosDeleteArgs>(args: SelectSubset<T, certificadosDeleteArgs<ExtArgs>>): Prisma__certificadosClient<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Certificados.
     * @param {certificadosUpdateArgs} args - Arguments to update one Certificados.
     * @example
     * // Update one Certificados
     * const certificados = await prisma.certificados.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends certificadosUpdateArgs>(args: SelectSubset<T, certificadosUpdateArgs<ExtArgs>>): Prisma__certificadosClient<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Certificados.
     * @param {certificadosDeleteManyArgs} args - Arguments to filter Certificados to delete.
     * @example
     * // Delete a few Certificados
     * const { count } = await prisma.certificados.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends certificadosDeleteManyArgs>(args?: SelectSubset<T, certificadosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificadosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certificados
     * const certificados = await prisma.certificados.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends certificadosUpdateManyArgs>(args: SelectSubset<T, certificadosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificados and returns the data updated in the database.
     * @param {certificadosUpdateManyAndReturnArgs} args - Arguments to update many Certificados.
     * @example
     * // Update many Certificados
     * const certificados = await prisma.certificados.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Certificados and only return the `id`
     * const certificadosWithIdOnly = await prisma.certificados.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends certificadosUpdateManyAndReturnArgs>(args: SelectSubset<T, certificadosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Certificados.
     * @param {certificadosUpsertArgs} args - Arguments to update or create a Certificados.
     * @example
     * // Update or create a Certificados
     * const certificados = await prisma.certificados.upsert({
     *   create: {
     *     // ... data to create a Certificados
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certificados we want to update
     *   }
     * })
     */
    upsert<T extends certificadosUpsertArgs>(args: SelectSubset<T, certificadosUpsertArgs<ExtArgs>>): Prisma__certificadosClient<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Certificados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificadosCountArgs} args - Arguments to filter Certificados to count.
     * @example
     * // Count the number of Certificados
     * const count = await prisma.certificados.count({
     *   where: {
     *     // ... the filter for the Certificados we want to count
     *   }
     * })
    **/
    count<T extends certificadosCountArgs>(
      args?: Subset<T, certificadosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificadosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certificados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificadosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificadosAggregateArgs>(args: Subset<T, CertificadosAggregateArgs>): Prisma.PrismaPromise<GetCertificadosAggregateType<T>>

    /**
     * Group by Certificados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificadosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends certificadosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: certificadosGroupByArgs['orderBy'] }
        : { orderBy?: certificadosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, certificadosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificadosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the certificados model
   */
  readonly fields: certificadosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for certificados.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__certificadosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    edicionesCursos<T extends edicionesCursosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursosDefaultArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    estudiantes<T extends estudiantesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, estudiantesDefaultArgs<ExtArgs>>): Prisma__estudiantesClient<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the certificados model
   */
  interface certificadosFieldRefs {
    readonly id: FieldRef<"certificados", 'String'>
    readonly codigoUnico: FieldRef<"certificados", 'String'>
    readonly edicionId: FieldRef<"certificados", 'String'>
    readonly estudianteId: FieldRef<"certificados", 'String'>
    readonly fechaEmision: FieldRef<"certificados", 'DateTime'>
    readonly tipo: FieldRef<"certificados", 'TipoCertificado'>
    readonly notaFinal: FieldRef<"certificados", 'Float'>
    readonly urlCertificado: FieldRef<"certificados", 'String'>
    readonly creadoEn: FieldRef<"certificados", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * certificados findUnique
   */
  export type certificadosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosInclude<ExtArgs> | null
    /**
     * Filter, which certificados to fetch.
     */
    where: certificadosWhereUniqueInput
  }

  /**
   * certificados findUniqueOrThrow
   */
  export type certificadosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosInclude<ExtArgs> | null
    /**
     * Filter, which certificados to fetch.
     */
    where: certificadosWhereUniqueInput
  }

  /**
   * certificados findFirst
   */
  export type certificadosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosInclude<ExtArgs> | null
    /**
     * Filter, which certificados to fetch.
     */
    where?: certificadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificados to fetch.
     */
    orderBy?: certificadosOrderByWithRelationInput | certificadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for certificados.
     */
    cursor?: certificadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of certificados.
     */
    distinct?: CertificadosScalarFieldEnum | CertificadosScalarFieldEnum[]
  }

  /**
   * certificados findFirstOrThrow
   */
  export type certificadosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosInclude<ExtArgs> | null
    /**
     * Filter, which certificados to fetch.
     */
    where?: certificadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificados to fetch.
     */
    orderBy?: certificadosOrderByWithRelationInput | certificadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for certificados.
     */
    cursor?: certificadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of certificados.
     */
    distinct?: CertificadosScalarFieldEnum | CertificadosScalarFieldEnum[]
  }

  /**
   * certificados findMany
   */
  export type certificadosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosInclude<ExtArgs> | null
    /**
     * Filter, which certificados to fetch.
     */
    where?: certificadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificados to fetch.
     */
    orderBy?: certificadosOrderByWithRelationInput | certificadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing certificados.
     */
    cursor?: certificadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificados.
     */
    skip?: number
    distinct?: CertificadosScalarFieldEnum | CertificadosScalarFieldEnum[]
  }

  /**
   * certificados create
   */
  export type certificadosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosInclude<ExtArgs> | null
    /**
     * The data needed to create a certificados.
     */
    data: XOR<certificadosCreateInput, certificadosUncheckedCreateInput>
  }

  /**
   * certificados createMany
   */
  export type certificadosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many certificados.
     */
    data: certificadosCreateManyInput | certificadosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * certificados createManyAndReturn
   */
  export type certificadosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * The data used to create many certificados.
     */
    data: certificadosCreateManyInput | certificadosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * certificados update
   */
  export type certificadosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosInclude<ExtArgs> | null
    /**
     * The data needed to update a certificados.
     */
    data: XOR<certificadosUpdateInput, certificadosUncheckedUpdateInput>
    /**
     * Choose, which certificados to update.
     */
    where: certificadosWhereUniqueInput
  }

  /**
   * certificados updateMany
   */
  export type certificadosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update certificados.
     */
    data: XOR<certificadosUpdateManyMutationInput, certificadosUncheckedUpdateManyInput>
    /**
     * Filter which certificados to update
     */
    where?: certificadosWhereInput
    /**
     * Limit how many certificados to update.
     */
    limit?: number
  }

  /**
   * certificados updateManyAndReturn
   */
  export type certificadosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * The data used to update certificados.
     */
    data: XOR<certificadosUpdateManyMutationInput, certificadosUncheckedUpdateManyInput>
    /**
     * Filter which certificados to update
     */
    where?: certificadosWhereInput
    /**
     * Limit how many certificados to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * certificados upsert
   */
  export type certificadosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosInclude<ExtArgs> | null
    /**
     * The filter to search for the certificados to update in case it exists.
     */
    where: certificadosWhereUniqueInput
    /**
     * In case the certificados found by the `where` argument doesn't exist, create a new certificados with this data.
     */
    create: XOR<certificadosCreateInput, certificadosUncheckedCreateInput>
    /**
     * In case the certificados was found with the provided `where` argument, update it with this data.
     */
    update: XOR<certificadosUpdateInput, certificadosUncheckedUpdateInput>
  }

  /**
   * certificados delete
   */
  export type certificadosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosInclude<ExtArgs> | null
    /**
     * Filter which certificados to delete.
     */
    where: certificadosWhereUniqueInput
  }

  /**
   * certificados deleteMany
   */
  export type certificadosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which certificados to delete
     */
    where?: certificadosWhereInput
    /**
     * Limit how many certificados to delete.
     */
    limit?: number
  }

  /**
   * certificados without action
   */
  export type certificadosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosInclude<ExtArgs> | null
  }


  /**
   * Model clases
   */

  export type AggregateClases = {
    _count: ClasesCountAggregateOutputType | null
    _avg: ClasesAvgAggregateOutputType | null
    _sum: ClasesSumAggregateOutputType | null
    _min: ClasesMinAggregateOutputType | null
    _max: ClasesMaxAggregateOutputType | null
  }

  export type ClasesAvgAggregateOutputType = {
    duracion: number | null
    orden: number | null
  }

  export type ClasesSumAggregateOutputType = {
    duracion: number | null
    orden: number | null
  }

  export type ClasesMinAggregateOutputType = {
    id: string | null
    edicionId: string | null
    descripcion: string | null
    duracion: number | null
    fecha: Date | null
    orden: number | null
    titulo: string | null
    urlYoutube: string | null
    creadoEn: Date | null
    urlPresentacion: string | null
  }

  export type ClasesMaxAggregateOutputType = {
    id: string | null
    edicionId: string | null
    descripcion: string | null
    duracion: number | null
    fecha: Date | null
    orden: number | null
    titulo: string | null
    urlYoutube: string | null
    creadoEn: Date | null
    urlPresentacion: string | null
  }

  export type ClasesCountAggregateOutputType = {
    id: number
    edicionId: number
    descripcion: number
    duracion: number
    fecha: number
    orden: number
    titulo: number
    urlYoutube: number
    creadoEn: number
    urlPresentacion: number
    _all: number
  }


  export type ClasesAvgAggregateInputType = {
    duracion?: true
    orden?: true
  }

  export type ClasesSumAggregateInputType = {
    duracion?: true
    orden?: true
  }

  export type ClasesMinAggregateInputType = {
    id?: true
    edicionId?: true
    descripcion?: true
    duracion?: true
    fecha?: true
    orden?: true
    titulo?: true
    urlYoutube?: true
    creadoEn?: true
    urlPresentacion?: true
  }

  export type ClasesMaxAggregateInputType = {
    id?: true
    edicionId?: true
    descripcion?: true
    duracion?: true
    fecha?: true
    orden?: true
    titulo?: true
    urlYoutube?: true
    creadoEn?: true
    urlPresentacion?: true
  }

  export type ClasesCountAggregateInputType = {
    id?: true
    edicionId?: true
    descripcion?: true
    duracion?: true
    fecha?: true
    orden?: true
    titulo?: true
    urlYoutube?: true
    creadoEn?: true
    urlPresentacion?: true
    _all?: true
  }

  export type ClasesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clases to aggregate.
     */
    where?: clasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clases to fetch.
     */
    orderBy?: clasesOrderByWithRelationInput | clasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clases
    **/
    _count?: true | ClasesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClasesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClasesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClasesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClasesMaxAggregateInputType
  }

  export type GetClasesAggregateType<T extends ClasesAggregateArgs> = {
        [P in keyof T & keyof AggregateClases]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClases[P]>
      : GetScalarType<T[P], AggregateClases[P]>
  }




  export type clasesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clasesWhereInput
    orderBy?: clasesOrderByWithAggregationInput | clasesOrderByWithAggregationInput[]
    by: ClasesScalarFieldEnum[] | ClasesScalarFieldEnum
    having?: clasesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClasesCountAggregateInputType | true
    _avg?: ClasesAvgAggregateInputType
    _sum?: ClasesSumAggregateInputType
    _min?: ClasesMinAggregateInputType
    _max?: ClasesMaxAggregateInputType
  }

  export type ClasesGroupByOutputType = {
    id: string
    edicionId: string
    descripcion: string
    duracion: number | null
    fecha: Date
    orden: number
    titulo: string
    urlYoutube: string | null
    creadoEn: Date
    urlPresentacion: string | null
    _count: ClasesCountAggregateOutputType | null
    _avg: ClasesAvgAggregateOutputType | null
    _sum: ClasesSumAggregateOutputType | null
    _min: ClasesMinAggregateOutputType | null
    _max: ClasesMaxAggregateOutputType | null
  }

  type GetClasesGroupByPayload<T extends clasesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClasesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClasesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClasesGroupByOutputType[P]>
            : GetScalarType<T[P], ClasesGroupByOutputType[P]>
        }
      >
    >


  export type clasesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    descripcion?: boolean
    duracion?: boolean
    fecha?: boolean
    orden?: boolean
    titulo?: boolean
    urlYoutube?: boolean
    creadoEn?: boolean
    urlPresentacion?: boolean
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    grabaciones?: boolean | clases$grabacionesArgs<ExtArgs>
    materiales?: boolean | clases$materialesArgs<ExtArgs>
    _count?: boolean | ClasesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clases"]>

  export type clasesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    descripcion?: boolean
    duracion?: boolean
    fecha?: boolean
    orden?: boolean
    titulo?: boolean
    urlYoutube?: boolean
    creadoEn?: boolean
    urlPresentacion?: boolean
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clases"]>

  export type clasesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    descripcion?: boolean
    duracion?: boolean
    fecha?: boolean
    orden?: boolean
    titulo?: boolean
    urlYoutube?: boolean
    creadoEn?: boolean
    urlPresentacion?: boolean
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clases"]>

  export type clasesSelectScalar = {
    id?: boolean
    edicionId?: boolean
    descripcion?: boolean
    duracion?: boolean
    fecha?: boolean
    orden?: boolean
    titulo?: boolean
    urlYoutube?: boolean
    creadoEn?: boolean
    urlPresentacion?: boolean
  }

  export type clasesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "edicionId" | "descripcion" | "duracion" | "fecha" | "orden" | "titulo" | "urlYoutube" | "creadoEn" | "urlPresentacion", ExtArgs["result"]["clases"]>
  export type clasesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    grabaciones?: boolean | clases$grabacionesArgs<ExtArgs>
    materiales?: boolean | clases$materialesArgs<ExtArgs>
    _count?: boolean | ClasesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type clasesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }
  export type clasesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }

  export type $clasesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "clases"
    objects: {
      edicionesCursos: Prisma.$edicionesCursosPayload<ExtArgs>
      grabaciones: Prisma.$grabacionesPayload<ExtArgs>[]
      materiales: Prisma.$materialesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      edicionId: string
      descripcion: string
      duracion: number | null
      fecha: Date
      orden: number
      titulo: string
      urlYoutube: string | null
      creadoEn: Date
      urlPresentacion: string | null
    }, ExtArgs["result"]["clases"]>
    composites: {}
  }

  type clasesGetPayload<S extends boolean | null | undefined | clasesDefaultArgs> = $Result.GetResult<Prisma.$clasesPayload, S>

  type clasesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<clasesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClasesCountAggregateInputType | true
    }

  export interface clasesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['clases'], meta: { name: 'clases' } }
    /**
     * Find zero or one Clases that matches the filter.
     * @param {clasesFindUniqueArgs} args - Arguments to find a Clases
     * @example
     * // Get one Clases
     * const clases = await prisma.clases.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clasesFindUniqueArgs>(args: SelectSubset<T, clasesFindUniqueArgs<ExtArgs>>): Prisma__clasesClient<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Clases that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {clasesFindUniqueOrThrowArgs} args - Arguments to find a Clases
     * @example
     * // Get one Clases
     * const clases = await prisma.clases.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clasesFindUniqueOrThrowArgs>(args: SelectSubset<T, clasesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clasesClient<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clasesFindFirstArgs} args - Arguments to find a Clases
     * @example
     * // Get one Clases
     * const clases = await prisma.clases.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clasesFindFirstArgs>(args?: SelectSubset<T, clasesFindFirstArgs<ExtArgs>>): Prisma__clasesClient<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clases that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clasesFindFirstOrThrowArgs} args - Arguments to find a Clases
     * @example
     * // Get one Clases
     * const clases = await prisma.clases.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clasesFindFirstOrThrowArgs>(args?: SelectSubset<T, clasesFindFirstOrThrowArgs<ExtArgs>>): Prisma__clasesClient<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clasesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clases
     * const clases = await prisma.clases.findMany()
     * 
     * // Get first 10 Clases
     * const clases = await prisma.clases.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clasesWithIdOnly = await prisma.clases.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends clasesFindManyArgs>(args?: SelectSubset<T, clasesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Clases.
     * @param {clasesCreateArgs} args - Arguments to create a Clases.
     * @example
     * // Create one Clases
     * const Clases = await prisma.clases.create({
     *   data: {
     *     // ... data to create a Clases
     *   }
     * })
     * 
     */
    create<T extends clasesCreateArgs>(args: SelectSubset<T, clasesCreateArgs<ExtArgs>>): Prisma__clasesClient<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clases.
     * @param {clasesCreateManyArgs} args - Arguments to create many Clases.
     * @example
     * // Create many Clases
     * const clases = await prisma.clases.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clasesCreateManyArgs>(args?: SelectSubset<T, clasesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clases and returns the data saved in the database.
     * @param {clasesCreateManyAndReturnArgs} args - Arguments to create many Clases.
     * @example
     * // Create many Clases
     * const clases = await prisma.clases.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clases and only return the `id`
     * const clasesWithIdOnly = await prisma.clases.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends clasesCreateManyAndReturnArgs>(args?: SelectSubset<T, clasesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Clases.
     * @param {clasesDeleteArgs} args - Arguments to delete one Clases.
     * @example
     * // Delete one Clases
     * const Clases = await prisma.clases.delete({
     *   where: {
     *     // ... filter to delete one Clases
     *   }
     * })
     * 
     */
    delete<T extends clasesDeleteArgs>(args: SelectSubset<T, clasesDeleteArgs<ExtArgs>>): Prisma__clasesClient<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Clases.
     * @param {clasesUpdateArgs} args - Arguments to update one Clases.
     * @example
     * // Update one Clases
     * const clases = await prisma.clases.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clasesUpdateArgs>(args: SelectSubset<T, clasesUpdateArgs<ExtArgs>>): Prisma__clasesClient<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clases.
     * @param {clasesDeleteManyArgs} args - Arguments to filter Clases to delete.
     * @example
     * // Delete a few Clases
     * const { count } = await prisma.clases.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clasesDeleteManyArgs>(args?: SelectSubset<T, clasesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clasesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clases
     * const clases = await prisma.clases.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clasesUpdateManyArgs>(args: SelectSubset<T, clasesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clases and returns the data updated in the database.
     * @param {clasesUpdateManyAndReturnArgs} args - Arguments to update many Clases.
     * @example
     * // Update many Clases
     * const clases = await prisma.clases.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clases and only return the `id`
     * const clasesWithIdOnly = await prisma.clases.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends clasesUpdateManyAndReturnArgs>(args: SelectSubset<T, clasesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Clases.
     * @param {clasesUpsertArgs} args - Arguments to update or create a Clases.
     * @example
     * // Update or create a Clases
     * const clases = await prisma.clases.upsert({
     *   create: {
     *     // ... data to create a Clases
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clases we want to update
     *   }
     * })
     */
    upsert<T extends clasesUpsertArgs>(args: SelectSubset<T, clasesUpsertArgs<ExtArgs>>): Prisma__clasesClient<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clasesCountArgs} args - Arguments to filter Clases to count.
     * @example
     * // Count the number of Clases
     * const count = await prisma.clases.count({
     *   where: {
     *     // ... the filter for the Clases we want to count
     *   }
     * })
    **/
    count<T extends clasesCountArgs>(
      args?: Subset<T, clasesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClasesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClasesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClasesAggregateArgs>(args: Subset<T, ClasesAggregateArgs>): Prisma.PrismaPromise<GetClasesAggregateType<T>>

    /**
     * Group by Clases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clasesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clasesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clasesGroupByArgs['orderBy'] }
        : { orderBy?: clasesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clasesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClasesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the clases model
   */
  readonly fields: clasesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for clases.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clasesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    edicionesCursos<T extends edicionesCursosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursosDefaultArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    grabaciones<T extends clases$grabacionesArgs<ExtArgs> = {}>(args?: Subset<T, clases$grabacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    materiales<T extends clases$materialesArgs<ExtArgs> = {}>(args?: Subset<T, clases$materialesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the clases model
   */
  interface clasesFieldRefs {
    readonly id: FieldRef<"clases", 'String'>
    readonly edicionId: FieldRef<"clases", 'String'>
    readonly descripcion: FieldRef<"clases", 'String'>
    readonly duracion: FieldRef<"clases", 'Int'>
    readonly fecha: FieldRef<"clases", 'DateTime'>
    readonly orden: FieldRef<"clases", 'Int'>
    readonly titulo: FieldRef<"clases", 'String'>
    readonly urlYoutube: FieldRef<"clases", 'String'>
    readonly creadoEn: FieldRef<"clases", 'DateTime'>
    readonly urlPresentacion: FieldRef<"clases", 'String'>
  }
    

  // Custom InputTypes
  /**
   * clases findUnique
   */
  export type clasesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesInclude<ExtArgs> | null
    /**
     * Filter, which clases to fetch.
     */
    where: clasesWhereUniqueInput
  }

  /**
   * clases findUniqueOrThrow
   */
  export type clasesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesInclude<ExtArgs> | null
    /**
     * Filter, which clases to fetch.
     */
    where: clasesWhereUniqueInput
  }

  /**
   * clases findFirst
   */
  export type clasesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesInclude<ExtArgs> | null
    /**
     * Filter, which clases to fetch.
     */
    where?: clasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clases to fetch.
     */
    orderBy?: clasesOrderByWithRelationInput | clasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clases.
     */
    cursor?: clasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clases.
     */
    distinct?: ClasesScalarFieldEnum | ClasesScalarFieldEnum[]
  }

  /**
   * clases findFirstOrThrow
   */
  export type clasesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesInclude<ExtArgs> | null
    /**
     * Filter, which clases to fetch.
     */
    where?: clasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clases to fetch.
     */
    orderBy?: clasesOrderByWithRelationInput | clasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clases.
     */
    cursor?: clasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clases.
     */
    distinct?: ClasesScalarFieldEnum | ClasesScalarFieldEnum[]
  }

  /**
   * clases findMany
   */
  export type clasesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesInclude<ExtArgs> | null
    /**
     * Filter, which clases to fetch.
     */
    where?: clasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clases to fetch.
     */
    orderBy?: clasesOrderByWithRelationInput | clasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clases.
     */
    cursor?: clasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clases.
     */
    skip?: number
    distinct?: ClasesScalarFieldEnum | ClasesScalarFieldEnum[]
  }

  /**
   * clases create
   */
  export type clasesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesInclude<ExtArgs> | null
    /**
     * The data needed to create a clases.
     */
    data: XOR<clasesCreateInput, clasesUncheckedCreateInput>
  }

  /**
   * clases createMany
   */
  export type clasesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clases.
     */
    data: clasesCreateManyInput | clasesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clases createManyAndReturn
   */
  export type clasesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * The data used to create many clases.
     */
    data: clasesCreateManyInput | clasesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * clases update
   */
  export type clasesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesInclude<ExtArgs> | null
    /**
     * The data needed to update a clases.
     */
    data: XOR<clasesUpdateInput, clasesUncheckedUpdateInput>
    /**
     * Choose, which clases to update.
     */
    where: clasesWhereUniqueInput
  }

  /**
   * clases updateMany
   */
  export type clasesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clases.
     */
    data: XOR<clasesUpdateManyMutationInput, clasesUncheckedUpdateManyInput>
    /**
     * Filter which clases to update
     */
    where?: clasesWhereInput
    /**
     * Limit how many clases to update.
     */
    limit?: number
  }

  /**
   * clases updateManyAndReturn
   */
  export type clasesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * The data used to update clases.
     */
    data: XOR<clasesUpdateManyMutationInput, clasesUncheckedUpdateManyInput>
    /**
     * Filter which clases to update
     */
    where?: clasesWhereInput
    /**
     * Limit how many clases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * clases upsert
   */
  export type clasesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesInclude<ExtArgs> | null
    /**
     * The filter to search for the clases to update in case it exists.
     */
    where: clasesWhereUniqueInput
    /**
     * In case the clases found by the `where` argument doesn't exist, create a new clases with this data.
     */
    create: XOR<clasesCreateInput, clasesUncheckedCreateInput>
    /**
     * In case the clases was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clasesUpdateInput, clasesUncheckedUpdateInput>
  }

  /**
   * clases delete
   */
  export type clasesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesInclude<ExtArgs> | null
    /**
     * Filter which clases to delete.
     */
    where: clasesWhereUniqueInput
  }

  /**
   * clases deleteMany
   */
  export type clasesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clases to delete
     */
    where?: clasesWhereInput
    /**
     * Limit how many clases to delete.
     */
    limit?: number
  }

  /**
   * clases.grabaciones
   */
  export type clases$grabacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesInclude<ExtArgs> | null
    where?: grabacionesWhereInput
    orderBy?: grabacionesOrderByWithRelationInput | grabacionesOrderByWithRelationInput[]
    cursor?: grabacionesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GrabacionesScalarFieldEnum | GrabacionesScalarFieldEnum[]
  }

  /**
   * clases.materiales
   */
  export type clases$materialesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesInclude<ExtArgs> | null
    where?: materialesWhereInput
    orderBy?: materialesOrderByWithRelationInput | materialesOrderByWithRelationInput[]
    cursor?: materialesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialesScalarFieldEnum | MaterialesScalarFieldEnum[]
  }

  /**
   * clases without action
   */
  export type clasesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesInclude<ExtArgs> | null
  }


  /**
   * Model compras
   */

  export type AggregateCompras = {
    _count: ComprasCountAggregateOutputType | null
    _avg: ComprasAvgAggregateOutputType | null
    _sum: ComprasSumAggregateOutputType | null
    _min: ComprasMinAggregateOutputType | null
    _max: ComprasMaxAggregateOutputType | null
  }

  export type ComprasAvgAggregateOutputType = {
    monto: number | null
    deuda: number | null
  }

  export type ComprasSumAggregateOutputType = {
    monto: number | null
    deuda: number | null
  }

  export type ComprasMinAggregateOutputType = {
    id: string | null
    edicionId: string | null
    monto: number | null
    moneda: string | null
    comprobado: boolean | null
    providerId: string | null
    fechaCompra: Date | null
    metodo: $Enums.MetodoPago | null
    deuda: number | null
    usuariosEstudiantesId: string | null
    estadoPago: $Enums.EstadoPago | null
    updatedAt: Date | null
    conDescuento: boolean | null
  }

  export type ComprasMaxAggregateOutputType = {
    id: string | null
    edicionId: string | null
    monto: number | null
    moneda: string | null
    comprobado: boolean | null
    providerId: string | null
    fechaCompra: Date | null
    metodo: $Enums.MetodoPago | null
    deuda: number | null
    usuariosEstudiantesId: string | null
    estadoPago: $Enums.EstadoPago | null
    updatedAt: Date | null
    conDescuento: boolean | null
  }

  export type ComprasCountAggregateOutputType = {
    id: number
    edicionId: number
    monto: number
    moneda: number
    comprobado: number
    providerId: number
    fechaCompra: number
    metodo: number
    deuda: number
    usuariosEstudiantesId: number
    estadoPago: number
    updatedAt: number
    conDescuento: number
    _all: number
  }


  export type ComprasAvgAggregateInputType = {
    monto?: true
    deuda?: true
  }

  export type ComprasSumAggregateInputType = {
    monto?: true
    deuda?: true
  }

  export type ComprasMinAggregateInputType = {
    id?: true
    edicionId?: true
    monto?: true
    moneda?: true
    comprobado?: true
    providerId?: true
    fechaCompra?: true
    metodo?: true
    deuda?: true
    usuariosEstudiantesId?: true
    estadoPago?: true
    updatedAt?: true
    conDescuento?: true
  }

  export type ComprasMaxAggregateInputType = {
    id?: true
    edicionId?: true
    monto?: true
    moneda?: true
    comprobado?: true
    providerId?: true
    fechaCompra?: true
    metodo?: true
    deuda?: true
    usuariosEstudiantesId?: true
    estadoPago?: true
    updatedAt?: true
    conDescuento?: true
  }

  export type ComprasCountAggregateInputType = {
    id?: true
    edicionId?: true
    monto?: true
    moneda?: true
    comprobado?: true
    providerId?: true
    fechaCompra?: true
    metodo?: true
    deuda?: true
    usuariosEstudiantesId?: true
    estadoPago?: true
    updatedAt?: true
    conDescuento?: true
    _all?: true
  }

  export type ComprasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which compras to aggregate.
     */
    where?: comprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of compras to fetch.
     */
    orderBy?: comprasOrderByWithRelationInput | comprasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: comprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` compras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` compras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned compras
    **/
    _count?: true | ComprasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComprasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComprasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComprasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComprasMaxAggregateInputType
  }

  export type GetComprasAggregateType<T extends ComprasAggregateArgs> = {
        [P in keyof T & keyof AggregateCompras]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompras[P]>
      : GetScalarType<T[P], AggregateCompras[P]>
  }




  export type comprasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comprasWhereInput
    orderBy?: comprasOrderByWithAggregationInput | comprasOrderByWithAggregationInput[]
    by: ComprasScalarFieldEnum[] | ComprasScalarFieldEnum
    having?: comprasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComprasCountAggregateInputType | true
    _avg?: ComprasAvgAggregateInputType
    _sum?: ComprasSumAggregateInputType
    _min?: ComprasMinAggregateInputType
    _max?: ComprasMaxAggregateInputType
  }

  export type ComprasGroupByOutputType = {
    id: string
    edicionId: string
    monto: number
    moneda: string
    comprobado: boolean
    providerId: string
    fechaCompra: Date
    metodo: $Enums.MetodoPago
    deuda: number
    usuariosEstudiantesId: string | null
    estadoPago: $Enums.EstadoPago
    updatedAt: Date
    conDescuento: boolean
    _count: ComprasCountAggregateOutputType | null
    _avg: ComprasAvgAggregateOutputType | null
    _sum: ComprasSumAggregateOutputType | null
    _min: ComprasMinAggregateOutputType | null
    _max: ComprasMaxAggregateOutputType | null
  }

  type GetComprasGroupByPayload<T extends comprasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComprasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComprasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComprasGroupByOutputType[P]>
            : GetScalarType<T[P], ComprasGroupByOutputType[P]>
        }
      >
    >


  export type comprasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    monto?: boolean
    moneda?: boolean
    comprobado?: boolean
    providerId?: boolean
    fechaCompra?: boolean
    metodo?: boolean
    deuda?: boolean
    usuariosEstudiantesId?: boolean
    estadoPago?: boolean
    updatedAt?: boolean
    conDescuento?: boolean
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | compras$usuariosEstudiantesArgs<ExtArgs>
    inscripciones?: boolean | compras$inscripcionesArgs<ExtArgs>
  }, ExtArgs["result"]["compras"]>

  export type comprasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    monto?: boolean
    moneda?: boolean
    comprobado?: boolean
    providerId?: boolean
    fechaCompra?: boolean
    metodo?: boolean
    deuda?: boolean
    usuariosEstudiantesId?: boolean
    estadoPago?: boolean
    updatedAt?: boolean
    conDescuento?: boolean
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | compras$usuariosEstudiantesArgs<ExtArgs>
  }, ExtArgs["result"]["compras"]>

  export type comprasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    monto?: boolean
    moneda?: boolean
    comprobado?: boolean
    providerId?: boolean
    fechaCompra?: boolean
    metodo?: boolean
    deuda?: boolean
    usuariosEstudiantesId?: boolean
    estadoPago?: boolean
    updatedAt?: boolean
    conDescuento?: boolean
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | compras$usuariosEstudiantesArgs<ExtArgs>
  }, ExtArgs["result"]["compras"]>

  export type comprasSelectScalar = {
    id?: boolean
    edicionId?: boolean
    monto?: boolean
    moneda?: boolean
    comprobado?: boolean
    providerId?: boolean
    fechaCompra?: boolean
    metodo?: boolean
    deuda?: boolean
    usuariosEstudiantesId?: boolean
    estadoPago?: boolean
    updatedAt?: boolean
    conDescuento?: boolean
  }

  export type comprasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "edicionId" | "monto" | "moneda" | "comprobado" | "providerId" | "fechaCompra" | "metodo" | "deuda" | "usuariosEstudiantesId" | "estadoPago" | "updatedAt" | "conDescuento", ExtArgs["result"]["compras"]>
  export type comprasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | compras$usuariosEstudiantesArgs<ExtArgs>
    inscripciones?: boolean | compras$inscripcionesArgs<ExtArgs>
  }
  export type comprasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | compras$usuariosEstudiantesArgs<ExtArgs>
  }
  export type comprasIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | compras$usuariosEstudiantesArgs<ExtArgs>
  }

  export type $comprasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "compras"
    objects: {
      edicionesCursos: Prisma.$edicionesCursosPayload<ExtArgs>
      usuariosEstudiantes: Prisma.$usuariosEstudiantesPayload<ExtArgs> | null
      inscripciones: Prisma.$inscripcionesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      edicionId: string
      monto: number
      moneda: string
      comprobado: boolean
      providerId: string
      fechaCompra: Date
      metodo: $Enums.MetodoPago
      deuda: number
      usuariosEstudiantesId: string | null
      estadoPago: $Enums.EstadoPago
      updatedAt: Date
      conDescuento: boolean
    }, ExtArgs["result"]["compras"]>
    composites: {}
  }

  type comprasGetPayload<S extends boolean | null | undefined | comprasDefaultArgs> = $Result.GetResult<Prisma.$comprasPayload, S>

  type comprasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<comprasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComprasCountAggregateInputType | true
    }

  export interface comprasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['compras'], meta: { name: 'compras' } }
    /**
     * Find zero or one Compras that matches the filter.
     * @param {comprasFindUniqueArgs} args - Arguments to find a Compras
     * @example
     * // Get one Compras
     * const compras = await prisma.compras.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends comprasFindUniqueArgs>(args: SelectSubset<T, comprasFindUniqueArgs<ExtArgs>>): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Compras that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {comprasFindUniqueOrThrowArgs} args - Arguments to find a Compras
     * @example
     * // Get one Compras
     * const compras = await prisma.compras.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends comprasFindUniqueOrThrowArgs>(args: SelectSubset<T, comprasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Compras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comprasFindFirstArgs} args - Arguments to find a Compras
     * @example
     * // Get one Compras
     * const compras = await prisma.compras.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends comprasFindFirstArgs>(args?: SelectSubset<T, comprasFindFirstArgs<ExtArgs>>): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Compras that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comprasFindFirstOrThrowArgs} args - Arguments to find a Compras
     * @example
     * // Get one Compras
     * const compras = await prisma.compras.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends comprasFindFirstOrThrowArgs>(args?: SelectSubset<T, comprasFindFirstOrThrowArgs<ExtArgs>>): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Compras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comprasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Compras
     * const compras = await prisma.compras.findMany()
     * 
     * // Get first 10 Compras
     * const compras = await prisma.compras.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comprasWithIdOnly = await prisma.compras.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends comprasFindManyArgs>(args?: SelectSubset<T, comprasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Compras.
     * @param {comprasCreateArgs} args - Arguments to create a Compras.
     * @example
     * // Create one Compras
     * const Compras = await prisma.compras.create({
     *   data: {
     *     // ... data to create a Compras
     *   }
     * })
     * 
     */
    create<T extends comprasCreateArgs>(args: SelectSubset<T, comprasCreateArgs<ExtArgs>>): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Compras.
     * @param {comprasCreateManyArgs} args - Arguments to create many Compras.
     * @example
     * // Create many Compras
     * const compras = await prisma.compras.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends comprasCreateManyArgs>(args?: SelectSubset<T, comprasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Compras and returns the data saved in the database.
     * @param {comprasCreateManyAndReturnArgs} args - Arguments to create many Compras.
     * @example
     * // Create many Compras
     * const compras = await prisma.compras.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Compras and only return the `id`
     * const comprasWithIdOnly = await prisma.compras.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends comprasCreateManyAndReturnArgs>(args?: SelectSubset<T, comprasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Compras.
     * @param {comprasDeleteArgs} args - Arguments to delete one Compras.
     * @example
     * // Delete one Compras
     * const Compras = await prisma.compras.delete({
     *   where: {
     *     // ... filter to delete one Compras
     *   }
     * })
     * 
     */
    delete<T extends comprasDeleteArgs>(args: SelectSubset<T, comprasDeleteArgs<ExtArgs>>): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Compras.
     * @param {comprasUpdateArgs} args - Arguments to update one Compras.
     * @example
     * // Update one Compras
     * const compras = await prisma.compras.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends comprasUpdateArgs>(args: SelectSubset<T, comprasUpdateArgs<ExtArgs>>): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Compras.
     * @param {comprasDeleteManyArgs} args - Arguments to filter Compras to delete.
     * @example
     * // Delete a few Compras
     * const { count } = await prisma.compras.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends comprasDeleteManyArgs>(args?: SelectSubset<T, comprasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Compras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comprasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Compras
     * const compras = await prisma.compras.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends comprasUpdateManyArgs>(args: SelectSubset<T, comprasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Compras and returns the data updated in the database.
     * @param {comprasUpdateManyAndReturnArgs} args - Arguments to update many Compras.
     * @example
     * // Update many Compras
     * const compras = await prisma.compras.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Compras and only return the `id`
     * const comprasWithIdOnly = await prisma.compras.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends comprasUpdateManyAndReturnArgs>(args: SelectSubset<T, comprasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Compras.
     * @param {comprasUpsertArgs} args - Arguments to update or create a Compras.
     * @example
     * // Update or create a Compras
     * const compras = await prisma.compras.upsert({
     *   create: {
     *     // ... data to create a Compras
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Compras we want to update
     *   }
     * })
     */
    upsert<T extends comprasUpsertArgs>(args: SelectSubset<T, comprasUpsertArgs<ExtArgs>>): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Compras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comprasCountArgs} args - Arguments to filter Compras to count.
     * @example
     * // Count the number of Compras
     * const count = await prisma.compras.count({
     *   where: {
     *     // ... the filter for the Compras we want to count
     *   }
     * })
    **/
    count<T extends comprasCountArgs>(
      args?: Subset<T, comprasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComprasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Compras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComprasAggregateArgs>(args: Subset<T, ComprasAggregateArgs>): Prisma.PrismaPromise<GetComprasAggregateType<T>>

    /**
     * Group by Compras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comprasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends comprasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: comprasGroupByArgs['orderBy'] }
        : { orderBy?: comprasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, comprasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComprasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the compras model
   */
  readonly fields: comprasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for compras.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__comprasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    edicionesCursos<T extends edicionesCursosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursosDefaultArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usuariosEstudiantes<T extends compras$usuariosEstudiantesArgs<ExtArgs> = {}>(args?: Subset<T, compras$usuariosEstudiantesArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    inscripciones<T extends compras$inscripcionesArgs<ExtArgs> = {}>(args?: Subset<T, compras$inscripcionesArgs<ExtArgs>>): Prisma__inscripcionesClient<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the compras model
   */
  interface comprasFieldRefs {
    readonly id: FieldRef<"compras", 'String'>
    readonly edicionId: FieldRef<"compras", 'String'>
    readonly monto: FieldRef<"compras", 'Float'>
    readonly moneda: FieldRef<"compras", 'String'>
    readonly comprobado: FieldRef<"compras", 'Boolean'>
    readonly providerId: FieldRef<"compras", 'String'>
    readonly fechaCompra: FieldRef<"compras", 'DateTime'>
    readonly metodo: FieldRef<"compras", 'MetodoPago'>
    readonly deuda: FieldRef<"compras", 'Float'>
    readonly usuariosEstudiantesId: FieldRef<"compras", 'String'>
    readonly estadoPago: FieldRef<"compras", 'EstadoPago'>
    readonly updatedAt: FieldRef<"compras", 'DateTime'>
    readonly conDescuento: FieldRef<"compras", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * compras findUnique
   */
  export type comprasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * Filter, which compras to fetch.
     */
    where: comprasWhereUniqueInput
  }

  /**
   * compras findUniqueOrThrow
   */
  export type comprasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * Filter, which compras to fetch.
     */
    where: comprasWhereUniqueInput
  }

  /**
   * compras findFirst
   */
  export type comprasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * Filter, which compras to fetch.
     */
    where?: comprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of compras to fetch.
     */
    orderBy?: comprasOrderByWithRelationInput | comprasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for compras.
     */
    cursor?: comprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` compras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` compras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of compras.
     */
    distinct?: ComprasScalarFieldEnum | ComprasScalarFieldEnum[]
  }

  /**
   * compras findFirstOrThrow
   */
  export type comprasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * Filter, which compras to fetch.
     */
    where?: comprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of compras to fetch.
     */
    orderBy?: comprasOrderByWithRelationInput | comprasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for compras.
     */
    cursor?: comprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` compras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` compras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of compras.
     */
    distinct?: ComprasScalarFieldEnum | ComprasScalarFieldEnum[]
  }

  /**
   * compras findMany
   */
  export type comprasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * Filter, which compras to fetch.
     */
    where?: comprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of compras to fetch.
     */
    orderBy?: comprasOrderByWithRelationInput | comprasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing compras.
     */
    cursor?: comprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` compras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` compras.
     */
    skip?: number
    distinct?: ComprasScalarFieldEnum | ComprasScalarFieldEnum[]
  }

  /**
   * compras create
   */
  export type comprasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * The data needed to create a compras.
     */
    data: XOR<comprasCreateInput, comprasUncheckedCreateInput>
  }

  /**
   * compras createMany
   */
  export type comprasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many compras.
     */
    data: comprasCreateManyInput | comprasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * compras createManyAndReturn
   */
  export type comprasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * The data used to create many compras.
     */
    data: comprasCreateManyInput | comprasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * compras update
   */
  export type comprasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * The data needed to update a compras.
     */
    data: XOR<comprasUpdateInput, comprasUncheckedUpdateInput>
    /**
     * Choose, which compras to update.
     */
    where: comprasWhereUniqueInput
  }

  /**
   * compras updateMany
   */
  export type comprasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update compras.
     */
    data: XOR<comprasUpdateManyMutationInput, comprasUncheckedUpdateManyInput>
    /**
     * Filter which compras to update
     */
    where?: comprasWhereInput
    /**
     * Limit how many compras to update.
     */
    limit?: number
  }

  /**
   * compras updateManyAndReturn
   */
  export type comprasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * The data used to update compras.
     */
    data: XOR<comprasUpdateManyMutationInput, comprasUncheckedUpdateManyInput>
    /**
     * Filter which compras to update
     */
    where?: comprasWhereInput
    /**
     * Limit how many compras to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * compras upsert
   */
  export type comprasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * The filter to search for the compras to update in case it exists.
     */
    where: comprasWhereUniqueInput
    /**
     * In case the compras found by the `where` argument doesn't exist, create a new compras with this data.
     */
    create: XOR<comprasCreateInput, comprasUncheckedCreateInput>
    /**
     * In case the compras was found with the provided `where` argument, update it with this data.
     */
    update: XOR<comprasUpdateInput, comprasUncheckedUpdateInput>
  }

  /**
   * compras delete
   */
  export type comprasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * Filter which compras to delete.
     */
    where: comprasWhereUniqueInput
  }

  /**
   * compras deleteMany
   */
  export type comprasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which compras to delete
     */
    where?: comprasWhereInput
    /**
     * Limit how many compras to delete.
     */
    limit?: number
  }

  /**
   * compras.usuariosEstudiantes
   */
  export type compras$usuariosEstudiantesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
    where?: usuariosEstudiantesWhereInput
  }

  /**
   * compras.inscripciones
   */
  export type compras$inscripcionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
    where?: inscripcionesWhereInput
  }

  /**
   * compras without action
   */
  export type comprasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasInclude<ExtArgs> | null
  }


  /**
   * Model cursos
   */

  export type AggregateCursos = {
    _count: CursosCountAggregateOutputType | null
    _avg: CursosAvgAggregateOutputType | null
    _sum: CursosSumAggregateOutputType | null
    _min: CursosMinAggregateOutputType | null
    _max: CursosMaxAggregateOutputType | null
  }

  export type CursosAvgAggregateOutputType = {
    cargaHoraria: number | null
  }

  export type CursosSumAggregateOutputType = {
    cargaHoraria: number | null
  }

  export type CursosMinAggregateOutputType = {
    id: string | null
    descripcion: string | null
    titulo: string | null
    urlMiniatura: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    descripcionCorta: string | null
    enVivo: boolean | null
    urlCurso: string | null
    cargaHoraria: number | null
    codigo: string | null
  }

  export type CursosMaxAggregateOutputType = {
    id: string | null
    descripcion: string | null
    titulo: string | null
    urlMiniatura: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    descripcionCorta: string | null
    enVivo: boolean | null
    urlCurso: string | null
    cargaHoraria: number | null
    codigo: string | null
  }

  export type CursosCountAggregateOutputType = {
    id: number
    descripcion: number
    titulo: number
    urlMiniatura: number
    creadoEn: number
    actualizadoEn: number
    descripcionCorta: number
    enVivo: number
    urlCurso: number
    cargaHoraria: number
    codigo: number
    _all: number
  }


  export type CursosAvgAggregateInputType = {
    cargaHoraria?: true
  }

  export type CursosSumAggregateInputType = {
    cargaHoraria?: true
  }

  export type CursosMinAggregateInputType = {
    id?: true
    descripcion?: true
    titulo?: true
    urlMiniatura?: true
    creadoEn?: true
    actualizadoEn?: true
    descripcionCorta?: true
    enVivo?: true
    urlCurso?: true
    cargaHoraria?: true
    codigo?: true
  }

  export type CursosMaxAggregateInputType = {
    id?: true
    descripcion?: true
    titulo?: true
    urlMiniatura?: true
    creadoEn?: true
    actualizadoEn?: true
    descripcionCorta?: true
    enVivo?: true
    urlCurso?: true
    cargaHoraria?: true
    codigo?: true
  }

  export type CursosCountAggregateInputType = {
    id?: true
    descripcion?: true
    titulo?: true
    urlMiniatura?: true
    creadoEn?: true
    actualizadoEn?: true
    descripcionCorta?: true
    enVivo?: true
    urlCurso?: true
    cargaHoraria?: true
    codigo?: true
    _all?: true
  }

  export type CursosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cursos to aggregate.
     */
    where?: cursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cursos to fetch.
     */
    orderBy?: cursosOrderByWithRelationInput | cursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cursos
    **/
    _count?: true | CursosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CursosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CursosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CursosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CursosMaxAggregateInputType
  }

  export type GetCursosAggregateType<T extends CursosAggregateArgs> = {
        [P in keyof T & keyof AggregateCursos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCursos[P]>
      : GetScalarType<T[P], AggregateCursos[P]>
  }




  export type cursosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cursosWhereInput
    orderBy?: cursosOrderByWithAggregationInput | cursosOrderByWithAggregationInput[]
    by: CursosScalarFieldEnum[] | CursosScalarFieldEnum
    having?: cursosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CursosCountAggregateInputType | true
    _avg?: CursosAvgAggregateInputType
    _sum?: CursosSumAggregateInputType
    _min?: CursosMinAggregateInputType
    _max?: CursosMaxAggregateInputType
  }

  export type CursosGroupByOutputType = {
    id: string
    descripcion: string
    titulo: string
    urlMiniatura: string | null
    creadoEn: Date
    actualizadoEn: Date
    descripcionCorta: string | null
    enVivo: boolean
    urlCurso: string | null
    cargaHoraria: number
    codigo: string
    _count: CursosCountAggregateOutputType | null
    _avg: CursosAvgAggregateOutputType | null
    _sum: CursosSumAggregateOutputType | null
    _min: CursosMinAggregateOutputType | null
    _max: CursosMaxAggregateOutputType | null
  }

  type GetCursosGroupByPayload<T extends cursosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CursosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CursosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CursosGroupByOutputType[P]>
            : GetScalarType<T[P], CursosGroupByOutputType[P]>
        }
      >
    >


  export type cursosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descripcion?: boolean
    titulo?: boolean
    urlMiniatura?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    descripcionCorta?: boolean
    enVivo?: boolean
    urlCurso?: boolean
    cargaHoraria?: boolean
    codigo?: boolean
    beneficiosCursos?: boolean | cursos$beneficiosCursosArgs<ExtArgs>
    categoriasCursos?: boolean | cursos$categoriasCursosArgs<ExtArgs>
    edicionesCursos?: boolean | cursos$edicionesCursosArgs<ExtArgs>
    objetivosCursos?: boolean | cursos$objetivosCursosArgs<ExtArgs>
    requisitosCursos?: boolean | cursos$requisitosCursosArgs<ExtArgs>
    reviewsCursos?: boolean | cursos$reviewsCursosArgs<ExtArgs>
    _count?: boolean | CursosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cursos"]>

  export type cursosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descripcion?: boolean
    titulo?: boolean
    urlMiniatura?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    descripcionCorta?: boolean
    enVivo?: boolean
    urlCurso?: boolean
    cargaHoraria?: boolean
    codigo?: boolean
  }, ExtArgs["result"]["cursos"]>

  export type cursosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descripcion?: boolean
    titulo?: boolean
    urlMiniatura?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    descripcionCorta?: boolean
    enVivo?: boolean
    urlCurso?: boolean
    cargaHoraria?: boolean
    codigo?: boolean
  }, ExtArgs["result"]["cursos"]>

  export type cursosSelectScalar = {
    id?: boolean
    descripcion?: boolean
    titulo?: boolean
    urlMiniatura?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    descripcionCorta?: boolean
    enVivo?: boolean
    urlCurso?: boolean
    cargaHoraria?: boolean
    codigo?: boolean
  }

  export type cursosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descripcion" | "titulo" | "urlMiniatura" | "creadoEn" | "actualizadoEn" | "descripcionCorta" | "enVivo" | "urlCurso" | "cargaHoraria" | "codigo", ExtArgs["result"]["cursos"]>
  export type cursosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    beneficiosCursos?: boolean | cursos$beneficiosCursosArgs<ExtArgs>
    categoriasCursos?: boolean | cursos$categoriasCursosArgs<ExtArgs>
    edicionesCursos?: boolean | cursos$edicionesCursosArgs<ExtArgs>
    objetivosCursos?: boolean | cursos$objetivosCursosArgs<ExtArgs>
    requisitosCursos?: boolean | cursos$requisitosCursosArgs<ExtArgs>
    reviewsCursos?: boolean | cursos$reviewsCursosArgs<ExtArgs>
    _count?: boolean | CursosCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type cursosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type cursosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $cursosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cursos"
    objects: {
      beneficiosCursos: Prisma.$beneficiosCursosPayload<ExtArgs>[]
      categoriasCursos: Prisma.$categoriasCursosPayload<ExtArgs>[]
      edicionesCursos: Prisma.$edicionesCursosPayload<ExtArgs>[]
      objetivosCursos: Prisma.$objetivosCursosPayload<ExtArgs>[]
      requisitosCursos: Prisma.$requisitosCursosPayload<ExtArgs>[]
      reviewsCursos: Prisma.$reviewsCursosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      descripcion: string
      titulo: string
      urlMiniatura: string | null
      creadoEn: Date
      actualizadoEn: Date
      descripcionCorta: string | null
      enVivo: boolean
      urlCurso: string | null
      cargaHoraria: number
      codigo: string
    }, ExtArgs["result"]["cursos"]>
    composites: {}
  }

  type cursosGetPayload<S extends boolean | null | undefined | cursosDefaultArgs> = $Result.GetResult<Prisma.$cursosPayload, S>

  type cursosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cursosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CursosCountAggregateInputType | true
    }

  export interface cursosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cursos'], meta: { name: 'cursos' } }
    /**
     * Find zero or one Cursos that matches the filter.
     * @param {cursosFindUniqueArgs} args - Arguments to find a Cursos
     * @example
     * // Get one Cursos
     * const cursos = await prisma.cursos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cursosFindUniqueArgs>(args: SelectSubset<T, cursosFindUniqueArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cursos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cursosFindUniqueOrThrowArgs} args - Arguments to find a Cursos
     * @example
     * // Get one Cursos
     * const cursos = await prisma.cursos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cursosFindUniqueOrThrowArgs>(args: SelectSubset<T, cursosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cursosFindFirstArgs} args - Arguments to find a Cursos
     * @example
     * // Get one Cursos
     * const cursos = await prisma.cursos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cursosFindFirstArgs>(args?: SelectSubset<T, cursosFindFirstArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cursos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cursosFindFirstOrThrowArgs} args - Arguments to find a Cursos
     * @example
     * // Get one Cursos
     * const cursos = await prisma.cursos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cursosFindFirstOrThrowArgs>(args?: SelectSubset<T, cursosFindFirstOrThrowArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cursosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cursos
     * const cursos = await prisma.cursos.findMany()
     * 
     * // Get first 10 Cursos
     * const cursos = await prisma.cursos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cursosWithIdOnly = await prisma.cursos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cursosFindManyArgs>(args?: SelectSubset<T, cursosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cursos.
     * @param {cursosCreateArgs} args - Arguments to create a Cursos.
     * @example
     * // Create one Cursos
     * const Cursos = await prisma.cursos.create({
     *   data: {
     *     // ... data to create a Cursos
     *   }
     * })
     * 
     */
    create<T extends cursosCreateArgs>(args: SelectSubset<T, cursosCreateArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cursos.
     * @param {cursosCreateManyArgs} args - Arguments to create many Cursos.
     * @example
     * // Create many Cursos
     * const cursos = await prisma.cursos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cursosCreateManyArgs>(args?: SelectSubset<T, cursosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cursos and returns the data saved in the database.
     * @param {cursosCreateManyAndReturnArgs} args - Arguments to create many Cursos.
     * @example
     * // Create many Cursos
     * const cursos = await prisma.cursos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cursos and only return the `id`
     * const cursosWithIdOnly = await prisma.cursos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends cursosCreateManyAndReturnArgs>(args?: SelectSubset<T, cursosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cursos.
     * @param {cursosDeleteArgs} args - Arguments to delete one Cursos.
     * @example
     * // Delete one Cursos
     * const Cursos = await prisma.cursos.delete({
     *   where: {
     *     // ... filter to delete one Cursos
     *   }
     * })
     * 
     */
    delete<T extends cursosDeleteArgs>(args: SelectSubset<T, cursosDeleteArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cursos.
     * @param {cursosUpdateArgs} args - Arguments to update one Cursos.
     * @example
     * // Update one Cursos
     * const cursos = await prisma.cursos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cursosUpdateArgs>(args: SelectSubset<T, cursosUpdateArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cursos.
     * @param {cursosDeleteManyArgs} args - Arguments to filter Cursos to delete.
     * @example
     * // Delete a few Cursos
     * const { count } = await prisma.cursos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cursosDeleteManyArgs>(args?: SelectSubset<T, cursosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cursosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cursos
     * const cursos = await prisma.cursos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cursosUpdateManyArgs>(args: SelectSubset<T, cursosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cursos and returns the data updated in the database.
     * @param {cursosUpdateManyAndReturnArgs} args - Arguments to update many Cursos.
     * @example
     * // Update many Cursos
     * const cursos = await prisma.cursos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cursos and only return the `id`
     * const cursosWithIdOnly = await prisma.cursos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends cursosUpdateManyAndReturnArgs>(args: SelectSubset<T, cursosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cursos.
     * @param {cursosUpsertArgs} args - Arguments to update or create a Cursos.
     * @example
     * // Update or create a Cursos
     * const cursos = await prisma.cursos.upsert({
     *   create: {
     *     // ... data to create a Cursos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cursos we want to update
     *   }
     * })
     */
    upsert<T extends cursosUpsertArgs>(args: SelectSubset<T, cursosUpsertArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cursosCountArgs} args - Arguments to filter Cursos to count.
     * @example
     * // Count the number of Cursos
     * const count = await prisma.cursos.count({
     *   where: {
     *     // ... the filter for the Cursos we want to count
     *   }
     * })
    **/
    count<T extends cursosCountArgs>(
      args?: Subset<T, cursosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CursosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CursosAggregateArgs>(args: Subset<T, CursosAggregateArgs>): Prisma.PrismaPromise<GetCursosAggregateType<T>>

    /**
     * Group by Cursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cursosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cursosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cursosGroupByArgs['orderBy'] }
        : { orderBy?: cursosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cursosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCursosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cursos model
   */
  readonly fields: cursosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cursos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cursosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    beneficiosCursos<T extends cursos$beneficiosCursosArgs<ExtArgs> = {}>(args?: Subset<T, cursos$beneficiosCursosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$beneficiosCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categoriasCursos<T extends cursos$categoriasCursosArgs<ExtArgs> = {}>(args?: Subset<T, cursos$categoriasCursosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriasCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    edicionesCursos<T extends cursos$edicionesCursosArgs<ExtArgs> = {}>(args?: Subset<T, cursos$edicionesCursosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    objetivosCursos<T extends cursos$objetivosCursosArgs<ExtArgs> = {}>(args?: Subset<T, cursos$objetivosCursosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$objetivosCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requisitosCursos<T extends cursos$requisitosCursosArgs<ExtArgs> = {}>(args?: Subset<T, cursos$requisitosCursosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$requisitosCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewsCursos<T extends cursos$reviewsCursosArgs<ExtArgs> = {}>(args?: Subset<T, cursos$reviewsCursosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cursos model
   */
  interface cursosFieldRefs {
    readonly id: FieldRef<"cursos", 'String'>
    readonly descripcion: FieldRef<"cursos", 'String'>
    readonly titulo: FieldRef<"cursos", 'String'>
    readonly urlMiniatura: FieldRef<"cursos", 'String'>
    readonly creadoEn: FieldRef<"cursos", 'DateTime'>
    readonly actualizadoEn: FieldRef<"cursos", 'DateTime'>
    readonly descripcionCorta: FieldRef<"cursos", 'String'>
    readonly enVivo: FieldRef<"cursos", 'Boolean'>
    readonly urlCurso: FieldRef<"cursos", 'String'>
    readonly cargaHoraria: FieldRef<"cursos", 'Int'>
    readonly codigo: FieldRef<"cursos", 'String'>
  }
    

  // Custom InputTypes
  /**
   * cursos findUnique
   */
  export type cursosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cursos
     */
    select?: cursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cursos
     */
    omit?: cursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cursosInclude<ExtArgs> | null
    /**
     * Filter, which cursos to fetch.
     */
    where: cursosWhereUniqueInput
  }

  /**
   * cursos findUniqueOrThrow
   */
  export type cursosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cursos
     */
    select?: cursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cursos
     */
    omit?: cursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cursosInclude<ExtArgs> | null
    /**
     * Filter, which cursos to fetch.
     */
    where: cursosWhereUniqueInput
  }

  /**
   * cursos findFirst
   */
  export type cursosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cursos
     */
    select?: cursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cursos
     */
    omit?: cursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cursosInclude<ExtArgs> | null
    /**
     * Filter, which cursos to fetch.
     */
    where?: cursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cursos to fetch.
     */
    orderBy?: cursosOrderByWithRelationInput | cursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cursos.
     */
    cursor?: cursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cursos.
     */
    distinct?: CursosScalarFieldEnum | CursosScalarFieldEnum[]
  }

  /**
   * cursos findFirstOrThrow
   */
  export type cursosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cursos
     */
    select?: cursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cursos
     */
    omit?: cursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cursosInclude<ExtArgs> | null
    /**
     * Filter, which cursos to fetch.
     */
    where?: cursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cursos to fetch.
     */
    orderBy?: cursosOrderByWithRelationInput | cursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cursos.
     */
    cursor?: cursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cursos.
     */
    distinct?: CursosScalarFieldEnum | CursosScalarFieldEnum[]
  }

  /**
   * cursos findMany
   */
  export type cursosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cursos
     */
    select?: cursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cursos
     */
    omit?: cursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cursosInclude<ExtArgs> | null
    /**
     * Filter, which cursos to fetch.
     */
    where?: cursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cursos to fetch.
     */
    orderBy?: cursosOrderByWithRelationInput | cursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cursos.
     */
    cursor?: cursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cursos.
     */
    skip?: number
    distinct?: CursosScalarFieldEnum | CursosScalarFieldEnum[]
  }

  /**
   * cursos create
   */
  export type cursosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cursos
     */
    select?: cursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cursos
     */
    omit?: cursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cursosInclude<ExtArgs> | null
    /**
     * The data needed to create a cursos.
     */
    data: XOR<cursosCreateInput, cursosUncheckedCreateInput>
  }

  /**
   * cursos createMany
   */
  export type cursosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cursos.
     */
    data: cursosCreateManyInput | cursosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cursos createManyAndReturn
   */
  export type cursosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cursos
     */
    select?: cursosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cursos
     */
    omit?: cursosOmit<ExtArgs> | null
    /**
     * The data used to create many cursos.
     */
    data: cursosCreateManyInput | cursosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cursos update
   */
  export type cursosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cursos
     */
    select?: cursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cursos
     */
    omit?: cursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cursosInclude<ExtArgs> | null
    /**
     * The data needed to update a cursos.
     */
    data: XOR<cursosUpdateInput, cursosUncheckedUpdateInput>
    /**
     * Choose, which cursos to update.
     */
    where: cursosWhereUniqueInput
  }

  /**
   * cursos updateMany
   */
  export type cursosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cursos.
     */
    data: XOR<cursosUpdateManyMutationInput, cursosUncheckedUpdateManyInput>
    /**
     * Filter which cursos to update
     */
    where?: cursosWhereInput
    /**
     * Limit how many cursos to update.
     */
    limit?: number
  }

  /**
   * cursos updateManyAndReturn
   */
  export type cursosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cursos
     */
    select?: cursosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cursos
     */
    omit?: cursosOmit<ExtArgs> | null
    /**
     * The data used to update cursos.
     */
    data: XOR<cursosUpdateManyMutationInput, cursosUncheckedUpdateManyInput>
    /**
     * Filter which cursos to update
     */
    where?: cursosWhereInput
    /**
     * Limit how many cursos to update.
     */
    limit?: number
  }

  /**
   * cursos upsert
   */
  export type cursosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cursos
     */
    select?: cursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cursos
     */
    omit?: cursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cursosInclude<ExtArgs> | null
    /**
     * The filter to search for the cursos to update in case it exists.
     */
    where: cursosWhereUniqueInput
    /**
     * In case the cursos found by the `where` argument doesn't exist, create a new cursos with this data.
     */
    create: XOR<cursosCreateInput, cursosUncheckedCreateInput>
    /**
     * In case the cursos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cursosUpdateInput, cursosUncheckedUpdateInput>
  }

  /**
   * cursos delete
   */
  export type cursosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cursos
     */
    select?: cursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cursos
     */
    omit?: cursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cursosInclude<ExtArgs> | null
    /**
     * Filter which cursos to delete.
     */
    where: cursosWhereUniqueInput
  }

  /**
   * cursos deleteMany
   */
  export type cursosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cursos to delete
     */
    where?: cursosWhereInput
    /**
     * Limit how many cursos to delete.
     */
    limit?: number
  }

  /**
   * cursos.beneficiosCursos
   */
  export type cursos$beneficiosCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the beneficiosCursos
     */
    select?: beneficiosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the beneficiosCursos
     */
    omit?: beneficiosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: beneficiosCursosInclude<ExtArgs> | null
    where?: beneficiosCursosWhereInput
    orderBy?: beneficiosCursosOrderByWithRelationInput | beneficiosCursosOrderByWithRelationInput[]
    cursor?: beneficiosCursosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BeneficiosCursosScalarFieldEnum | BeneficiosCursosScalarFieldEnum[]
  }

  /**
   * cursos.categoriasCursos
   */
  export type cursos$categoriasCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriasCursos
     */
    select?: categoriasCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categoriasCursos
     */
    omit?: categoriasCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriasCursosInclude<ExtArgs> | null
    where?: categoriasCursosWhereInput
    orderBy?: categoriasCursosOrderByWithRelationInput | categoriasCursosOrderByWithRelationInput[]
    cursor?: categoriasCursosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoriasCursosScalarFieldEnum | CategoriasCursosScalarFieldEnum[]
  }

  /**
   * cursos.edicionesCursos
   */
  export type cursos$edicionesCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosInclude<ExtArgs> | null
    where?: edicionesCursosWhereInput
    orderBy?: edicionesCursosOrderByWithRelationInput | edicionesCursosOrderByWithRelationInput[]
    cursor?: edicionesCursosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EdicionesCursosScalarFieldEnum | EdicionesCursosScalarFieldEnum[]
  }

  /**
   * cursos.objetivosCursos
   */
  export type cursos$objetivosCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosInclude<ExtArgs> | null
    where?: objetivosCursosWhereInput
    orderBy?: objetivosCursosOrderByWithRelationInput | objetivosCursosOrderByWithRelationInput[]
    cursor?: objetivosCursosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObjetivosCursosScalarFieldEnum | ObjetivosCursosScalarFieldEnum[]
  }

  /**
   * cursos.requisitosCursos
   */
  export type cursos$requisitosCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosInclude<ExtArgs> | null
    where?: requisitosCursosWhereInput
    orderBy?: requisitosCursosOrderByWithRelationInput | requisitosCursosOrderByWithRelationInput[]
    cursor?: requisitosCursosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequisitosCursosScalarFieldEnum | RequisitosCursosScalarFieldEnum[]
  }

  /**
   * cursos.reviewsCursos
   */
  export type cursos$reviewsCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosInclude<ExtArgs> | null
    where?: reviewsCursosWhereInput
    orderBy?: reviewsCursosOrderByWithRelationInput | reviewsCursosOrderByWithRelationInput[]
    cursor?: reviewsCursosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewsCursosScalarFieldEnum | ReviewsCursosScalarFieldEnum[]
  }

  /**
   * cursos without action
   */
  export type cursosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cursos
     */
    select?: cursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cursos
     */
    omit?: cursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cursosInclude<ExtArgs> | null
  }


  /**
   * Model docente
   */

  export type AggregateDocente = {
    _count: DocenteCountAggregateOutputType | null
    _avg: DocenteAvgAggregateOutputType | null
    _sum: DocenteSumAggregateOutputType | null
    _min: DocenteMinAggregateOutputType | null
    _max: DocenteMaxAggregateOutputType | null
  }

  export type DocenteAvgAggregateOutputType = {
    experiencia: number | null
  }

  export type DocenteSumAggregateOutputType = {
    experiencia: number | null
  }

  export type DocenteMinAggregateOutputType = {
    id: string | null
    nombre_completo: string | null
    celular: string | null
    especialidad: string | null
    experiencia: number | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    usuarioId: string | null
    pais: string | null
  }

  export type DocenteMaxAggregateOutputType = {
    id: string | null
    nombre_completo: string | null
    celular: string | null
    especialidad: string | null
    experiencia: number | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    usuarioId: string | null
    pais: string | null
  }

  export type DocenteCountAggregateOutputType = {
    id: number
    nombre_completo: number
    celular: number
    especialidad: number
    experiencia: number
    creadoEn: number
    actualizadoEn: number
    usuarioId: number
    pais: number
    _all: number
  }


  export type DocenteAvgAggregateInputType = {
    experiencia?: true
  }

  export type DocenteSumAggregateInputType = {
    experiencia?: true
  }

  export type DocenteMinAggregateInputType = {
    id?: true
    nombre_completo?: true
    celular?: true
    especialidad?: true
    experiencia?: true
    creadoEn?: true
    actualizadoEn?: true
    usuarioId?: true
    pais?: true
  }

  export type DocenteMaxAggregateInputType = {
    id?: true
    nombre_completo?: true
    celular?: true
    especialidad?: true
    experiencia?: true
    creadoEn?: true
    actualizadoEn?: true
    usuarioId?: true
    pais?: true
  }

  export type DocenteCountAggregateInputType = {
    id?: true
    nombre_completo?: true
    celular?: true
    especialidad?: true
    experiencia?: true
    creadoEn?: true
    actualizadoEn?: true
    usuarioId?: true
    pais?: true
    _all?: true
  }

  export type DocenteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which docente to aggregate.
     */
    where?: docenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of docentes to fetch.
     */
    orderBy?: docenteOrderByWithRelationInput | docenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: docenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` docentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` docentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned docentes
    **/
    _count?: true | DocenteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocenteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocenteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocenteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocenteMaxAggregateInputType
  }

  export type GetDocenteAggregateType<T extends DocenteAggregateArgs> = {
        [P in keyof T & keyof AggregateDocente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocente[P]>
      : GetScalarType<T[P], AggregateDocente[P]>
  }




  export type docenteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: docenteWhereInput
    orderBy?: docenteOrderByWithAggregationInput | docenteOrderByWithAggregationInput[]
    by: DocenteScalarFieldEnum[] | DocenteScalarFieldEnum
    having?: docenteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocenteCountAggregateInputType | true
    _avg?: DocenteAvgAggregateInputType
    _sum?: DocenteSumAggregateInputType
    _min?: DocenteMinAggregateInputType
    _max?: DocenteMaxAggregateInputType
  }

  export type DocenteGroupByOutputType = {
    id: string
    nombre_completo: string
    celular: string | null
    especialidad: string
    experiencia: number
    creadoEn: Date
    actualizadoEn: Date
    usuarioId: string
    pais: string
    _count: DocenteCountAggregateOutputType | null
    _avg: DocenteAvgAggregateOutputType | null
    _sum: DocenteSumAggregateOutputType | null
    _min: DocenteMinAggregateOutputType | null
    _max: DocenteMaxAggregateOutputType | null
  }

  type GetDocenteGroupByPayload<T extends docenteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocenteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocenteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocenteGroupByOutputType[P]>
            : GetScalarType<T[P], DocenteGroupByOutputType[P]>
        }
      >
    >


  export type docenteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_completo?: boolean
    celular?: boolean
    especialidad?: boolean
    experiencia?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    usuarioId?: boolean
    pais?: boolean
    usuariosAdministradores?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
    edicionesCursos?: boolean | docente$edicionesCursosArgs<ExtArgs>
    pagosDocentes?: boolean | docente$pagosDocentesArgs<ExtArgs>
    _count?: boolean | DocenteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["docente"]>

  export type docenteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_completo?: boolean
    celular?: boolean
    especialidad?: boolean
    experiencia?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    usuarioId?: boolean
    pais?: boolean
    usuariosAdministradores?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["docente"]>

  export type docenteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre_completo?: boolean
    celular?: boolean
    especialidad?: boolean
    experiencia?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    usuarioId?: boolean
    pais?: boolean
    usuariosAdministradores?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["docente"]>

  export type docenteSelectScalar = {
    id?: boolean
    nombre_completo?: boolean
    celular?: boolean
    especialidad?: boolean
    experiencia?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    usuarioId?: boolean
    pais?: boolean
  }

  export type docenteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre_completo" | "celular" | "especialidad" | "experiencia" | "creadoEn" | "actualizadoEn" | "usuarioId" | "pais", ExtArgs["result"]["docente"]>
  export type docenteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuariosAdministradores?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
    edicionesCursos?: boolean | docente$edicionesCursosArgs<ExtArgs>
    pagosDocentes?: boolean | docente$pagosDocentesArgs<ExtArgs>
    _count?: boolean | DocenteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type docenteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuariosAdministradores?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }
  export type docenteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuariosAdministradores?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }

  export type $docentePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "docente"
    objects: {
      usuariosAdministradores: Prisma.$usuariosAdministradoresPayload<ExtArgs>
      edicionesCursos: Prisma.$edicionesCursosPayload<ExtArgs>[]
      pagosDocentes: Prisma.$pagosDocentesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre_completo: string
      celular: string | null
      especialidad: string
      experiencia: number
      creadoEn: Date
      actualizadoEn: Date
      usuarioId: string
      pais: string
    }, ExtArgs["result"]["docente"]>
    composites: {}
  }

  type docenteGetPayload<S extends boolean | null | undefined | docenteDefaultArgs> = $Result.GetResult<Prisma.$docentePayload, S>

  type docenteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<docenteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocenteCountAggregateInputType | true
    }

  export interface docenteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['docente'], meta: { name: 'docente' } }
    /**
     * Find zero or one Docente that matches the filter.
     * @param {docenteFindUniqueArgs} args - Arguments to find a Docente
     * @example
     * // Get one Docente
     * const docente = await prisma.docente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends docenteFindUniqueArgs>(args: SelectSubset<T, docenteFindUniqueArgs<ExtArgs>>): Prisma__docenteClient<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Docente that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {docenteFindUniqueOrThrowArgs} args - Arguments to find a Docente
     * @example
     * // Get one Docente
     * const docente = await prisma.docente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends docenteFindUniqueOrThrowArgs>(args: SelectSubset<T, docenteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__docenteClient<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Docente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {docenteFindFirstArgs} args - Arguments to find a Docente
     * @example
     * // Get one Docente
     * const docente = await prisma.docente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends docenteFindFirstArgs>(args?: SelectSubset<T, docenteFindFirstArgs<ExtArgs>>): Prisma__docenteClient<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Docente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {docenteFindFirstOrThrowArgs} args - Arguments to find a Docente
     * @example
     * // Get one Docente
     * const docente = await prisma.docente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends docenteFindFirstOrThrowArgs>(args?: SelectSubset<T, docenteFindFirstOrThrowArgs<ExtArgs>>): Prisma__docenteClient<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Docentes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {docenteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Docentes
     * const docentes = await prisma.docente.findMany()
     * 
     * // Get first 10 Docentes
     * const docentes = await prisma.docente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const docenteWithIdOnly = await prisma.docente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends docenteFindManyArgs>(args?: SelectSubset<T, docenteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Docente.
     * @param {docenteCreateArgs} args - Arguments to create a Docente.
     * @example
     * // Create one Docente
     * const Docente = await prisma.docente.create({
     *   data: {
     *     // ... data to create a Docente
     *   }
     * })
     * 
     */
    create<T extends docenteCreateArgs>(args: SelectSubset<T, docenteCreateArgs<ExtArgs>>): Prisma__docenteClient<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Docentes.
     * @param {docenteCreateManyArgs} args - Arguments to create many Docentes.
     * @example
     * // Create many Docentes
     * const docente = await prisma.docente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends docenteCreateManyArgs>(args?: SelectSubset<T, docenteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Docentes and returns the data saved in the database.
     * @param {docenteCreateManyAndReturnArgs} args - Arguments to create many Docentes.
     * @example
     * // Create many Docentes
     * const docente = await prisma.docente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Docentes and only return the `id`
     * const docenteWithIdOnly = await prisma.docente.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends docenteCreateManyAndReturnArgs>(args?: SelectSubset<T, docenteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Docente.
     * @param {docenteDeleteArgs} args - Arguments to delete one Docente.
     * @example
     * // Delete one Docente
     * const Docente = await prisma.docente.delete({
     *   where: {
     *     // ... filter to delete one Docente
     *   }
     * })
     * 
     */
    delete<T extends docenteDeleteArgs>(args: SelectSubset<T, docenteDeleteArgs<ExtArgs>>): Prisma__docenteClient<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Docente.
     * @param {docenteUpdateArgs} args - Arguments to update one Docente.
     * @example
     * // Update one Docente
     * const docente = await prisma.docente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends docenteUpdateArgs>(args: SelectSubset<T, docenteUpdateArgs<ExtArgs>>): Prisma__docenteClient<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Docentes.
     * @param {docenteDeleteManyArgs} args - Arguments to filter Docentes to delete.
     * @example
     * // Delete a few Docentes
     * const { count } = await prisma.docente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends docenteDeleteManyArgs>(args?: SelectSubset<T, docenteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Docentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {docenteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Docentes
     * const docente = await prisma.docente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends docenteUpdateManyArgs>(args: SelectSubset<T, docenteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Docentes and returns the data updated in the database.
     * @param {docenteUpdateManyAndReturnArgs} args - Arguments to update many Docentes.
     * @example
     * // Update many Docentes
     * const docente = await prisma.docente.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Docentes and only return the `id`
     * const docenteWithIdOnly = await prisma.docente.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends docenteUpdateManyAndReturnArgs>(args: SelectSubset<T, docenteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Docente.
     * @param {docenteUpsertArgs} args - Arguments to update or create a Docente.
     * @example
     * // Update or create a Docente
     * const docente = await prisma.docente.upsert({
     *   create: {
     *     // ... data to create a Docente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Docente we want to update
     *   }
     * })
     */
    upsert<T extends docenteUpsertArgs>(args: SelectSubset<T, docenteUpsertArgs<ExtArgs>>): Prisma__docenteClient<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Docentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {docenteCountArgs} args - Arguments to filter Docentes to count.
     * @example
     * // Count the number of Docentes
     * const count = await prisma.docente.count({
     *   where: {
     *     // ... the filter for the Docentes we want to count
     *   }
     * })
    **/
    count<T extends docenteCountArgs>(
      args?: Subset<T, docenteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocenteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Docente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocenteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocenteAggregateArgs>(args: Subset<T, DocenteAggregateArgs>): Prisma.PrismaPromise<GetDocenteAggregateType<T>>

    /**
     * Group by Docente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {docenteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends docenteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: docenteGroupByArgs['orderBy'] }
        : { orderBy?: docenteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, docenteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocenteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the docente model
   */
  readonly fields: docenteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for docente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__docenteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuariosAdministradores<T extends usuariosAdministradoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usuariosAdministradoresDefaultArgs<ExtArgs>>): Prisma__usuariosAdministradoresClient<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    edicionesCursos<T extends docente$edicionesCursosArgs<ExtArgs> = {}>(args?: Subset<T, docente$edicionesCursosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pagosDocentes<T extends docente$pagosDocentesArgs<ExtArgs> = {}>(args?: Subset<T, docente$pagosDocentesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pagosDocentesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the docente model
   */
  interface docenteFieldRefs {
    readonly id: FieldRef<"docente", 'String'>
    readonly nombre_completo: FieldRef<"docente", 'String'>
    readonly celular: FieldRef<"docente", 'String'>
    readonly especialidad: FieldRef<"docente", 'String'>
    readonly experiencia: FieldRef<"docente", 'Int'>
    readonly creadoEn: FieldRef<"docente", 'DateTime'>
    readonly actualizadoEn: FieldRef<"docente", 'DateTime'>
    readonly usuarioId: FieldRef<"docente", 'String'>
    readonly pais: FieldRef<"docente", 'String'>
  }
    

  // Custom InputTypes
  /**
   * docente findUnique
   */
  export type docenteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteInclude<ExtArgs> | null
    /**
     * Filter, which docente to fetch.
     */
    where: docenteWhereUniqueInput
  }

  /**
   * docente findUniqueOrThrow
   */
  export type docenteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteInclude<ExtArgs> | null
    /**
     * Filter, which docente to fetch.
     */
    where: docenteWhereUniqueInput
  }

  /**
   * docente findFirst
   */
  export type docenteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteInclude<ExtArgs> | null
    /**
     * Filter, which docente to fetch.
     */
    where?: docenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of docentes to fetch.
     */
    orderBy?: docenteOrderByWithRelationInput | docenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for docentes.
     */
    cursor?: docenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` docentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` docentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of docentes.
     */
    distinct?: DocenteScalarFieldEnum | DocenteScalarFieldEnum[]
  }

  /**
   * docente findFirstOrThrow
   */
  export type docenteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteInclude<ExtArgs> | null
    /**
     * Filter, which docente to fetch.
     */
    where?: docenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of docentes to fetch.
     */
    orderBy?: docenteOrderByWithRelationInput | docenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for docentes.
     */
    cursor?: docenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` docentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` docentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of docentes.
     */
    distinct?: DocenteScalarFieldEnum | DocenteScalarFieldEnum[]
  }

  /**
   * docente findMany
   */
  export type docenteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteInclude<ExtArgs> | null
    /**
     * Filter, which docentes to fetch.
     */
    where?: docenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of docentes to fetch.
     */
    orderBy?: docenteOrderByWithRelationInput | docenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing docentes.
     */
    cursor?: docenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` docentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` docentes.
     */
    skip?: number
    distinct?: DocenteScalarFieldEnum | DocenteScalarFieldEnum[]
  }

  /**
   * docente create
   */
  export type docenteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteInclude<ExtArgs> | null
    /**
     * The data needed to create a docente.
     */
    data: XOR<docenteCreateInput, docenteUncheckedCreateInput>
  }

  /**
   * docente createMany
   */
  export type docenteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many docentes.
     */
    data: docenteCreateManyInput | docenteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * docente createManyAndReturn
   */
  export type docenteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * The data used to create many docentes.
     */
    data: docenteCreateManyInput | docenteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * docente update
   */
  export type docenteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteInclude<ExtArgs> | null
    /**
     * The data needed to update a docente.
     */
    data: XOR<docenteUpdateInput, docenteUncheckedUpdateInput>
    /**
     * Choose, which docente to update.
     */
    where: docenteWhereUniqueInput
  }

  /**
   * docente updateMany
   */
  export type docenteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update docentes.
     */
    data: XOR<docenteUpdateManyMutationInput, docenteUncheckedUpdateManyInput>
    /**
     * Filter which docentes to update
     */
    where?: docenteWhereInput
    /**
     * Limit how many docentes to update.
     */
    limit?: number
  }

  /**
   * docente updateManyAndReturn
   */
  export type docenteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * The data used to update docentes.
     */
    data: XOR<docenteUpdateManyMutationInput, docenteUncheckedUpdateManyInput>
    /**
     * Filter which docentes to update
     */
    where?: docenteWhereInput
    /**
     * Limit how many docentes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * docente upsert
   */
  export type docenteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteInclude<ExtArgs> | null
    /**
     * The filter to search for the docente to update in case it exists.
     */
    where: docenteWhereUniqueInput
    /**
     * In case the docente found by the `where` argument doesn't exist, create a new docente with this data.
     */
    create: XOR<docenteCreateInput, docenteUncheckedCreateInput>
    /**
     * In case the docente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<docenteUpdateInput, docenteUncheckedUpdateInput>
  }

  /**
   * docente delete
   */
  export type docenteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteInclude<ExtArgs> | null
    /**
     * Filter which docente to delete.
     */
    where: docenteWhereUniqueInput
  }

  /**
   * docente deleteMany
   */
  export type docenteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which docentes to delete
     */
    where?: docenteWhereInput
    /**
     * Limit how many docentes to delete.
     */
    limit?: number
  }

  /**
   * docente.edicionesCursos
   */
  export type docente$edicionesCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosInclude<ExtArgs> | null
    where?: edicionesCursosWhereInput
    orderBy?: edicionesCursosOrderByWithRelationInput | edicionesCursosOrderByWithRelationInput[]
    cursor?: edicionesCursosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EdicionesCursosScalarFieldEnum | EdicionesCursosScalarFieldEnum[]
  }

  /**
   * docente.pagosDocentes
   */
  export type docente$pagosDocentesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagosDocentes
     */
    select?: pagosDocentesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pagosDocentes
     */
    omit?: pagosDocentesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagosDocentesInclude<ExtArgs> | null
    where?: pagosDocentesWhereInput
    orderBy?: pagosDocentesOrderByWithRelationInput | pagosDocentesOrderByWithRelationInput[]
    cursor?: pagosDocentesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagosDocentesScalarFieldEnum | PagosDocentesScalarFieldEnum[]
  }

  /**
   * docente without action
   */
  export type docenteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteInclude<ExtArgs> | null
  }


  /**
   * Model edicionesCursos
   */

  export type AggregateEdicionesCursos = {
    _count: EdicionesCursosCountAggregateOutputType | null
    _avg: EdicionesCursosAvgAggregateOutputType | null
    _sum: EdicionesCursosSumAggregateOutputType | null
    _min: EdicionesCursosMinAggregateOutputType | null
    _max: EdicionesCursosMaxAggregateOutputType | null
  }

  export type EdicionesCursosAvgAggregateOutputType = {
    notaMaxima: number | null
    notaMinima: number | null
  }

  export type EdicionesCursosSumAggregateOutputType = {
    notaMaxima: number | null
    notaMinima: number | null
  }

  export type EdicionesCursosMinAggregateOutputType = {
    id: string | null
    codigo: string | null
    cursoId: string | null
    descripcion: string | null
    estado: $Enums.EdicionEstado | null
    fechaFin: Date | null
    fechaInicio: Date | null
    notaMaxima: number | null
    notaMinima: number | null
    urlWhatsapp: string | null
    vigente: boolean | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    docenteId: string | null
  }

  export type EdicionesCursosMaxAggregateOutputType = {
    id: string | null
    codigo: string | null
    cursoId: string | null
    descripcion: string | null
    estado: $Enums.EdicionEstado | null
    fechaFin: Date | null
    fechaInicio: Date | null
    notaMaxima: number | null
    notaMinima: number | null
    urlWhatsapp: string | null
    vigente: boolean | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    docenteId: string | null
  }

  export type EdicionesCursosCountAggregateOutputType = {
    id: number
    codigo: number
    cursoId: number
    descripcion: number
    estado: number
    fechaFin: number
    fechaInicio: number
    notaMaxima: number
    notaMinima: number
    urlWhatsapp: number
    vigente: number
    creadoEn: number
    actualizadoEn: number
    docenteId: number
    _all: number
  }


  export type EdicionesCursosAvgAggregateInputType = {
    notaMaxima?: true
    notaMinima?: true
  }

  export type EdicionesCursosSumAggregateInputType = {
    notaMaxima?: true
    notaMinima?: true
  }

  export type EdicionesCursosMinAggregateInputType = {
    id?: true
    codigo?: true
    cursoId?: true
    descripcion?: true
    estado?: true
    fechaFin?: true
    fechaInicio?: true
    notaMaxima?: true
    notaMinima?: true
    urlWhatsapp?: true
    vigente?: true
    creadoEn?: true
    actualizadoEn?: true
    docenteId?: true
  }

  export type EdicionesCursosMaxAggregateInputType = {
    id?: true
    codigo?: true
    cursoId?: true
    descripcion?: true
    estado?: true
    fechaFin?: true
    fechaInicio?: true
    notaMaxima?: true
    notaMinima?: true
    urlWhatsapp?: true
    vigente?: true
    creadoEn?: true
    actualizadoEn?: true
    docenteId?: true
  }

  export type EdicionesCursosCountAggregateInputType = {
    id?: true
    codigo?: true
    cursoId?: true
    descripcion?: true
    estado?: true
    fechaFin?: true
    fechaInicio?: true
    notaMaxima?: true
    notaMinima?: true
    urlWhatsapp?: true
    vigente?: true
    creadoEn?: true
    actualizadoEn?: true
    docenteId?: true
    _all?: true
  }

  export type EdicionesCursosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which edicionesCursos to aggregate.
     */
    where?: edicionesCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edicionesCursos to fetch.
     */
    orderBy?: edicionesCursosOrderByWithRelationInput | edicionesCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: edicionesCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edicionesCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edicionesCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned edicionesCursos
    **/
    _count?: true | EdicionesCursosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EdicionesCursosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EdicionesCursosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EdicionesCursosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EdicionesCursosMaxAggregateInputType
  }

  export type GetEdicionesCursosAggregateType<T extends EdicionesCursosAggregateArgs> = {
        [P in keyof T & keyof AggregateEdicionesCursos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEdicionesCursos[P]>
      : GetScalarType<T[P], AggregateEdicionesCursos[P]>
  }




  export type edicionesCursosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: edicionesCursosWhereInput
    orderBy?: edicionesCursosOrderByWithAggregationInput | edicionesCursosOrderByWithAggregationInput[]
    by: EdicionesCursosScalarFieldEnum[] | EdicionesCursosScalarFieldEnum
    having?: edicionesCursosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EdicionesCursosCountAggregateInputType | true
    _avg?: EdicionesCursosAvgAggregateInputType
    _sum?: EdicionesCursosSumAggregateInputType
    _min?: EdicionesCursosMinAggregateInputType
    _max?: EdicionesCursosMaxAggregateInputType
  }

  export type EdicionesCursosGroupByOutputType = {
    id: string
    codigo: string
    cursoId: string
    descripcion: string | null
    estado: $Enums.EdicionEstado
    fechaFin: Date
    fechaInicio: Date
    notaMaxima: number
    notaMinima: number
    urlWhatsapp: string | null
    vigente: boolean
    creadoEn: Date
    actualizadoEn: Date
    docenteId: string | null
    _count: EdicionesCursosCountAggregateOutputType | null
    _avg: EdicionesCursosAvgAggregateOutputType | null
    _sum: EdicionesCursosSumAggregateOutputType | null
    _min: EdicionesCursosMinAggregateOutputType | null
    _max: EdicionesCursosMaxAggregateOutputType | null
  }

  type GetEdicionesCursosGroupByPayload<T extends edicionesCursosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EdicionesCursosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EdicionesCursosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EdicionesCursosGroupByOutputType[P]>
            : GetScalarType<T[P], EdicionesCursosGroupByOutputType[P]>
        }
      >
    >


  export type edicionesCursosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    cursoId?: boolean
    descripcion?: boolean
    estado?: boolean
    fechaFin?: boolean
    fechaInicio?: boolean
    notaMaxima?: boolean
    notaMinima?: boolean
    urlWhatsapp?: boolean
    vigente?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    docenteId?: boolean
    certificados?: boolean | edicionesCursos$certificadosArgs<ExtArgs>
    clases?: boolean | edicionesCursos$clasesArgs<ExtArgs>
    compras?: boolean | edicionesCursos$comprasArgs<ExtArgs>
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
    docente?: boolean | edicionesCursos$docenteArgs<ExtArgs>
    examenes?: boolean | edicionesCursos$examenesArgs<ExtArgs>
    inscripciones?: boolean | edicionesCursos$inscripcionesArgs<ExtArgs>
    pagosDocentes?: boolean | edicionesCursos$pagosDocentesArgs<ExtArgs>
    preciosCursos?: boolean | edicionesCursos$preciosCursosArgs<ExtArgs>
    _count?: boolean | EdicionesCursosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["edicionesCursos"]>

  export type edicionesCursosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    cursoId?: boolean
    descripcion?: boolean
    estado?: boolean
    fechaFin?: boolean
    fechaInicio?: boolean
    notaMaxima?: boolean
    notaMinima?: boolean
    urlWhatsapp?: boolean
    vigente?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    docenteId?: boolean
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
    docente?: boolean | edicionesCursos$docenteArgs<ExtArgs>
  }, ExtArgs["result"]["edicionesCursos"]>

  export type edicionesCursosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    cursoId?: boolean
    descripcion?: boolean
    estado?: boolean
    fechaFin?: boolean
    fechaInicio?: boolean
    notaMaxima?: boolean
    notaMinima?: boolean
    urlWhatsapp?: boolean
    vigente?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    docenteId?: boolean
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
    docente?: boolean | edicionesCursos$docenteArgs<ExtArgs>
  }, ExtArgs["result"]["edicionesCursos"]>

  export type edicionesCursosSelectScalar = {
    id?: boolean
    codigo?: boolean
    cursoId?: boolean
    descripcion?: boolean
    estado?: boolean
    fechaFin?: boolean
    fechaInicio?: boolean
    notaMaxima?: boolean
    notaMinima?: boolean
    urlWhatsapp?: boolean
    vigente?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    docenteId?: boolean
  }

  export type edicionesCursosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "codigo" | "cursoId" | "descripcion" | "estado" | "fechaFin" | "fechaInicio" | "notaMaxima" | "notaMinima" | "urlWhatsapp" | "vigente" | "creadoEn" | "actualizadoEn" | "docenteId", ExtArgs["result"]["edicionesCursos"]>
  export type edicionesCursosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certificados?: boolean | edicionesCursos$certificadosArgs<ExtArgs>
    clases?: boolean | edicionesCursos$clasesArgs<ExtArgs>
    compras?: boolean | edicionesCursos$comprasArgs<ExtArgs>
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
    docente?: boolean | edicionesCursos$docenteArgs<ExtArgs>
    examenes?: boolean | edicionesCursos$examenesArgs<ExtArgs>
    inscripciones?: boolean | edicionesCursos$inscripcionesArgs<ExtArgs>
    pagosDocentes?: boolean | edicionesCursos$pagosDocentesArgs<ExtArgs>
    preciosCursos?: boolean | edicionesCursos$preciosCursosArgs<ExtArgs>
    _count?: boolean | EdicionesCursosCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type edicionesCursosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
    docente?: boolean | edicionesCursos$docenteArgs<ExtArgs>
  }
  export type edicionesCursosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
    docente?: boolean | edicionesCursos$docenteArgs<ExtArgs>
  }

  export type $edicionesCursosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "edicionesCursos"
    objects: {
      certificados: Prisma.$certificadosPayload<ExtArgs>[]
      clases: Prisma.$clasesPayload<ExtArgs>[]
      compras: Prisma.$comprasPayload<ExtArgs>[]
      cursos: Prisma.$cursosPayload<ExtArgs>
      docente: Prisma.$docentePayload<ExtArgs> | null
      examenes: Prisma.$examenesPayload<ExtArgs>[]
      inscripciones: Prisma.$inscripcionesPayload<ExtArgs>[]
      pagosDocentes: Prisma.$pagosDocentesPayload<ExtArgs> | null
      preciosCursos: Prisma.$preciosCursosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      codigo: string
      cursoId: string
      descripcion: string | null
      estado: $Enums.EdicionEstado
      fechaFin: Date
      fechaInicio: Date
      notaMaxima: number
      notaMinima: number
      urlWhatsapp: string | null
      vigente: boolean
      creadoEn: Date
      actualizadoEn: Date
      docenteId: string | null
    }, ExtArgs["result"]["edicionesCursos"]>
    composites: {}
  }

  type edicionesCursosGetPayload<S extends boolean | null | undefined | edicionesCursosDefaultArgs> = $Result.GetResult<Prisma.$edicionesCursosPayload, S>

  type edicionesCursosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<edicionesCursosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EdicionesCursosCountAggregateInputType | true
    }

  export interface edicionesCursosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['edicionesCursos'], meta: { name: 'edicionesCursos' } }
    /**
     * Find zero or one EdicionesCursos that matches the filter.
     * @param {edicionesCursosFindUniqueArgs} args - Arguments to find a EdicionesCursos
     * @example
     * // Get one EdicionesCursos
     * const edicionesCursos = await prisma.edicionesCursos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends edicionesCursosFindUniqueArgs>(args: SelectSubset<T, edicionesCursosFindUniqueArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EdicionesCursos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {edicionesCursosFindUniqueOrThrowArgs} args - Arguments to find a EdicionesCursos
     * @example
     * // Get one EdicionesCursos
     * const edicionesCursos = await prisma.edicionesCursos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends edicionesCursosFindUniqueOrThrowArgs>(args: SelectSubset<T, edicionesCursosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EdicionesCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edicionesCursosFindFirstArgs} args - Arguments to find a EdicionesCursos
     * @example
     * // Get one EdicionesCursos
     * const edicionesCursos = await prisma.edicionesCursos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends edicionesCursosFindFirstArgs>(args?: SelectSubset<T, edicionesCursosFindFirstArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EdicionesCursos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edicionesCursosFindFirstOrThrowArgs} args - Arguments to find a EdicionesCursos
     * @example
     * // Get one EdicionesCursos
     * const edicionesCursos = await prisma.edicionesCursos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends edicionesCursosFindFirstOrThrowArgs>(args?: SelectSubset<T, edicionesCursosFindFirstOrThrowArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EdicionesCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edicionesCursosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EdicionesCursos
     * const edicionesCursos = await prisma.edicionesCursos.findMany()
     * 
     * // Get first 10 EdicionesCursos
     * const edicionesCursos = await prisma.edicionesCursos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const edicionesCursosWithIdOnly = await prisma.edicionesCursos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends edicionesCursosFindManyArgs>(args?: SelectSubset<T, edicionesCursosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EdicionesCursos.
     * @param {edicionesCursosCreateArgs} args - Arguments to create a EdicionesCursos.
     * @example
     * // Create one EdicionesCursos
     * const EdicionesCursos = await prisma.edicionesCursos.create({
     *   data: {
     *     // ... data to create a EdicionesCursos
     *   }
     * })
     * 
     */
    create<T extends edicionesCursosCreateArgs>(args: SelectSubset<T, edicionesCursosCreateArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EdicionesCursos.
     * @param {edicionesCursosCreateManyArgs} args - Arguments to create many EdicionesCursos.
     * @example
     * // Create many EdicionesCursos
     * const edicionesCursos = await prisma.edicionesCursos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends edicionesCursosCreateManyArgs>(args?: SelectSubset<T, edicionesCursosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EdicionesCursos and returns the data saved in the database.
     * @param {edicionesCursosCreateManyAndReturnArgs} args - Arguments to create many EdicionesCursos.
     * @example
     * // Create many EdicionesCursos
     * const edicionesCursos = await prisma.edicionesCursos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EdicionesCursos and only return the `id`
     * const edicionesCursosWithIdOnly = await prisma.edicionesCursos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends edicionesCursosCreateManyAndReturnArgs>(args?: SelectSubset<T, edicionesCursosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EdicionesCursos.
     * @param {edicionesCursosDeleteArgs} args - Arguments to delete one EdicionesCursos.
     * @example
     * // Delete one EdicionesCursos
     * const EdicionesCursos = await prisma.edicionesCursos.delete({
     *   where: {
     *     // ... filter to delete one EdicionesCursos
     *   }
     * })
     * 
     */
    delete<T extends edicionesCursosDeleteArgs>(args: SelectSubset<T, edicionesCursosDeleteArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EdicionesCursos.
     * @param {edicionesCursosUpdateArgs} args - Arguments to update one EdicionesCursos.
     * @example
     * // Update one EdicionesCursos
     * const edicionesCursos = await prisma.edicionesCursos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends edicionesCursosUpdateArgs>(args: SelectSubset<T, edicionesCursosUpdateArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EdicionesCursos.
     * @param {edicionesCursosDeleteManyArgs} args - Arguments to filter EdicionesCursos to delete.
     * @example
     * // Delete a few EdicionesCursos
     * const { count } = await prisma.edicionesCursos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends edicionesCursosDeleteManyArgs>(args?: SelectSubset<T, edicionesCursosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EdicionesCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edicionesCursosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EdicionesCursos
     * const edicionesCursos = await prisma.edicionesCursos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends edicionesCursosUpdateManyArgs>(args: SelectSubset<T, edicionesCursosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EdicionesCursos and returns the data updated in the database.
     * @param {edicionesCursosUpdateManyAndReturnArgs} args - Arguments to update many EdicionesCursos.
     * @example
     * // Update many EdicionesCursos
     * const edicionesCursos = await prisma.edicionesCursos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EdicionesCursos and only return the `id`
     * const edicionesCursosWithIdOnly = await prisma.edicionesCursos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends edicionesCursosUpdateManyAndReturnArgs>(args: SelectSubset<T, edicionesCursosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EdicionesCursos.
     * @param {edicionesCursosUpsertArgs} args - Arguments to update or create a EdicionesCursos.
     * @example
     * // Update or create a EdicionesCursos
     * const edicionesCursos = await prisma.edicionesCursos.upsert({
     *   create: {
     *     // ... data to create a EdicionesCursos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EdicionesCursos we want to update
     *   }
     * })
     */
    upsert<T extends edicionesCursosUpsertArgs>(args: SelectSubset<T, edicionesCursosUpsertArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EdicionesCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edicionesCursosCountArgs} args - Arguments to filter EdicionesCursos to count.
     * @example
     * // Count the number of EdicionesCursos
     * const count = await prisma.edicionesCursos.count({
     *   where: {
     *     // ... the filter for the EdicionesCursos we want to count
     *   }
     * })
    **/
    count<T extends edicionesCursosCountArgs>(
      args?: Subset<T, edicionesCursosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EdicionesCursosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EdicionesCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdicionesCursosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EdicionesCursosAggregateArgs>(args: Subset<T, EdicionesCursosAggregateArgs>): Prisma.PrismaPromise<GetEdicionesCursosAggregateType<T>>

    /**
     * Group by EdicionesCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {edicionesCursosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends edicionesCursosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: edicionesCursosGroupByArgs['orderBy'] }
        : { orderBy?: edicionesCursosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, edicionesCursosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEdicionesCursosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the edicionesCursos model
   */
  readonly fields: edicionesCursosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for edicionesCursos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__edicionesCursosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    certificados<T extends edicionesCursos$certificadosArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursos$certificadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clases<T extends edicionesCursos$clasesArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursos$clasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    compras<T extends edicionesCursos$comprasArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursos$comprasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cursos<T extends cursosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, cursosDefaultArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    docente<T extends edicionesCursos$docenteArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursos$docenteArgs<ExtArgs>>): Prisma__docenteClient<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    examenes<T extends edicionesCursos$examenesArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursos$examenesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inscripciones<T extends edicionesCursos$inscripcionesArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursos$inscripcionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pagosDocentes<T extends edicionesCursos$pagosDocentesArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursos$pagosDocentesArgs<ExtArgs>>): Prisma__pagosDocentesClient<$Result.GetResult<Prisma.$pagosDocentesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    preciosCursos<T extends edicionesCursos$preciosCursosArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursos$preciosCursosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$preciosCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the edicionesCursos model
   */
  interface edicionesCursosFieldRefs {
    readonly id: FieldRef<"edicionesCursos", 'String'>
    readonly codigo: FieldRef<"edicionesCursos", 'String'>
    readonly cursoId: FieldRef<"edicionesCursos", 'String'>
    readonly descripcion: FieldRef<"edicionesCursos", 'String'>
    readonly estado: FieldRef<"edicionesCursos", 'EdicionEstado'>
    readonly fechaFin: FieldRef<"edicionesCursos", 'DateTime'>
    readonly fechaInicio: FieldRef<"edicionesCursos", 'DateTime'>
    readonly notaMaxima: FieldRef<"edicionesCursos", 'Float'>
    readonly notaMinima: FieldRef<"edicionesCursos", 'Float'>
    readonly urlWhatsapp: FieldRef<"edicionesCursos", 'String'>
    readonly vigente: FieldRef<"edicionesCursos", 'Boolean'>
    readonly creadoEn: FieldRef<"edicionesCursos", 'DateTime'>
    readonly actualizadoEn: FieldRef<"edicionesCursos", 'DateTime'>
    readonly docenteId: FieldRef<"edicionesCursos", 'String'>
  }
    

  // Custom InputTypes
  /**
   * edicionesCursos findUnique
   */
  export type edicionesCursosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosInclude<ExtArgs> | null
    /**
     * Filter, which edicionesCursos to fetch.
     */
    where: edicionesCursosWhereUniqueInput
  }

  /**
   * edicionesCursos findUniqueOrThrow
   */
  export type edicionesCursosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosInclude<ExtArgs> | null
    /**
     * Filter, which edicionesCursos to fetch.
     */
    where: edicionesCursosWhereUniqueInput
  }

  /**
   * edicionesCursos findFirst
   */
  export type edicionesCursosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosInclude<ExtArgs> | null
    /**
     * Filter, which edicionesCursos to fetch.
     */
    where?: edicionesCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edicionesCursos to fetch.
     */
    orderBy?: edicionesCursosOrderByWithRelationInput | edicionesCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for edicionesCursos.
     */
    cursor?: edicionesCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edicionesCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edicionesCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of edicionesCursos.
     */
    distinct?: EdicionesCursosScalarFieldEnum | EdicionesCursosScalarFieldEnum[]
  }

  /**
   * edicionesCursos findFirstOrThrow
   */
  export type edicionesCursosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosInclude<ExtArgs> | null
    /**
     * Filter, which edicionesCursos to fetch.
     */
    where?: edicionesCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edicionesCursos to fetch.
     */
    orderBy?: edicionesCursosOrderByWithRelationInput | edicionesCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for edicionesCursos.
     */
    cursor?: edicionesCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edicionesCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edicionesCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of edicionesCursos.
     */
    distinct?: EdicionesCursosScalarFieldEnum | EdicionesCursosScalarFieldEnum[]
  }

  /**
   * edicionesCursos findMany
   */
  export type edicionesCursosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosInclude<ExtArgs> | null
    /**
     * Filter, which edicionesCursos to fetch.
     */
    where?: edicionesCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of edicionesCursos to fetch.
     */
    orderBy?: edicionesCursosOrderByWithRelationInput | edicionesCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing edicionesCursos.
     */
    cursor?: edicionesCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` edicionesCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` edicionesCursos.
     */
    skip?: number
    distinct?: EdicionesCursosScalarFieldEnum | EdicionesCursosScalarFieldEnum[]
  }

  /**
   * edicionesCursos create
   */
  export type edicionesCursosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosInclude<ExtArgs> | null
    /**
     * The data needed to create a edicionesCursos.
     */
    data: XOR<edicionesCursosCreateInput, edicionesCursosUncheckedCreateInput>
  }

  /**
   * edicionesCursos createMany
   */
  export type edicionesCursosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many edicionesCursos.
     */
    data: edicionesCursosCreateManyInput | edicionesCursosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * edicionesCursos createManyAndReturn
   */
  export type edicionesCursosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * The data used to create many edicionesCursos.
     */
    data: edicionesCursosCreateManyInput | edicionesCursosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * edicionesCursos update
   */
  export type edicionesCursosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosInclude<ExtArgs> | null
    /**
     * The data needed to update a edicionesCursos.
     */
    data: XOR<edicionesCursosUpdateInput, edicionesCursosUncheckedUpdateInput>
    /**
     * Choose, which edicionesCursos to update.
     */
    where: edicionesCursosWhereUniqueInput
  }

  /**
   * edicionesCursos updateMany
   */
  export type edicionesCursosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update edicionesCursos.
     */
    data: XOR<edicionesCursosUpdateManyMutationInput, edicionesCursosUncheckedUpdateManyInput>
    /**
     * Filter which edicionesCursos to update
     */
    where?: edicionesCursosWhereInput
    /**
     * Limit how many edicionesCursos to update.
     */
    limit?: number
  }

  /**
   * edicionesCursos updateManyAndReturn
   */
  export type edicionesCursosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * The data used to update edicionesCursos.
     */
    data: XOR<edicionesCursosUpdateManyMutationInput, edicionesCursosUncheckedUpdateManyInput>
    /**
     * Filter which edicionesCursos to update
     */
    where?: edicionesCursosWhereInput
    /**
     * Limit how many edicionesCursos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * edicionesCursos upsert
   */
  export type edicionesCursosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosInclude<ExtArgs> | null
    /**
     * The filter to search for the edicionesCursos to update in case it exists.
     */
    where: edicionesCursosWhereUniqueInput
    /**
     * In case the edicionesCursos found by the `where` argument doesn't exist, create a new edicionesCursos with this data.
     */
    create: XOR<edicionesCursosCreateInput, edicionesCursosUncheckedCreateInput>
    /**
     * In case the edicionesCursos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<edicionesCursosUpdateInput, edicionesCursosUncheckedUpdateInput>
  }

  /**
   * edicionesCursos delete
   */
  export type edicionesCursosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosInclude<ExtArgs> | null
    /**
     * Filter which edicionesCursos to delete.
     */
    where: edicionesCursosWhereUniqueInput
  }

  /**
   * edicionesCursos deleteMany
   */
  export type edicionesCursosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which edicionesCursos to delete
     */
    where?: edicionesCursosWhereInput
    /**
     * Limit how many edicionesCursos to delete.
     */
    limit?: number
  }

  /**
   * edicionesCursos.certificados
   */
  export type edicionesCursos$certificadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosInclude<ExtArgs> | null
    where?: certificadosWhereInput
    orderBy?: certificadosOrderByWithRelationInput | certificadosOrderByWithRelationInput[]
    cursor?: certificadosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificadosScalarFieldEnum | CertificadosScalarFieldEnum[]
  }

  /**
   * edicionesCursos.clases
   */
  export type edicionesCursos$clasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clases
     */
    select?: clasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clases
     */
    omit?: clasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clasesInclude<ExtArgs> | null
    where?: clasesWhereInput
    orderBy?: clasesOrderByWithRelationInput | clasesOrderByWithRelationInput[]
    cursor?: clasesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClasesScalarFieldEnum | ClasesScalarFieldEnum[]
  }

  /**
   * edicionesCursos.compras
   */
  export type edicionesCursos$comprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasInclude<ExtArgs> | null
    where?: comprasWhereInput
    orderBy?: comprasOrderByWithRelationInput | comprasOrderByWithRelationInput[]
    cursor?: comprasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComprasScalarFieldEnum | ComprasScalarFieldEnum[]
  }

  /**
   * edicionesCursos.docente
   */
  export type edicionesCursos$docenteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteInclude<ExtArgs> | null
    where?: docenteWhereInput
  }

  /**
   * edicionesCursos.examenes
   */
  export type edicionesCursos$examenesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesInclude<ExtArgs> | null
    where?: examenesWhereInput
    orderBy?: examenesOrderByWithRelationInput | examenesOrderByWithRelationInput[]
    cursor?: examenesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamenesScalarFieldEnum | ExamenesScalarFieldEnum[]
  }

  /**
   * edicionesCursos.inscripciones
   */
  export type edicionesCursos$inscripcionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
    where?: inscripcionesWhereInput
    orderBy?: inscripcionesOrderByWithRelationInput | inscripcionesOrderByWithRelationInput[]
    cursor?: inscripcionesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InscripcionesScalarFieldEnum | InscripcionesScalarFieldEnum[]
  }

  /**
   * edicionesCursos.pagosDocentes
   */
  export type edicionesCursos$pagosDocentesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagosDocentes
     */
    select?: pagosDocentesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pagosDocentes
     */
    omit?: pagosDocentesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagosDocentesInclude<ExtArgs> | null
    where?: pagosDocentesWhereInput
  }

  /**
   * edicionesCursos.preciosCursos
   */
  export type edicionesCursos$preciosCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosInclude<ExtArgs> | null
    where?: preciosCursosWhereInput
    orderBy?: preciosCursosOrderByWithRelationInput | preciosCursosOrderByWithRelationInput[]
    cursor?: preciosCursosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreciosCursosScalarFieldEnum | PreciosCursosScalarFieldEnum[]
  }

  /**
   * edicionesCursos without action
   */
  export type edicionesCursosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the edicionesCursos
     */
    select?: edicionesCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the edicionesCursos
     */
    omit?: edicionesCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: edicionesCursosInclude<ExtArgs> | null
  }


  /**
   * Model estudiantes
   */

  export type AggregateEstudiantes = {
    _count: EstudiantesCountAggregateOutputType | null
    _avg: EstudiantesAvgAggregateOutputType | null
    _sum: EstudiantesSumAggregateOutputType | null
    _min: EstudiantesMinAggregateOutputType | null
    _max: EstudiantesMaxAggregateOutputType | null
  }

  export type EstudiantesAvgAggregateOutputType = {
    nroUpdates: number | null
  }

  export type EstudiantesSumAggregateOutputType = {
    nroUpdates: number | null
  }

  export type EstudiantesMinAggregateOutputType = {
    id: string | null
    apellido: string | null
    celular: string | null
    pais: string | null
    genero: $Enums.TipoGenero | null
    fechaNacimiento: Date | null
    nombre: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    nroUpdates: number | null
  }

  export type EstudiantesMaxAggregateOutputType = {
    id: string | null
    apellido: string | null
    celular: string | null
    pais: string | null
    genero: $Enums.TipoGenero | null
    fechaNacimiento: Date | null
    nombre: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    nroUpdates: number | null
  }

  export type EstudiantesCountAggregateOutputType = {
    id: number
    apellido: number
    celular: number
    pais: number
    genero: number
    fechaNacimiento: number
    nombre: number
    creadoEn: number
    actualizadoEn: number
    nroUpdates: number
    _all: number
  }


  export type EstudiantesAvgAggregateInputType = {
    nroUpdates?: true
  }

  export type EstudiantesSumAggregateInputType = {
    nroUpdates?: true
  }

  export type EstudiantesMinAggregateInputType = {
    id?: true
    apellido?: true
    celular?: true
    pais?: true
    genero?: true
    fechaNacimiento?: true
    nombre?: true
    creadoEn?: true
    actualizadoEn?: true
    nroUpdates?: true
  }

  export type EstudiantesMaxAggregateInputType = {
    id?: true
    apellido?: true
    celular?: true
    pais?: true
    genero?: true
    fechaNacimiento?: true
    nombre?: true
    creadoEn?: true
    actualizadoEn?: true
    nroUpdates?: true
  }

  export type EstudiantesCountAggregateInputType = {
    id?: true
    apellido?: true
    celular?: true
    pais?: true
    genero?: true
    fechaNacimiento?: true
    nombre?: true
    creadoEn?: true
    actualizadoEn?: true
    nroUpdates?: true
    _all?: true
  }

  export type EstudiantesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estudiantes to aggregate.
     */
    where?: estudiantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estudiantes to fetch.
     */
    orderBy?: estudiantesOrderByWithRelationInput | estudiantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: estudiantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned estudiantes
    **/
    _count?: true | EstudiantesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstudiantesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstudiantesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstudiantesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstudiantesMaxAggregateInputType
  }

  export type GetEstudiantesAggregateType<T extends EstudiantesAggregateArgs> = {
        [P in keyof T & keyof AggregateEstudiantes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstudiantes[P]>
      : GetScalarType<T[P], AggregateEstudiantes[P]>
  }




  export type estudiantesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: estudiantesWhereInput
    orderBy?: estudiantesOrderByWithAggregationInput | estudiantesOrderByWithAggregationInput[]
    by: EstudiantesScalarFieldEnum[] | EstudiantesScalarFieldEnum
    having?: estudiantesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstudiantesCountAggregateInputType | true
    _avg?: EstudiantesAvgAggregateInputType
    _sum?: EstudiantesSumAggregateInputType
    _min?: EstudiantesMinAggregateInputType
    _max?: EstudiantesMaxAggregateInputType
  }

  export type EstudiantesGroupByOutputType = {
    id: string
    apellido: string | null
    celular: string | null
    pais: string
    genero: $Enums.TipoGenero
    fechaNacimiento: Date | null
    nombre: string
    creadoEn: Date
    actualizadoEn: Date
    nroUpdates: number
    _count: EstudiantesCountAggregateOutputType | null
    _avg: EstudiantesAvgAggregateOutputType | null
    _sum: EstudiantesSumAggregateOutputType | null
    _min: EstudiantesMinAggregateOutputType | null
    _max: EstudiantesMaxAggregateOutputType | null
  }

  type GetEstudiantesGroupByPayload<T extends estudiantesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EstudiantesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstudiantesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstudiantesGroupByOutputType[P]>
            : GetScalarType<T[P], EstudiantesGroupByOutputType[P]>
        }
      >
    >


  export type estudiantesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apellido?: boolean
    celular?: boolean
    pais?: boolean
    genero?: boolean
    fechaNacimiento?: boolean
    nombre?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    nroUpdates?: boolean
    calificaciones?: boolean | estudiantes$calificacionesArgs<ExtArgs>
    certificados?: boolean | estudiantes$certificadosArgs<ExtArgs>
    inscripciones?: boolean | estudiantes$inscripcionesArgs<ExtArgs>
    usuariosEstudiantes?: boolean | estudiantes$usuariosEstudiantesArgs<ExtArgs>
    _count?: boolean | EstudiantesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estudiantes"]>

  export type estudiantesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apellido?: boolean
    celular?: boolean
    pais?: boolean
    genero?: boolean
    fechaNacimiento?: boolean
    nombre?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    nroUpdates?: boolean
  }, ExtArgs["result"]["estudiantes"]>

  export type estudiantesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apellido?: boolean
    celular?: boolean
    pais?: boolean
    genero?: boolean
    fechaNacimiento?: boolean
    nombre?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    nroUpdates?: boolean
  }, ExtArgs["result"]["estudiantes"]>

  export type estudiantesSelectScalar = {
    id?: boolean
    apellido?: boolean
    celular?: boolean
    pais?: boolean
    genero?: boolean
    fechaNacimiento?: boolean
    nombre?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    nroUpdates?: boolean
  }

  export type estudiantesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "apellido" | "celular" | "pais" | "genero" | "fechaNacimiento" | "nombre" | "creadoEn" | "actualizadoEn" | "nroUpdates", ExtArgs["result"]["estudiantes"]>
  export type estudiantesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calificaciones?: boolean | estudiantes$calificacionesArgs<ExtArgs>
    certificados?: boolean | estudiantes$certificadosArgs<ExtArgs>
    inscripciones?: boolean | estudiantes$inscripcionesArgs<ExtArgs>
    usuariosEstudiantes?: boolean | estudiantes$usuariosEstudiantesArgs<ExtArgs>
    _count?: boolean | EstudiantesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type estudiantesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type estudiantesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $estudiantesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "estudiantes"
    objects: {
      calificaciones: Prisma.$calificacionesPayload<ExtArgs>[]
      certificados: Prisma.$certificadosPayload<ExtArgs>[]
      inscripciones: Prisma.$inscripcionesPayload<ExtArgs>[]
      usuariosEstudiantes: Prisma.$usuariosEstudiantesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      apellido: string | null
      celular: string | null
      pais: string
      genero: $Enums.TipoGenero
      fechaNacimiento: Date | null
      nombre: string
      creadoEn: Date
      actualizadoEn: Date
      nroUpdates: number
    }, ExtArgs["result"]["estudiantes"]>
    composites: {}
  }

  type estudiantesGetPayload<S extends boolean | null | undefined | estudiantesDefaultArgs> = $Result.GetResult<Prisma.$estudiantesPayload, S>

  type estudiantesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<estudiantesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EstudiantesCountAggregateInputType | true
    }

  export interface estudiantesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['estudiantes'], meta: { name: 'estudiantes' } }
    /**
     * Find zero or one Estudiantes that matches the filter.
     * @param {estudiantesFindUniqueArgs} args - Arguments to find a Estudiantes
     * @example
     * // Get one Estudiantes
     * const estudiantes = await prisma.estudiantes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends estudiantesFindUniqueArgs>(args: SelectSubset<T, estudiantesFindUniqueArgs<ExtArgs>>): Prisma__estudiantesClient<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Estudiantes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {estudiantesFindUniqueOrThrowArgs} args - Arguments to find a Estudiantes
     * @example
     * // Get one Estudiantes
     * const estudiantes = await prisma.estudiantes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends estudiantesFindUniqueOrThrowArgs>(args: SelectSubset<T, estudiantesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__estudiantesClient<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estudiantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estudiantesFindFirstArgs} args - Arguments to find a Estudiantes
     * @example
     * // Get one Estudiantes
     * const estudiantes = await prisma.estudiantes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends estudiantesFindFirstArgs>(args?: SelectSubset<T, estudiantesFindFirstArgs<ExtArgs>>): Prisma__estudiantesClient<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estudiantes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estudiantesFindFirstOrThrowArgs} args - Arguments to find a Estudiantes
     * @example
     * // Get one Estudiantes
     * const estudiantes = await prisma.estudiantes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends estudiantesFindFirstOrThrowArgs>(args?: SelectSubset<T, estudiantesFindFirstOrThrowArgs<ExtArgs>>): Prisma__estudiantesClient<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Estudiantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estudiantesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estudiantes
     * const estudiantes = await prisma.estudiantes.findMany()
     * 
     * // Get first 10 Estudiantes
     * const estudiantes = await prisma.estudiantes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estudiantesWithIdOnly = await prisma.estudiantes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends estudiantesFindManyArgs>(args?: SelectSubset<T, estudiantesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Estudiantes.
     * @param {estudiantesCreateArgs} args - Arguments to create a Estudiantes.
     * @example
     * // Create one Estudiantes
     * const Estudiantes = await prisma.estudiantes.create({
     *   data: {
     *     // ... data to create a Estudiantes
     *   }
     * })
     * 
     */
    create<T extends estudiantesCreateArgs>(args: SelectSubset<T, estudiantesCreateArgs<ExtArgs>>): Prisma__estudiantesClient<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Estudiantes.
     * @param {estudiantesCreateManyArgs} args - Arguments to create many Estudiantes.
     * @example
     * // Create many Estudiantes
     * const estudiantes = await prisma.estudiantes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends estudiantesCreateManyArgs>(args?: SelectSubset<T, estudiantesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Estudiantes and returns the data saved in the database.
     * @param {estudiantesCreateManyAndReturnArgs} args - Arguments to create many Estudiantes.
     * @example
     * // Create many Estudiantes
     * const estudiantes = await prisma.estudiantes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Estudiantes and only return the `id`
     * const estudiantesWithIdOnly = await prisma.estudiantes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends estudiantesCreateManyAndReturnArgs>(args?: SelectSubset<T, estudiantesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Estudiantes.
     * @param {estudiantesDeleteArgs} args - Arguments to delete one Estudiantes.
     * @example
     * // Delete one Estudiantes
     * const Estudiantes = await prisma.estudiantes.delete({
     *   where: {
     *     // ... filter to delete one Estudiantes
     *   }
     * })
     * 
     */
    delete<T extends estudiantesDeleteArgs>(args: SelectSubset<T, estudiantesDeleteArgs<ExtArgs>>): Prisma__estudiantesClient<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Estudiantes.
     * @param {estudiantesUpdateArgs} args - Arguments to update one Estudiantes.
     * @example
     * // Update one Estudiantes
     * const estudiantes = await prisma.estudiantes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends estudiantesUpdateArgs>(args: SelectSubset<T, estudiantesUpdateArgs<ExtArgs>>): Prisma__estudiantesClient<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Estudiantes.
     * @param {estudiantesDeleteManyArgs} args - Arguments to filter Estudiantes to delete.
     * @example
     * // Delete a few Estudiantes
     * const { count } = await prisma.estudiantes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends estudiantesDeleteManyArgs>(args?: SelectSubset<T, estudiantesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estudiantesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estudiantes
     * const estudiantes = await prisma.estudiantes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends estudiantesUpdateManyArgs>(args: SelectSubset<T, estudiantesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estudiantes and returns the data updated in the database.
     * @param {estudiantesUpdateManyAndReturnArgs} args - Arguments to update many Estudiantes.
     * @example
     * // Update many Estudiantes
     * const estudiantes = await prisma.estudiantes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Estudiantes and only return the `id`
     * const estudiantesWithIdOnly = await prisma.estudiantes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends estudiantesUpdateManyAndReturnArgs>(args: SelectSubset<T, estudiantesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Estudiantes.
     * @param {estudiantesUpsertArgs} args - Arguments to update or create a Estudiantes.
     * @example
     * // Update or create a Estudiantes
     * const estudiantes = await prisma.estudiantes.upsert({
     *   create: {
     *     // ... data to create a Estudiantes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estudiantes we want to update
     *   }
     * })
     */
    upsert<T extends estudiantesUpsertArgs>(args: SelectSubset<T, estudiantesUpsertArgs<ExtArgs>>): Prisma__estudiantesClient<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Estudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estudiantesCountArgs} args - Arguments to filter Estudiantes to count.
     * @example
     * // Count the number of Estudiantes
     * const count = await prisma.estudiantes.count({
     *   where: {
     *     // ... the filter for the Estudiantes we want to count
     *   }
     * })
    **/
    count<T extends estudiantesCountArgs>(
      args?: Subset<T, estudiantesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstudiantesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstudiantesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstudiantesAggregateArgs>(args: Subset<T, EstudiantesAggregateArgs>): Prisma.PrismaPromise<GetEstudiantesAggregateType<T>>

    /**
     * Group by Estudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estudiantesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends estudiantesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: estudiantesGroupByArgs['orderBy'] }
        : { orderBy?: estudiantesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, estudiantesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstudiantesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the estudiantes model
   */
  readonly fields: estudiantesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for estudiantes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__estudiantesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    calificaciones<T extends estudiantes$calificacionesArgs<ExtArgs> = {}>(args?: Subset<T, estudiantes$calificacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    certificados<T extends estudiantes$certificadosArgs<ExtArgs> = {}>(args?: Subset<T, estudiantes$certificadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificadosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inscripciones<T extends estudiantes$inscripcionesArgs<ExtArgs> = {}>(args?: Subset<T, estudiantes$inscripcionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usuariosEstudiantes<T extends estudiantes$usuariosEstudiantesArgs<ExtArgs> = {}>(args?: Subset<T, estudiantes$usuariosEstudiantesArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the estudiantes model
   */
  interface estudiantesFieldRefs {
    readonly id: FieldRef<"estudiantes", 'String'>
    readonly apellido: FieldRef<"estudiantes", 'String'>
    readonly celular: FieldRef<"estudiantes", 'String'>
    readonly pais: FieldRef<"estudiantes", 'String'>
    readonly genero: FieldRef<"estudiantes", 'TipoGenero'>
    readonly fechaNacimiento: FieldRef<"estudiantes", 'DateTime'>
    readonly nombre: FieldRef<"estudiantes", 'String'>
    readonly creadoEn: FieldRef<"estudiantes", 'DateTime'>
    readonly actualizadoEn: FieldRef<"estudiantes", 'DateTime'>
    readonly nroUpdates: FieldRef<"estudiantes", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * estudiantes findUnique
   */
  export type estudiantesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estudiantesInclude<ExtArgs> | null
    /**
     * Filter, which estudiantes to fetch.
     */
    where: estudiantesWhereUniqueInput
  }

  /**
   * estudiantes findUniqueOrThrow
   */
  export type estudiantesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estudiantesInclude<ExtArgs> | null
    /**
     * Filter, which estudiantes to fetch.
     */
    where: estudiantesWhereUniqueInput
  }

  /**
   * estudiantes findFirst
   */
  export type estudiantesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estudiantesInclude<ExtArgs> | null
    /**
     * Filter, which estudiantes to fetch.
     */
    where?: estudiantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estudiantes to fetch.
     */
    orderBy?: estudiantesOrderByWithRelationInput | estudiantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estudiantes.
     */
    cursor?: estudiantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estudiantes.
     */
    distinct?: EstudiantesScalarFieldEnum | EstudiantesScalarFieldEnum[]
  }

  /**
   * estudiantes findFirstOrThrow
   */
  export type estudiantesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estudiantesInclude<ExtArgs> | null
    /**
     * Filter, which estudiantes to fetch.
     */
    where?: estudiantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estudiantes to fetch.
     */
    orderBy?: estudiantesOrderByWithRelationInput | estudiantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estudiantes.
     */
    cursor?: estudiantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estudiantes.
     */
    distinct?: EstudiantesScalarFieldEnum | EstudiantesScalarFieldEnum[]
  }

  /**
   * estudiantes findMany
   */
  export type estudiantesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estudiantesInclude<ExtArgs> | null
    /**
     * Filter, which estudiantes to fetch.
     */
    where?: estudiantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estudiantes to fetch.
     */
    orderBy?: estudiantesOrderByWithRelationInput | estudiantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing estudiantes.
     */
    cursor?: estudiantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estudiantes.
     */
    skip?: number
    distinct?: EstudiantesScalarFieldEnum | EstudiantesScalarFieldEnum[]
  }

  /**
   * estudiantes create
   */
  export type estudiantesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estudiantesInclude<ExtArgs> | null
    /**
     * The data needed to create a estudiantes.
     */
    data: XOR<estudiantesCreateInput, estudiantesUncheckedCreateInput>
  }

  /**
   * estudiantes createMany
   */
  export type estudiantesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many estudiantes.
     */
    data: estudiantesCreateManyInput | estudiantesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * estudiantes createManyAndReturn
   */
  export type estudiantesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * The data used to create many estudiantes.
     */
    data: estudiantesCreateManyInput | estudiantesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * estudiantes update
   */
  export type estudiantesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estudiantesInclude<ExtArgs> | null
    /**
     * The data needed to update a estudiantes.
     */
    data: XOR<estudiantesUpdateInput, estudiantesUncheckedUpdateInput>
    /**
     * Choose, which estudiantes to update.
     */
    where: estudiantesWhereUniqueInput
  }

  /**
   * estudiantes updateMany
   */
  export type estudiantesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update estudiantes.
     */
    data: XOR<estudiantesUpdateManyMutationInput, estudiantesUncheckedUpdateManyInput>
    /**
     * Filter which estudiantes to update
     */
    where?: estudiantesWhereInput
    /**
     * Limit how many estudiantes to update.
     */
    limit?: number
  }

  /**
   * estudiantes updateManyAndReturn
   */
  export type estudiantesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * The data used to update estudiantes.
     */
    data: XOR<estudiantesUpdateManyMutationInput, estudiantesUncheckedUpdateManyInput>
    /**
     * Filter which estudiantes to update
     */
    where?: estudiantesWhereInput
    /**
     * Limit how many estudiantes to update.
     */
    limit?: number
  }

  /**
   * estudiantes upsert
   */
  export type estudiantesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estudiantesInclude<ExtArgs> | null
    /**
     * The filter to search for the estudiantes to update in case it exists.
     */
    where: estudiantesWhereUniqueInput
    /**
     * In case the estudiantes found by the `where` argument doesn't exist, create a new estudiantes with this data.
     */
    create: XOR<estudiantesCreateInput, estudiantesUncheckedCreateInput>
    /**
     * In case the estudiantes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<estudiantesUpdateInput, estudiantesUncheckedUpdateInput>
  }

  /**
   * estudiantes delete
   */
  export type estudiantesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estudiantesInclude<ExtArgs> | null
    /**
     * Filter which estudiantes to delete.
     */
    where: estudiantesWhereUniqueInput
  }

  /**
   * estudiantes deleteMany
   */
  export type estudiantesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estudiantes to delete
     */
    where?: estudiantesWhereInput
    /**
     * Limit how many estudiantes to delete.
     */
    limit?: number
  }

  /**
   * estudiantes.calificaciones
   */
  export type estudiantes$calificacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesInclude<ExtArgs> | null
    where?: calificacionesWhereInput
    orderBy?: calificacionesOrderByWithRelationInput | calificacionesOrderByWithRelationInput[]
    cursor?: calificacionesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalificacionesScalarFieldEnum | CalificacionesScalarFieldEnum[]
  }

  /**
   * estudiantes.certificados
   */
  export type estudiantes$certificadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificados
     */
    select?: certificadosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificados
     */
    omit?: certificadosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificadosInclude<ExtArgs> | null
    where?: certificadosWhereInput
    orderBy?: certificadosOrderByWithRelationInput | certificadosOrderByWithRelationInput[]
    cursor?: certificadosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificadosScalarFieldEnum | CertificadosScalarFieldEnum[]
  }

  /**
   * estudiantes.inscripciones
   */
  export type estudiantes$inscripcionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
    where?: inscripcionesWhereInput
    orderBy?: inscripcionesOrderByWithRelationInput | inscripcionesOrderByWithRelationInput[]
    cursor?: inscripcionesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InscripcionesScalarFieldEnum | InscripcionesScalarFieldEnum[]
  }

  /**
   * estudiantes.usuariosEstudiantes
   */
  export type estudiantes$usuariosEstudiantesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
    where?: usuariosEstudiantesWhereInput
  }

  /**
   * estudiantes without action
   */
  export type estudiantesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estudiantesInclude<ExtArgs> | null
  }


  /**
   * Model temas
   */

  export type AggregateTemas = {
    _count: TemasCountAggregateOutputType | null
    _min: TemasMinAggregateOutputType | null
    _max: TemasMaxAggregateOutputType | null
  }

  export type TemasMinAggregateOutputType = {
    id: string | null
    titulo: string | null
    descripcion: string | null
    capituloId: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type TemasMaxAggregateOutputType = {
    id: string | null
    titulo: string | null
    descripcion: string | null
    capituloId: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type TemasCountAggregateOutputType = {
    id: number
    titulo: number
    descripcion: number
    capituloId: number
    creadoEn: number
    actualizadoEn: number
    _all: number
  }


  export type TemasMinAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    capituloId?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type TemasMaxAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    capituloId?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type TemasCountAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    capituloId?: true
    creadoEn?: true
    actualizadoEn?: true
    _all?: true
  }

  export type TemasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which temas to aggregate.
     */
    where?: temasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of temas to fetch.
     */
    orderBy?: temasOrderByWithRelationInput | temasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: temasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` temas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` temas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned temas
    **/
    _count?: true | TemasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemasMaxAggregateInputType
  }

  export type GetTemasAggregateType<T extends TemasAggregateArgs> = {
        [P in keyof T & keyof AggregateTemas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemas[P]>
      : GetScalarType<T[P], AggregateTemas[P]>
  }




  export type temasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: temasWhereInput
    orderBy?: temasOrderByWithAggregationInput | temasOrderByWithAggregationInput[]
    by: TemasScalarFieldEnum[] | TemasScalarFieldEnum
    having?: temasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemasCountAggregateInputType | true
    _min?: TemasMinAggregateInputType
    _max?: TemasMaxAggregateInputType
  }

  export type TemasGroupByOutputType = {
    id: string
    titulo: string
    descripcion: string | null
    capituloId: string | null
    creadoEn: Date
    actualizadoEn: Date
    _count: TemasCountAggregateOutputType | null
    _min: TemasMinAggregateOutputType | null
    _max: TemasMaxAggregateOutputType | null
  }

  type GetTemasGroupByPayload<T extends temasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemasGroupByOutputType[P]>
            : GetScalarType<T[P], TemasGroupByOutputType[P]>
        }
      >
    >


  export type temasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    capituloId?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    capitulos?: boolean | temas$capitulosArgs<ExtArgs>
    preguntas?: boolean | temas$preguntasArgs<ExtArgs>
    _count?: boolean | TemasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["temas"]>

  export type temasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    capituloId?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    capitulos?: boolean | temas$capitulosArgs<ExtArgs>
  }, ExtArgs["result"]["temas"]>

  export type temasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    capituloId?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    capitulos?: boolean | temas$capitulosArgs<ExtArgs>
  }, ExtArgs["result"]["temas"]>

  export type temasSelectScalar = {
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    capituloId?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }

  export type temasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "titulo" | "descripcion" | "capituloId" | "creadoEn" | "actualizadoEn", ExtArgs["result"]["temas"]>
  export type temasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capitulos?: boolean | temas$capitulosArgs<ExtArgs>
    preguntas?: boolean | temas$preguntasArgs<ExtArgs>
    _count?: boolean | TemasCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type temasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capitulos?: boolean | temas$capitulosArgs<ExtArgs>
  }
  export type temasIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capitulos?: boolean | temas$capitulosArgs<ExtArgs>
  }

  export type $temasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "temas"
    objects: {
      capitulos: Prisma.$capitulosPayload<ExtArgs> | null
      preguntas: Prisma.$preguntasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      titulo: string
      descripcion: string | null
      capituloId: string | null
      creadoEn: Date
      actualizadoEn: Date
    }, ExtArgs["result"]["temas"]>
    composites: {}
  }

  type temasGetPayload<S extends boolean | null | undefined | temasDefaultArgs> = $Result.GetResult<Prisma.$temasPayload, S>

  type temasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<temasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TemasCountAggregateInputType | true
    }

  export interface temasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['temas'], meta: { name: 'temas' } }
    /**
     * Find zero or one Temas that matches the filter.
     * @param {temasFindUniqueArgs} args - Arguments to find a Temas
     * @example
     * // Get one Temas
     * const temas = await prisma.temas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends temasFindUniqueArgs>(args: SelectSubset<T, temasFindUniqueArgs<ExtArgs>>): Prisma__temasClient<$Result.GetResult<Prisma.$temasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Temas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {temasFindUniqueOrThrowArgs} args - Arguments to find a Temas
     * @example
     * // Get one Temas
     * const temas = await prisma.temas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends temasFindUniqueOrThrowArgs>(args: SelectSubset<T, temasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__temasClient<$Result.GetResult<Prisma.$temasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Temas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {temasFindFirstArgs} args - Arguments to find a Temas
     * @example
     * // Get one Temas
     * const temas = await prisma.temas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends temasFindFirstArgs>(args?: SelectSubset<T, temasFindFirstArgs<ExtArgs>>): Prisma__temasClient<$Result.GetResult<Prisma.$temasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Temas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {temasFindFirstOrThrowArgs} args - Arguments to find a Temas
     * @example
     * // Get one Temas
     * const temas = await prisma.temas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends temasFindFirstOrThrowArgs>(args?: SelectSubset<T, temasFindFirstOrThrowArgs<ExtArgs>>): Prisma__temasClient<$Result.GetResult<Prisma.$temasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Temas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {temasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Temas
     * const temas = await prisma.temas.findMany()
     * 
     * // Get first 10 Temas
     * const temas = await prisma.temas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const temasWithIdOnly = await prisma.temas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends temasFindManyArgs>(args?: SelectSubset<T, temasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$temasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Temas.
     * @param {temasCreateArgs} args - Arguments to create a Temas.
     * @example
     * // Create one Temas
     * const Temas = await prisma.temas.create({
     *   data: {
     *     // ... data to create a Temas
     *   }
     * })
     * 
     */
    create<T extends temasCreateArgs>(args: SelectSubset<T, temasCreateArgs<ExtArgs>>): Prisma__temasClient<$Result.GetResult<Prisma.$temasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Temas.
     * @param {temasCreateManyArgs} args - Arguments to create many Temas.
     * @example
     * // Create many Temas
     * const temas = await prisma.temas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends temasCreateManyArgs>(args?: SelectSubset<T, temasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Temas and returns the data saved in the database.
     * @param {temasCreateManyAndReturnArgs} args - Arguments to create many Temas.
     * @example
     * // Create many Temas
     * const temas = await prisma.temas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Temas and only return the `id`
     * const temasWithIdOnly = await prisma.temas.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends temasCreateManyAndReturnArgs>(args?: SelectSubset<T, temasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$temasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Temas.
     * @param {temasDeleteArgs} args - Arguments to delete one Temas.
     * @example
     * // Delete one Temas
     * const Temas = await prisma.temas.delete({
     *   where: {
     *     // ... filter to delete one Temas
     *   }
     * })
     * 
     */
    delete<T extends temasDeleteArgs>(args: SelectSubset<T, temasDeleteArgs<ExtArgs>>): Prisma__temasClient<$Result.GetResult<Prisma.$temasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Temas.
     * @param {temasUpdateArgs} args - Arguments to update one Temas.
     * @example
     * // Update one Temas
     * const temas = await prisma.temas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends temasUpdateArgs>(args: SelectSubset<T, temasUpdateArgs<ExtArgs>>): Prisma__temasClient<$Result.GetResult<Prisma.$temasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Temas.
     * @param {temasDeleteManyArgs} args - Arguments to filter Temas to delete.
     * @example
     * // Delete a few Temas
     * const { count } = await prisma.temas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends temasDeleteManyArgs>(args?: SelectSubset<T, temasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Temas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {temasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Temas
     * const temas = await prisma.temas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends temasUpdateManyArgs>(args: SelectSubset<T, temasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Temas and returns the data updated in the database.
     * @param {temasUpdateManyAndReturnArgs} args - Arguments to update many Temas.
     * @example
     * // Update many Temas
     * const temas = await prisma.temas.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Temas and only return the `id`
     * const temasWithIdOnly = await prisma.temas.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends temasUpdateManyAndReturnArgs>(args: SelectSubset<T, temasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$temasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Temas.
     * @param {temasUpsertArgs} args - Arguments to update or create a Temas.
     * @example
     * // Update or create a Temas
     * const temas = await prisma.temas.upsert({
     *   create: {
     *     // ... data to create a Temas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Temas we want to update
     *   }
     * })
     */
    upsert<T extends temasUpsertArgs>(args: SelectSubset<T, temasUpsertArgs<ExtArgs>>): Prisma__temasClient<$Result.GetResult<Prisma.$temasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Temas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {temasCountArgs} args - Arguments to filter Temas to count.
     * @example
     * // Count the number of Temas
     * const count = await prisma.temas.count({
     *   where: {
     *     // ... the filter for the Temas we want to count
     *   }
     * })
    **/
    count<T extends temasCountArgs>(
      args?: Subset<T, temasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Temas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemasAggregateArgs>(args: Subset<T, TemasAggregateArgs>): Prisma.PrismaPromise<GetTemasAggregateType<T>>

    /**
     * Group by Temas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {temasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends temasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: temasGroupByArgs['orderBy'] }
        : { orderBy?: temasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, temasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the temas model
   */
  readonly fields: temasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for temas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__temasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    capitulos<T extends temas$capitulosArgs<ExtArgs> = {}>(args?: Subset<T, temas$capitulosArgs<ExtArgs>>): Prisma__capitulosClient<$Result.GetResult<Prisma.$capitulosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    preguntas<T extends temas$preguntasArgs<ExtArgs> = {}>(args?: Subset<T, temas$preguntasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$preguntasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the temas model
   */
  interface temasFieldRefs {
    readonly id: FieldRef<"temas", 'String'>
    readonly titulo: FieldRef<"temas", 'String'>
    readonly descripcion: FieldRef<"temas", 'String'>
    readonly capituloId: FieldRef<"temas", 'String'>
    readonly creadoEn: FieldRef<"temas", 'DateTime'>
    readonly actualizadoEn: FieldRef<"temas", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * temas findUnique
   */
  export type temasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temas
     */
    select?: temasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the temas
     */
    omit?: temasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: temasInclude<ExtArgs> | null
    /**
     * Filter, which temas to fetch.
     */
    where: temasWhereUniqueInput
  }

  /**
   * temas findUniqueOrThrow
   */
  export type temasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temas
     */
    select?: temasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the temas
     */
    omit?: temasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: temasInclude<ExtArgs> | null
    /**
     * Filter, which temas to fetch.
     */
    where: temasWhereUniqueInput
  }

  /**
   * temas findFirst
   */
  export type temasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temas
     */
    select?: temasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the temas
     */
    omit?: temasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: temasInclude<ExtArgs> | null
    /**
     * Filter, which temas to fetch.
     */
    where?: temasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of temas to fetch.
     */
    orderBy?: temasOrderByWithRelationInput | temasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for temas.
     */
    cursor?: temasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` temas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` temas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of temas.
     */
    distinct?: TemasScalarFieldEnum | TemasScalarFieldEnum[]
  }

  /**
   * temas findFirstOrThrow
   */
  export type temasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temas
     */
    select?: temasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the temas
     */
    omit?: temasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: temasInclude<ExtArgs> | null
    /**
     * Filter, which temas to fetch.
     */
    where?: temasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of temas to fetch.
     */
    orderBy?: temasOrderByWithRelationInput | temasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for temas.
     */
    cursor?: temasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` temas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` temas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of temas.
     */
    distinct?: TemasScalarFieldEnum | TemasScalarFieldEnum[]
  }

  /**
   * temas findMany
   */
  export type temasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temas
     */
    select?: temasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the temas
     */
    omit?: temasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: temasInclude<ExtArgs> | null
    /**
     * Filter, which temas to fetch.
     */
    where?: temasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of temas to fetch.
     */
    orderBy?: temasOrderByWithRelationInput | temasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing temas.
     */
    cursor?: temasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` temas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` temas.
     */
    skip?: number
    distinct?: TemasScalarFieldEnum | TemasScalarFieldEnum[]
  }

  /**
   * temas create
   */
  export type temasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temas
     */
    select?: temasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the temas
     */
    omit?: temasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: temasInclude<ExtArgs> | null
    /**
     * The data needed to create a temas.
     */
    data: XOR<temasCreateInput, temasUncheckedCreateInput>
  }

  /**
   * temas createMany
   */
  export type temasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many temas.
     */
    data: temasCreateManyInput | temasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * temas createManyAndReturn
   */
  export type temasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temas
     */
    select?: temasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the temas
     */
    omit?: temasOmit<ExtArgs> | null
    /**
     * The data used to create many temas.
     */
    data: temasCreateManyInput | temasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: temasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * temas update
   */
  export type temasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temas
     */
    select?: temasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the temas
     */
    omit?: temasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: temasInclude<ExtArgs> | null
    /**
     * The data needed to update a temas.
     */
    data: XOR<temasUpdateInput, temasUncheckedUpdateInput>
    /**
     * Choose, which temas to update.
     */
    where: temasWhereUniqueInput
  }

  /**
   * temas updateMany
   */
  export type temasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update temas.
     */
    data: XOR<temasUpdateManyMutationInput, temasUncheckedUpdateManyInput>
    /**
     * Filter which temas to update
     */
    where?: temasWhereInput
    /**
     * Limit how many temas to update.
     */
    limit?: number
  }

  /**
   * temas updateManyAndReturn
   */
  export type temasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temas
     */
    select?: temasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the temas
     */
    omit?: temasOmit<ExtArgs> | null
    /**
     * The data used to update temas.
     */
    data: XOR<temasUpdateManyMutationInput, temasUncheckedUpdateManyInput>
    /**
     * Filter which temas to update
     */
    where?: temasWhereInput
    /**
     * Limit how many temas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: temasIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * temas upsert
   */
  export type temasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temas
     */
    select?: temasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the temas
     */
    omit?: temasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: temasInclude<ExtArgs> | null
    /**
     * The filter to search for the temas to update in case it exists.
     */
    where: temasWhereUniqueInput
    /**
     * In case the temas found by the `where` argument doesn't exist, create a new temas with this data.
     */
    create: XOR<temasCreateInput, temasUncheckedCreateInput>
    /**
     * In case the temas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<temasUpdateInput, temasUncheckedUpdateInput>
  }

  /**
   * temas delete
   */
  export type temasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temas
     */
    select?: temasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the temas
     */
    omit?: temasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: temasInclude<ExtArgs> | null
    /**
     * Filter which temas to delete.
     */
    where: temasWhereUniqueInput
  }

  /**
   * temas deleteMany
   */
  export type temasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which temas to delete
     */
    where?: temasWhereInput
    /**
     * Limit how many temas to delete.
     */
    limit?: number
  }

  /**
   * temas.capitulos
   */
  export type temas$capitulosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capitulos
     */
    select?: capitulosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capitulos
     */
    omit?: capitulosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capitulosInclude<ExtArgs> | null
    where?: capitulosWhereInput
  }

  /**
   * temas.preguntas
   */
  export type temas$preguntasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preguntas
     */
    select?: preguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preguntas
     */
    omit?: preguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preguntasInclude<ExtArgs> | null
    where?: preguntasWhereInput
    orderBy?: preguntasOrderByWithRelationInput | preguntasOrderByWithRelationInput[]
    cursor?: preguntasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreguntasScalarFieldEnum | PreguntasScalarFieldEnum[]
  }

  /**
   * temas without action
   */
  export type temasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temas
     */
    select?: temasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the temas
     */
    omit?: temasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: temasInclude<ExtArgs> | null
  }


  /**
   * Model examenes
   */

  export type AggregateExamenes = {
    _count: ExamenesCountAggregateOutputType | null
    _avg: ExamenesAvgAggregateOutputType | null
    _sum: ExamenesSumAggregateOutputType | null
    _min: ExamenesMinAggregateOutputType | null
    _max: ExamenesMaxAggregateOutputType | null
  }

  export type ExamenesAvgAggregateOutputType = {
    notaMaxima: number | null
    notaMinima: number | null
  }

  export type ExamenesSumAggregateOutputType = {
    notaMaxima: number | null
    notaMinima: number | null
  }

  export type ExamenesMinAggregateOutputType = {
    id: string | null
    edicionId: string | null
    descripcion: string | null
    fechaDisponible: Date | null
    fechaLimite: Date | null
    notaMaxima: number | null
    notaMinima: number | null
    titulo: string | null
    creadoEn: Date | null
  }

  export type ExamenesMaxAggregateOutputType = {
    id: string | null
    edicionId: string | null
    descripcion: string | null
    fechaDisponible: Date | null
    fechaLimite: Date | null
    notaMaxima: number | null
    notaMinima: number | null
    titulo: string | null
    creadoEn: Date | null
  }

  export type ExamenesCountAggregateOutputType = {
    id: number
    edicionId: number
    descripcion: number
    fechaDisponible: number
    fechaLimite: number
    notaMaxima: number
    notaMinima: number
    titulo: number
    creadoEn: number
    _all: number
  }


  export type ExamenesAvgAggregateInputType = {
    notaMaxima?: true
    notaMinima?: true
  }

  export type ExamenesSumAggregateInputType = {
    notaMaxima?: true
    notaMinima?: true
  }

  export type ExamenesMinAggregateInputType = {
    id?: true
    edicionId?: true
    descripcion?: true
    fechaDisponible?: true
    fechaLimite?: true
    notaMaxima?: true
    notaMinima?: true
    titulo?: true
    creadoEn?: true
  }

  export type ExamenesMaxAggregateInputType = {
    id?: true
    edicionId?: true
    descripcion?: true
    fechaDisponible?: true
    fechaLimite?: true
    notaMaxima?: true
    notaMinima?: true
    titulo?: true
    creadoEn?: true
  }

  export type ExamenesCountAggregateInputType = {
    id?: true
    edicionId?: true
    descripcion?: true
    fechaDisponible?: true
    fechaLimite?: true
    notaMaxima?: true
    notaMinima?: true
    titulo?: true
    creadoEn?: true
    _all?: true
  }

  export type ExamenesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which examenes to aggregate.
     */
    where?: examenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examenes to fetch.
     */
    orderBy?: examenesOrderByWithRelationInput | examenesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: examenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examenes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examenes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned examenes
    **/
    _count?: true | ExamenesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamenesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamenesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamenesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamenesMaxAggregateInputType
  }

  export type GetExamenesAggregateType<T extends ExamenesAggregateArgs> = {
        [P in keyof T & keyof AggregateExamenes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamenes[P]>
      : GetScalarType<T[P], AggregateExamenes[P]>
  }




  export type examenesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: examenesWhereInput
    orderBy?: examenesOrderByWithAggregationInput | examenesOrderByWithAggregationInput[]
    by: ExamenesScalarFieldEnum[] | ExamenesScalarFieldEnum
    having?: examenesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamenesCountAggregateInputType | true
    _avg?: ExamenesAvgAggregateInputType
    _sum?: ExamenesSumAggregateInputType
    _min?: ExamenesMinAggregateInputType
    _max?: ExamenesMaxAggregateInputType
  }

  export type ExamenesGroupByOutputType = {
    id: string
    edicionId: string
    descripcion: string | null
    fechaDisponible: Date
    fechaLimite: Date
    notaMaxima: number
    notaMinima: number
    titulo: string
    creadoEn: Date
    _count: ExamenesCountAggregateOutputType | null
    _avg: ExamenesAvgAggregateOutputType | null
    _sum: ExamenesSumAggregateOutputType | null
    _min: ExamenesMinAggregateOutputType | null
    _max: ExamenesMaxAggregateOutputType | null
  }

  type GetExamenesGroupByPayload<T extends examenesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamenesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamenesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamenesGroupByOutputType[P]>
            : GetScalarType<T[P], ExamenesGroupByOutputType[P]>
        }
      >
    >


  export type examenesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    descripcion?: boolean
    fechaDisponible?: boolean
    fechaLimite?: boolean
    notaMaxima?: boolean
    notaMinima?: boolean
    titulo?: boolean
    creadoEn?: boolean
    calificaciones?: boolean | examenes$calificacionesArgs<ExtArgs>
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    _count?: boolean | ExamenesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examenes"]>

  export type examenesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    descripcion?: boolean
    fechaDisponible?: boolean
    fechaLimite?: boolean
    notaMaxima?: boolean
    notaMinima?: boolean
    titulo?: boolean
    creadoEn?: boolean
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examenes"]>

  export type examenesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    descripcion?: boolean
    fechaDisponible?: boolean
    fechaLimite?: boolean
    notaMaxima?: boolean
    notaMinima?: boolean
    titulo?: boolean
    creadoEn?: boolean
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examenes"]>

  export type examenesSelectScalar = {
    id?: boolean
    edicionId?: boolean
    descripcion?: boolean
    fechaDisponible?: boolean
    fechaLimite?: boolean
    notaMaxima?: boolean
    notaMinima?: boolean
    titulo?: boolean
    creadoEn?: boolean
  }

  export type examenesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "edicionId" | "descripcion" | "fechaDisponible" | "fechaLimite" | "notaMaxima" | "notaMinima" | "titulo" | "creadoEn", ExtArgs["result"]["examenes"]>
  export type examenesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calificaciones?: boolean | examenes$calificacionesArgs<ExtArgs>
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    _count?: boolean | ExamenesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type examenesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }
  export type examenesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }

  export type $examenesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "examenes"
    objects: {
      calificaciones: Prisma.$calificacionesPayload<ExtArgs>[]
      edicionesCursos: Prisma.$edicionesCursosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      edicionId: string
      descripcion: string | null
      fechaDisponible: Date
      fechaLimite: Date
      notaMaxima: number
      notaMinima: number
      titulo: string
      creadoEn: Date
    }, ExtArgs["result"]["examenes"]>
    composites: {}
  }

  type examenesGetPayload<S extends boolean | null | undefined | examenesDefaultArgs> = $Result.GetResult<Prisma.$examenesPayload, S>

  type examenesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<examenesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamenesCountAggregateInputType | true
    }

  export interface examenesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['examenes'], meta: { name: 'examenes' } }
    /**
     * Find zero or one Examenes that matches the filter.
     * @param {examenesFindUniqueArgs} args - Arguments to find a Examenes
     * @example
     * // Get one Examenes
     * const examenes = await prisma.examenes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends examenesFindUniqueArgs>(args: SelectSubset<T, examenesFindUniqueArgs<ExtArgs>>): Prisma__examenesClient<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Examenes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {examenesFindUniqueOrThrowArgs} args - Arguments to find a Examenes
     * @example
     * // Get one Examenes
     * const examenes = await prisma.examenes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends examenesFindUniqueOrThrowArgs>(args: SelectSubset<T, examenesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__examenesClient<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Examenes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examenesFindFirstArgs} args - Arguments to find a Examenes
     * @example
     * // Get one Examenes
     * const examenes = await prisma.examenes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends examenesFindFirstArgs>(args?: SelectSubset<T, examenesFindFirstArgs<ExtArgs>>): Prisma__examenesClient<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Examenes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examenesFindFirstOrThrowArgs} args - Arguments to find a Examenes
     * @example
     * // Get one Examenes
     * const examenes = await prisma.examenes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends examenesFindFirstOrThrowArgs>(args?: SelectSubset<T, examenesFindFirstOrThrowArgs<ExtArgs>>): Prisma__examenesClient<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Examenes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examenesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Examenes
     * const examenes = await prisma.examenes.findMany()
     * 
     * // Get first 10 Examenes
     * const examenes = await prisma.examenes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examenesWithIdOnly = await prisma.examenes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends examenesFindManyArgs>(args?: SelectSubset<T, examenesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Examenes.
     * @param {examenesCreateArgs} args - Arguments to create a Examenes.
     * @example
     * // Create one Examenes
     * const Examenes = await prisma.examenes.create({
     *   data: {
     *     // ... data to create a Examenes
     *   }
     * })
     * 
     */
    create<T extends examenesCreateArgs>(args: SelectSubset<T, examenesCreateArgs<ExtArgs>>): Prisma__examenesClient<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Examenes.
     * @param {examenesCreateManyArgs} args - Arguments to create many Examenes.
     * @example
     * // Create many Examenes
     * const examenes = await prisma.examenes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends examenesCreateManyArgs>(args?: SelectSubset<T, examenesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Examenes and returns the data saved in the database.
     * @param {examenesCreateManyAndReturnArgs} args - Arguments to create many Examenes.
     * @example
     * // Create many Examenes
     * const examenes = await prisma.examenes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Examenes and only return the `id`
     * const examenesWithIdOnly = await prisma.examenes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends examenesCreateManyAndReturnArgs>(args?: SelectSubset<T, examenesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Examenes.
     * @param {examenesDeleteArgs} args - Arguments to delete one Examenes.
     * @example
     * // Delete one Examenes
     * const Examenes = await prisma.examenes.delete({
     *   where: {
     *     // ... filter to delete one Examenes
     *   }
     * })
     * 
     */
    delete<T extends examenesDeleteArgs>(args: SelectSubset<T, examenesDeleteArgs<ExtArgs>>): Prisma__examenesClient<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Examenes.
     * @param {examenesUpdateArgs} args - Arguments to update one Examenes.
     * @example
     * // Update one Examenes
     * const examenes = await prisma.examenes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends examenesUpdateArgs>(args: SelectSubset<T, examenesUpdateArgs<ExtArgs>>): Prisma__examenesClient<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Examenes.
     * @param {examenesDeleteManyArgs} args - Arguments to filter Examenes to delete.
     * @example
     * // Delete a few Examenes
     * const { count } = await prisma.examenes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends examenesDeleteManyArgs>(args?: SelectSubset<T, examenesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Examenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examenesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Examenes
     * const examenes = await prisma.examenes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends examenesUpdateManyArgs>(args: SelectSubset<T, examenesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Examenes and returns the data updated in the database.
     * @param {examenesUpdateManyAndReturnArgs} args - Arguments to update many Examenes.
     * @example
     * // Update many Examenes
     * const examenes = await prisma.examenes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Examenes and only return the `id`
     * const examenesWithIdOnly = await prisma.examenes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends examenesUpdateManyAndReturnArgs>(args: SelectSubset<T, examenesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Examenes.
     * @param {examenesUpsertArgs} args - Arguments to update or create a Examenes.
     * @example
     * // Update or create a Examenes
     * const examenes = await prisma.examenes.upsert({
     *   create: {
     *     // ... data to create a Examenes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Examenes we want to update
     *   }
     * })
     */
    upsert<T extends examenesUpsertArgs>(args: SelectSubset<T, examenesUpsertArgs<ExtArgs>>): Prisma__examenesClient<$Result.GetResult<Prisma.$examenesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Examenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examenesCountArgs} args - Arguments to filter Examenes to count.
     * @example
     * // Count the number of Examenes
     * const count = await prisma.examenes.count({
     *   where: {
     *     // ... the filter for the Examenes we want to count
     *   }
     * })
    **/
    count<T extends examenesCountArgs>(
      args?: Subset<T, examenesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamenesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Examenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamenesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamenesAggregateArgs>(args: Subset<T, ExamenesAggregateArgs>): Prisma.PrismaPromise<GetExamenesAggregateType<T>>

    /**
     * Group by Examenes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examenesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends examenesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: examenesGroupByArgs['orderBy'] }
        : { orderBy?: examenesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, examenesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamenesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the examenes model
   */
  readonly fields: examenesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for examenes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__examenesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    calificaciones<T extends examenes$calificacionesArgs<ExtArgs> = {}>(args?: Subset<T, examenes$calificacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$calificacionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    edicionesCursos<T extends edicionesCursosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursosDefaultArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the examenes model
   */
  interface examenesFieldRefs {
    readonly id: FieldRef<"examenes", 'String'>
    readonly edicionId: FieldRef<"examenes", 'String'>
    readonly descripcion: FieldRef<"examenes", 'String'>
    readonly fechaDisponible: FieldRef<"examenes", 'DateTime'>
    readonly fechaLimite: FieldRef<"examenes", 'DateTime'>
    readonly notaMaxima: FieldRef<"examenes", 'Float'>
    readonly notaMinima: FieldRef<"examenes", 'Float'>
    readonly titulo: FieldRef<"examenes", 'String'>
    readonly creadoEn: FieldRef<"examenes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * examenes findUnique
   */
  export type examenesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesInclude<ExtArgs> | null
    /**
     * Filter, which examenes to fetch.
     */
    where: examenesWhereUniqueInput
  }

  /**
   * examenes findUniqueOrThrow
   */
  export type examenesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesInclude<ExtArgs> | null
    /**
     * Filter, which examenes to fetch.
     */
    where: examenesWhereUniqueInput
  }

  /**
   * examenes findFirst
   */
  export type examenesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesInclude<ExtArgs> | null
    /**
     * Filter, which examenes to fetch.
     */
    where?: examenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examenes to fetch.
     */
    orderBy?: examenesOrderByWithRelationInput | examenesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for examenes.
     */
    cursor?: examenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examenes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examenes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of examenes.
     */
    distinct?: ExamenesScalarFieldEnum | ExamenesScalarFieldEnum[]
  }

  /**
   * examenes findFirstOrThrow
   */
  export type examenesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesInclude<ExtArgs> | null
    /**
     * Filter, which examenes to fetch.
     */
    where?: examenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examenes to fetch.
     */
    orderBy?: examenesOrderByWithRelationInput | examenesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for examenes.
     */
    cursor?: examenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examenes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examenes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of examenes.
     */
    distinct?: ExamenesScalarFieldEnum | ExamenesScalarFieldEnum[]
  }

  /**
   * examenes findMany
   */
  export type examenesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesInclude<ExtArgs> | null
    /**
     * Filter, which examenes to fetch.
     */
    where?: examenesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examenes to fetch.
     */
    orderBy?: examenesOrderByWithRelationInput | examenesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing examenes.
     */
    cursor?: examenesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examenes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examenes.
     */
    skip?: number
    distinct?: ExamenesScalarFieldEnum | ExamenesScalarFieldEnum[]
  }

  /**
   * examenes create
   */
  export type examenesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesInclude<ExtArgs> | null
    /**
     * The data needed to create a examenes.
     */
    data: XOR<examenesCreateInput, examenesUncheckedCreateInput>
  }

  /**
   * examenes createMany
   */
  export type examenesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many examenes.
     */
    data: examenesCreateManyInput | examenesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * examenes createManyAndReturn
   */
  export type examenesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * The data used to create many examenes.
     */
    data: examenesCreateManyInput | examenesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * examenes update
   */
  export type examenesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesInclude<ExtArgs> | null
    /**
     * The data needed to update a examenes.
     */
    data: XOR<examenesUpdateInput, examenesUncheckedUpdateInput>
    /**
     * Choose, which examenes to update.
     */
    where: examenesWhereUniqueInput
  }

  /**
   * examenes updateMany
   */
  export type examenesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update examenes.
     */
    data: XOR<examenesUpdateManyMutationInput, examenesUncheckedUpdateManyInput>
    /**
     * Filter which examenes to update
     */
    where?: examenesWhereInput
    /**
     * Limit how many examenes to update.
     */
    limit?: number
  }

  /**
   * examenes updateManyAndReturn
   */
  export type examenesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * The data used to update examenes.
     */
    data: XOR<examenesUpdateManyMutationInput, examenesUncheckedUpdateManyInput>
    /**
     * Filter which examenes to update
     */
    where?: examenesWhereInput
    /**
     * Limit how many examenes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * examenes upsert
   */
  export type examenesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesInclude<ExtArgs> | null
    /**
     * The filter to search for the examenes to update in case it exists.
     */
    where: examenesWhereUniqueInput
    /**
     * In case the examenes found by the `where` argument doesn't exist, create a new examenes with this data.
     */
    create: XOR<examenesCreateInput, examenesUncheckedCreateInput>
    /**
     * In case the examenes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<examenesUpdateInput, examenesUncheckedUpdateInput>
  }

  /**
   * examenes delete
   */
  export type examenesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesInclude<ExtArgs> | null
    /**
     * Filter which examenes to delete.
     */
    where: examenesWhereUniqueInput
  }

  /**
   * examenes deleteMany
   */
  export type examenesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which examenes to delete
     */
    where?: examenesWhereInput
    /**
     * Limit how many examenes to delete.
     */
    limit?: number
  }

  /**
   * examenes.calificaciones
   */
  export type examenes$calificacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calificaciones
     */
    select?: calificacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calificaciones
     */
    omit?: calificacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calificacionesInclude<ExtArgs> | null
    where?: calificacionesWhereInput
    orderBy?: calificacionesOrderByWithRelationInput | calificacionesOrderByWithRelationInput[]
    cursor?: calificacionesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalificacionesScalarFieldEnum | CalificacionesScalarFieldEnum[]
  }

  /**
   * examenes without action
   */
  export type examenesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the examenes
     */
    select?: examenesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the examenes
     */
    omit?: examenesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examenesInclude<ExtArgs> | null
  }


  /**
   * Model grabaciones
   */

  export type AggregateGrabaciones = {
    _count: GrabacionesCountAggregateOutputType | null
    _avg: GrabacionesAvgAggregateOutputType | null
    _sum: GrabacionesSumAggregateOutputType | null
    _min: GrabacionesMinAggregateOutputType | null
    _max: GrabacionesMaxAggregateOutputType | null
  }

  export type GrabacionesAvgAggregateOutputType = {
    duracionSegundos: number | null
  }

  export type GrabacionesSumAggregateOutputType = {
    duracionSegundos: number | null
  }

  export type GrabacionesMinAggregateOutputType = {
    id: string | null
    claseId: string | null
    usuarioId: string | null
    fechaInicio: Date | null
    fechaFin: Date | null
    duracionSegundos: number | null
    completada: boolean | null
  }

  export type GrabacionesMaxAggregateOutputType = {
    id: string | null
    claseId: string | null
    usuarioId: string | null
    fechaInicio: Date | null
    fechaFin: Date | null
    duracionSegundos: number | null
    completada: boolean | null
  }

  export type GrabacionesCountAggregateOutputType = {
    id: number
    claseId: number
    usuarioId: number
    fechaInicio: number
    fechaFin: number
    duracionSegundos: number
    completada: number
    _all: number
  }


  export type GrabacionesAvgAggregateInputType = {
    duracionSegundos?: true
  }

  export type GrabacionesSumAggregateInputType = {
    duracionSegundos?: true
  }

  export type GrabacionesMinAggregateInputType = {
    id?: true
    claseId?: true
    usuarioId?: true
    fechaInicio?: true
    fechaFin?: true
    duracionSegundos?: true
    completada?: true
  }

  export type GrabacionesMaxAggregateInputType = {
    id?: true
    claseId?: true
    usuarioId?: true
    fechaInicio?: true
    fechaFin?: true
    duracionSegundos?: true
    completada?: true
  }

  export type GrabacionesCountAggregateInputType = {
    id?: true
    claseId?: true
    usuarioId?: true
    fechaInicio?: true
    fechaFin?: true
    duracionSegundos?: true
    completada?: true
    _all?: true
  }

  export type GrabacionesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which grabaciones to aggregate.
     */
    where?: grabacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grabaciones to fetch.
     */
    orderBy?: grabacionesOrderByWithRelationInput | grabacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: grabacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grabaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grabaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned grabaciones
    **/
    _count?: true | GrabacionesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GrabacionesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GrabacionesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GrabacionesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GrabacionesMaxAggregateInputType
  }

  export type GetGrabacionesAggregateType<T extends GrabacionesAggregateArgs> = {
        [P in keyof T & keyof AggregateGrabaciones]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrabaciones[P]>
      : GetScalarType<T[P], AggregateGrabaciones[P]>
  }




  export type grabacionesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: grabacionesWhereInput
    orderBy?: grabacionesOrderByWithAggregationInput | grabacionesOrderByWithAggregationInput[]
    by: GrabacionesScalarFieldEnum[] | GrabacionesScalarFieldEnum
    having?: grabacionesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GrabacionesCountAggregateInputType | true
    _avg?: GrabacionesAvgAggregateInputType
    _sum?: GrabacionesSumAggregateInputType
    _min?: GrabacionesMinAggregateInputType
    _max?: GrabacionesMaxAggregateInputType
  }

  export type GrabacionesGroupByOutputType = {
    id: string
    claseId: string
    usuarioId: string
    fechaInicio: Date
    fechaFin: Date | null
    duracionSegundos: number | null
    completada: boolean
    _count: GrabacionesCountAggregateOutputType | null
    _avg: GrabacionesAvgAggregateOutputType | null
    _sum: GrabacionesSumAggregateOutputType | null
    _min: GrabacionesMinAggregateOutputType | null
    _max: GrabacionesMaxAggregateOutputType | null
  }

  type GetGrabacionesGroupByPayload<T extends grabacionesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GrabacionesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GrabacionesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GrabacionesGroupByOutputType[P]>
            : GetScalarType<T[P], GrabacionesGroupByOutputType[P]>
        }
      >
    >


  export type grabacionesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claseId?: boolean
    usuarioId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    duracionSegundos?: boolean
    completada?: boolean
    clases?: boolean | clasesDefaultArgs<ExtArgs>
    usuariosAdministradores?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grabaciones"]>

  export type grabacionesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claseId?: boolean
    usuarioId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    duracionSegundos?: boolean
    completada?: boolean
    clases?: boolean | clasesDefaultArgs<ExtArgs>
    usuariosAdministradores?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grabaciones"]>

  export type grabacionesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claseId?: boolean
    usuarioId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    duracionSegundos?: boolean
    completada?: boolean
    clases?: boolean | clasesDefaultArgs<ExtArgs>
    usuariosAdministradores?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grabaciones"]>

  export type grabacionesSelectScalar = {
    id?: boolean
    claseId?: boolean
    usuarioId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    duracionSegundos?: boolean
    completada?: boolean
  }

  export type grabacionesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "claseId" | "usuarioId" | "fechaInicio" | "fechaFin" | "duracionSegundos" | "completada", ExtArgs["result"]["grabaciones"]>
  export type grabacionesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clases?: boolean | clasesDefaultArgs<ExtArgs>
    usuariosAdministradores?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }
  export type grabacionesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clases?: boolean | clasesDefaultArgs<ExtArgs>
    usuariosAdministradores?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }
  export type grabacionesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clases?: boolean | clasesDefaultArgs<ExtArgs>
    usuariosAdministradores?: boolean | usuariosAdministradoresDefaultArgs<ExtArgs>
  }

  export type $grabacionesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "grabaciones"
    objects: {
      clases: Prisma.$clasesPayload<ExtArgs>
      usuariosAdministradores: Prisma.$usuariosAdministradoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      claseId: string
      usuarioId: string
      fechaInicio: Date
      fechaFin: Date | null
      duracionSegundos: number | null
      completada: boolean
    }, ExtArgs["result"]["grabaciones"]>
    composites: {}
  }

  type grabacionesGetPayload<S extends boolean | null | undefined | grabacionesDefaultArgs> = $Result.GetResult<Prisma.$grabacionesPayload, S>

  type grabacionesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<grabacionesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GrabacionesCountAggregateInputType | true
    }

  export interface grabacionesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['grabaciones'], meta: { name: 'grabaciones' } }
    /**
     * Find zero or one Grabaciones that matches the filter.
     * @param {grabacionesFindUniqueArgs} args - Arguments to find a Grabaciones
     * @example
     * // Get one Grabaciones
     * const grabaciones = await prisma.grabaciones.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends grabacionesFindUniqueArgs>(args: SelectSubset<T, grabacionesFindUniqueArgs<ExtArgs>>): Prisma__grabacionesClient<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Grabaciones that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {grabacionesFindUniqueOrThrowArgs} args - Arguments to find a Grabaciones
     * @example
     * // Get one Grabaciones
     * const grabaciones = await prisma.grabaciones.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends grabacionesFindUniqueOrThrowArgs>(args: SelectSubset<T, grabacionesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__grabacionesClient<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grabaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grabacionesFindFirstArgs} args - Arguments to find a Grabaciones
     * @example
     * // Get one Grabaciones
     * const grabaciones = await prisma.grabaciones.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends grabacionesFindFirstArgs>(args?: SelectSubset<T, grabacionesFindFirstArgs<ExtArgs>>): Prisma__grabacionesClient<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grabaciones that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grabacionesFindFirstOrThrowArgs} args - Arguments to find a Grabaciones
     * @example
     * // Get one Grabaciones
     * const grabaciones = await prisma.grabaciones.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends grabacionesFindFirstOrThrowArgs>(args?: SelectSubset<T, grabacionesFindFirstOrThrowArgs<ExtArgs>>): Prisma__grabacionesClient<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Grabaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grabacionesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grabaciones
     * const grabaciones = await prisma.grabaciones.findMany()
     * 
     * // Get first 10 Grabaciones
     * const grabaciones = await prisma.grabaciones.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const grabacionesWithIdOnly = await prisma.grabaciones.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends grabacionesFindManyArgs>(args?: SelectSubset<T, grabacionesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Grabaciones.
     * @param {grabacionesCreateArgs} args - Arguments to create a Grabaciones.
     * @example
     * // Create one Grabaciones
     * const Grabaciones = await prisma.grabaciones.create({
     *   data: {
     *     // ... data to create a Grabaciones
     *   }
     * })
     * 
     */
    create<T extends grabacionesCreateArgs>(args: SelectSubset<T, grabacionesCreateArgs<ExtArgs>>): Prisma__grabacionesClient<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Grabaciones.
     * @param {grabacionesCreateManyArgs} args - Arguments to create many Grabaciones.
     * @example
     * // Create many Grabaciones
     * const grabaciones = await prisma.grabaciones.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends grabacionesCreateManyArgs>(args?: SelectSubset<T, grabacionesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Grabaciones and returns the data saved in the database.
     * @param {grabacionesCreateManyAndReturnArgs} args - Arguments to create many Grabaciones.
     * @example
     * // Create many Grabaciones
     * const grabaciones = await prisma.grabaciones.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Grabaciones and only return the `id`
     * const grabacionesWithIdOnly = await prisma.grabaciones.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends grabacionesCreateManyAndReturnArgs>(args?: SelectSubset<T, grabacionesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Grabaciones.
     * @param {grabacionesDeleteArgs} args - Arguments to delete one Grabaciones.
     * @example
     * // Delete one Grabaciones
     * const Grabaciones = await prisma.grabaciones.delete({
     *   where: {
     *     // ... filter to delete one Grabaciones
     *   }
     * })
     * 
     */
    delete<T extends grabacionesDeleteArgs>(args: SelectSubset<T, grabacionesDeleteArgs<ExtArgs>>): Prisma__grabacionesClient<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Grabaciones.
     * @param {grabacionesUpdateArgs} args - Arguments to update one Grabaciones.
     * @example
     * // Update one Grabaciones
     * const grabaciones = await prisma.grabaciones.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends grabacionesUpdateArgs>(args: SelectSubset<T, grabacionesUpdateArgs<ExtArgs>>): Prisma__grabacionesClient<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Grabaciones.
     * @param {grabacionesDeleteManyArgs} args - Arguments to filter Grabaciones to delete.
     * @example
     * // Delete a few Grabaciones
     * const { count } = await prisma.grabaciones.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends grabacionesDeleteManyArgs>(args?: SelectSubset<T, grabacionesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grabaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grabacionesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grabaciones
     * const grabaciones = await prisma.grabaciones.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends grabacionesUpdateManyArgs>(args: SelectSubset<T, grabacionesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grabaciones and returns the data updated in the database.
     * @param {grabacionesUpdateManyAndReturnArgs} args - Arguments to update many Grabaciones.
     * @example
     * // Update many Grabaciones
     * const grabaciones = await prisma.grabaciones.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Grabaciones and only return the `id`
     * const grabacionesWithIdOnly = await prisma.grabaciones.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends grabacionesUpdateManyAndReturnArgs>(args: SelectSubset<T, grabacionesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Grabaciones.
     * @param {grabacionesUpsertArgs} args - Arguments to update or create a Grabaciones.
     * @example
     * // Update or create a Grabaciones
     * const grabaciones = await prisma.grabaciones.upsert({
     *   create: {
     *     // ... data to create a Grabaciones
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grabaciones we want to update
     *   }
     * })
     */
    upsert<T extends grabacionesUpsertArgs>(args: SelectSubset<T, grabacionesUpsertArgs<ExtArgs>>): Prisma__grabacionesClient<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Grabaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grabacionesCountArgs} args - Arguments to filter Grabaciones to count.
     * @example
     * // Count the number of Grabaciones
     * const count = await prisma.grabaciones.count({
     *   where: {
     *     // ... the filter for the Grabaciones we want to count
     *   }
     * })
    **/
    count<T extends grabacionesCountArgs>(
      args?: Subset<T, grabacionesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GrabacionesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grabaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrabacionesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GrabacionesAggregateArgs>(args: Subset<T, GrabacionesAggregateArgs>): Prisma.PrismaPromise<GetGrabacionesAggregateType<T>>

    /**
     * Group by Grabaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {grabacionesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends grabacionesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: grabacionesGroupByArgs['orderBy'] }
        : { orderBy?: grabacionesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, grabacionesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGrabacionesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the grabaciones model
   */
  readonly fields: grabacionesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for grabaciones.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__grabacionesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clases<T extends clasesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clasesDefaultArgs<ExtArgs>>): Prisma__clasesClient<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usuariosAdministradores<T extends usuariosAdministradoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usuariosAdministradoresDefaultArgs<ExtArgs>>): Prisma__usuariosAdministradoresClient<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the grabaciones model
   */
  interface grabacionesFieldRefs {
    readonly id: FieldRef<"grabaciones", 'String'>
    readonly claseId: FieldRef<"grabaciones", 'String'>
    readonly usuarioId: FieldRef<"grabaciones", 'String'>
    readonly fechaInicio: FieldRef<"grabaciones", 'DateTime'>
    readonly fechaFin: FieldRef<"grabaciones", 'DateTime'>
    readonly duracionSegundos: FieldRef<"grabaciones", 'Int'>
    readonly completada: FieldRef<"grabaciones", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * grabaciones findUnique
   */
  export type grabacionesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesInclude<ExtArgs> | null
    /**
     * Filter, which grabaciones to fetch.
     */
    where: grabacionesWhereUniqueInput
  }

  /**
   * grabaciones findUniqueOrThrow
   */
  export type grabacionesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesInclude<ExtArgs> | null
    /**
     * Filter, which grabaciones to fetch.
     */
    where: grabacionesWhereUniqueInput
  }

  /**
   * grabaciones findFirst
   */
  export type grabacionesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesInclude<ExtArgs> | null
    /**
     * Filter, which grabaciones to fetch.
     */
    where?: grabacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grabaciones to fetch.
     */
    orderBy?: grabacionesOrderByWithRelationInput | grabacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for grabaciones.
     */
    cursor?: grabacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grabaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grabaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of grabaciones.
     */
    distinct?: GrabacionesScalarFieldEnum | GrabacionesScalarFieldEnum[]
  }

  /**
   * grabaciones findFirstOrThrow
   */
  export type grabacionesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesInclude<ExtArgs> | null
    /**
     * Filter, which grabaciones to fetch.
     */
    where?: grabacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grabaciones to fetch.
     */
    orderBy?: grabacionesOrderByWithRelationInput | grabacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for grabaciones.
     */
    cursor?: grabacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grabaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grabaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of grabaciones.
     */
    distinct?: GrabacionesScalarFieldEnum | GrabacionesScalarFieldEnum[]
  }

  /**
   * grabaciones findMany
   */
  export type grabacionesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesInclude<ExtArgs> | null
    /**
     * Filter, which grabaciones to fetch.
     */
    where?: grabacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of grabaciones to fetch.
     */
    orderBy?: grabacionesOrderByWithRelationInput | grabacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing grabaciones.
     */
    cursor?: grabacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` grabaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` grabaciones.
     */
    skip?: number
    distinct?: GrabacionesScalarFieldEnum | GrabacionesScalarFieldEnum[]
  }

  /**
   * grabaciones create
   */
  export type grabacionesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesInclude<ExtArgs> | null
    /**
     * The data needed to create a grabaciones.
     */
    data: XOR<grabacionesCreateInput, grabacionesUncheckedCreateInput>
  }

  /**
   * grabaciones createMany
   */
  export type grabacionesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many grabaciones.
     */
    data: grabacionesCreateManyInput | grabacionesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * grabaciones createManyAndReturn
   */
  export type grabacionesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * The data used to create many grabaciones.
     */
    data: grabacionesCreateManyInput | grabacionesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * grabaciones update
   */
  export type grabacionesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesInclude<ExtArgs> | null
    /**
     * The data needed to update a grabaciones.
     */
    data: XOR<grabacionesUpdateInput, grabacionesUncheckedUpdateInput>
    /**
     * Choose, which grabaciones to update.
     */
    where: grabacionesWhereUniqueInput
  }

  /**
   * grabaciones updateMany
   */
  export type grabacionesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update grabaciones.
     */
    data: XOR<grabacionesUpdateManyMutationInput, grabacionesUncheckedUpdateManyInput>
    /**
     * Filter which grabaciones to update
     */
    where?: grabacionesWhereInput
    /**
     * Limit how many grabaciones to update.
     */
    limit?: number
  }

  /**
   * grabaciones updateManyAndReturn
   */
  export type grabacionesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * The data used to update grabaciones.
     */
    data: XOR<grabacionesUpdateManyMutationInput, grabacionesUncheckedUpdateManyInput>
    /**
     * Filter which grabaciones to update
     */
    where?: grabacionesWhereInput
    /**
     * Limit how many grabaciones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * grabaciones upsert
   */
  export type grabacionesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesInclude<ExtArgs> | null
    /**
     * The filter to search for the grabaciones to update in case it exists.
     */
    where: grabacionesWhereUniqueInput
    /**
     * In case the grabaciones found by the `where` argument doesn't exist, create a new grabaciones with this data.
     */
    create: XOR<grabacionesCreateInput, grabacionesUncheckedCreateInput>
    /**
     * In case the grabaciones was found with the provided `where` argument, update it with this data.
     */
    update: XOR<grabacionesUpdateInput, grabacionesUncheckedUpdateInput>
  }

  /**
   * grabaciones delete
   */
  export type grabacionesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesInclude<ExtArgs> | null
    /**
     * Filter which grabaciones to delete.
     */
    where: grabacionesWhereUniqueInput
  }

  /**
   * grabaciones deleteMany
   */
  export type grabacionesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which grabaciones to delete
     */
    where?: grabacionesWhereInput
    /**
     * Limit how many grabaciones to delete.
     */
    limit?: number
  }

  /**
   * grabaciones without action
   */
  export type grabacionesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesInclude<ExtArgs> | null
  }


  /**
   * Model inscripciones
   */

  export type AggregateInscripciones = {
    _count: InscripcionesCountAggregateOutputType | null
    _min: InscripcionesMinAggregateOutputType | null
    _max: InscripcionesMaxAggregateOutputType | null
  }

  export type InscripcionesMinAggregateOutputType = {
    id: string | null
    edicionId: string | null
    estado: boolean | null
    estudianteId: string | null
    inscritoEn: Date | null
    compraId: string | null
  }

  export type InscripcionesMaxAggregateOutputType = {
    id: string | null
    edicionId: string | null
    estado: boolean | null
    estudianteId: string | null
    inscritoEn: Date | null
    compraId: string | null
  }

  export type InscripcionesCountAggregateOutputType = {
    id: number
    edicionId: number
    estado: number
    estudianteId: number
    inscritoEn: number
    compraId: number
    _all: number
  }


  export type InscripcionesMinAggregateInputType = {
    id?: true
    edicionId?: true
    estado?: true
    estudianteId?: true
    inscritoEn?: true
    compraId?: true
  }

  export type InscripcionesMaxAggregateInputType = {
    id?: true
    edicionId?: true
    estado?: true
    estudianteId?: true
    inscritoEn?: true
    compraId?: true
  }

  export type InscripcionesCountAggregateInputType = {
    id?: true
    edicionId?: true
    estado?: true
    estudianteId?: true
    inscritoEn?: true
    compraId?: true
    _all?: true
  }

  export type InscripcionesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inscripciones to aggregate.
     */
    where?: inscripcionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inscripciones to fetch.
     */
    orderBy?: inscripcionesOrderByWithRelationInput | inscripcionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inscripcionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inscripciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inscripciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inscripciones
    **/
    _count?: true | InscripcionesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InscripcionesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InscripcionesMaxAggregateInputType
  }

  export type GetInscripcionesAggregateType<T extends InscripcionesAggregateArgs> = {
        [P in keyof T & keyof AggregateInscripciones]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInscripciones[P]>
      : GetScalarType<T[P], AggregateInscripciones[P]>
  }




  export type inscripcionesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inscripcionesWhereInput
    orderBy?: inscripcionesOrderByWithAggregationInput | inscripcionesOrderByWithAggregationInput[]
    by: InscripcionesScalarFieldEnum[] | InscripcionesScalarFieldEnum
    having?: inscripcionesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InscripcionesCountAggregateInputType | true
    _min?: InscripcionesMinAggregateInputType
    _max?: InscripcionesMaxAggregateInputType
  }

  export type InscripcionesGroupByOutputType = {
    id: string
    edicionId: string
    estado: boolean
    estudianteId: string
    inscritoEn: Date
    compraId: string
    _count: InscripcionesCountAggregateOutputType | null
    _min: InscripcionesMinAggregateOutputType | null
    _max: InscripcionesMaxAggregateOutputType | null
  }

  type GetInscripcionesGroupByPayload<T extends inscripcionesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InscripcionesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InscripcionesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InscripcionesGroupByOutputType[P]>
            : GetScalarType<T[P], InscripcionesGroupByOutputType[P]>
        }
      >
    >


  export type inscripcionesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    estado?: boolean
    estudianteId?: boolean
    inscritoEn?: boolean
    compraId?: boolean
    compras?: boolean | comprasDefaultArgs<ExtArgs>
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    estudiantes?: boolean | estudiantesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inscripciones"]>

  export type inscripcionesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    estado?: boolean
    estudianteId?: boolean
    inscritoEn?: boolean
    compraId?: boolean
    compras?: boolean | comprasDefaultArgs<ExtArgs>
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    estudiantes?: boolean | estudiantesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inscripciones"]>

  export type inscripcionesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    estado?: boolean
    estudianteId?: boolean
    inscritoEn?: boolean
    compraId?: boolean
    compras?: boolean | comprasDefaultArgs<ExtArgs>
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    estudiantes?: boolean | estudiantesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inscripciones"]>

  export type inscripcionesSelectScalar = {
    id?: boolean
    edicionId?: boolean
    estado?: boolean
    estudianteId?: boolean
    inscritoEn?: boolean
    compraId?: boolean
  }

  export type inscripcionesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "edicionId" | "estado" | "estudianteId" | "inscritoEn" | "compraId", ExtArgs["result"]["inscripciones"]>
  export type inscripcionesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    compras?: boolean | comprasDefaultArgs<ExtArgs>
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    estudiantes?: boolean | estudiantesDefaultArgs<ExtArgs>
  }
  export type inscripcionesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    compras?: boolean | comprasDefaultArgs<ExtArgs>
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    estudiantes?: boolean | estudiantesDefaultArgs<ExtArgs>
  }
  export type inscripcionesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    compras?: boolean | comprasDefaultArgs<ExtArgs>
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
    estudiantes?: boolean | estudiantesDefaultArgs<ExtArgs>
  }

  export type $inscripcionesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "inscripciones"
    objects: {
      compras: Prisma.$comprasPayload<ExtArgs>
      edicionesCursos: Prisma.$edicionesCursosPayload<ExtArgs>
      estudiantes: Prisma.$estudiantesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      edicionId: string
      estado: boolean
      estudianteId: string
      inscritoEn: Date
      compraId: string
    }, ExtArgs["result"]["inscripciones"]>
    composites: {}
  }

  type inscripcionesGetPayload<S extends boolean | null | undefined | inscripcionesDefaultArgs> = $Result.GetResult<Prisma.$inscripcionesPayload, S>

  type inscripcionesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<inscripcionesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InscripcionesCountAggregateInputType | true
    }

  export interface inscripcionesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inscripciones'], meta: { name: 'inscripciones' } }
    /**
     * Find zero or one Inscripciones that matches the filter.
     * @param {inscripcionesFindUniqueArgs} args - Arguments to find a Inscripciones
     * @example
     * // Get one Inscripciones
     * const inscripciones = await prisma.inscripciones.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends inscripcionesFindUniqueArgs>(args: SelectSubset<T, inscripcionesFindUniqueArgs<ExtArgs>>): Prisma__inscripcionesClient<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inscripciones that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {inscripcionesFindUniqueOrThrowArgs} args - Arguments to find a Inscripciones
     * @example
     * // Get one Inscripciones
     * const inscripciones = await prisma.inscripciones.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends inscripcionesFindUniqueOrThrowArgs>(args: SelectSubset<T, inscripcionesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__inscripcionesClient<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inscripciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inscripcionesFindFirstArgs} args - Arguments to find a Inscripciones
     * @example
     * // Get one Inscripciones
     * const inscripciones = await prisma.inscripciones.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends inscripcionesFindFirstArgs>(args?: SelectSubset<T, inscripcionesFindFirstArgs<ExtArgs>>): Prisma__inscripcionesClient<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inscripciones that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inscripcionesFindFirstOrThrowArgs} args - Arguments to find a Inscripciones
     * @example
     * // Get one Inscripciones
     * const inscripciones = await prisma.inscripciones.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends inscripcionesFindFirstOrThrowArgs>(args?: SelectSubset<T, inscripcionesFindFirstOrThrowArgs<ExtArgs>>): Prisma__inscripcionesClient<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inscripciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inscripcionesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inscripciones
     * const inscripciones = await prisma.inscripciones.findMany()
     * 
     * // Get first 10 Inscripciones
     * const inscripciones = await prisma.inscripciones.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inscripcionesWithIdOnly = await prisma.inscripciones.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends inscripcionesFindManyArgs>(args?: SelectSubset<T, inscripcionesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inscripciones.
     * @param {inscripcionesCreateArgs} args - Arguments to create a Inscripciones.
     * @example
     * // Create one Inscripciones
     * const Inscripciones = await prisma.inscripciones.create({
     *   data: {
     *     // ... data to create a Inscripciones
     *   }
     * })
     * 
     */
    create<T extends inscripcionesCreateArgs>(args: SelectSubset<T, inscripcionesCreateArgs<ExtArgs>>): Prisma__inscripcionesClient<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inscripciones.
     * @param {inscripcionesCreateManyArgs} args - Arguments to create many Inscripciones.
     * @example
     * // Create many Inscripciones
     * const inscripciones = await prisma.inscripciones.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends inscripcionesCreateManyArgs>(args?: SelectSubset<T, inscripcionesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inscripciones and returns the data saved in the database.
     * @param {inscripcionesCreateManyAndReturnArgs} args - Arguments to create many Inscripciones.
     * @example
     * // Create many Inscripciones
     * const inscripciones = await prisma.inscripciones.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inscripciones and only return the `id`
     * const inscripcionesWithIdOnly = await prisma.inscripciones.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends inscripcionesCreateManyAndReturnArgs>(args?: SelectSubset<T, inscripcionesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Inscripciones.
     * @param {inscripcionesDeleteArgs} args - Arguments to delete one Inscripciones.
     * @example
     * // Delete one Inscripciones
     * const Inscripciones = await prisma.inscripciones.delete({
     *   where: {
     *     // ... filter to delete one Inscripciones
     *   }
     * })
     * 
     */
    delete<T extends inscripcionesDeleteArgs>(args: SelectSubset<T, inscripcionesDeleteArgs<ExtArgs>>): Prisma__inscripcionesClient<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inscripciones.
     * @param {inscripcionesUpdateArgs} args - Arguments to update one Inscripciones.
     * @example
     * // Update one Inscripciones
     * const inscripciones = await prisma.inscripciones.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends inscripcionesUpdateArgs>(args: SelectSubset<T, inscripcionesUpdateArgs<ExtArgs>>): Prisma__inscripcionesClient<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inscripciones.
     * @param {inscripcionesDeleteManyArgs} args - Arguments to filter Inscripciones to delete.
     * @example
     * // Delete a few Inscripciones
     * const { count } = await prisma.inscripciones.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends inscripcionesDeleteManyArgs>(args?: SelectSubset<T, inscripcionesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inscripciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inscripcionesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inscripciones
     * const inscripciones = await prisma.inscripciones.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends inscripcionesUpdateManyArgs>(args: SelectSubset<T, inscripcionesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inscripciones and returns the data updated in the database.
     * @param {inscripcionesUpdateManyAndReturnArgs} args - Arguments to update many Inscripciones.
     * @example
     * // Update many Inscripciones
     * const inscripciones = await prisma.inscripciones.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inscripciones and only return the `id`
     * const inscripcionesWithIdOnly = await prisma.inscripciones.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends inscripcionesUpdateManyAndReturnArgs>(args: SelectSubset<T, inscripcionesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Inscripciones.
     * @param {inscripcionesUpsertArgs} args - Arguments to update or create a Inscripciones.
     * @example
     * // Update or create a Inscripciones
     * const inscripciones = await prisma.inscripciones.upsert({
     *   create: {
     *     // ... data to create a Inscripciones
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inscripciones we want to update
     *   }
     * })
     */
    upsert<T extends inscripcionesUpsertArgs>(args: SelectSubset<T, inscripcionesUpsertArgs<ExtArgs>>): Prisma__inscripcionesClient<$Result.GetResult<Prisma.$inscripcionesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inscripciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inscripcionesCountArgs} args - Arguments to filter Inscripciones to count.
     * @example
     * // Count the number of Inscripciones
     * const count = await prisma.inscripciones.count({
     *   where: {
     *     // ... the filter for the Inscripciones we want to count
     *   }
     * })
    **/
    count<T extends inscripcionesCountArgs>(
      args?: Subset<T, inscripcionesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InscripcionesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inscripciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InscripcionesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InscripcionesAggregateArgs>(args: Subset<T, InscripcionesAggregateArgs>): Prisma.PrismaPromise<GetInscripcionesAggregateType<T>>

    /**
     * Group by Inscripciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inscripcionesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inscripcionesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inscripcionesGroupByArgs['orderBy'] }
        : { orderBy?: inscripcionesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inscripcionesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInscripcionesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inscripciones model
   */
  readonly fields: inscripcionesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inscripciones.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inscripcionesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    compras<T extends comprasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, comprasDefaultArgs<ExtArgs>>): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    edicionesCursos<T extends edicionesCursosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursosDefaultArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    estudiantes<T extends estudiantesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, estudiantesDefaultArgs<ExtArgs>>): Prisma__estudiantesClient<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the inscripciones model
   */
  interface inscripcionesFieldRefs {
    readonly id: FieldRef<"inscripciones", 'String'>
    readonly edicionId: FieldRef<"inscripciones", 'String'>
    readonly estado: FieldRef<"inscripciones", 'Boolean'>
    readonly estudianteId: FieldRef<"inscripciones", 'String'>
    readonly inscritoEn: FieldRef<"inscripciones", 'DateTime'>
    readonly compraId: FieldRef<"inscripciones", 'String'>
  }
    

  // Custom InputTypes
  /**
   * inscripciones findUnique
   */
  export type inscripcionesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
    /**
     * Filter, which inscripciones to fetch.
     */
    where: inscripcionesWhereUniqueInput
  }

  /**
   * inscripciones findUniqueOrThrow
   */
  export type inscripcionesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
    /**
     * Filter, which inscripciones to fetch.
     */
    where: inscripcionesWhereUniqueInput
  }

  /**
   * inscripciones findFirst
   */
  export type inscripcionesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
    /**
     * Filter, which inscripciones to fetch.
     */
    where?: inscripcionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inscripciones to fetch.
     */
    orderBy?: inscripcionesOrderByWithRelationInput | inscripcionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inscripciones.
     */
    cursor?: inscripcionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inscripciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inscripciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inscripciones.
     */
    distinct?: InscripcionesScalarFieldEnum | InscripcionesScalarFieldEnum[]
  }

  /**
   * inscripciones findFirstOrThrow
   */
  export type inscripcionesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
    /**
     * Filter, which inscripciones to fetch.
     */
    where?: inscripcionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inscripciones to fetch.
     */
    orderBy?: inscripcionesOrderByWithRelationInput | inscripcionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inscripciones.
     */
    cursor?: inscripcionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inscripciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inscripciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inscripciones.
     */
    distinct?: InscripcionesScalarFieldEnum | InscripcionesScalarFieldEnum[]
  }

  /**
   * inscripciones findMany
   */
  export type inscripcionesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
    /**
     * Filter, which inscripciones to fetch.
     */
    where?: inscripcionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inscripciones to fetch.
     */
    orderBy?: inscripcionesOrderByWithRelationInput | inscripcionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inscripciones.
     */
    cursor?: inscripcionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inscripciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inscripciones.
     */
    skip?: number
    distinct?: InscripcionesScalarFieldEnum | InscripcionesScalarFieldEnum[]
  }

  /**
   * inscripciones create
   */
  export type inscripcionesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
    /**
     * The data needed to create a inscripciones.
     */
    data: XOR<inscripcionesCreateInput, inscripcionesUncheckedCreateInput>
  }

  /**
   * inscripciones createMany
   */
  export type inscripcionesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inscripciones.
     */
    data: inscripcionesCreateManyInput | inscripcionesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * inscripciones createManyAndReturn
   */
  export type inscripcionesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * The data used to create many inscripciones.
     */
    data: inscripcionesCreateManyInput | inscripcionesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * inscripciones update
   */
  export type inscripcionesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
    /**
     * The data needed to update a inscripciones.
     */
    data: XOR<inscripcionesUpdateInput, inscripcionesUncheckedUpdateInput>
    /**
     * Choose, which inscripciones to update.
     */
    where: inscripcionesWhereUniqueInput
  }

  /**
   * inscripciones updateMany
   */
  export type inscripcionesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inscripciones.
     */
    data: XOR<inscripcionesUpdateManyMutationInput, inscripcionesUncheckedUpdateManyInput>
    /**
     * Filter which inscripciones to update
     */
    where?: inscripcionesWhereInput
    /**
     * Limit how many inscripciones to update.
     */
    limit?: number
  }

  /**
   * inscripciones updateManyAndReturn
   */
  export type inscripcionesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * The data used to update inscripciones.
     */
    data: XOR<inscripcionesUpdateManyMutationInput, inscripcionesUncheckedUpdateManyInput>
    /**
     * Filter which inscripciones to update
     */
    where?: inscripcionesWhereInput
    /**
     * Limit how many inscripciones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * inscripciones upsert
   */
  export type inscripcionesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
    /**
     * The filter to search for the inscripciones to update in case it exists.
     */
    where: inscripcionesWhereUniqueInput
    /**
     * In case the inscripciones found by the `where` argument doesn't exist, create a new inscripciones with this data.
     */
    create: XOR<inscripcionesCreateInput, inscripcionesUncheckedCreateInput>
    /**
     * In case the inscripciones was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inscripcionesUpdateInput, inscripcionesUncheckedUpdateInput>
  }

  /**
   * inscripciones delete
   */
  export type inscripcionesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
    /**
     * Filter which inscripciones to delete.
     */
    where: inscripcionesWhereUniqueInput
  }

  /**
   * inscripciones deleteMany
   */
  export type inscripcionesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inscripciones to delete
     */
    where?: inscripcionesWhereInput
    /**
     * Limit how many inscripciones to delete.
     */
    limit?: number
  }

  /**
   * inscripciones without action
   */
  export type inscripcionesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inscripciones
     */
    select?: inscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inscripciones
     */
    omit?: inscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inscripcionesInclude<ExtArgs> | null
  }


  /**
   * Model materiales
   */

  export type AggregateMateriales = {
    _count: MaterialesCountAggregateOutputType | null
    _min: MaterialesMinAggregateOutputType | null
    _max: MaterialesMaxAggregateOutputType | null
  }

  export type MaterialesMinAggregateOutputType = {
    id: string | null
    claseId: string | null
    tipo: $Enums.TipoMaterial | null
    titulo: string | null
    url: string | null
    creadoEn: Date | null
  }

  export type MaterialesMaxAggregateOutputType = {
    id: string | null
    claseId: string | null
    tipo: $Enums.TipoMaterial | null
    titulo: string | null
    url: string | null
    creadoEn: Date | null
  }

  export type MaterialesCountAggregateOutputType = {
    id: number
    claseId: number
    tipo: number
    titulo: number
    url: number
    creadoEn: number
    _all: number
  }


  export type MaterialesMinAggregateInputType = {
    id?: true
    claseId?: true
    tipo?: true
    titulo?: true
    url?: true
    creadoEn?: true
  }

  export type MaterialesMaxAggregateInputType = {
    id?: true
    claseId?: true
    tipo?: true
    titulo?: true
    url?: true
    creadoEn?: true
  }

  export type MaterialesCountAggregateInputType = {
    id?: true
    claseId?: true
    tipo?: true
    titulo?: true
    url?: true
    creadoEn?: true
    _all?: true
  }

  export type MaterialesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which materiales to aggregate.
     */
    where?: materialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materiales to fetch.
     */
    orderBy?: materialesOrderByWithRelationInput | materialesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: materialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materiales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materiales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned materiales
    **/
    _count?: true | MaterialesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialesMaxAggregateInputType
  }

  export type GetMaterialesAggregateType<T extends MaterialesAggregateArgs> = {
        [P in keyof T & keyof AggregateMateriales]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMateriales[P]>
      : GetScalarType<T[P], AggregateMateriales[P]>
  }




  export type materialesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: materialesWhereInput
    orderBy?: materialesOrderByWithAggregationInput | materialesOrderByWithAggregationInput[]
    by: MaterialesScalarFieldEnum[] | MaterialesScalarFieldEnum
    having?: materialesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialesCountAggregateInputType | true
    _min?: MaterialesMinAggregateInputType
    _max?: MaterialesMaxAggregateInputType
  }

  export type MaterialesGroupByOutputType = {
    id: string
    claseId: string
    tipo: $Enums.TipoMaterial
    titulo: string
    url: string
    creadoEn: Date
    _count: MaterialesCountAggregateOutputType | null
    _min: MaterialesMinAggregateOutputType | null
    _max: MaterialesMaxAggregateOutputType | null
  }

  type GetMaterialesGroupByPayload<T extends materialesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialesGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialesGroupByOutputType[P]>
        }
      >
    >


  export type materialesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claseId?: boolean
    tipo?: boolean
    titulo?: boolean
    url?: boolean
    creadoEn?: boolean
    clases?: boolean | clasesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materiales"]>

  export type materialesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claseId?: boolean
    tipo?: boolean
    titulo?: boolean
    url?: boolean
    creadoEn?: boolean
    clases?: boolean | clasesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materiales"]>

  export type materialesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claseId?: boolean
    tipo?: boolean
    titulo?: boolean
    url?: boolean
    creadoEn?: boolean
    clases?: boolean | clasesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materiales"]>

  export type materialesSelectScalar = {
    id?: boolean
    claseId?: boolean
    tipo?: boolean
    titulo?: boolean
    url?: boolean
    creadoEn?: boolean
  }

  export type materialesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "claseId" | "tipo" | "titulo" | "url" | "creadoEn", ExtArgs["result"]["materiales"]>
  export type materialesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clases?: boolean | clasesDefaultArgs<ExtArgs>
  }
  export type materialesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clases?: boolean | clasesDefaultArgs<ExtArgs>
  }
  export type materialesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clases?: boolean | clasesDefaultArgs<ExtArgs>
  }

  export type $materialesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "materiales"
    objects: {
      clases: Prisma.$clasesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      claseId: string
      tipo: $Enums.TipoMaterial
      titulo: string
      url: string
      creadoEn: Date
    }, ExtArgs["result"]["materiales"]>
    composites: {}
  }

  type materialesGetPayload<S extends boolean | null | undefined | materialesDefaultArgs> = $Result.GetResult<Prisma.$materialesPayload, S>

  type materialesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<materialesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaterialesCountAggregateInputType | true
    }

  export interface materialesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['materiales'], meta: { name: 'materiales' } }
    /**
     * Find zero or one Materiales that matches the filter.
     * @param {materialesFindUniqueArgs} args - Arguments to find a Materiales
     * @example
     * // Get one Materiales
     * const materiales = await prisma.materiales.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends materialesFindUniqueArgs>(args: SelectSubset<T, materialesFindUniqueArgs<ExtArgs>>): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Materiales that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {materialesFindUniqueOrThrowArgs} args - Arguments to find a Materiales
     * @example
     * // Get one Materiales
     * const materiales = await prisma.materiales.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends materialesFindUniqueOrThrowArgs>(args: SelectSubset<T, materialesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Materiales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialesFindFirstArgs} args - Arguments to find a Materiales
     * @example
     * // Get one Materiales
     * const materiales = await prisma.materiales.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends materialesFindFirstArgs>(args?: SelectSubset<T, materialesFindFirstArgs<ExtArgs>>): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Materiales that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialesFindFirstOrThrowArgs} args - Arguments to find a Materiales
     * @example
     * // Get one Materiales
     * const materiales = await prisma.materiales.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends materialesFindFirstOrThrowArgs>(args?: SelectSubset<T, materialesFindFirstOrThrowArgs<ExtArgs>>): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Materiales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materiales
     * const materiales = await prisma.materiales.findMany()
     * 
     * // Get first 10 Materiales
     * const materiales = await prisma.materiales.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialesWithIdOnly = await prisma.materiales.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends materialesFindManyArgs>(args?: SelectSubset<T, materialesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Materiales.
     * @param {materialesCreateArgs} args - Arguments to create a Materiales.
     * @example
     * // Create one Materiales
     * const Materiales = await prisma.materiales.create({
     *   data: {
     *     // ... data to create a Materiales
     *   }
     * })
     * 
     */
    create<T extends materialesCreateArgs>(args: SelectSubset<T, materialesCreateArgs<ExtArgs>>): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Materiales.
     * @param {materialesCreateManyArgs} args - Arguments to create many Materiales.
     * @example
     * // Create many Materiales
     * const materiales = await prisma.materiales.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends materialesCreateManyArgs>(args?: SelectSubset<T, materialesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Materiales and returns the data saved in the database.
     * @param {materialesCreateManyAndReturnArgs} args - Arguments to create many Materiales.
     * @example
     * // Create many Materiales
     * const materiales = await prisma.materiales.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Materiales and only return the `id`
     * const materialesWithIdOnly = await prisma.materiales.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends materialesCreateManyAndReturnArgs>(args?: SelectSubset<T, materialesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Materiales.
     * @param {materialesDeleteArgs} args - Arguments to delete one Materiales.
     * @example
     * // Delete one Materiales
     * const Materiales = await prisma.materiales.delete({
     *   where: {
     *     // ... filter to delete one Materiales
     *   }
     * })
     * 
     */
    delete<T extends materialesDeleteArgs>(args: SelectSubset<T, materialesDeleteArgs<ExtArgs>>): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Materiales.
     * @param {materialesUpdateArgs} args - Arguments to update one Materiales.
     * @example
     * // Update one Materiales
     * const materiales = await prisma.materiales.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends materialesUpdateArgs>(args: SelectSubset<T, materialesUpdateArgs<ExtArgs>>): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Materiales.
     * @param {materialesDeleteManyArgs} args - Arguments to filter Materiales to delete.
     * @example
     * // Delete a few Materiales
     * const { count } = await prisma.materiales.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends materialesDeleteManyArgs>(args?: SelectSubset<T, materialesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materiales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materiales
     * const materiales = await prisma.materiales.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends materialesUpdateManyArgs>(args: SelectSubset<T, materialesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materiales and returns the data updated in the database.
     * @param {materialesUpdateManyAndReturnArgs} args - Arguments to update many Materiales.
     * @example
     * // Update many Materiales
     * const materiales = await prisma.materiales.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Materiales and only return the `id`
     * const materialesWithIdOnly = await prisma.materiales.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends materialesUpdateManyAndReturnArgs>(args: SelectSubset<T, materialesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Materiales.
     * @param {materialesUpsertArgs} args - Arguments to update or create a Materiales.
     * @example
     * // Update or create a Materiales
     * const materiales = await prisma.materiales.upsert({
     *   create: {
     *     // ... data to create a Materiales
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Materiales we want to update
     *   }
     * })
     */
    upsert<T extends materialesUpsertArgs>(args: SelectSubset<T, materialesUpsertArgs<ExtArgs>>): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Materiales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialesCountArgs} args - Arguments to filter Materiales to count.
     * @example
     * // Count the number of Materiales
     * const count = await prisma.materiales.count({
     *   where: {
     *     // ... the filter for the Materiales we want to count
     *   }
     * })
    **/
    count<T extends materialesCountArgs>(
      args?: Subset<T, materialesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Materiales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialesAggregateArgs>(args: Subset<T, MaterialesAggregateArgs>): Prisma.PrismaPromise<GetMaterialesAggregateType<T>>

    /**
     * Group by Materiales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends materialesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: materialesGroupByArgs['orderBy'] }
        : { orderBy?: materialesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, materialesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the materiales model
   */
  readonly fields: materialesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for materiales.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__materialesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clases<T extends clasesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clasesDefaultArgs<ExtArgs>>): Prisma__clasesClient<$Result.GetResult<Prisma.$clasesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the materiales model
   */
  interface materialesFieldRefs {
    readonly id: FieldRef<"materiales", 'String'>
    readonly claseId: FieldRef<"materiales", 'String'>
    readonly tipo: FieldRef<"materiales", 'TipoMaterial'>
    readonly titulo: FieldRef<"materiales", 'String'>
    readonly url: FieldRef<"materiales", 'String'>
    readonly creadoEn: FieldRef<"materiales", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * materiales findUnique
   */
  export type materialesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * Filter, which materiales to fetch.
     */
    where: materialesWhereUniqueInput
  }

  /**
   * materiales findUniqueOrThrow
   */
  export type materialesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * Filter, which materiales to fetch.
     */
    where: materialesWhereUniqueInput
  }

  /**
   * materiales findFirst
   */
  export type materialesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * Filter, which materiales to fetch.
     */
    where?: materialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materiales to fetch.
     */
    orderBy?: materialesOrderByWithRelationInput | materialesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for materiales.
     */
    cursor?: materialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materiales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materiales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of materiales.
     */
    distinct?: MaterialesScalarFieldEnum | MaterialesScalarFieldEnum[]
  }

  /**
   * materiales findFirstOrThrow
   */
  export type materialesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * Filter, which materiales to fetch.
     */
    where?: materialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materiales to fetch.
     */
    orderBy?: materialesOrderByWithRelationInput | materialesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for materiales.
     */
    cursor?: materialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materiales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materiales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of materiales.
     */
    distinct?: MaterialesScalarFieldEnum | MaterialesScalarFieldEnum[]
  }

  /**
   * materiales findMany
   */
  export type materialesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * Filter, which materiales to fetch.
     */
    where?: materialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materiales to fetch.
     */
    orderBy?: materialesOrderByWithRelationInput | materialesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing materiales.
     */
    cursor?: materialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materiales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materiales.
     */
    skip?: number
    distinct?: MaterialesScalarFieldEnum | MaterialesScalarFieldEnum[]
  }

  /**
   * materiales create
   */
  export type materialesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * The data needed to create a materiales.
     */
    data: XOR<materialesCreateInput, materialesUncheckedCreateInput>
  }

  /**
   * materiales createMany
   */
  export type materialesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many materiales.
     */
    data: materialesCreateManyInput | materialesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * materiales createManyAndReturn
   */
  export type materialesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * The data used to create many materiales.
     */
    data: materialesCreateManyInput | materialesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * materiales update
   */
  export type materialesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * The data needed to update a materiales.
     */
    data: XOR<materialesUpdateInput, materialesUncheckedUpdateInput>
    /**
     * Choose, which materiales to update.
     */
    where: materialesWhereUniqueInput
  }

  /**
   * materiales updateMany
   */
  export type materialesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update materiales.
     */
    data: XOR<materialesUpdateManyMutationInput, materialesUncheckedUpdateManyInput>
    /**
     * Filter which materiales to update
     */
    where?: materialesWhereInput
    /**
     * Limit how many materiales to update.
     */
    limit?: number
  }

  /**
   * materiales updateManyAndReturn
   */
  export type materialesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * The data used to update materiales.
     */
    data: XOR<materialesUpdateManyMutationInput, materialesUncheckedUpdateManyInput>
    /**
     * Filter which materiales to update
     */
    where?: materialesWhereInput
    /**
     * Limit how many materiales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * materiales upsert
   */
  export type materialesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * The filter to search for the materiales to update in case it exists.
     */
    where: materialesWhereUniqueInput
    /**
     * In case the materiales found by the `where` argument doesn't exist, create a new materiales with this data.
     */
    create: XOR<materialesCreateInput, materialesUncheckedCreateInput>
    /**
     * In case the materiales was found with the provided `where` argument, update it with this data.
     */
    update: XOR<materialesUpdateInput, materialesUncheckedUpdateInput>
  }

  /**
   * materiales delete
   */
  export type materialesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * Filter which materiales to delete.
     */
    where: materialesWhereUniqueInput
  }

  /**
   * materiales deleteMany
   */
  export type materialesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which materiales to delete
     */
    where?: materialesWhereInput
    /**
     * Limit how many materiales to delete.
     */
    limit?: number
  }

  /**
   * materiales without action
   */
  export type materialesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materiales
     */
    omit?: materialesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: materialesInclude<ExtArgs> | null
  }


  /**
   * Model objetivosCursos
   */

  export type AggregateObjetivosCursos = {
    _count: ObjetivosCursosCountAggregateOutputType | null
    _avg: ObjetivosCursosAvgAggregateOutputType | null
    _sum: ObjetivosCursosSumAggregateOutputType | null
    _min: ObjetivosCursosMinAggregateOutputType | null
    _max: ObjetivosCursosMaxAggregateOutputType | null
  }

  export type ObjetivosCursosAvgAggregateOutputType = {
    orden: number | null
  }

  export type ObjetivosCursosSumAggregateOutputType = {
    orden: number | null
  }

  export type ObjetivosCursosMinAggregateOutputType = {
    id: string | null
    cursoId: string | null
    descripcion: string | null
    orden: number | null
    creadoEn: Date | null
  }

  export type ObjetivosCursosMaxAggregateOutputType = {
    id: string | null
    cursoId: string | null
    descripcion: string | null
    orden: number | null
    creadoEn: Date | null
  }

  export type ObjetivosCursosCountAggregateOutputType = {
    id: number
    cursoId: number
    descripcion: number
    orden: number
    creadoEn: number
    _all: number
  }


  export type ObjetivosCursosAvgAggregateInputType = {
    orden?: true
  }

  export type ObjetivosCursosSumAggregateInputType = {
    orden?: true
  }

  export type ObjetivosCursosMinAggregateInputType = {
    id?: true
    cursoId?: true
    descripcion?: true
    orden?: true
    creadoEn?: true
  }

  export type ObjetivosCursosMaxAggregateInputType = {
    id?: true
    cursoId?: true
    descripcion?: true
    orden?: true
    creadoEn?: true
  }

  export type ObjetivosCursosCountAggregateInputType = {
    id?: true
    cursoId?: true
    descripcion?: true
    orden?: true
    creadoEn?: true
    _all?: true
  }

  export type ObjetivosCursosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which objetivosCursos to aggregate.
     */
    where?: objetivosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of objetivosCursos to fetch.
     */
    orderBy?: objetivosCursosOrderByWithRelationInput | objetivosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: objetivosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` objetivosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` objetivosCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned objetivosCursos
    **/
    _count?: true | ObjetivosCursosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObjetivosCursosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObjetivosCursosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObjetivosCursosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObjetivosCursosMaxAggregateInputType
  }

  export type GetObjetivosCursosAggregateType<T extends ObjetivosCursosAggregateArgs> = {
        [P in keyof T & keyof AggregateObjetivosCursos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObjetivosCursos[P]>
      : GetScalarType<T[P], AggregateObjetivosCursos[P]>
  }




  export type objetivosCursosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: objetivosCursosWhereInput
    orderBy?: objetivosCursosOrderByWithAggregationInput | objetivosCursosOrderByWithAggregationInput[]
    by: ObjetivosCursosScalarFieldEnum[] | ObjetivosCursosScalarFieldEnum
    having?: objetivosCursosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObjetivosCursosCountAggregateInputType | true
    _avg?: ObjetivosCursosAvgAggregateInputType
    _sum?: ObjetivosCursosSumAggregateInputType
    _min?: ObjetivosCursosMinAggregateInputType
    _max?: ObjetivosCursosMaxAggregateInputType
  }

  export type ObjetivosCursosGroupByOutputType = {
    id: string
    cursoId: string
    descripcion: string
    orden: number
    creadoEn: Date
    _count: ObjetivosCursosCountAggregateOutputType | null
    _avg: ObjetivosCursosAvgAggregateOutputType | null
    _sum: ObjetivosCursosSumAggregateOutputType | null
    _min: ObjetivosCursosMinAggregateOutputType | null
    _max: ObjetivosCursosMaxAggregateOutputType | null
  }

  type GetObjetivosCursosGroupByPayload<T extends objetivosCursosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObjetivosCursosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObjetivosCursosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObjetivosCursosGroupByOutputType[P]>
            : GetScalarType<T[P], ObjetivosCursosGroupByOutputType[P]>
        }
      >
    >


  export type objetivosCursosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    descripcion?: boolean
    orden?: boolean
    creadoEn?: boolean
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["objetivosCursos"]>

  export type objetivosCursosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    descripcion?: boolean
    orden?: boolean
    creadoEn?: boolean
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["objetivosCursos"]>

  export type objetivosCursosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    descripcion?: boolean
    orden?: boolean
    creadoEn?: boolean
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["objetivosCursos"]>

  export type objetivosCursosSelectScalar = {
    id?: boolean
    cursoId?: boolean
    descripcion?: boolean
    orden?: boolean
    creadoEn?: boolean
  }

  export type objetivosCursosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cursoId" | "descripcion" | "orden" | "creadoEn", ExtArgs["result"]["objetivosCursos"]>
  export type objetivosCursosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
  }
  export type objetivosCursosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
  }
  export type objetivosCursosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
  }

  export type $objetivosCursosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "objetivosCursos"
    objects: {
      cursos: Prisma.$cursosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cursoId: string
      descripcion: string
      orden: number
      creadoEn: Date
    }, ExtArgs["result"]["objetivosCursos"]>
    composites: {}
  }

  type objetivosCursosGetPayload<S extends boolean | null | undefined | objetivosCursosDefaultArgs> = $Result.GetResult<Prisma.$objetivosCursosPayload, S>

  type objetivosCursosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<objetivosCursosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ObjetivosCursosCountAggregateInputType | true
    }

  export interface objetivosCursosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['objetivosCursos'], meta: { name: 'objetivosCursos' } }
    /**
     * Find zero or one ObjetivosCursos that matches the filter.
     * @param {objetivosCursosFindUniqueArgs} args - Arguments to find a ObjetivosCursos
     * @example
     * // Get one ObjetivosCursos
     * const objetivosCursos = await prisma.objetivosCursos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends objetivosCursosFindUniqueArgs>(args: SelectSubset<T, objetivosCursosFindUniqueArgs<ExtArgs>>): Prisma__objetivosCursosClient<$Result.GetResult<Prisma.$objetivosCursosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ObjetivosCursos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {objetivosCursosFindUniqueOrThrowArgs} args - Arguments to find a ObjetivosCursos
     * @example
     * // Get one ObjetivosCursos
     * const objetivosCursos = await prisma.objetivosCursos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends objetivosCursosFindUniqueOrThrowArgs>(args: SelectSubset<T, objetivosCursosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__objetivosCursosClient<$Result.GetResult<Prisma.$objetivosCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ObjetivosCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {objetivosCursosFindFirstArgs} args - Arguments to find a ObjetivosCursos
     * @example
     * // Get one ObjetivosCursos
     * const objetivosCursos = await prisma.objetivosCursos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends objetivosCursosFindFirstArgs>(args?: SelectSubset<T, objetivosCursosFindFirstArgs<ExtArgs>>): Prisma__objetivosCursosClient<$Result.GetResult<Prisma.$objetivosCursosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ObjetivosCursos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {objetivosCursosFindFirstOrThrowArgs} args - Arguments to find a ObjetivosCursos
     * @example
     * // Get one ObjetivosCursos
     * const objetivosCursos = await prisma.objetivosCursos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends objetivosCursosFindFirstOrThrowArgs>(args?: SelectSubset<T, objetivosCursosFindFirstOrThrowArgs<ExtArgs>>): Prisma__objetivosCursosClient<$Result.GetResult<Prisma.$objetivosCursosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ObjetivosCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {objetivosCursosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ObjetivosCursos
     * const objetivosCursos = await prisma.objetivosCursos.findMany()
     * 
     * // Get first 10 ObjetivosCursos
     * const objetivosCursos = await prisma.objetivosCursos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const objetivosCursosWithIdOnly = await prisma.objetivosCursos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends objetivosCursosFindManyArgs>(args?: SelectSubset<T, objetivosCursosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$objetivosCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ObjetivosCursos.
     * @param {objetivosCursosCreateArgs} args - Arguments to create a ObjetivosCursos.
     * @example
     * // Create one ObjetivosCursos
     * const ObjetivosCursos = await prisma.objetivosCursos.create({
     *   data: {
     *     // ... data to create a ObjetivosCursos
     *   }
     * })
     * 
     */
    create<T extends objetivosCursosCreateArgs>(args: SelectSubset<T, objetivosCursosCreateArgs<ExtArgs>>): Prisma__objetivosCursosClient<$Result.GetResult<Prisma.$objetivosCursosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ObjetivosCursos.
     * @param {objetivosCursosCreateManyArgs} args - Arguments to create many ObjetivosCursos.
     * @example
     * // Create many ObjetivosCursos
     * const objetivosCursos = await prisma.objetivosCursos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends objetivosCursosCreateManyArgs>(args?: SelectSubset<T, objetivosCursosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ObjetivosCursos and returns the data saved in the database.
     * @param {objetivosCursosCreateManyAndReturnArgs} args - Arguments to create many ObjetivosCursos.
     * @example
     * // Create many ObjetivosCursos
     * const objetivosCursos = await prisma.objetivosCursos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ObjetivosCursos and only return the `id`
     * const objetivosCursosWithIdOnly = await prisma.objetivosCursos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends objetivosCursosCreateManyAndReturnArgs>(args?: SelectSubset<T, objetivosCursosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$objetivosCursosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ObjetivosCursos.
     * @param {objetivosCursosDeleteArgs} args - Arguments to delete one ObjetivosCursos.
     * @example
     * // Delete one ObjetivosCursos
     * const ObjetivosCursos = await prisma.objetivosCursos.delete({
     *   where: {
     *     // ... filter to delete one ObjetivosCursos
     *   }
     * })
     * 
     */
    delete<T extends objetivosCursosDeleteArgs>(args: SelectSubset<T, objetivosCursosDeleteArgs<ExtArgs>>): Prisma__objetivosCursosClient<$Result.GetResult<Prisma.$objetivosCursosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ObjetivosCursos.
     * @param {objetivosCursosUpdateArgs} args - Arguments to update one ObjetivosCursos.
     * @example
     * // Update one ObjetivosCursos
     * const objetivosCursos = await prisma.objetivosCursos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends objetivosCursosUpdateArgs>(args: SelectSubset<T, objetivosCursosUpdateArgs<ExtArgs>>): Prisma__objetivosCursosClient<$Result.GetResult<Prisma.$objetivosCursosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ObjetivosCursos.
     * @param {objetivosCursosDeleteManyArgs} args - Arguments to filter ObjetivosCursos to delete.
     * @example
     * // Delete a few ObjetivosCursos
     * const { count } = await prisma.objetivosCursos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends objetivosCursosDeleteManyArgs>(args?: SelectSubset<T, objetivosCursosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ObjetivosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {objetivosCursosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ObjetivosCursos
     * const objetivosCursos = await prisma.objetivosCursos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends objetivosCursosUpdateManyArgs>(args: SelectSubset<T, objetivosCursosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ObjetivosCursos and returns the data updated in the database.
     * @param {objetivosCursosUpdateManyAndReturnArgs} args - Arguments to update many ObjetivosCursos.
     * @example
     * // Update many ObjetivosCursos
     * const objetivosCursos = await prisma.objetivosCursos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ObjetivosCursos and only return the `id`
     * const objetivosCursosWithIdOnly = await prisma.objetivosCursos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends objetivosCursosUpdateManyAndReturnArgs>(args: SelectSubset<T, objetivosCursosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$objetivosCursosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ObjetivosCursos.
     * @param {objetivosCursosUpsertArgs} args - Arguments to update or create a ObjetivosCursos.
     * @example
     * // Update or create a ObjetivosCursos
     * const objetivosCursos = await prisma.objetivosCursos.upsert({
     *   create: {
     *     // ... data to create a ObjetivosCursos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ObjetivosCursos we want to update
     *   }
     * })
     */
    upsert<T extends objetivosCursosUpsertArgs>(args: SelectSubset<T, objetivosCursosUpsertArgs<ExtArgs>>): Prisma__objetivosCursosClient<$Result.GetResult<Prisma.$objetivosCursosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ObjetivosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {objetivosCursosCountArgs} args - Arguments to filter ObjetivosCursos to count.
     * @example
     * // Count the number of ObjetivosCursos
     * const count = await prisma.objetivosCursos.count({
     *   where: {
     *     // ... the filter for the ObjetivosCursos we want to count
     *   }
     * })
    **/
    count<T extends objetivosCursosCountArgs>(
      args?: Subset<T, objetivosCursosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObjetivosCursosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ObjetivosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjetivosCursosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObjetivosCursosAggregateArgs>(args: Subset<T, ObjetivosCursosAggregateArgs>): Prisma.PrismaPromise<GetObjetivosCursosAggregateType<T>>

    /**
     * Group by ObjetivosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {objetivosCursosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends objetivosCursosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: objetivosCursosGroupByArgs['orderBy'] }
        : { orderBy?: objetivosCursosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, objetivosCursosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObjetivosCursosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the objetivosCursos model
   */
  readonly fields: objetivosCursosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for objetivosCursos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__objetivosCursosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cursos<T extends cursosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, cursosDefaultArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the objetivosCursos model
   */
  interface objetivosCursosFieldRefs {
    readonly id: FieldRef<"objetivosCursos", 'String'>
    readonly cursoId: FieldRef<"objetivosCursos", 'String'>
    readonly descripcion: FieldRef<"objetivosCursos", 'String'>
    readonly orden: FieldRef<"objetivosCursos", 'Int'>
    readonly creadoEn: FieldRef<"objetivosCursos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * objetivosCursos findUnique
   */
  export type objetivosCursosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosInclude<ExtArgs> | null
    /**
     * Filter, which objetivosCursos to fetch.
     */
    where: objetivosCursosWhereUniqueInput
  }

  /**
   * objetivosCursos findUniqueOrThrow
   */
  export type objetivosCursosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosInclude<ExtArgs> | null
    /**
     * Filter, which objetivosCursos to fetch.
     */
    where: objetivosCursosWhereUniqueInput
  }

  /**
   * objetivosCursos findFirst
   */
  export type objetivosCursosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosInclude<ExtArgs> | null
    /**
     * Filter, which objetivosCursos to fetch.
     */
    where?: objetivosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of objetivosCursos to fetch.
     */
    orderBy?: objetivosCursosOrderByWithRelationInput | objetivosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for objetivosCursos.
     */
    cursor?: objetivosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` objetivosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` objetivosCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of objetivosCursos.
     */
    distinct?: ObjetivosCursosScalarFieldEnum | ObjetivosCursosScalarFieldEnum[]
  }

  /**
   * objetivosCursos findFirstOrThrow
   */
  export type objetivosCursosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosInclude<ExtArgs> | null
    /**
     * Filter, which objetivosCursos to fetch.
     */
    where?: objetivosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of objetivosCursos to fetch.
     */
    orderBy?: objetivosCursosOrderByWithRelationInput | objetivosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for objetivosCursos.
     */
    cursor?: objetivosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` objetivosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` objetivosCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of objetivosCursos.
     */
    distinct?: ObjetivosCursosScalarFieldEnum | ObjetivosCursosScalarFieldEnum[]
  }

  /**
   * objetivosCursos findMany
   */
  export type objetivosCursosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosInclude<ExtArgs> | null
    /**
     * Filter, which objetivosCursos to fetch.
     */
    where?: objetivosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of objetivosCursos to fetch.
     */
    orderBy?: objetivosCursosOrderByWithRelationInput | objetivosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing objetivosCursos.
     */
    cursor?: objetivosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` objetivosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` objetivosCursos.
     */
    skip?: number
    distinct?: ObjetivosCursosScalarFieldEnum | ObjetivosCursosScalarFieldEnum[]
  }

  /**
   * objetivosCursos create
   */
  export type objetivosCursosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosInclude<ExtArgs> | null
    /**
     * The data needed to create a objetivosCursos.
     */
    data: XOR<objetivosCursosCreateInput, objetivosCursosUncheckedCreateInput>
  }

  /**
   * objetivosCursos createMany
   */
  export type objetivosCursosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many objetivosCursos.
     */
    data: objetivosCursosCreateManyInput | objetivosCursosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * objetivosCursos createManyAndReturn
   */
  export type objetivosCursosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * The data used to create many objetivosCursos.
     */
    data: objetivosCursosCreateManyInput | objetivosCursosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * objetivosCursos update
   */
  export type objetivosCursosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosInclude<ExtArgs> | null
    /**
     * The data needed to update a objetivosCursos.
     */
    data: XOR<objetivosCursosUpdateInput, objetivosCursosUncheckedUpdateInput>
    /**
     * Choose, which objetivosCursos to update.
     */
    where: objetivosCursosWhereUniqueInput
  }

  /**
   * objetivosCursos updateMany
   */
  export type objetivosCursosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update objetivosCursos.
     */
    data: XOR<objetivosCursosUpdateManyMutationInput, objetivosCursosUncheckedUpdateManyInput>
    /**
     * Filter which objetivosCursos to update
     */
    where?: objetivosCursosWhereInput
    /**
     * Limit how many objetivosCursos to update.
     */
    limit?: number
  }

  /**
   * objetivosCursos updateManyAndReturn
   */
  export type objetivosCursosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * The data used to update objetivosCursos.
     */
    data: XOR<objetivosCursosUpdateManyMutationInput, objetivosCursosUncheckedUpdateManyInput>
    /**
     * Filter which objetivosCursos to update
     */
    where?: objetivosCursosWhereInput
    /**
     * Limit how many objetivosCursos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * objetivosCursos upsert
   */
  export type objetivosCursosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosInclude<ExtArgs> | null
    /**
     * The filter to search for the objetivosCursos to update in case it exists.
     */
    where: objetivosCursosWhereUniqueInput
    /**
     * In case the objetivosCursos found by the `where` argument doesn't exist, create a new objetivosCursos with this data.
     */
    create: XOR<objetivosCursosCreateInput, objetivosCursosUncheckedCreateInput>
    /**
     * In case the objetivosCursos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<objetivosCursosUpdateInput, objetivosCursosUncheckedUpdateInput>
  }

  /**
   * objetivosCursos delete
   */
  export type objetivosCursosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosInclude<ExtArgs> | null
    /**
     * Filter which objetivosCursos to delete.
     */
    where: objetivosCursosWhereUniqueInput
  }

  /**
   * objetivosCursos deleteMany
   */
  export type objetivosCursosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which objetivosCursos to delete
     */
    where?: objetivosCursosWhereInput
    /**
     * Limit how many objetivosCursos to delete.
     */
    limit?: number
  }

  /**
   * objetivosCursos without action
   */
  export type objetivosCursosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the objetivosCursos
     */
    select?: objetivosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the objetivosCursos
     */
    omit?: objetivosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: objetivosCursosInclude<ExtArgs> | null
  }


  /**
   * Model pagosDocentes
   */

  export type AggregatePagosDocentes = {
    _count: PagosDocentesCountAggregateOutputType | null
    _avg: PagosDocentesAvgAggregateOutputType | null
    _sum: PagosDocentesSumAggregateOutputType | null
    _min: PagosDocentesMinAggregateOutputType | null
    _max: PagosDocentesMaxAggregateOutputType | null
  }

  export type PagosDocentesAvgAggregateOutputType = {
    monto: number | null
    deuda: number | null
  }

  export type PagosDocentesSumAggregateOutputType = {
    monto: number | null
    deuda: number | null
  }

  export type PagosDocentesMinAggregateOutputType = {
    id: string | null
    docenteId: string | null
    edicionId: string | null
    monto: number | null
    deuda: number | null
    estadoPago: $Enums.EstadoPago | null
    fechaPago: Date | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type PagosDocentesMaxAggregateOutputType = {
    id: string | null
    docenteId: string | null
    edicionId: string | null
    monto: number | null
    deuda: number | null
    estadoPago: $Enums.EstadoPago | null
    fechaPago: Date | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type PagosDocentesCountAggregateOutputType = {
    id: number
    docenteId: number
    edicionId: number
    monto: number
    deuda: number
    estadoPago: number
    fechaPago: number
    creadoEn: number
    actualizadoEn: number
    _all: number
  }


  export type PagosDocentesAvgAggregateInputType = {
    monto?: true
    deuda?: true
  }

  export type PagosDocentesSumAggregateInputType = {
    monto?: true
    deuda?: true
  }

  export type PagosDocentesMinAggregateInputType = {
    id?: true
    docenteId?: true
    edicionId?: true
    monto?: true
    deuda?: true
    estadoPago?: true
    fechaPago?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type PagosDocentesMaxAggregateInputType = {
    id?: true
    docenteId?: true
    edicionId?: true
    monto?: true
    deuda?: true
    estadoPago?: true
    fechaPago?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type PagosDocentesCountAggregateInputType = {
    id?: true
    docenteId?: true
    edicionId?: true
    monto?: true
    deuda?: true
    estadoPago?: true
    fechaPago?: true
    creadoEn?: true
    actualizadoEn?: true
    _all?: true
  }

  export type PagosDocentesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pagosDocentes to aggregate.
     */
    where?: pagosDocentesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagosDocentes to fetch.
     */
    orderBy?: pagosDocentesOrderByWithRelationInput | pagosDocentesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pagosDocentesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagosDocentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagosDocentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pagosDocentes
    **/
    _count?: true | PagosDocentesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PagosDocentesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PagosDocentesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PagosDocentesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PagosDocentesMaxAggregateInputType
  }

  export type GetPagosDocentesAggregateType<T extends PagosDocentesAggregateArgs> = {
        [P in keyof T & keyof AggregatePagosDocentes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePagosDocentes[P]>
      : GetScalarType<T[P], AggregatePagosDocentes[P]>
  }




  export type pagosDocentesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pagosDocentesWhereInput
    orderBy?: pagosDocentesOrderByWithAggregationInput | pagosDocentesOrderByWithAggregationInput[]
    by: PagosDocentesScalarFieldEnum[] | PagosDocentesScalarFieldEnum
    having?: pagosDocentesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PagosDocentesCountAggregateInputType | true
    _avg?: PagosDocentesAvgAggregateInputType
    _sum?: PagosDocentesSumAggregateInputType
    _min?: PagosDocentesMinAggregateInputType
    _max?: PagosDocentesMaxAggregateInputType
  }

  export type PagosDocentesGroupByOutputType = {
    id: string
    docenteId: string
    edicionId: string
    monto: number
    deuda: number
    estadoPago: $Enums.EstadoPago
    fechaPago: Date | null
    creadoEn: Date
    actualizadoEn: Date
    _count: PagosDocentesCountAggregateOutputType | null
    _avg: PagosDocentesAvgAggregateOutputType | null
    _sum: PagosDocentesSumAggregateOutputType | null
    _min: PagosDocentesMinAggregateOutputType | null
    _max: PagosDocentesMaxAggregateOutputType | null
  }

  type GetPagosDocentesGroupByPayload<T extends pagosDocentesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PagosDocentesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PagosDocentesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PagosDocentesGroupByOutputType[P]>
            : GetScalarType<T[P], PagosDocentesGroupByOutputType[P]>
        }
      >
    >


  export type pagosDocentesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    docenteId?: boolean
    edicionId?: boolean
    monto?: boolean
    deuda?: boolean
    estadoPago?: boolean
    fechaPago?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    docente?: boolean | docenteDefaultArgs<ExtArgs>
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pagosDocentes"]>

  export type pagosDocentesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    docenteId?: boolean
    edicionId?: boolean
    monto?: boolean
    deuda?: boolean
    estadoPago?: boolean
    fechaPago?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    docente?: boolean | docenteDefaultArgs<ExtArgs>
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pagosDocentes"]>

  export type pagosDocentesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    docenteId?: boolean
    edicionId?: boolean
    monto?: boolean
    deuda?: boolean
    estadoPago?: boolean
    fechaPago?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    docente?: boolean | docenteDefaultArgs<ExtArgs>
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pagosDocentes"]>

  export type pagosDocentesSelectScalar = {
    id?: boolean
    docenteId?: boolean
    edicionId?: boolean
    monto?: boolean
    deuda?: boolean
    estadoPago?: boolean
    fechaPago?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }

  export type pagosDocentesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "docenteId" | "edicionId" | "monto" | "deuda" | "estadoPago" | "fechaPago" | "creadoEn" | "actualizadoEn", ExtArgs["result"]["pagosDocentes"]>
  export type pagosDocentesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    docente?: boolean | docenteDefaultArgs<ExtArgs>
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }
  export type pagosDocentesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    docente?: boolean | docenteDefaultArgs<ExtArgs>
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }
  export type pagosDocentesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    docente?: boolean | docenteDefaultArgs<ExtArgs>
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }

  export type $pagosDocentesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pagosDocentes"
    objects: {
      docente: Prisma.$docentePayload<ExtArgs>
      edicionesCursos: Prisma.$edicionesCursosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      docenteId: string
      edicionId: string
      monto: number
      deuda: number
      estadoPago: $Enums.EstadoPago
      fechaPago: Date | null
      creadoEn: Date
      actualizadoEn: Date
    }, ExtArgs["result"]["pagosDocentes"]>
    composites: {}
  }

  type pagosDocentesGetPayload<S extends boolean | null | undefined | pagosDocentesDefaultArgs> = $Result.GetResult<Prisma.$pagosDocentesPayload, S>

  type pagosDocentesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pagosDocentesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PagosDocentesCountAggregateInputType | true
    }

  export interface pagosDocentesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pagosDocentes'], meta: { name: 'pagosDocentes' } }
    /**
     * Find zero or one PagosDocentes that matches the filter.
     * @param {pagosDocentesFindUniqueArgs} args - Arguments to find a PagosDocentes
     * @example
     * // Get one PagosDocentes
     * const pagosDocentes = await prisma.pagosDocentes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pagosDocentesFindUniqueArgs>(args: SelectSubset<T, pagosDocentesFindUniqueArgs<ExtArgs>>): Prisma__pagosDocentesClient<$Result.GetResult<Prisma.$pagosDocentesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PagosDocentes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pagosDocentesFindUniqueOrThrowArgs} args - Arguments to find a PagosDocentes
     * @example
     * // Get one PagosDocentes
     * const pagosDocentes = await prisma.pagosDocentes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pagosDocentesFindUniqueOrThrowArgs>(args: SelectSubset<T, pagosDocentesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pagosDocentesClient<$Result.GetResult<Prisma.$pagosDocentesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PagosDocentes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagosDocentesFindFirstArgs} args - Arguments to find a PagosDocentes
     * @example
     * // Get one PagosDocentes
     * const pagosDocentes = await prisma.pagosDocentes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pagosDocentesFindFirstArgs>(args?: SelectSubset<T, pagosDocentesFindFirstArgs<ExtArgs>>): Prisma__pagosDocentesClient<$Result.GetResult<Prisma.$pagosDocentesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PagosDocentes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagosDocentesFindFirstOrThrowArgs} args - Arguments to find a PagosDocentes
     * @example
     * // Get one PagosDocentes
     * const pagosDocentes = await prisma.pagosDocentes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pagosDocentesFindFirstOrThrowArgs>(args?: SelectSubset<T, pagosDocentesFindFirstOrThrowArgs<ExtArgs>>): Prisma__pagosDocentesClient<$Result.GetResult<Prisma.$pagosDocentesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PagosDocentes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagosDocentesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PagosDocentes
     * const pagosDocentes = await prisma.pagosDocentes.findMany()
     * 
     * // Get first 10 PagosDocentes
     * const pagosDocentes = await prisma.pagosDocentes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pagosDocentesWithIdOnly = await prisma.pagosDocentes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pagosDocentesFindManyArgs>(args?: SelectSubset<T, pagosDocentesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pagosDocentesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PagosDocentes.
     * @param {pagosDocentesCreateArgs} args - Arguments to create a PagosDocentes.
     * @example
     * // Create one PagosDocentes
     * const PagosDocentes = await prisma.pagosDocentes.create({
     *   data: {
     *     // ... data to create a PagosDocentes
     *   }
     * })
     * 
     */
    create<T extends pagosDocentesCreateArgs>(args: SelectSubset<T, pagosDocentesCreateArgs<ExtArgs>>): Prisma__pagosDocentesClient<$Result.GetResult<Prisma.$pagosDocentesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PagosDocentes.
     * @param {pagosDocentesCreateManyArgs} args - Arguments to create many PagosDocentes.
     * @example
     * // Create many PagosDocentes
     * const pagosDocentes = await prisma.pagosDocentes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pagosDocentesCreateManyArgs>(args?: SelectSubset<T, pagosDocentesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PagosDocentes and returns the data saved in the database.
     * @param {pagosDocentesCreateManyAndReturnArgs} args - Arguments to create many PagosDocentes.
     * @example
     * // Create many PagosDocentes
     * const pagosDocentes = await prisma.pagosDocentes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PagosDocentes and only return the `id`
     * const pagosDocentesWithIdOnly = await prisma.pagosDocentes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pagosDocentesCreateManyAndReturnArgs>(args?: SelectSubset<T, pagosDocentesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pagosDocentesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PagosDocentes.
     * @param {pagosDocentesDeleteArgs} args - Arguments to delete one PagosDocentes.
     * @example
     * // Delete one PagosDocentes
     * const PagosDocentes = await prisma.pagosDocentes.delete({
     *   where: {
     *     // ... filter to delete one PagosDocentes
     *   }
     * })
     * 
     */
    delete<T extends pagosDocentesDeleteArgs>(args: SelectSubset<T, pagosDocentesDeleteArgs<ExtArgs>>): Prisma__pagosDocentesClient<$Result.GetResult<Prisma.$pagosDocentesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PagosDocentes.
     * @param {pagosDocentesUpdateArgs} args - Arguments to update one PagosDocentes.
     * @example
     * // Update one PagosDocentes
     * const pagosDocentes = await prisma.pagosDocentes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pagosDocentesUpdateArgs>(args: SelectSubset<T, pagosDocentesUpdateArgs<ExtArgs>>): Prisma__pagosDocentesClient<$Result.GetResult<Prisma.$pagosDocentesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PagosDocentes.
     * @param {pagosDocentesDeleteManyArgs} args - Arguments to filter PagosDocentes to delete.
     * @example
     * // Delete a few PagosDocentes
     * const { count } = await prisma.pagosDocentes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pagosDocentesDeleteManyArgs>(args?: SelectSubset<T, pagosDocentesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PagosDocentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagosDocentesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PagosDocentes
     * const pagosDocentes = await prisma.pagosDocentes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pagosDocentesUpdateManyArgs>(args: SelectSubset<T, pagosDocentesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PagosDocentes and returns the data updated in the database.
     * @param {pagosDocentesUpdateManyAndReturnArgs} args - Arguments to update many PagosDocentes.
     * @example
     * // Update many PagosDocentes
     * const pagosDocentes = await prisma.pagosDocentes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PagosDocentes and only return the `id`
     * const pagosDocentesWithIdOnly = await prisma.pagosDocentes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends pagosDocentesUpdateManyAndReturnArgs>(args: SelectSubset<T, pagosDocentesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pagosDocentesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PagosDocentes.
     * @param {pagosDocentesUpsertArgs} args - Arguments to update or create a PagosDocentes.
     * @example
     * // Update or create a PagosDocentes
     * const pagosDocentes = await prisma.pagosDocentes.upsert({
     *   create: {
     *     // ... data to create a PagosDocentes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PagosDocentes we want to update
     *   }
     * })
     */
    upsert<T extends pagosDocentesUpsertArgs>(args: SelectSubset<T, pagosDocentesUpsertArgs<ExtArgs>>): Prisma__pagosDocentesClient<$Result.GetResult<Prisma.$pagosDocentesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PagosDocentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagosDocentesCountArgs} args - Arguments to filter PagosDocentes to count.
     * @example
     * // Count the number of PagosDocentes
     * const count = await prisma.pagosDocentes.count({
     *   where: {
     *     // ... the filter for the PagosDocentes we want to count
     *   }
     * })
    **/
    count<T extends pagosDocentesCountArgs>(
      args?: Subset<T, pagosDocentesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagosDocentesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PagosDocentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagosDocentesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PagosDocentesAggregateArgs>(args: Subset<T, PagosDocentesAggregateArgs>): Prisma.PrismaPromise<GetPagosDocentesAggregateType<T>>

    /**
     * Group by PagosDocentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagosDocentesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pagosDocentesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pagosDocentesGroupByArgs['orderBy'] }
        : { orderBy?: pagosDocentesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pagosDocentesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagosDocentesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pagosDocentes model
   */
  readonly fields: pagosDocentesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pagosDocentes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pagosDocentesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    docente<T extends docenteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, docenteDefaultArgs<ExtArgs>>): Prisma__docenteClient<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    edicionesCursos<T extends edicionesCursosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursosDefaultArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pagosDocentes model
   */
  interface pagosDocentesFieldRefs {
    readonly id: FieldRef<"pagosDocentes", 'String'>
    readonly docenteId: FieldRef<"pagosDocentes", 'String'>
    readonly edicionId: FieldRef<"pagosDocentes", 'String'>
    readonly monto: FieldRef<"pagosDocentes", 'Float'>
    readonly deuda: FieldRef<"pagosDocentes", 'Float'>
    readonly estadoPago: FieldRef<"pagosDocentes", 'EstadoPago'>
    readonly fechaPago: FieldRef<"pagosDocentes", 'DateTime'>
    readonly creadoEn: FieldRef<"pagosDocentes", 'DateTime'>
    readonly actualizadoEn: FieldRef<"pagosDocentes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * pagosDocentes findUnique
   */
  export type pagosDocentesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagosDocentes
     */
    select?: pagosDocentesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pagosDocentes
     */
    omit?: pagosDocentesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagosDocentesInclude<ExtArgs> | null
    /**
     * Filter, which pagosDocentes to fetch.
     */
    where: pagosDocentesWhereUniqueInput
  }

  /**
   * pagosDocentes findUniqueOrThrow
   */
  export type pagosDocentesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagosDocentes
     */
    select?: pagosDocentesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pagosDocentes
     */
    omit?: pagosDocentesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagosDocentesInclude<ExtArgs> | null
    /**
     * Filter, which pagosDocentes to fetch.
     */
    where: pagosDocentesWhereUniqueInput
  }

  /**
   * pagosDocentes findFirst
   */
  export type pagosDocentesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagosDocentes
     */
    select?: pagosDocentesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pagosDocentes
     */
    omit?: pagosDocentesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagosDocentesInclude<ExtArgs> | null
    /**
     * Filter, which pagosDocentes to fetch.
     */
    where?: pagosDocentesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagosDocentes to fetch.
     */
    orderBy?: pagosDocentesOrderByWithRelationInput | pagosDocentesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pagosDocentes.
     */
    cursor?: pagosDocentesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagosDocentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagosDocentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pagosDocentes.
     */
    distinct?: PagosDocentesScalarFieldEnum | PagosDocentesScalarFieldEnum[]
  }

  /**
   * pagosDocentes findFirstOrThrow
   */
  export type pagosDocentesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagosDocentes
     */
    select?: pagosDocentesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pagosDocentes
     */
    omit?: pagosDocentesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagosDocentesInclude<ExtArgs> | null
    /**
     * Filter, which pagosDocentes to fetch.
     */
    where?: pagosDocentesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagosDocentes to fetch.
     */
    orderBy?: pagosDocentesOrderByWithRelationInput | pagosDocentesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pagosDocentes.
     */
    cursor?: pagosDocentesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagosDocentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagosDocentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pagosDocentes.
     */
    distinct?: PagosDocentesScalarFieldEnum | PagosDocentesScalarFieldEnum[]
  }

  /**
   * pagosDocentes findMany
   */
  export type pagosDocentesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagosDocentes
     */
    select?: pagosDocentesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pagosDocentes
     */
    omit?: pagosDocentesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagosDocentesInclude<ExtArgs> | null
    /**
     * Filter, which pagosDocentes to fetch.
     */
    where?: pagosDocentesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagosDocentes to fetch.
     */
    orderBy?: pagosDocentesOrderByWithRelationInput | pagosDocentesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pagosDocentes.
     */
    cursor?: pagosDocentesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagosDocentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagosDocentes.
     */
    skip?: number
    distinct?: PagosDocentesScalarFieldEnum | PagosDocentesScalarFieldEnum[]
  }

  /**
   * pagosDocentes create
   */
  export type pagosDocentesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagosDocentes
     */
    select?: pagosDocentesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pagosDocentes
     */
    omit?: pagosDocentesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagosDocentesInclude<ExtArgs> | null
    /**
     * The data needed to create a pagosDocentes.
     */
    data: XOR<pagosDocentesCreateInput, pagosDocentesUncheckedCreateInput>
  }

  /**
   * pagosDocentes createMany
   */
  export type pagosDocentesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pagosDocentes.
     */
    data: pagosDocentesCreateManyInput | pagosDocentesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pagosDocentes createManyAndReturn
   */
  export type pagosDocentesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagosDocentes
     */
    select?: pagosDocentesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pagosDocentes
     */
    omit?: pagosDocentesOmit<ExtArgs> | null
    /**
     * The data used to create many pagosDocentes.
     */
    data: pagosDocentesCreateManyInput | pagosDocentesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagosDocentesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * pagosDocentes update
   */
  export type pagosDocentesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagosDocentes
     */
    select?: pagosDocentesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pagosDocentes
     */
    omit?: pagosDocentesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagosDocentesInclude<ExtArgs> | null
    /**
     * The data needed to update a pagosDocentes.
     */
    data: XOR<pagosDocentesUpdateInput, pagosDocentesUncheckedUpdateInput>
    /**
     * Choose, which pagosDocentes to update.
     */
    where: pagosDocentesWhereUniqueInput
  }

  /**
   * pagosDocentes updateMany
   */
  export type pagosDocentesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pagosDocentes.
     */
    data: XOR<pagosDocentesUpdateManyMutationInput, pagosDocentesUncheckedUpdateManyInput>
    /**
     * Filter which pagosDocentes to update
     */
    where?: pagosDocentesWhereInput
    /**
     * Limit how many pagosDocentes to update.
     */
    limit?: number
  }

  /**
   * pagosDocentes updateManyAndReturn
   */
  export type pagosDocentesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagosDocentes
     */
    select?: pagosDocentesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pagosDocentes
     */
    omit?: pagosDocentesOmit<ExtArgs> | null
    /**
     * The data used to update pagosDocentes.
     */
    data: XOR<pagosDocentesUpdateManyMutationInput, pagosDocentesUncheckedUpdateManyInput>
    /**
     * Filter which pagosDocentes to update
     */
    where?: pagosDocentesWhereInput
    /**
     * Limit how many pagosDocentes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagosDocentesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * pagosDocentes upsert
   */
  export type pagosDocentesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagosDocentes
     */
    select?: pagosDocentesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pagosDocentes
     */
    omit?: pagosDocentesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagosDocentesInclude<ExtArgs> | null
    /**
     * The filter to search for the pagosDocentes to update in case it exists.
     */
    where: pagosDocentesWhereUniqueInput
    /**
     * In case the pagosDocentes found by the `where` argument doesn't exist, create a new pagosDocentes with this data.
     */
    create: XOR<pagosDocentesCreateInput, pagosDocentesUncheckedCreateInput>
    /**
     * In case the pagosDocentes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pagosDocentesUpdateInput, pagosDocentesUncheckedUpdateInput>
  }

  /**
   * pagosDocentes delete
   */
  export type pagosDocentesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagosDocentes
     */
    select?: pagosDocentesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pagosDocentes
     */
    omit?: pagosDocentesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagosDocentesInclude<ExtArgs> | null
    /**
     * Filter which pagosDocentes to delete.
     */
    where: pagosDocentesWhereUniqueInput
  }

  /**
   * pagosDocentes deleteMany
   */
  export type pagosDocentesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pagosDocentes to delete
     */
    where?: pagosDocentesWhereInput
    /**
     * Limit how many pagosDocentes to delete.
     */
    limit?: number
  }

  /**
   * pagosDocentes without action
   */
  export type pagosDocentesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagosDocentes
     */
    select?: pagosDocentesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pagosDocentes
     */
    omit?: pagosDocentesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagosDocentesInclude<ExtArgs> | null
  }


  /**
   * Model preciosCursos
   */

  export type AggregatePreciosCursos = {
    _count: PreciosCursosCountAggregateOutputType | null
    _avg: PreciosCursosAvgAggregateOutputType | null
    _sum: PreciosCursosSumAggregateOutputType | null
    _min: PreciosCursosMinAggregateOutputType | null
    _max: PreciosCursosMaxAggregateOutputType | null
  }

  export type PreciosCursosAvgAggregateOutputType = {
    porcentajeDescuento: number | null
    precio: number | null
    precioOriginal: number | null
  }

  export type PreciosCursosSumAggregateOutputType = {
    porcentajeDescuento: number | null
    precio: number | null
    precioOriginal: number | null
  }

  export type PreciosCursosMinAggregateOutputType = {
    id: string | null
    edicionId: string | null
    fechaInicio: Date | null
    fechaFin: Date | null
    esDescuento: boolean | null
    esPrecioDefault: boolean | null
    moneda: string | null
    nombre: string | null
    porcentajeDescuento: number | null
    precio: number | null
    precioOriginal: number | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type PreciosCursosMaxAggregateOutputType = {
    id: string | null
    edicionId: string | null
    fechaInicio: Date | null
    fechaFin: Date | null
    esDescuento: boolean | null
    esPrecioDefault: boolean | null
    moneda: string | null
    nombre: string | null
    porcentajeDescuento: number | null
    precio: number | null
    precioOriginal: number | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type PreciosCursosCountAggregateOutputType = {
    id: number
    edicionId: number
    fechaInicio: number
    fechaFin: number
    esDescuento: number
    esPrecioDefault: number
    moneda: number
    nombre: number
    porcentajeDescuento: number
    precio: number
    precioOriginal: number
    creadoEn: number
    actualizadoEn: number
    _all: number
  }


  export type PreciosCursosAvgAggregateInputType = {
    porcentajeDescuento?: true
    precio?: true
    precioOriginal?: true
  }

  export type PreciosCursosSumAggregateInputType = {
    porcentajeDescuento?: true
    precio?: true
    precioOriginal?: true
  }

  export type PreciosCursosMinAggregateInputType = {
    id?: true
    edicionId?: true
    fechaInicio?: true
    fechaFin?: true
    esDescuento?: true
    esPrecioDefault?: true
    moneda?: true
    nombre?: true
    porcentajeDescuento?: true
    precio?: true
    precioOriginal?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type PreciosCursosMaxAggregateInputType = {
    id?: true
    edicionId?: true
    fechaInicio?: true
    fechaFin?: true
    esDescuento?: true
    esPrecioDefault?: true
    moneda?: true
    nombre?: true
    porcentajeDescuento?: true
    precio?: true
    precioOriginal?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type PreciosCursosCountAggregateInputType = {
    id?: true
    edicionId?: true
    fechaInicio?: true
    fechaFin?: true
    esDescuento?: true
    esPrecioDefault?: true
    moneda?: true
    nombre?: true
    porcentajeDescuento?: true
    precio?: true
    precioOriginal?: true
    creadoEn?: true
    actualizadoEn?: true
    _all?: true
  }

  export type PreciosCursosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which preciosCursos to aggregate.
     */
    where?: preciosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preciosCursos to fetch.
     */
    orderBy?: preciosCursosOrderByWithRelationInput | preciosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: preciosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preciosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preciosCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned preciosCursos
    **/
    _count?: true | PreciosCursosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PreciosCursosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PreciosCursosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PreciosCursosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PreciosCursosMaxAggregateInputType
  }

  export type GetPreciosCursosAggregateType<T extends PreciosCursosAggregateArgs> = {
        [P in keyof T & keyof AggregatePreciosCursos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePreciosCursos[P]>
      : GetScalarType<T[P], AggregatePreciosCursos[P]>
  }




  export type preciosCursosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: preciosCursosWhereInput
    orderBy?: preciosCursosOrderByWithAggregationInput | preciosCursosOrderByWithAggregationInput[]
    by: PreciosCursosScalarFieldEnum[] | PreciosCursosScalarFieldEnum
    having?: preciosCursosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PreciosCursosCountAggregateInputType | true
    _avg?: PreciosCursosAvgAggregateInputType
    _sum?: PreciosCursosSumAggregateInputType
    _min?: PreciosCursosMinAggregateInputType
    _max?: PreciosCursosMaxAggregateInputType
  }

  export type PreciosCursosGroupByOutputType = {
    id: string
    edicionId: string
    fechaInicio: Date | null
    fechaFin: Date | null
    esDescuento: boolean
    esPrecioDefault: boolean
    moneda: string
    nombre: string
    porcentajeDescuento: number | null
    precio: number
    precioOriginal: number | null
    creadoEn: Date
    actualizadoEn: Date
    _count: PreciosCursosCountAggregateOutputType | null
    _avg: PreciosCursosAvgAggregateOutputType | null
    _sum: PreciosCursosSumAggregateOutputType | null
    _min: PreciosCursosMinAggregateOutputType | null
    _max: PreciosCursosMaxAggregateOutputType | null
  }

  type GetPreciosCursosGroupByPayload<T extends preciosCursosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PreciosCursosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PreciosCursosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PreciosCursosGroupByOutputType[P]>
            : GetScalarType<T[P], PreciosCursosGroupByOutputType[P]>
        }
      >
    >


  export type preciosCursosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    esDescuento?: boolean
    esPrecioDefault?: boolean
    moneda?: boolean
    nombre?: boolean
    porcentajeDescuento?: boolean
    precio?: boolean
    precioOriginal?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preciosCursos"]>

  export type preciosCursosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    esDescuento?: boolean
    esPrecioDefault?: boolean
    moneda?: boolean
    nombre?: boolean
    porcentajeDescuento?: boolean
    precio?: boolean
    precioOriginal?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preciosCursos"]>

  export type preciosCursosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    edicionId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    esDescuento?: boolean
    esPrecioDefault?: boolean
    moneda?: boolean
    nombre?: boolean
    porcentajeDescuento?: boolean
    precio?: boolean
    precioOriginal?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preciosCursos"]>

  export type preciosCursosSelectScalar = {
    id?: boolean
    edicionId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    esDescuento?: boolean
    esPrecioDefault?: boolean
    moneda?: boolean
    nombre?: boolean
    porcentajeDescuento?: boolean
    precio?: boolean
    precioOriginal?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }

  export type preciosCursosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "edicionId" | "fechaInicio" | "fechaFin" | "esDescuento" | "esPrecioDefault" | "moneda" | "nombre" | "porcentajeDescuento" | "precio" | "precioOriginal" | "creadoEn" | "actualizadoEn", ExtArgs["result"]["preciosCursos"]>
  export type preciosCursosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }
  export type preciosCursosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }
  export type preciosCursosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    edicionesCursos?: boolean | edicionesCursosDefaultArgs<ExtArgs>
  }

  export type $preciosCursosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "preciosCursos"
    objects: {
      edicionesCursos: Prisma.$edicionesCursosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      edicionId: string
      fechaInicio: Date | null
      fechaFin: Date | null
      esDescuento: boolean
      esPrecioDefault: boolean
      moneda: string
      nombre: string
      porcentajeDescuento: number | null
      precio: number
      precioOriginal: number | null
      creadoEn: Date
      actualizadoEn: Date
    }, ExtArgs["result"]["preciosCursos"]>
    composites: {}
  }

  type preciosCursosGetPayload<S extends boolean | null | undefined | preciosCursosDefaultArgs> = $Result.GetResult<Prisma.$preciosCursosPayload, S>

  type preciosCursosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<preciosCursosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PreciosCursosCountAggregateInputType | true
    }

  export interface preciosCursosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['preciosCursos'], meta: { name: 'preciosCursos' } }
    /**
     * Find zero or one PreciosCursos that matches the filter.
     * @param {preciosCursosFindUniqueArgs} args - Arguments to find a PreciosCursos
     * @example
     * // Get one PreciosCursos
     * const preciosCursos = await prisma.preciosCursos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends preciosCursosFindUniqueArgs>(args: SelectSubset<T, preciosCursosFindUniqueArgs<ExtArgs>>): Prisma__preciosCursosClient<$Result.GetResult<Prisma.$preciosCursosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PreciosCursos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {preciosCursosFindUniqueOrThrowArgs} args - Arguments to find a PreciosCursos
     * @example
     * // Get one PreciosCursos
     * const preciosCursos = await prisma.preciosCursos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends preciosCursosFindUniqueOrThrowArgs>(args: SelectSubset<T, preciosCursosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__preciosCursosClient<$Result.GetResult<Prisma.$preciosCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PreciosCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preciosCursosFindFirstArgs} args - Arguments to find a PreciosCursos
     * @example
     * // Get one PreciosCursos
     * const preciosCursos = await prisma.preciosCursos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends preciosCursosFindFirstArgs>(args?: SelectSubset<T, preciosCursosFindFirstArgs<ExtArgs>>): Prisma__preciosCursosClient<$Result.GetResult<Prisma.$preciosCursosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PreciosCursos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preciosCursosFindFirstOrThrowArgs} args - Arguments to find a PreciosCursos
     * @example
     * // Get one PreciosCursos
     * const preciosCursos = await prisma.preciosCursos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends preciosCursosFindFirstOrThrowArgs>(args?: SelectSubset<T, preciosCursosFindFirstOrThrowArgs<ExtArgs>>): Prisma__preciosCursosClient<$Result.GetResult<Prisma.$preciosCursosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PreciosCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preciosCursosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PreciosCursos
     * const preciosCursos = await prisma.preciosCursos.findMany()
     * 
     * // Get first 10 PreciosCursos
     * const preciosCursos = await prisma.preciosCursos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const preciosCursosWithIdOnly = await prisma.preciosCursos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends preciosCursosFindManyArgs>(args?: SelectSubset<T, preciosCursosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$preciosCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PreciosCursos.
     * @param {preciosCursosCreateArgs} args - Arguments to create a PreciosCursos.
     * @example
     * // Create one PreciosCursos
     * const PreciosCursos = await prisma.preciosCursos.create({
     *   data: {
     *     // ... data to create a PreciosCursos
     *   }
     * })
     * 
     */
    create<T extends preciosCursosCreateArgs>(args: SelectSubset<T, preciosCursosCreateArgs<ExtArgs>>): Prisma__preciosCursosClient<$Result.GetResult<Prisma.$preciosCursosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PreciosCursos.
     * @param {preciosCursosCreateManyArgs} args - Arguments to create many PreciosCursos.
     * @example
     * // Create many PreciosCursos
     * const preciosCursos = await prisma.preciosCursos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends preciosCursosCreateManyArgs>(args?: SelectSubset<T, preciosCursosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PreciosCursos and returns the data saved in the database.
     * @param {preciosCursosCreateManyAndReturnArgs} args - Arguments to create many PreciosCursos.
     * @example
     * // Create many PreciosCursos
     * const preciosCursos = await prisma.preciosCursos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PreciosCursos and only return the `id`
     * const preciosCursosWithIdOnly = await prisma.preciosCursos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends preciosCursosCreateManyAndReturnArgs>(args?: SelectSubset<T, preciosCursosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$preciosCursosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PreciosCursos.
     * @param {preciosCursosDeleteArgs} args - Arguments to delete one PreciosCursos.
     * @example
     * // Delete one PreciosCursos
     * const PreciosCursos = await prisma.preciosCursos.delete({
     *   where: {
     *     // ... filter to delete one PreciosCursos
     *   }
     * })
     * 
     */
    delete<T extends preciosCursosDeleteArgs>(args: SelectSubset<T, preciosCursosDeleteArgs<ExtArgs>>): Prisma__preciosCursosClient<$Result.GetResult<Prisma.$preciosCursosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PreciosCursos.
     * @param {preciosCursosUpdateArgs} args - Arguments to update one PreciosCursos.
     * @example
     * // Update one PreciosCursos
     * const preciosCursos = await prisma.preciosCursos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends preciosCursosUpdateArgs>(args: SelectSubset<T, preciosCursosUpdateArgs<ExtArgs>>): Prisma__preciosCursosClient<$Result.GetResult<Prisma.$preciosCursosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PreciosCursos.
     * @param {preciosCursosDeleteManyArgs} args - Arguments to filter PreciosCursos to delete.
     * @example
     * // Delete a few PreciosCursos
     * const { count } = await prisma.preciosCursos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends preciosCursosDeleteManyArgs>(args?: SelectSubset<T, preciosCursosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PreciosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preciosCursosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PreciosCursos
     * const preciosCursos = await prisma.preciosCursos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends preciosCursosUpdateManyArgs>(args: SelectSubset<T, preciosCursosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PreciosCursos and returns the data updated in the database.
     * @param {preciosCursosUpdateManyAndReturnArgs} args - Arguments to update many PreciosCursos.
     * @example
     * // Update many PreciosCursos
     * const preciosCursos = await prisma.preciosCursos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PreciosCursos and only return the `id`
     * const preciosCursosWithIdOnly = await prisma.preciosCursos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends preciosCursosUpdateManyAndReturnArgs>(args: SelectSubset<T, preciosCursosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$preciosCursosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PreciosCursos.
     * @param {preciosCursosUpsertArgs} args - Arguments to update or create a PreciosCursos.
     * @example
     * // Update or create a PreciosCursos
     * const preciosCursos = await prisma.preciosCursos.upsert({
     *   create: {
     *     // ... data to create a PreciosCursos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PreciosCursos we want to update
     *   }
     * })
     */
    upsert<T extends preciosCursosUpsertArgs>(args: SelectSubset<T, preciosCursosUpsertArgs<ExtArgs>>): Prisma__preciosCursosClient<$Result.GetResult<Prisma.$preciosCursosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PreciosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preciosCursosCountArgs} args - Arguments to filter PreciosCursos to count.
     * @example
     * // Count the number of PreciosCursos
     * const count = await prisma.preciosCursos.count({
     *   where: {
     *     // ... the filter for the PreciosCursos we want to count
     *   }
     * })
    **/
    count<T extends preciosCursosCountArgs>(
      args?: Subset<T, preciosCursosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PreciosCursosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PreciosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreciosCursosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PreciosCursosAggregateArgs>(args: Subset<T, PreciosCursosAggregateArgs>): Prisma.PrismaPromise<GetPreciosCursosAggregateType<T>>

    /**
     * Group by PreciosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preciosCursosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends preciosCursosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: preciosCursosGroupByArgs['orderBy'] }
        : { orderBy?: preciosCursosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, preciosCursosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPreciosCursosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the preciosCursos model
   */
  readonly fields: preciosCursosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for preciosCursos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__preciosCursosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    edicionesCursos<T extends edicionesCursosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, edicionesCursosDefaultArgs<ExtArgs>>): Prisma__edicionesCursosClient<$Result.GetResult<Prisma.$edicionesCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the preciosCursos model
   */
  interface preciosCursosFieldRefs {
    readonly id: FieldRef<"preciosCursos", 'String'>
    readonly edicionId: FieldRef<"preciosCursos", 'String'>
    readonly fechaInicio: FieldRef<"preciosCursos", 'DateTime'>
    readonly fechaFin: FieldRef<"preciosCursos", 'DateTime'>
    readonly esDescuento: FieldRef<"preciosCursos", 'Boolean'>
    readonly esPrecioDefault: FieldRef<"preciosCursos", 'Boolean'>
    readonly moneda: FieldRef<"preciosCursos", 'String'>
    readonly nombre: FieldRef<"preciosCursos", 'String'>
    readonly porcentajeDescuento: FieldRef<"preciosCursos", 'Float'>
    readonly precio: FieldRef<"preciosCursos", 'Float'>
    readonly precioOriginal: FieldRef<"preciosCursos", 'Float'>
    readonly creadoEn: FieldRef<"preciosCursos", 'DateTime'>
    readonly actualizadoEn: FieldRef<"preciosCursos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * preciosCursos findUnique
   */
  export type preciosCursosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosInclude<ExtArgs> | null
    /**
     * Filter, which preciosCursos to fetch.
     */
    where: preciosCursosWhereUniqueInput
  }

  /**
   * preciosCursos findUniqueOrThrow
   */
  export type preciosCursosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosInclude<ExtArgs> | null
    /**
     * Filter, which preciosCursos to fetch.
     */
    where: preciosCursosWhereUniqueInput
  }

  /**
   * preciosCursos findFirst
   */
  export type preciosCursosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosInclude<ExtArgs> | null
    /**
     * Filter, which preciosCursos to fetch.
     */
    where?: preciosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preciosCursos to fetch.
     */
    orderBy?: preciosCursosOrderByWithRelationInput | preciosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for preciosCursos.
     */
    cursor?: preciosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preciosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preciosCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of preciosCursos.
     */
    distinct?: PreciosCursosScalarFieldEnum | PreciosCursosScalarFieldEnum[]
  }

  /**
   * preciosCursos findFirstOrThrow
   */
  export type preciosCursosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosInclude<ExtArgs> | null
    /**
     * Filter, which preciosCursos to fetch.
     */
    where?: preciosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preciosCursos to fetch.
     */
    orderBy?: preciosCursosOrderByWithRelationInput | preciosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for preciosCursos.
     */
    cursor?: preciosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preciosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preciosCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of preciosCursos.
     */
    distinct?: PreciosCursosScalarFieldEnum | PreciosCursosScalarFieldEnum[]
  }

  /**
   * preciosCursos findMany
   */
  export type preciosCursosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosInclude<ExtArgs> | null
    /**
     * Filter, which preciosCursos to fetch.
     */
    where?: preciosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preciosCursos to fetch.
     */
    orderBy?: preciosCursosOrderByWithRelationInput | preciosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing preciosCursos.
     */
    cursor?: preciosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preciosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preciosCursos.
     */
    skip?: number
    distinct?: PreciosCursosScalarFieldEnum | PreciosCursosScalarFieldEnum[]
  }

  /**
   * preciosCursos create
   */
  export type preciosCursosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosInclude<ExtArgs> | null
    /**
     * The data needed to create a preciosCursos.
     */
    data: XOR<preciosCursosCreateInput, preciosCursosUncheckedCreateInput>
  }

  /**
   * preciosCursos createMany
   */
  export type preciosCursosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many preciosCursos.
     */
    data: preciosCursosCreateManyInput | preciosCursosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * preciosCursos createManyAndReturn
   */
  export type preciosCursosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * The data used to create many preciosCursos.
     */
    data: preciosCursosCreateManyInput | preciosCursosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * preciosCursos update
   */
  export type preciosCursosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosInclude<ExtArgs> | null
    /**
     * The data needed to update a preciosCursos.
     */
    data: XOR<preciosCursosUpdateInput, preciosCursosUncheckedUpdateInput>
    /**
     * Choose, which preciosCursos to update.
     */
    where: preciosCursosWhereUniqueInput
  }

  /**
   * preciosCursos updateMany
   */
  export type preciosCursosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update preciosCursos.
     */
    data: XOR<preciosCursosUpdateManyMutationInput, preciosCursosUncheckedUpdateManyInput>
    /**
     * Filter which preciosCursos to update
     */
    where?: preciosCursosWhereInput
    /**
     * Limit how many preciosCursos to update.
     */
    limit?: number
  }

  /**
   * preciosCursos updateManyAndReturn
   */
  export type preciosCursosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * The data used to update preciosCursos.
     */
    data: XOR<preciosCursosUpdateManyMutationInput, preciosCursosUncheckedUpdateManyInput>
    /**
     * Filter which preciosCursos to update
     */
    where?: preciosCursosWhereInput
    /**
     * Limit how many preciosCursos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * preciosCursos upsert
   */
  export type preciosCursosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosInclude<ExtArgs> | null
    /**
     * The filter to search for the preciosCursos to update in case it exists.
     */
    where: preciosCursosWhereUniqueInput
    /**
     * In case the preciosCursos found by the `where` argument doesn't exist, create a new preciosCursos with this data.
     */
    create: XOR<preciosCursosCreateInput, preciosCursosUncheckedCreateInput>
    /**
     * In case the preciosCursos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<preciosCursosUpdateInput, preciosCursosUncheckedUpdateInput>
  }

  /**
   * preciosCursos delete
   */
  export type preciosCursosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosInclude<ExtArgs> | null
    /**
     * Filter which preciosCursos to delete.
     */
    where: preciosCursosWhereUniqueInput
  }

  /**
   * preciosCursos deleteMany
   */
  export type preciosCursosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which preciosCursos to delete
     */
    where?: preciosCursosWhereInput
    /**
     * Limit how many preciosCursos to delete.
     */
    limit?: number
  }

  /**
   * preciosCursos without action
   */
  export type preciosCursosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preciosCursos
     */
    select?: preciosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preciosCursos
     */
    omit?: preciosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preciosCursosInclude<ExtArgs> | null
  }


  /**
   * Model preguntas
   */

  export type AggregatePreguntas = {
    _count: PreguntasCountAggregateOutputType | null
    _avg: PreguntasAvgAggregateOutputType | null
    _sum: PreguntasSumAggregateOutputType | null
    _min: PreguntasMinAggregateOutputType | null
    _max: PreguntasMaxAggregateOutputType | null
  }

  export type PreguntasAvgAggregateOutputType = {
    gestion: number | null
    likes: number | null
    dislikes: number | null
    tasaAcierto: number | null
    totalBien: number | null
    totalMal: number | null
    totalRespondidas: number | null
  }

  export type PreguntasSumAggregateOutputType = {
    gestion: number | null
    likes: number | null
    dislikes: number | null
    tasaAcierto: number | null
    totalBien: number | null
    totalMal: number | null
    totalRespondidas: number | null
  }

  export type PreguntasMinAggregateOutputType = {
    id: string | null
    codigo: string | null
    enunciado: string | null
    explicacion: string | null
    referencia: string | null
    estado: $Enums.PreguntaEstado | null
    gestion: number | null
    likes: number | null
    dislikes: number | null
    dificultad: $Enums.PreguntaDificultad | null
    dificultadActualizadaEn: Date | null
    tasaAcierto: number | null
    totalBien: number | null
    totalMal: number | null
    totalRespondidas: number | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type PreguntasMaxAggregateOutputType = {
    id: string | null
    codigo: string | null
    enunciado: string | null
    explicacion: string | null
    referencia: string | null
    estado: $Enums.PreguntaEstado | null
    gestion: number | null
    likes: number | null
    dislikes: number | null
    dificultad: $Enums.PreguntaDificultad | null
    dificultadActualizadaEn: Date | null
    tasaAcierto: number | null
    totalBien: number | null
    totalMal: number | null
    totalRespondidas: number | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type PreguntasCountAggregateOutputType = {
    id: number
    codigo: number
    enunciado: number
    explicacion: number
    referencia: number
    opciones: number
    solucion: number
    estado: number
    gestion: number
    likes: number
    dislikes: number
    dificultad: number
    dificultadActualizadaEn: number
    tasaAcierto: number
    totalBien: number
    totalMal: number
    totalRespondidas: number
    creadoEn: number
    actualizadoEn: number
    _all: number
  }


  export type PreguntasAvgAggregateInputType = {
    gestion?: true
    likes?: true
    dislikes?: true
    tasaAcierto?: true
    totalBien?: true
    totalMal?: true
    totalRespondidas?: true
  }

  export type PreguntasSumAggregateInputType = {
    gestion?: true
    likes?: true
    dislikes?: true
    tasaAcierto?: true
    totalBien?: true
    totalMal?: true
    totalRespondidas?: true
  }

  export type PreguntasMinAggregateInputType = {
    id?: true
    codigo?: true
    enunciado?: true
    explicacion?: true
    referencia?: true
    estado?: true
    gestion?: true
    likes?: true
    dislikes?: true
    dificultad?: true
    dificultadActualizadaEn?: true
    tasaAcierto?: true
    totalBien?: true
    totalMal?: true
    totalRespondidas?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type PreguntasMaxAggregateInputType = {
    id?: true
    codigo?: true
    enunciado?: true
    explicacion?: true
    referencia?: true
    estado?: true
    gestion?: true
    likes?: true
    dislikes?: true
    dificultad?: true
    dificultadActualizadaEn?: true
    tasaAcierto?: true
    totalBien?: true
    totalMal?: true
    totalRespondidas?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type PreguntasCountAggregateInputType = {
    id?: true
    codigo?: true
    enunciado?: true
    explicacion?: true
    referencia?: true
    opciones?: true
    solucion?: true
    estado?: true
    gestion?: true
    likes?: true
    dislikes?: true
    dificultad?: true
    dificultadActualizadaEn?: true
    tasaAcierto?: true
    totalBien?: true
    totalMal?: true
    totalRespondidas?: true
    creadoEn?: true
    actualizadoEn?: true
    _all?: true
  }

  export type PreguntasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which preguntas to aggregate.
     */
    where?: preguntasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preguntas to fetch.
     */
    orderBy?: preguntasOrderByWithRelationInput | preguntasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: preguntasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preguntas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preguntas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned preguntas
    **/
    _count?: true | PreguntasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PreguntasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PreguntasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PreguntasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PreguntasMaxAggregateInputType
  }

  export type GetPreguntasAggregateType<T extends PreguntasAggregateArgs> = {
        [P in keyof T & keyof AggregatePreguntas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePreguntas[P]>
      : GetScalarType<T[P], AggregatePreguntas[P]>
  }




  export type preguntasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: preguntasWhereInput
    orderBy?: preguntasOrderByWithAggregationInput | preguntasOrderByWithAggregationInput[]
    by: PreguntasScalarFieldEnum[] | PreguntasScalarFieldEnum
    having?: preguntasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PreguntasCountAggregateInputType | true
    _avg?: PreguntasAvgAggregateInputType
    _sum?: PreguntasSumAggregateInputType
    _min?: PreguntasMinAggregateInputType
    _max?: PreguntasMaxAggregateInputType
  }

  export type PreguntasGroupByOutputType = {
    id: string
    codigo: string
    enunciado: string
    explicacion: string | null
    referencia: string | null
    opciones: JsonValue
    solucion: JsonValue
    estado: $Enums.PreguntaEstado
    gestion: number
    likes: number
    dislikes: number
    dificultad: $Enums.PreguntaDificultad
    dificultadActualizadaEn: Date | null
    tasaAcierto: number
    totalBien: number
    totalMal: number
    totalRespondidas: number
    creadoEn: Date
    actualizadoEn: Date
    _count: PreguntasCountAggregateOutputType | null
    _avg: PreguntasAvgAggregateOutputType | null
    _sum: PreguntasSumAggregateOutputType | null
    _min: PreguntasMinAggregateOutputType | null
    _max: PreguntasMaxAggregateOutputType | null
  }

  type GetPreguntasGroupByPayload<T extends preguntasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PreguntasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PreguntasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PreguntasGroupByOutputType[P]>
            : GetScalarType<T[P], PreguntasGroupByOutputType[P]>
        }
      >
    >


  export type preguntasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    enunciado?: boolean
    explicacion?: boolean
    referencia?: boolean
    opciones?: boolean
    solucion?: boolean
    estado?: boolean
    gestion?: boolean
    likes?: boolean
    dislikes?: boolean
    dificultad?: boolean
    dificultadActualizadaEn?: boolean
    tasaAcierto?: boolean
    totalBien?: boolean
    totalMal?: boolean
    totalRespondidas?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    reaccionesPreguntas?: boolean | preguntas$reaccionesPreguntasArgs<ExtArgs>
    repasoRegistros?: boolean | preguntas$repasoRegistrosArgs<ExtArgs>
    respuestasIntentos?: boolean | preguntas$respuestasIntentosArgs<ExtArgs>
    areas?: boolean | preguntas$areasArgs<ExtArgs>
    banqueo?: boolean | preguntas$banqueoArgs<ExtArgs>
    capitulos?: boolean | preguntas$capitulosArgs<ExtArgs>
    temas?: boolean | preguntas$temasArgs<ExtArgs>
    _count?: boolean | PreguntasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preguntas"]>

  export type preguntasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    enunciado?: boolean
    explicacion?: boolean
    referencia?: boolean
    opciones?: boolean
    solucion?: boolean
    estado?: boolean
    gestion?: boolean
    likes?: boolean
    dislikes?: boolean
    dificultad?: boolean
    dificultadActualizadaEn?: boolean
    tasaAcierto?: boolean
    totalBien?: boolean
    totalMal?: boolean
    totalRespondidas?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }, ExtArgs["result"]["preguntas"]>

  export type preguntasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    enunciado?: boolean
    explicacion?: boolean
    referencia?: boolean
    opciones?: boolean
    solucion?: boolean
    estado?: boolean
    gestion?: boolean
    likes?: boolean
    dislikes?: boolean
    dificultad?: boolean
    dificultadActualizadaEn?: boolean
    tasaAcierto?: boolean
    totalBien?: boolean
    totalMal?: boolean
    totalRespondidas?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }, ExtArgs["result"]["preguntas"]>

  export type preguntasSelectScalar = {
    id?: boolean
    codigo?: boolean
    enunciado?: boolean
    explicacion?: boolean
    referencia?: boolean
    opciones?: boolean
    solucion?: boolean
    estado?: boolean
    gestion?: boolean
    likes?: boolean
    dislikes?: boolean
    dificultad?: boolean
    dificultadActualizadaEn?: boolean
    tasaAcierto?: boolean
    totalBien?: boolean
    totalMal?: boolean
    totalRespondidas?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }

  export type preguntasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "codigo" | "enunciado" | "explicacion" | "referencia" | "opciones" | "solucion" | "estado" | "gestion" | "likes" | "dislikes" | "dificultad" | "dificultadActualizadaEn" | "tasaAcierto" | "totalBien" | "totalMal" | "totalRespondidas" | "creadoEn" | "actualizadoEn", ExtArgs["result"]["preguntas"]>
  export type preguntasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reaccionesPreguntas?: boolean | preguntas$reaccionesPreguntasArgs<ExtArgs>
    repasoRegistros?: boolean | preguntas$repasoRegistrosArgs<ExtArgs>
    respuestasIntentos?: boolean | preguntas$respuestasIntentosArgs<ExtArgs>
    areas?: boolean | preguntas$areasArgs<ExtArgs>
    banqueo?: boolean | preguntas$banqueoArgs<ExtArgs>
    capitulos?: boolean | preguntas$capitulosArgs<ExtArgs>
    temas?: boolean | preguntas$temasArgs<ExtArgs>
    _count?: boolean | PreguntasCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type preguntasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type preguntasIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $preguntasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "preguntas"
    objects: {
      reaccionesPreguntas: Prisma.$reaccionesPreguntasPayload<ExtArgs>[]
      repasoRegistros: Prisma.$repasoRegistrosPayload<ExtArgs>[]
      respuestasIntentos: Prisma.$respuestasIntentosPayload<ExtArgs>[]
      areas: Prisma.$areasPayload<ExtArgs>[]
      banqueo: Prisma.$banqueoPayload<ExtArgs>[]
      capitulos: Prisma.$capitulosPayload<ExtArgs>[]
      temas: Prisma.$temasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      codigo: string
      enunciado: string
      explicacion: string | null
      referencia: string | null
      opciones: Prisma.JsonValue
      solucion: Prisma.JsonValue
      estado: $Enums.PreguntaEstado
      gestion: number
      likes: number
      dislikes: number
      dificultad: $Enums.PreguntaDificultad
      dificultadActualizadaEn: Date | null
      tasaAcierto: number
      totalBien: number
      totalMal: number
      totalRespondidas: number
      creadoEn: Date
      actualizadoEn: Date
    }, ExtArgs["result"]["preguntas"]>
    composites: {}
  }

  type preguntasGetPayload<S extends boolean | null | undefined | preguntasDefaultArgs> = $Result.GetResult<Prisma.$preguntasPayload, S>

  type preguntasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<preguntasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PreguntasCountAggregateInputType | true
    }

  export interface preguntasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['preguntas'], meta: { name: 'preguntas' } }
    /**
     * Find zero or one Preguntas that matches the filter.
     * @param {preguntasFindUniqueArgs} args - Arguments to find a Preguntas
     * @example
     * // Get one Preguntas
     * const preguntas = await prisma.preguntas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends preguntasFindUniqueArgs>(args: SelectSubset<T, preguntasFindUniqueArgs<ExtArgs>>): Prisma__preguntasClient<$Result.GetResult<Prisma.$preguntasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Preguntas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {preguntasFindUniqueOrThrowArgs} args - Arguments to find a Preguntas
     * @example
     * // Get one Preguntas
     * const preguntas = await prisma.preguntas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends preguntasFindUniqueOrThrowArgs>(args: SelectSubset<T, preguntasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__preguntasClient<$Result.GetResult<Prisma.$preguntasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Preguntas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preguntasFindFirstArgs} args - Arguments to find a Preguntas
     * @example
     * // Get one Preguntas
     * const preguntas = await prisma.preguntas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends preguntasFindFirstArgs>(args?: SelectSubset<T, preguntasFindFirstArgs<ExtArgs>>): Prisma__preguntasClient<$Result.GetResult<Prisma.$preguntasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Preguntas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preguntasFindFirstOrThrowArgs} args - Arguments to find a Preguntas
     * @example
     * // Get one Preguntas
     * const preguntas = await prisma.preguntas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends preguntasFindFirstOrThrowArgs>(args?: SelectSubset<T, preguntasFindFirstOrThrowArgs<ExtArgs>>): Prisma__preguntasClient<$Result.GetResult<Prisma.$preguntasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Preguntas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preguntasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Preguntas
     * const preguntas = await prisma.preguntas.findMany()
     * 
     * // Get first 10 Preguntas
     * const preguntas = await prisma.preguntas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const preguntasWithIdOnly = await prisma.preguntas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends preguntasFindManyArgs>(args?: SelectSubset<T, preguntasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$preguntasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Preguntas.
     * @param {preguntasCreateArgs} args - Arguments to create a Preguntas.
     * @example
     * // Create one Preguntas
     * const Preguntas = await prisma.preguntas.create({
     *   data: {
     *     // ... data to create a Preguntas
     *   }
     * })
     * 
     */
    create<T extends preguntasCreateArgs>(args: SelectSubset<T, preguntasCreateArgs<ExtArgs>>): Prisma__preguntasClient<$Result.GetResult<Prisma.$preguntasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Preguntas.
     * @param {preguntasCreateManyArgs} args - Arguments to create many Preguntas.
     * @example
     * // Create many Preguntas
     * const preguntas = await prisma.preguntas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends preguntasCreateManyArgs>(args?: SelectSubset<T, preguntasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Preguntas and returns the data saved in the database.
     * @param {preguntasCreateManyAndReturnArgs} args - Arguments to create many Preguntas.
     * @example
     * // Create many Preguntas
     * const preguntas = await prisma.preguntas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Preguntas and only return the `id`
     * const preguntasWithIdOnly = await prisma.preguntas.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends preguntasCreateManyAndReturnArgs>(args?: SelectSubset<T, preguntasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$preguntasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Preguntas.
     * @param {preguntasDeleteArgs} args - Arguments to delete one Preguntas.
     * @example
     * // Delete one Preguntas
     * const Preguntas = await prisma.preguntas.delete({
     *   where: {
     *     // ... filter to delete one Preguntas
     *   }
     * })
     * 
     */
    delete<T extends preguntasDeleteArgs>(args: SelectSubset<T, preguntasDeleteArgs<ExtArgs>>): Prisma__preguntasClient<$Result.GetResult<Prisma.$preguntasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Preguntas.
     * @param {preguntasUpdateArgs} args - Arguments to update one Preguntas.
     * @example
     * // Update one Preguntas
     * const preguntas = await prisma.preguntas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends preguntasUpdateArgs>(args: SelectSubset<T, preguntasUpdateArgs<ExtArgs>>): Prisma__preguntasClient<$Result.GetResult<Prisma.$preguntasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Preguntas.
     * @param {preguntasDeleteManyArgs} args - Arguments to filter Preguntas to delete.
     * @example
     * // Delete a few Preguntas
     * const { count } = await prisma.preguntas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends preguntasDeleteManyArgs>(args?: SelectSubset<T, preguntasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Preguntas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preguntasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Preguntas
     * const preguntas = await prisma.preguntas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends preguntasUpdateManyArgs>(args: SelectSubset<T, preguntasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Preguntas and returns the data updated in the database.
     * @param {preguntasUpdateManyAndReturnArgs} args - Arguments to update many Preguntas.
     * @example
     * // Update many Preguntas
     * const preguntas = await prisma.preguntas.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Preguntas and only return the `id`
     * const preguntasWithIdOnly = await prisma.preguntas.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends preguntasUpdateManyAndReturnArgs>(args: SelectSubset<T, preguntasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$preguntasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Preguntas.
     * @param {preguntasUpsertArgs} args - Arguments to update or create a Preguntas.
     * @example
     * // Update or create a Preguntas
     * const preguntas = await prisma.preguntas.upsert({
     *   create: {
     *     // ... data to create a Preguntas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Preguntas we want to update
     *   }
     * })
     */
    upsert<T extends preguntasUpsertArgs>(args: SelectSubset<T, preguntasUpsertArgs<ExtArgs>>): Prisma__preguntasClient<$Result.GetResult<Prisma.$preguntasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Preguntas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preguntasCountArgs} args - Arguments to filter Preguntas to count.
     * @example
     * // Count the number of Preguntas
     * const count = await prisma.preguntas.count({
     *   where: {
     *     // ... the filter for the Preguntas we want to count
     *   }
     * })
    **/
    count<T extends preguntasCountArgs>(
      args?: Subset<T, preguntasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PreguntasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Preguntas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreguntasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PreguntasAggregateArgs>(args: Subset<T, PreguntasAggregateArgs>): Prisma.PrismaPromise<GetPreguntasAggregateType<T>>

    /**
     * Group by Preguntas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {preguntasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends preguntasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: preguntasGroupByArgs['orderBy'] }
        : { orderBy?: preguntasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, preguntasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPreguntasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the preguntas model
   */
  readonly fields: preguntasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for preguntas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__preguntasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reaccionesPreguntas<T extends preguntas$reaccionesPreguntasArgs<ExtArgs> = {}>(args?: Subset<T, preguntas$reaccionesPreguntasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reaccionesPreguntasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    repasoRegistros<T extends preguntas$repasoRegistrosArgs<ExtArgs> = {}>(args?: Subset<T, preguntas$repasoRegistrosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$repasoRegistrosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    respuestasIntentos<T extends preguntas$respuestasIntentosArgs<ExtArgs> = {}>(args?: Subset<T, preguntas$respuestasIntentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$respuestasIntentosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    areas<T extends preguntas$areasArgs<ExtArgs> = {}>(args?: Subset<T, preguntas$areasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$areasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    banqueo<T extends preguntas$banqueoArgs<ExtArgs> = {}>(args?: Subset<T, preguntas$banqueoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$banqueoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    capitulos<T extends preguntas$capitulosArgs<ExtArgs> = {}>(args?: Subset<T, preguntas$capitulosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$capitulosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    temas<T extends preguntas$temasArgs<ExtArgs> = {}>(args?: Subset<T, preguntas$temasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$temasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the preguntas model
   */
  interface preguntasFieldRefs {
    readonly id: FieldRef<"preguntas", 'String'>
    readonly codigo: FieldRef<"preguntas", 'String'>
    readonly enunciado: FieldRef<"preguntas", 'String'>
    readonly explicacion: FieldRef<"preguntas", 'String'>
    readonly referencia: FieldRef<"preguntas", 'String'>
    readonly opciones: FieldRef<"preguntas", 'Json'>
    readonly solucion: FieldRef<"preguntas", 'Json'>
    readonly estado: FieldRef<"preguntas", 'PreguntaEstado'>
    readonly gestion: FieldRef<"preguntas", 'Int'>
    readonly likes: FieldRef<"preguntas", 'Int'>
    readonly dislikes: FieldRef<"preguntas", 'Int'>
    readonly dificultad: FieldRef<"preguntas", 'PreguntaDificultad'>
    readonly dificultadActualizadaEn: FieldRef<"preguntas", 'DateTime'>
    readonly tasaAcierto: FieldRef<"preguntas", 'Int'>
    readonly totalBien: FieldRef<"preguntas", 'Int'>
    readonly totalMal: FieldRef<"preguntas", 'Int'>
    readonly totalRespondidas: FieldRef<"preguntas", 'Int'>
    readonly creadoEn: FieldRef<"preguntas", 'DateTime'>
    readonly actualizadoEn: FieldRef<"preguntas", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * preguntas findUnique
   */
  export type preguntasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preguntas
     */
    select?: preguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preguntas
     */
    omit?: preguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preguntasInclude<ExtArgs> | null
    /**
     * Filter, which preguntas to fetch.
     */
    where: preguntasWhereUniqueInput
  }

  /**
   * preguntas findUniqueOrThrow
   */
  export type preguntasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preguntas
     */
    select?: preguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preguntas
     */
    omit?: preguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preguntasInclude<ExtArgs> | null
    /**
     * Filter, which preguntas to fetch.
     */
    where: preguntasWhereUniqueInput
  }

  /**
   * preguntas findFirst
   */
  export type preguntasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preguntas
     */
    select?: preguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preguntas
     */
    omit?: preguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preguntasInclude<ExtArgs> | null
    /**
     * Filter, which preguntas to fetch.
     */
    where?: preguntasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preguntas to fetch.
     */
    orderBy?: preguntasOrderByWithRelationInput | preguntasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for preguntas.
     */
    cursor?: preguntasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preguntas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preguntas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of preguntas.
     */
    distinct?: PreguntasScalarFieldEnum | PreguntasScalarFieldEnum[]
  }

  /**
   * preguntas findFirstOrThrow
   */
  export type preguntasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preguntas
     */
    select?: preguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preguntas
     */
    omit?: preguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preguntasInclude<ExtArgs> | null
    /**
     * Filter, which preguntas to fetch.
     */
    where?: preguntasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preguntas to fetch.
     */
    orderBy?: preguntasOrderByWithRelationInput | preguntasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for preguntas.
     */
    cursor?: preguntasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preguntas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preguntas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of preguntas.
     */
    distinct?: PreguntasScalarFieldEnum | PreguntasScalarFieldEnum[]
  }

  /**
   * preguntas findMany
   */
  export type preguntasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preguntas
     */
    select?: preguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preguntas
     */
    omit?: preguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preguntasInclude<ExtArgs> | null
    /**
     * Filter, which preguntas to fetch.
     */
    where?: preguntasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of preguntas to fetch.
     */
    orderBy?: preguntasOrderByWithRelationInput | preguntasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing preguntas.
     */
    cursor?: preguntasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` preguntas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` preguntas.
     */
    skip?: number
    distinct?: PreguntasScalarFieldEnum | PreguntasScalarFieldEnum[]
  }

  /**
   * preguntas create
   */
  export type preguntasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preguntas
     */
    select?: preguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preguntas
     */
    omit?: preguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preguntasInclude<ExtArgs> | null
    /**
     * The data needed to create a preguntas.
     */
    data: XOR<preguntasCreateInput, preguntasUncheckedCreateInput>
  }

  /**
   * preguntas createMany
   */
  export type preguntasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many preguntas.
     */
    data: preguntasCreateManyInput | preguntasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * preguntas createManyAndReturn
   */
  export type preguntasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preguntas
     */
    select?: preguntasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the preguntas
     */
    omit?: preguntasOmit<ExtArgs> | null
    /**
     * The data used to create many preguntas.
     */
    data: preguntasCreateManyInput | preguntasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * preguntas update
   */
  export type preguntasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preguntas
     */
    select?: preguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preguntas
     */
    omit?: preguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preguntasInclude<ExtArgs> | null
    /**
     * The data needed to update a preguntas.
     */
    data: XOR<preguntasUpdateInput, preguntasUncheckedUpdateInput>
    /**
     * Choose, which preguntas to update.
     */
    where: preguntasWhereUniqueInput
  }

  /**
   * preguntas updateMany
   */
  export type preguntasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update preguntas.
     */
    data: XOR<preguntasUpdateManyMutationInput, preguntasUncheckedUpdateManyInput>
    /**
     * Filter which preguntas to update
     */
    where?: preguntasWhereInput
    /**
     * Limit how many preguntas to update.
     */
    limit?: number
  }

  /**
   * preguntas updateManyAndReturn
   */
  export type preguntasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preguntas
     */
    select?: preguntasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the preguntas
     */
    omit?: preguntasOmit<ExtArgs> | null
    /**
     * The data used to update preguntas.
     */
    data: XOR<preguntasUpdateManyMutationInput, preguntasUncheckedUpdateManyInput>
    /**
     * Filter which preguntas to update
     */
    where?: preguntasWhereInput
    /**
     * Limit how many preguntas to update.
     */
    limit?: number
  }

  /**
   * preguntas upsert
   */
  export type preguntasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preguntas
     */
    select?: preguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preguntas
     */
    omit?: preguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preguntasInclude<ExtArgs> | null
    /**
     * The filter to search for the preguntas to update in case it exists.
     */
    where: preguntasWhereUniqueInput
    /**
     * In case the preguntas found by the `where` argument doesn't exist, create a new preguntas with this data.
     */
    create: XOR<preguntasCreateInput, preguntasUncheckedCreateInput>
    /**
     * In case the preguntas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<preguntasUpdateInput, preguntasUncheckedUpdateInput>
  }

  /**
   * preguntas delete
   */
  export type preguntasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preguntas
     */
    select?: preguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preguntas
     */
    omit?: preguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preguntasInclude<ExtArgs> | null
    /**
     * Filter which preguntas to delete.
     */
    where: preguntasWhereUniqueInput
  }

  /**
   * preguntas deleteMany
   */
  export type preguntasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which preguntas to delete
     */
    where?: preguntasWhereInput
    /**
     * Limit how many preguntas to delete.
     */
    limit?: number
  }

  /**
   * preguntas.reaccionesPreguntas
   */
  export type preguntas$reaccionesPreguntasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reaccionesPreguntas
     */
    select?: reaccionesPreguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reaccionesPreguntas
     */
    omit?: reaccionesPreguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reaccionesPreguntasInclude<ExtArgs> | null
    where?: reaccionesPreguntasWhereInput
    orderBy?: reaccionesPreguntasOrderByWithRelationInput | reaccionesPreguntasOrderByWithRelationInput[]
    cursor?: reaccionesPreguntasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReaccionesPreguntasScalarFieldEnum | ReaccionesPreguntasScalarFieldEnum[]
  }

  /**
   * preguntas.repasoRegistros
   */
  export type preguntas$repasoRegistrosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repasoRegistros
     */
    select?: repasoRegistrosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repasoRegistros
     */
    omit?: repasoRegistrosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: repasoRegistrosInclude<ExtArgs> | null
    where?: repasoRegistrosWhereInput
    orderBy?: repasoRegistrosOrderByWithRelationInput | repasoRegistrosOrderByWithRelationInput[]
    cursor?: repasoRegistrosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RepasoRegistrosScalarFieldEnum | RepasoRegistrosScalarFieldEnum[]
  }

  /**
   * preguntas.respuestasIntentos
   */
  export type preguntas$respuestasIntentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the respuestasIntentos
     */
    select?: respuestasIntentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the respuestasIntentos
     */
    omit?: respuestasIntentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: respuestasIntentosInclude<ExtArgs> | null
    where?: respuestasIntentosWhereInput
    orderBy?: respuestasIntentosOrderByWithRelationInput | respuestasIntentosOrderByWithRelationInput[]
    cursor?: respuestasIntentosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RespuestasIntentosScalarFieldEnum | RespuestasIntentosScalarFieldEnum[]
  }

  /**
   * preguntas.areas
   */
  export type preguntas$areasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the areas
     */
    select?: areasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the areas
     */
    omit?: areasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: areasInclude<ExtArgs> | null
    where?: areasWhereInput
    orderBy?: areasOrderByWithRelationInput | areasOrderByWithRelationInput[]
    cursor?: areasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AreasScalarFieldEnum | AreasScalarFieldEnum[]
  }

  /**
   * preguntas.banqueo
   */
  export type preguntas$banqueoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banqueo
     */
    select?: banqueoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banqueo
     */
    omit?: banqueoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banqueoInclude<ExtArgs> | null
    where?: banqueoWhereInput
    orderBy?: banqueoOrderByWithRelationInput | banqueoOrderByWithRelationInput[]
    cursor?: banqueoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BanqueoScalarFieldEnum | BanqueoScalarFieldEnum[]
  }

  /**
   * preguntas.capitulos
   */
  export type preguntas$capitulosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capitulos
     */
    select?: capitulosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capitulos
     */
    omit?: capitulosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capitulosInclude<ExtArgs> | null
    where?: capitulosWhereInput
    orderBy?: capitulosOrderByWithRelationInput | capitulosOrderByWithRelationInput[]
    cursor?: capitulosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CapitulosScalarFieldEnum | CapitulosScalarFieldEnum[]
  }

  /**
   * preguntas.temas
   */
  export type preguntas$temasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temas
     */
    select?: temasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the temas
     */
    omit?: temasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: temasInclude<ExtArgs> | null
    where?: temasWhereInput
    orderBy?: temasOrderByWithRelationInput | temasOrderByWithRelationInput[]
    cursor?: temasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemasScalarFieldEnum | TemasScalarFieldEnum[]
  }

  /**
   * preguntas without action
   */
  export type preguntasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preguntas
     */
    select?: preguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preguntas
     */
    omit?: preguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preguntasInclude<ExtArgs> | null
  }


  /**
   * Model reaccionesPreguntas
   */

  export type AggregateReaccionesPreguntas = {
    _count: ReaccionesPreguntasCountAggregateOutputType | null
    _min: ReaccionesPreguntasMinAggregateOutputType | null
    _max: ReaccionesPreguntasMaxAggregateOutputType | null
  }

  export type ReaccionesPreguntasMinAggregateOutputType = {
    id: string | null
    preguntaId: string | null
    usuarioEstudianteId: string | null
    tipo: $Enums.TipoReaccion | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type ReaccionesPreguntasMaxAggregateOutputType = {
    id: string | null
    preguntaId: string | null
    usuarioEstudianteId: string | null
    tipo: $Enums.TipoReaccion | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type ReaccionesPreguntasCountAggregateOutputType = {
    id: number
    preguntaId: number
    usuarioEstudianteId: number
    tipo: number
    creadoEn: number
    actualizadoEn: number
    _all: number
  }


  export type ReaccionesPreguntasMinAggregateInputType = {
    id?: true
    preguntaId?: true
    usuarioEstudianteId?: true
    tipo?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type ReaccionesPreguntasMaxAggregateInputType = {
    id?: true
    preguntaId?: true
    usuarioEstudianteId?: true
    tipo?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type ReaccionesPreguntasCountAggregateInputType = {
    id?: true
    preguntaId?: true
    usuarioEstudianteId?: true
    tipo?: true
    creadoEn?: true
    actualizadoEn?: true
    _all?: true
  }

  export type ReaccionesPreguntasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reaccionesPreguntas to aggregate.
     */
    where?: reaccionesPreguntasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reaccionesPreguntas to fetch.
     */
    orderBy?: reaccionesPreguntasOrderByWithRelationInput | reaccionesPreguntasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reaccionesPreguntasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reaccionesPreguntas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reaccionesPreguntas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reaccionesPreguntas
    **/
    _count?: true | ReaccionesPreguntasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReaccionesPreguntasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReaccionesPreguntasMaxAggregateInputType
  }

  export type GetReaccionesPreguntasAggregateType<T extends ReaccionesPreguntasAggregateArgs> = {
        [P in keyof T & keyof AggregateReaccionesPreguntas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReaccionesPreguntas[P]>
      : GetScalarType<T[P], AggregateReaccionesPreguntas[P]>
  }




  export type reaccionesPreguntasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reaccionesPreguntasWhereInput
    orderBy?: reaccionesPreguntasOrderByWithAggregationInput | reaccionesPreguntasOrderByWithAggregationInput[]
    by: ReaccionesPreguntasScalarFieldEnum[] | ReaccionesPreguntasScalarFieldEnum
    having?: reaccionesPreguntasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReaccionesPreguntasCountAggregateInputType | true
    _min?: ReaccionesPreguntasMinAggregateInputType
    _max?: ReaccionesPreguntasMaxAggregateInputType
  }

  export type ReaccionesPreguntasGroupByOutputType = {
    id: string
    preguntaId: string
    usuarioEstudianteId: string
    tipo: $Enums.TipoReaccion
    creadoEn: Date
    actualizadoEn: Date
    _count: ReaccionesPreguntasCountAggregateOutputType | null
    _min: ReaccionesPreguntasMinAggregateOutputType | null
    _max: ReaccionesPreguntasMaxAggregateOutputType | null
  }

  type GetReaccionesPreguntasGroupByPayload<T extends reaccionesPreguntasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReaccionesPreguntasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReaccionesPreguntasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReaccionesPreguntasGroupByOutputType[P]>
            : GetScalarType<T[P], ReaccionesPreguntasGroupByOutputType[P]>
        }
      >
    >


  export type reaccionesPreguntasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    preguntaId?: boolean
    usuarioEstudianteId?: boolean
    tipo?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    pregunta?: boolean | preguntasDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | usuariosEstudiantesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reaccionesPreguntas"]>

  export type reaccionesPreguntasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    preguntaId?: boolean
    usuarioEstudianteId?: boolean
    tipo?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    pregunta?: boolean | preguntasDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | usuariosEstudiantesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reaccionesPreguntas"]>

  export type reaccionesPreguntasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    preguntaId?: boolean
    usuarioEstudianteId?: boolean
    tipo?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    pregunta?: boolean | preguntasDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | usuariosEstudiantesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reaccionesPreguntas"]>

  export type reaccionesPreguntasSelectScalar = {
    id?: boolean
    preguntaId?: boolean
    usuarioEstudianteId?: boolean
    tipo?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }

  export type reaccionesPreguntasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "preguntaId" | "usuarioEstudianteId" | "tipo" | "creadoEn" | "actualizadoEn", ExtArgs["result"]["reaccionesPreguntas"]>
  export type reaccionesPreguntasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pregunta?: boolean | preguntasDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | usuariosEstudiantesDefaultArgs<ExtArgs>
  }
  export type reaccionesPreguntasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pregunta?: boolean | preguntasDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | usuariosEstudiantesDefaultArgs<ExtArgs>
  }
  export type reaccionesPreguntasIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pregunta?: boolean | preguntasDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | usuariosEstudiantesDefaultArgs<ExtArgs>
  }

  export type $reaccionesPreguntasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reaccionesPreguntas"
    objects: {
      pregunta: Prisma.$preguntasPayload<ExtArgs>
      usuariosEstudiantes: Prisma.$usuariosEstudiantesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      preguntaId: string
      usuarioEstudianteId: string
      tipo: $Enums.TipoReaccion
      creadoEn: Date
      actualizadoEn: Date
    }, ExtArgs["result"]["reaccionesPreguntas"]>
    composites: {}
  }

  type reaccionesPreguntasGetPayload<S extends boolean | null | undefined | reaccionesPreguntasDefaultArgs> = $Result.GetResult<Prisma.$reaccionesPreguntasPayload, S>

  type reaccionesPreguntasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<reaccionesPreguntasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReaccionesPreguntasCountAggregateInputType | true
    }

  export interface reaccionesPreguntasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reaccionesPreguntas'], meta: { name: 'reaccionesPreguntas' } }
    /**
     * Find zero or one ReaccionesPreguntas that matches the filter.
     * @param {reaccionesPreguntasFindUniqueArgs} args - Arguments to find a ReaccionesPreguntas
     * @example
     * // Get one ReaccionesPreguntas
     * const reaccionesPreguntas = await prisma.reaccionesPreguntas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reaccionesPreguntasFindUniqueArgs>(args: SelectSubset<T, reaccionesPreguntasFindUniqueArgs<ExtArgs>>): Prisma__reaccionesPreguntasClient<$Result.GetResult<Prisma.$reaccionesPreguntasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReaccionesPreguntas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {reaccionesPreguntasFindUniqueOrThrowArgs} args - Arguments to find a ReaccionesPreguntas
     * @example
     * // Get one ReaccionesPreguntas
     * const reaccionesPreguntas = await prisma.reaccionesPreguntas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reaccionesPreguntasFindUniqueOrThrowArgs>(args: SelectSubset<T, reaccionesPreguntasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reaccionesPreguntasClient<$Result.GetResult<Prisma.$reaccionesPreguntasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReaccionesPreguntas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reaccionesPreguntasFindFirstArgs} args - Arguments to find a ReaccionesPreguntas
     * @example
     * // Get one ReaccionesPreguntas
     * const reaccionesPreguntas = await prisma.reaccionesPreguntas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reaccionesPreguntasFindFirstArgs>(args?: SelectSubset<T, reaccionesPreguntasFindFirstArgs<ExtArgs>>): Prisma__reaccionesPreguntasClient<$Result.GetResult<Prisma.$reaccionesPreguntasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReaccionesPreguntas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reaccionesPreguntasFindFirstOrThrowArgs} args - Arguments to find a ReaccionesPreguntas
     * @example
     * // Get one ReaccionesPreguntas
     * const reaccionesPreguntas = await prisma.reaccionesPreguntas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reaccionesPreguntasFindFirstOrThrowArgs>(args?: SelectSubset<T, reaccionesPreguntasFindFirstOrThrowArgs<ExtArgs>>): Prisma__reaccionesPreguntasClient<$Result.GetResult<Prisma.$reaccionesPreguntasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReaccionesPreguntas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reaccionesPreguntasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReaccionesPreguntas
     * const reaccionesPreguntas = await prisma.reaccionesPreguntas.findMany()
     * 
     * // Get first 10 ReaccionesPreguntas
     * const reaccionesPreguntas = await prisma.reaccionesPreguntas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reaccionesPreguntasWithIdOnly = await prisma.reaccionesPreguntas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends reaccionesPreguntasFindManyArgs>(args?: SelectSubset<T, reaccionesPreguntasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reaccionesPreguntasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReaccionesPreguntas.
     * @param {reaccionesPreguntasCreateArgs} args - Arguments to create a ReaccionesPreguntas.
     * @example
     * // Create one ReaccionesPreguntas
     * const ReaccionesPreguntas = await prisma.reaccionesPreguntas.create({
     *   data: {
     *     // ... data to create a ReaccionesPreguntas
     *   }
     * })
     * 
     */
    create<T extends reaccionesPreguntasCreateArgs>(args: SelectSubset<T, reaccionesPreguntasCreateArgs<ExtArgs>>): Prisma__reaccionesPreguntasClient<$Result.GetResult<Prisma.$reaccionesPreguntasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReaccionesPreguntas.
     * @param {reaccionesPreguntasCreateManyArgs} args - Arguments to create many ReaccionesPreguntas.
     * @example
     * // Create many ReaccionesPreguntas
     * const reaccionesPreguntas = await prisma.reaccionesPreguntas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reaccionesPreguntasCreateManyArgs>(args?: SelectSubset<T, reaccionesPreguntasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReaccionesPreguntas and returns the data saved in the database.
     * @param {reaccionesPreguntasCreateManyAndReturnArgs} args - Arguments to create many ReaccionesPreguntas.
     * @example
     * // Create many ReaccionesPreguntas
     * const reaccionesPreguntas = await prisma.reaccionesPreguntas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReaccionesPreguntas and only return the `id`
     * const reaccionesPreguntasWithIdOnly = await prisma.reaccionesPreguntas.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends reaccionesPreguntasCreateManyAndReturnArgs>(args?: SelectSubset<T, reaccionesPreguntasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reaccionesPreguntasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReaccionesPreguntas.
     * @param {reaccionesPreguntasDeleteArgs} args - Arguments to delete one ReaccionesPreguntas.
     * @example
     * // Delete one ReaccionesPreguntas
     * const ReaccionesPreguntas = await prisma.reaccionesPreguntas.delete({
     *   where: {
     *     // ... filter to delete one ReaccionesPreguntas
     *   }
     * })
     * 
     */
    delete<T extends reaccionesPreguntasDeleteArgs>(args: SelectSubset<T, reaccionesPreguntasDeleteArgs<ExtArgs>>): Prisma__reaccionesPreguntasClient<$Result.GetResult<Prisma.$reaccionesPreguntasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReaccionesPreguntas.
     * @param {reaccionesPreguntasUpdateArgs} args - Arguments to update one ReaccionesPreguntas.
     * @example
     * // Update one ReaccionesPreguntas
     * const reaccionesPreguntas = await prisma.reaccionesPreguntas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reaccionesPreguntasUpdateArgs>(args: SelectSubset<T, reaccionesPreguntasUpdateArgs<ExtArgs>>): Prisma__reaccionesPreguntasClient<$Result.GetResult<Prisma.$reaccionesPreguntasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReaccionesPreguntas.
     * @param {reaccionesPreguntasDeleteManyArgs} args - Arguments to filter ReaccionesPreguntas to delete.
     * @example
     * // Delete a few ReaccionesPreguntas
     * const { count } = await prisma.reaccionesPreguntas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reaccionesPreguntasDeleteManyArgs>(args?: SelectSubset<T, reaccionesPreguntasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReaccionesPreguntas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reaccionesPreguntasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReaccionesPreguntas
     * const reaccionesPreguntas = await prisma.reaccionesPreguntas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reaccionesPreguntasUpdateManyArgs>(args: SelectSubset<T, reaccionesPreguntasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReaccionesPreguntas and returns the data updated in the database.
     * @param {reaccionesPreguntasUpdateManyAndReturnArgs} args - Arguments to update many ReaccionesPreguntas.
     * @example
     * // Update many ReaccionesPreguntas
     * const reaccionesPreguntas = await prisma.reaccionesPreguntas.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReaccionesPreguntas and only return the `id`
     * const reaccionesPreguntasWithIdOnly = await prisma.reaccionesPreguntas.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends reaccionesPreguntasUpdateManyAndReturnArgs>(args: SelectSubset<T, reaccionesPreguntasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reaccionesPreguntasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReaccionesPreguntas.
     * @param {reaccionesPreguntasUpsertArgs} args - Arguments to update or create a ReaccionesPreguntas.
     * @example
     * // Update or create a ReaccionesPreguntas
     * const reaccionesPreguntas = await prisma.reaccionesPreguntas.upsert({
     *   create: {
     *     // ... data to create a ReaccionesPreguntas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReaccionesPreguntas we want to update
     *   }
     * })
     */
    upsert<T extends reaccionesPreguntasUpsertArgs>(args: SelectSubset<T, reaccionesPreguntasUpsertArgs<ExtArgs>>): Prisma__reaccionesPreguntasClient<$Result.GetResult<Prisma.$reaccionesPreguntasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReaccionesPreguntas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reaccionesPreguntasCountArgs} args - Arguments to filter ReaccionesPreguntas to count.
     * @example
     * // Count the number of ReaccionesPreguntas
     * const count = await prisma.reaccionesPreguntas.count({
     *   where: {
     *     // ... the filter for the ReaccionesPreguntas we want to count
     *   }
     * })
    **/
    count<T extends reaccionesPreguntasCountArgs>(
      args?: Subset<T, reaccionesPreguntasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReaccionesPreguntasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReaccionesPreguntas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReaccionesPreguntasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReaccionesPreguntasAggregateArgs>(args: Subset<T, ReaccionesPreguntasAggregateArgs>): Prisma.PrismaPromise<GetReaccionesPreguntasAggregateType<T>>

    /**
     * Group by ReaccionesPreguntas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reaccionesPreguntasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reaccionesPreguntasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reaccionesPreguntasGroupByArgs['orderBy'] }
        : { orderBy?: reaccionesPreguntasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reaccionesPreguntasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReaccionesPreguntasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reaccionesPreguntas model
   */
  readonly fields: reaccionesPreguntasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reaccionesPreguntas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reaccionesPreguntasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pregunta<T extends preguntasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, preguntasDefaultArgs<ExtArgs>>): Prisma__preguntasClient<$Result.GetResult<Prisma.$preguntasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usuariosEstudiantes<T extends usuariosEstudiantesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usuariosEstudiantesDefaultArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reaccionesPreguntas model
   */
  interface reaccionesPreguntasFieldRefs {
    readonly id: FieldRef<"reaccionesPreguntas", 'String'>
    readonly preguntaId: FieldRef<"reaccionesPreguntas", 'String'>
    readonly usuarioEstudianteId: FieldRef<"reaccionesPreguntas", 'String'>
    readonly tipo: FieldRef<"reaccionesPreguntas", 'TipoReaccion'>
    readonly creadoEn: FieldRef<"reaccionesPreguntas", 'DateTime'>
    readonly actualizadoEn: FieldRef<"reaccionesPreguntas", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * reaccionesPreguntas findUnique
   */
  export type reaccionesPreguntasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reaccionesPreguntas
     */
    select?: reaccionesPreguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reaccionesPreguntas
     */
    omit?: reaccionesPreguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reaccionesPreguntasInclude<ExtArgs> | null
    /**
     * Filter, which reaccionesPreguntas to fetch.
     */
    where: reaccionesPreguntasWhereUniqueInput
  }

  /**
   * reaccionesPreguntas findUniqueOrThrow
   */
  export type reaccionesPreguntasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reaccionesPreguntas
     */
    select?: reaccionesPreguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reaccionesPreguntas
     */
    omit?: reaccionesPreguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reaccionesPreguntasInclude<ExtArgs> | null
    /**
     * Filter, which reaccionesPreguntas to fetch.
     */
    where: reaccionesPreguntasWhereUniqueInput
  }

  /**
   * reaccionesPreguntas findFirst
   */
  export type reaccionesPreguntasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reaccionesPreguntas
     */
    select?: reaccionesPreguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reaccionesPreguntas
     */
    omit?: reaccionesPreguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reaccionesPreguntasInclude<ExtArgs> | null
    /**
     * Filter, which reaccionesPreguntas to fetch.
     */
    where?: reaccionesPreguntasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reaccionesPreguntas to fetch.
     */
    orderBy?: reaccionesPreguntasOrderByWithRelationInput | reaccionesPreguntasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reaccionesPreguntas.
     */
    cursor?: reaccionesPreguntasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reaccionesPreguntas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reaccionesPreguntas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reaccionesPreguntas.
     */
    distinct?: ReaccionesPreguntasScalarFieldEnum | ReaccionesPreguntasScalarFieldEnum[]
  }

  /**
   * reaccionesPreguntas findFirstOrThrow
   */
  export type reaccionesPreguntasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reaccionesPreguntas
     */
    select?: reaccionesPreguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reaccionesPreguntas
     */
    omit?: reaccionesPreguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reaccionesPreguntasInclude<ExtArgs> | null
    /**
     * Filter, which reaccionesPreguntas to fetch.
     */
    where?: reaccionesPreguntasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reaccionesPreguntas to fetch.
     */
    orderBy?: reaccionesPreguntasOrderByWithRelationInput | reaccionesPreguntasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reaccionesPreguntas.
     */
    cursor?: reaccionesPreguntasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reaccionesPreguntas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reaccionesPreguntas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reaccionesPreguntas.
     */
    distinct?: ReaccionesPreguntasScalarFieldEnum | ReaccionesPreguntasScalarFieldEnum[]
  }

  /**
   * reaccionesPreguntas findMany
   */
  export type reaccionesPreguntasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reaccionesPreguntas
     */
    select?: reaccionesPreguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reaccionesPreguntas
     */
    omit?: reaccionesPreguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reaccionesPreguntasInclude<ExtArgs> | null
    /**
     * Filter, which reaccionesPreguntas to fetch.
     */
    where?: reaccionesPreguntasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reaccionesPreguntas to fetch.
     */
    orderBy?: reaccionesPreguntasOrderByWithRelationInput | reaccionesPreguntasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reaccionesPreguntas.
     */
    cursor?: reaccionesPreguntasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reaccionesPreguntas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reaccionesPreguntas.
     */
    skip?: number
    distinct?: ReaccionesPreguntasScalarFieldEnum | ReaccionesPreguntasScalarFieldEnum[]
  }

  /**
   * reaccionesPreguntas create
   */
  export type reaccionesPreguntasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reaccionesPreguntas
     */
    select?: reaccionesPreguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reaccionesPreguntas
     */
    omit?: reaccionesPreguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reaccionesPreguntasInclude<ExtArgs> | null
    /**
     * The data needed to create a reaccionesPreguntas.
     */
    data: XOR<reaccionesPreguntasCreateInput, reaccionesPreguntasUncheckedCreateInput>
  }

  /**
   * reaccionesPreguntas createMany
   */
  export type reaccionesPreguntasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reaccionesPreguntas.
     */
    data: reaccionesPreguntasCreateManyInput | reaccionesPreguntasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reaccionesPreguntas createManyAndReturn
   */
  export type reaccionesPreguntasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reaccionesPreguntas
     */
    select?: reaccionesPreguntasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reaccionesPreguntas
     */
    omit?: reaccionesPreguntasOmit<ExtArgs> | null
    /**
     * The data used to create many reaccionesPreguntas.
     */
    data: reaccionesPreguntasCreateManyInput | reaccionesPreguntasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reaccionesPreguntasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * reaccionesPreguntas update
   */
  export type reaccionesPreguntasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reaccionesPreguntas
     */
    select?: reaccionesPreguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reaccionesPreguntas
     */
    omit?: reaccionesPreguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reaccionesPreguntasInclude<ExtArgs> | null
    /**
     * The data needed to update a reaccionesPreguntas.
     */
    data: XOR<reaccionesPreguntasUpdateInput, reaccionesPreguntasUncheckedUpdateInput>
    /**
     * Choose, which reaccionesPreguntas to update.
     */
    where: reaccionesPreguntasWhereUniqueInput
  }

  /**
   * reaccionesPreguntas updateMany
   */
  export type reaccionesPreguntasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reaccionesPreguntas.
     */
    data: XOR<reaccionesPreguntasUpdateManyMutationInput, reaccionesPreguntasUncheckedUpdateManyInput>
    /**
     * Filter which reaccionesPreguntas to update
     */
    where?: reaccionesPreguntasWhereInput
    /**
     * Limit how many reaccionesPreguntas to update.
     */
    limit?: number
  }

  /**
   * reaccionesPreguntas updateManyAndReturn
   */
  export type reaccionesPreguntasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reaccionesPreguntas
     */
    select?: reaccionesPreguntasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reaccionesPreguntas
     */
    omit?: reaccionesPreguntasOmit<ExtArgs> | null
    /**
     * The data used to update reaccionesPreguntas.
     */
    data: XOR<reaccionesPreguntasUpdateManyMutationInput, reaccionesPreguntasUncheckedUpdateManyInput>
    /**
     * Filter which reaccionesPreguntas to update
     */
    where?: reaccionesPreguntasWhereInput
    /**
     * Limit how many reaccionesPreguntas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reaccionesPreguntasIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * reaccionesPreguntas upsert
   */
  export type reaccionesPreguntasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reaccionesPreguntas
     */
    select?: reaccionesPreguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reaccionesPreguntas
     */
    omit?: reaccionesPreguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reaccionesPreguntasInclude<ExtArgs> | null
    /**
     * The filter to search for the reaccionesPreguntas to update in case it exists.
     */
    where: reaccionesPreguntasWhereUniqueInput
    /**
     * In case the reaccionesPreguntas found by the `where` argument doesn't exist, create a new reaccionesPreguntas with this data.
     */
    create: XOR<reaccionesPreguntasCreateInput, reaccionesPreguntasUncheckedCreateInput>
    /**
     * In case the reaccionesPreguntas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reaccionesPreguntasUpdateInput, reaccionesPreguntasUncheckedUpdateInput>
  }

  /**
   * reaccionesPreguntas delete
   */
  export type reaccionesPreguntasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reaccionesPreguntas
     */
    select?: reaccionesPreguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reaccionesPreguntas
     */
    omit?: reaccionesPreguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reaccionesPreguntasInclude<ExtArgs> | null
    /**
     * Filter which reaccionesPreguntas to delete.
     */
    where: reaccionesPreguntasWhereUniqueInput
  }

  /**
   * reaccionesPreguntas deleteMany
   */
  export type reaccionesPreguntasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reaccionesPreguntas to delete
     */
    where?: reaccionesPreguntasWhereInput
    /**
     * Limit how many reaccionesPreguntas to delete.
     */
    limit?: number
  }

  /**
   * reaccionesPreguntas without action
   */
  export type reaccionesPreguntasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reaccionesPreguntas
     */
    select?: reaccionesPreguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reaccionesPreguntas
     */
    omit?: reaccionesPreguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reaccionesPreguntasInclude<ExtArgs> | null
  }


  /**
   * Model requisitosCursos
   */

  export type AggregateRequisitosCursos = {
    _count: RequisitosCursosCountAggregateOutputType | null
    _avg: RequisitosCursosAvgAggregateOutputType | null
    _sum: RequisitosCursosSumAggregateOutputType | null
    _min: RequisitosCursosMinAggregateOutputType | null
    _max: RequisitosCursosMaxAggregateOutputType | null
  }

  export type RequisitosCursosAvgAggregateOutputType = {
    orden: number | null
  }

  export type RequisitosCursosSumAggregateOutputType = {
    orden: number | null
  }

  export type RequisitosCursosMinAggregateOutputType = {
    id: string | null
    cursoId: string | null
    descripcion: string | null
    orden: number | null
    creadoEn: Date | null
  }

  export type RequisitosCursosMaxAggregateOutputType = {
    id: string | null
    cursoId: string | null
    descripcion: string | null
    orden: number | null
    creadoEn: Date | null
  }

  export type RequisitosCursosCountAggregateOutputType = {
    id: number
    cursoId: number
    descripcion: number
    orden: number
    creadoEn: number
    _all: number
  }


  export type RequisitosCursosAvgAggregateInputType = {
    orden?: true
  }

  export type RequisitosCursosSumAggregateInputType = {
    orden?: true
  }

  export type RequisitosCursosMinAggregateInputType = {
    id?: true
    cursoId?: true
    descripcion?: true
    orden?: true
    creadoEn?: true
  }

  export type RequisitosCursosMaxAggregateInputType = {
    id?: true
    cursoId?: true
    descripcion?: true
    orden?: true
    creadoEn?: true
  }

  export type RequisitosCursosCountAggregateInputType = {
    id?: true
    cursoId?: true
    descripcion?: true
    orden?: true
    creadoEn?: true
    _all?: true
  }

  export type RequisitosCursosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which requisitosCursos to aggregate.
     */
    where?: requisitosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requisitosCursos to fetch.
     */
    orderBy?: requisitosCursosOrderByWithRelationInput | requisitosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: requisitosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requisitosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requisitosCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned requisitosCursos
    **/
    _count?: true | RequisitosCursosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequisitosCursosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequisitosCursosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequisitosCursosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequisitosCursosMaxAggregateInputType
  }

  export type GetRequisitosCursosAggregateType<T extends RequisitosCursosAggregateArgs> = {
        [P in keyof T & keyof AggregateRequisitosCursos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequisitosCursos[P]>
      : GetScalarType<T[P], AggregateRequisitosCursos[P]>
  }




  export type requisitosCursosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: requisitosCursosWhereInput
    orderBy?: requisitosCursosOrderByWithAggregationInput | requisitosCursosOrderByWithAggregationInput[]
    by: RequisitosCursosScalarFieldEnum[] | RequisitosCursosScalarFieldEnum
    having?: requisitosCursosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequisitosCursosCountAggregateInputType | true
    _avg?: RequisitosCursosAvgAggregateInputType
    _sum?: RequisitosCursosSumAggregateInputType
    _min?: RequisitosCursosMinAggregateInputType
    _max?: RequisitosCursosMaxAggregateInputType
  }

  export type RequisitosCursosGroupByOutputType = {
    id: string
    cursoId: string
    descripcion: string
    orden: number
    creadoEn: Date
    _count: RequisitosCursosCountAggregateOutputType | null
    _avg: RequisitosCursosAvgAggregateOutputType | null
    _sum: RequisitosCursosSumAggregateOutputType | null
    _min: RequisitosCursosMinAggregateOutputType | null
    _max: RequisitosCursosMaxAggregateOutputType | null
  }

  type GetRequisitosCursosGroupByPayload<T extends requisitosCursosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequisitosCursosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequisitosCursosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequisitosCursosGroupByOutputType[P]>
            : GetScalarType<T[P], RequisitosCursosGroupByOutputType[P]>
        }
      >
    >


  export type requisitosCursosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    descripcion?: boolean
    orden?: boolean
    creadoEn?: boolean
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requisitosCursos"]>

  export type requisitosCursosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    descripcion?: boolean
    orden?: boolean
    creadoEn?: boolean
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requisitosCursos"]>

  export type requisitosCursosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    descripcion?: boolean
    orden?: boolean
    creadoEn?: boolean
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requisitosCursos"]>

  export type requisitosCursosSelectScalar = {
    id?: boolean
    cursoId?: boolean
    descripcion?: boolean
    orden?: boolean
    creadoEn?: boolean
  }

  export type requisitosCursosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cursoId" | "descripcion" | "orden" | "creadoEn", ExtArgs["result"]["requisitosCursos"]>
  export type requisitosCursosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
  }
  export type requisitosCursosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
  }
  export type requisitosCursosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
  }

  export type $requisitosCursosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "requisitosCursos"
    objects: {
      cursos: Prisma.$cursosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cursoId: string
      descripcion: string
      orden: number
      creadoEn: Date
    }, ExtArgs["result"]["requisitosCursos"]>
    composites: {}
  }

  type requisitosCursosGetPayload<S extends boolean | null | undefined | requisitosCursosDefaultArgs> = $Result.GetResult<Prisma.$requisitosCursosPayload, S>

  type requisitosCursosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<requisitosCursosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequisitosCursosCountAggregateInputType | true
    }

  export interface requisitosCursosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['requisitosCursos'], meta: { name: 'requisitosCursos' } }
    /**
     * Find zero or one RequisitosCursos that matches the filter.
     * @param {requisitosCursosFindUniqueArgs} args - Arguments to find a RequisitosCursos
     * @example
     * // Get one RequisitosCursos
     * const requisitosCursos = await prisma.requisitosCursos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends requisitosCursosFindUniqueArgs>(args: SelectSubset<T, requisitosCursosFindUniqueArgs<ExtArgs>>): Prisma__requisitosCursosClient<$Result.GetResult<Prisma.$requisitosCursosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RequisitosCursos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {requisitosCursosFindUniqueOrThrowArgs} args - Arguments to find a RequisitosCursos
     * @example
     * // Get one RequisitosCursos
     * const requisitosCursos = await prisma.requisitosCursos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends requisitosCursosFindUniqueOrThrowArgs>(args: SelectSubset<T, requisitosCursosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__requisitosCursosClient<$Result.GetResult<Prisma.$requisitosCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequisitosCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requisitosCursosFindFirstArgs} args - Arguments to find a RequisitosCursos
     * @example
     * // Get one RequisitosCursos
     * const requisitosCursos = await prisma.requisitosCursos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends requisitosCursosFindFirstArgs>(args?: SelectSubset<T, requisitosCursosFindFirstArgs<ExtArgs>>): Prisma__requisitosCursosClient<$Result.GetResult<Prisma.$requisitosCursosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequisitosCursos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requisitosCursosFindFirstOrThrowArgs} args - Arguments to find a RequisitosCursos
     * @example
     * // Get one RequisitosCursos
     * const requisitosCursos = await prisma.requisitosCursos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends requisitosCursosFindFirstOrThrowArgs>(args?: SelectSubset<T, requisitosCursosFindFirstOrThrowArgs<ExtArgs>>): Prisma__requisitosCursosClient<$Result.GetResult<Prisma.$requisitosCursosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RequisitosCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requisitosCursosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequisitosCursos
     * const requisitosCursos = await prisma.requisitosCursos.findMany()
     * 
     * // Get first 10 RequisitosCursos
     * const requisitosCursos = await prisma.requisitosCursos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requisitosCursosWithIdOnly = await prisma.requisitosCursos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends requisitosCursosFindManyArgs>(args?: SelectSubset<T, requisitosCursosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$requisitosCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RequisitosCursos.
     * @param {requisitosCursosCreateArgs} args - Arguments to create a RequisitosCursos.
     * @example
     * // Create one RequisitosCursos
     * const RequisitosCursos = await prisma.requisitosCursos.create({
     *   data: {
     *     // ... data to create a RequisitosCursos
     *   }
     * })
     * 
     */
    create<T extends requisitosCursosCreateArgs>(args: SelectSubset<T, requisitosCursosCreateArgs<ExtArgs>>): Prisma__requisitosCursosClient<$Result.GetResult<Prisma.$requisitosCursosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RequisitosCursos.
     * @param {requisitosCursosCreateManyArgs} args - Arguments to create many RequisitosCursos.
     * @example
     * // Create many RequisitosCursos
     * const requisitosCursos = await prisma.requisitosCursos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends requisitosCursosCreateManyArgs>(args?: SelectSubset<T, requisitosCursosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RequisitosCursos and returns the data saved in the database.
     * @param {requisitosCursosCreateManyAndReturnArgs} args - Arguments to create many RequisitosCursos.
     * @example
     * // Create many RequisitosCursos
     * const requisitosCursos = await prisma.requisitosCursos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RequisitosCursos and only return the `id`
     * const requisitosCursosWithIdOnly = await prisma.requisitosCursos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends requisitosCursosCreateManyAndReturnArgs>(args?: SelectSubset<T, requisitosCursosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$requisitosCursosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RequisitosCursos.
     * @param {requisitosCursosDeleteArgs} args - Arguments to delete one RequisitosCursos.
     * @example
     * // Delete one RequisitosCursos
     * const RequisitosCursos = await prisma.requisitosCursos.delete({
     *   where: {
     *     // ... filter to delete one RequisitosCursos
     *   }
     * })
     * 
     */
    delete<T extends requisitosCursosDeleteArgs>(args: SelectSubset<T, requisitosCursosDeleteArgs<ExtArgs>>): Prisma__requisitosCursosClient<$Result.GetResult<Prisma.$requisitosCursosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RequisitosCursos.
     * @param {requisitosCursosUpdateArgs} args - Arguments to update one RequisitosCursos.
     * @example
     * // Update one RequisitosCursos
     * const requisitosCursos = await prisma.requisitosCursos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends requisitosCursosUpdateArgs>(args: SelectSubset<T, requisitosCursosUpdateArgs<ExtArgs>>): Prisma__requisitosCursosClient<$Result.GetResult<Prisma.$requisitosCursosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RequisitosCursos.
     * @param {requisitosCursosDeleteManyArgs} args - Arguments to filter RequisitosCursos to delete.
     * @example
     * // Delete a few RequisitosCursos
     * const { count } = await prisma.requisitosCursos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends requisitosCursosDeleteManyArgs>(args?: SelectSubset<T, requisitosCursosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequisitosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requisitosCursosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequisitosCursos
     * const requisitosCursos = await prisma.requisitosCursos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends requisitosCursosUpdateManyArgs>(args: SelectSubset<T, requisitosCursosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequisitosCursos and returns the data updated in the database.
     * @param {requisitosCursosUpdateManyAndReturnArgs} args - Arguments to update many RequisitosCursos.
     * @example
     * // Update many RequisitosCursos
     * const requisitosCursos = await prisma.requisitosCursos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RequisitosCursos and only return the `id`
     * const requisitosCursosWithIdOnly = await prisma.requisitosCursos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends requisitosCursosUpdateManyAndReturnArgs>(args: SelectSubset<T, requisitosCursosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$requisitosCursosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RequisitosCursos.
     * @param {requisitosCursosUpsertArgs} args - Arguments to update or create a RequisitosCursos.
     * @example
     * // Update or create a RequisitosCursos
     * const requisitosCursos = await prisma.requisitosCursos.upsert({
     *   create: {
     *     // ... data to create a RequisitosCursos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequisitosCursos we want to update
     *   }
     * })
     */
    upsert<T extends requisitosCursosUpsertArgs>(args: SelectSubset<T, requisitosCursosUpsertArgs<ExtArgs>>): Prisma__requisitosCursosClient<$Result.GetResult<Prisma.$requisitosCursosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RequisitosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requisitosCursosCountArgs} args - Arguments to filter RequisitosCursos to count.
     * @example
     * // Count the number of RequisitosCursos
     * const count = await prisma.requisitosCursos.count({
     *   where: {
     *     // ... the filter for the RequisitosCursos we want to count
     *   }
     * })
    **/
    count<T extends requisitosCursosCountArgs>(
      args?: Subset<T, requisitosCursosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequisitosCursosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequisitosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequisitosCursosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequisitosCursosAggregateArgs>(args: Subset<T, RequisitosCursosAggregateArgs>): Prisma.PrismaPromise<GetRequisitosCursosAggregateType<T>>

    /**
     * Group by RequisitosCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {requisitosCursosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends requisitosCursosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: requisitosCursosGroupByArgs['orderBy'] }
        : { orderBy?: requisitosCursosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, requisitosCursosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequisitosCursosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the requisitosCursos model
   */
  readonly fields: requisitosCursosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for requisitosCursos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__requisitosCursosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cursos<T extends cursosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, cursosDefaultArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the requisitosCursos model
   */
  interface requisitosCursosFieldRefs {
    readonly id: FieldRef<"requisitosCursos", 'String'>
    readonly cursoId: FieldRef<"requisitosCursos", 'String'>
    readonly descripcion: FieldRef<"requisitosCursos", 'String'>
    readonly orden: FieldRef<"requisitosCursos", 'Int'>
    readonly creadoEn: FieldRef<"requisitosCursos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * requisitosCursos findUnique
   */
  export type requisitosCursosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosInclude<ExtArgs> | null
    /**
     * Filter, which requisitosCursos to fetch.
     */
    where: requisitosCursosWhereUniqueInput
  }

  /**
   * requisitosCursos findUniqueOrThrow
   */
  export type requisitosCursosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosInclude<ExtArgs> | null
    /**
     * Filter, which requisitosCursos to fetch.
     */
    where: requisitosCursosWhereUniqueInput
  }

  /**
   * requisitosCursos findFirst
   */
  export type requisitosCursosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosInclude<ExtArgs> | null
    /**
     * Filter, which requisitosCursos to fetch.
     */
    where?: requisitosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requisitosCursos to fetch.
     */
    orderBy?: requisitosCursosOrderByWithRelationInput | requisitosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for requisitosCursos.
     */
    cursor?: requisitosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requisitosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requisitosCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of requisitosCursos.
     */
    distinct?: RequisitosCursosScalarFieldEnum | RequisitosCursosScalarFieldEnum[]
  }

  /**
   * requisitosCursos findFirstOrThrow
   */
  export type requisitosCursosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosInclude<ExtArgs> | null
    /**
     * Filter, which requisitosCursos to fetch.
     */
    where?: requisitosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requisitosCursos to fetch.
     */
    orderBy?: requisitosCursosOrderByWithRelationInput | requisitosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for requisitosCursos.
     */
    cursor?: requisitosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requisitosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requisitosCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of requisitosCursos.
     */
    distinct?: RequisitosCursosScalarFieldEnum | RequisitosCursosScalarFieldEnum[]
  }

  /**
   * requisitosCursos findMany
   */
  export type requisitosCursosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosInclude<ExtArgs> | null
    /**
     * Filter, which requisitosCursos to fetch.
     */
    where?: requisitosCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of requisitosCursos to fetch.
     */
    orderBy?: requisitosCursosOrderByWithRelationInput | requisitosCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing requisitosCursos.
     */
    cursor?: requisitosCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` requisitosCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` requisitosCursos.
     */
    skip?: number
    distinct?: RequisitosCursosScalarFieldEnum | RequisitosCursosScalarFieldEnum[]
  }

  /**
   * requisitosCursos create
   */
  export type requisitosCursosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosInclude<ExtArgs> | null
    /**
     * The data needed to create a requisitosCursos.
     */
    data: XOR<requisitosCursosCreateInput, requisitosCursosUncheckedCreateInput>
  }

  /**
   * requisitosCursos createMany
   */
  export type requisitosCursosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many requisitosCursos.
     */
    data: requisitosCursosCreateManyInput | requisitosCursosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * requisitosCursos createManyAndReturn
   */
  export type requisitosCursosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * The data used to create many requisitosCursos.
     */
    data: requisitosCursosCreateManyInput | requisitosCursosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * requisitosCursos update
   */
  export type requisitosCursosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosInclude<ExtArgs> | null
    /**
     * The data needed to update a requisitosCursos.
     */
    data: XOR<requisitosCursosUpdateInput, requisitosCursosUncheckedUpdateInput>
    /**
     * Choose, which requisitosCursos to update.
     */
    where: requisitosCursosWhereUniqueInput
  }

  /**
   * requisitosCursos updateMany
   */
  export type requisitosCursosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update requisitosCursos.
     */
    data: XOR<requisitosCursosUpdateManyMutationInput, requisitosCursosUncheckedUpdateManyInput>
    /**
     * Filter which requisitosCursos to update
     */
    where?: requisitosCursosWhereInput
    /**
     * Limit how many requisitosCursos to update.
     */
    limit?: number
  }

  /**
   * requisitosCursos updateManyAndReturn
   */
  export type requisitosCursosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * The data used to update requisitosCursos.
     */
    data: XOR<requisitosCursosUpdateManyMutationInput, requisitosCursosUncheckedUpdateManyInput>
    /**
     * Filter which requisitosCursos to update
     */
    where?: requisitosCursosWhereInput
    /**
     * Limit how many requisitosCursos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * requisitosCursos upsert
   */
  export type requisitosCursosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosInclude<ExtArgs> | null
    /**
     * The filter to search for the requisitosCursos to update in case it exists.
     */
    where: requisitosCursosWhereUniqueInput
    /**
     * In case the requisitosCursos found by the `where` argument doesn't exist, create a new requisitosCursos with this data.
     */
    create: XOR<requisitosCursosCreateInput, requisitosCursosUncheckedCreateInput>
    /**
     * In case the requisitosCursos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<requisitosCursosUpdateInput, requisitosCursosUncheckedUpdateInput>
  }

  /**
   * requisitosCursos delete
   */
  export type requisitosCursosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosInclude<ExtArgs> | null
    /**
     * Filter which requisitosCursos to delete.
     */
    where: requisitosCursosWhereUniqueInput
  }

  /**
   * requisitosCursos deleteMany
   */
  export type requisitosCursosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which requisitosCursos to delete
     */
    where?: requisitosCursosWhereInput
    /**
     * Limit how many requisitosCursos to delete.
     */
    limit?: number
  }

  /**
   * requisitosCursos without action
   */
  export type requisitosCursosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the requisitosCursos
     */
    select?: requisitosCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the requisitosCursos
     */
    omit?: requisitosCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: requisitosCursosInclude<ExtArgs> | null
  }


  /**
   * Model reviewsCursos
   */

  export type AggregateReviewsCursos = {
    _count: ReviewsCursosCountAggregateOutputType | null
    _avg: ReviewsCursosAvgAggregateOutputType | null
    _sum: ReviewsCursosSumAggregateOutputType | null
    _min: ReviewsCursosMinAggregateOutputType | null
    _max: ReviewsCursosMaxAggregateOutputType | null
  }

  export type ReviewsCursosAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewsCursosSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewsCursosMinAggregateOutputType = {
    id: string | null
    cursoId: string | null
    rating: number | null
    comentario: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    usuariosEstudiantesId: string | null
  }

  export type ReviewsCursosMaxAggregateOutputType = {
    id: string | null
    cursoId: string | null
    rating: number | null
    comentario: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    usuariosEstudiantesId: string | null
  }

  export type ReviewsCursosCountAggregateOutputType = {
    id: number
    cursoId: number
    rating: number
    comentario: number
    creadoEn: number
    actualizadoEn: number
    usuariosEstudiantesId: number
    _all: number
  }


  export type ReviewsCursosAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewsCursosSumAggregateInputType = {
    rating?: true
  }

  export type ReviewsCursosMinAggregateInputType = {
    id?: true
    cursoId?: true
    rating?: true
    comentario?: true
    creadoEn?: true
    actualizadoEn?: true
    usuariosEstudiantesId?: true
  }

  export type ReviewsCursosMaxAggregateInputType = {
    id?: true
    cursoId?: true
    rating?: true
    comentario?: true
    creadoEn?: true
    actualizadoEn?: true
    usuariosEstudiantesId?: true
  }

  export type ReviewsCursosCountAggregateInputType = {
    id?: true
    cursoId?: true
    rating?: true
    comentario?: true
    creadoEn?: true
    actualizadoEn?: true
    usuariosEstudiantesId?: true
    _all?: true
  }

  export type ReviewsCursosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reviewsCursos to aggregate.
     */
    where?: reviewsCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviewsCursos to fetch.
     */
    orderBy?: reviewsCursosOrderByWithRelationInput | reviewsCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reviewsCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviewsCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviewsCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reviewsCursos
    **/
    _count?: true | ReviewsCursosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewsCursosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewsCursosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewsCursosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewsCursosMaxAggregateInputType
  }

  export type GetReviewsCursosAggregateType<T extends ReviewsCursosAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewsCursos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewsCursos[P]>
      : GetScalarType<T[P], AggregateReviewsCursos[P]>
  }




  export type reviewsCursosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewsCursosWhereInput
    orderBy?: reviewsCursosOrderByWithAggregationInput | reviewsCursosOrderByWithAggregationInput[]
    by: ReviewsCursosScalarFieldEnum[] | ReviewsCursosScalarFieldEnum
    having?: reviewsCursosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewsCursosCountAggregateInputType | true
    _avg?: ReviewsCursosAvgAggregateInputType
    _sum?: ReviewsCursosSumAggregateInputType
    _min?: ReviewsCursosMinAggregateInputType
    _max?: ReviewsCursosMaxAggregateInputType
  }

  export type ReviewsCursosGroupByOutputType = {
    id: string
    cursoId: string
    rating: number
    comentario: string | null
    creadoEn: Date
    actualizadoEn: Date
    usuariosEstudiantesId: string | null
    _count: ReviewsCursosCountAggregateOutputType | null
    _avg: ReviewsCursosAvgAggregateOutputType | null
    _sum: ReviewsCursosSumAggregateOutputType | null
    _min: ReviewsCursosMinAggregateOutputType | null
    _max: ReviewsCursosMaxAggregateOutputType | null
  }

  type GetReviewsCursosGroupByPayload<T extends reviewsCursosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewsCursosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewsCursosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewsCursosGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewsCursosGroupByOutputType[P]>
        }
      >
    >


  export type reviewsCursosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    rating?: boolean
    comentario?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    usuariosEstudiantesId?: boolean
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | reviewsCursos$usuariosEstudiantesArgs<ExtArgs>
  }, ExtArgs["result"]["reviewsCursos"]>

  export type reviewsCursosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    rating?: boolean
    comentario?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    usuariosEstudiantesId?: boolean
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | reviewsCursos$usuariosEstudiantesArgs<ExtArgs>
  }, ExtArgs["result"]["reviewsCursos"]>

  export type reviewsCursosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cursoId?: boolean
    rating?: boolean
    comentario?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    usuariosEstudiantesId?: boolean
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | reviewsCursos$usuariosEstudiantesArgs<ExtArgs>
  }, ExtArgs["result"]["reviewsCursos"]>

  export type reviewsCursosSelectScalar = {
    id?: boolean
    cursoId?: boolean
    rating?: boolean
    comentario?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    usuariosEstudiantesId?: boolean
  }

  export type reviewsCursosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cursoId" | "rating" | "comentario" | "creadoEn" | "actualizadoEn" | "usuariosEstudiantesId", ExtArgs["result"]["reviewsCursos"]>
  export type reviewsCursosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | reviewsCursos$usuariosEstudiantesArgs<ExtArgs>
  }
  export type reviewsCursosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | reviewsCursos$usuariosEstudiantesArgs<ExtArgs>
  }
  export type reviewsCursosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cursos?: boolean | cursosDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | reviewsCursos$usuariosEstudiantesArgs<ExtArgs>
  }

  export type $reviewsCursosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reviewsCursos"
    objects: {
      cursos: Prisma.$cursosPayload<ExtArgs>
      usuariosEstudiantes: Prisma.$usuariosEstudiantesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cursoId: string
      rating: number
      comentario: string | null
      creadoEn: Date
      actualizadoEn: Date
      usuariosEstudiantesId: string | null
    }, ExtArgs["result"]["reviewsCursos"]>
    composites: {}
  }

  type reviewsCursosGetPayload<S extends boolean | null | undefined | reviewsCursosDefaultArgs> = $Result.GetResult<Prisma.$reviewsCursosPayload, S>

  type reviewsCursosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<reviewsCursosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewsCursosCountAggregateInputType | true
    }

  export interface reviewsCursosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reviewsCursos'], meta: { name: 'reviewsCursos' } }
    /**
     * Find zero or one ReviewsCursos that matches the filter.
     * @param {reviewsCursosFindUniqueArgs} args - Arguments to find a ReviewsCursos
     * @example
     * // Get one ReviewsCursos
     * const reviewsCursos = await prisma.reviewsCursos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reviewsCursosFindUniqueArgs>(args: SelectSubset<T, reviewsCursosFindUniqueArgs<ExtArgs>>): Prisma__reviewsCursosClient<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReviewsCursos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {reviewsCursosFindUniqueOrThrowArgs} args - Arguments to find a ReviewsCursos
     * @example
     * // Get one ReviewsCursos
     * const reviewsCursos = await prisma.reviewsCursos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reviewsCursosFindUniqueOrThrowArgs>(args: SelectSubset<T, reviewsCursosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reviewsCursosClient<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewsCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsCursosFindFirstArgs} args - Arguments to find a ReviewsCursos
     * @example
     * // Get one ReviewsCursos
     * const reviewsCursos = await prisma.reviewsCursos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reviewsCursosFindFirstArgs>(args?: SelectSubset<T, reviewsCursosFindFirstArgs<ExtArgs>>): Prisma__reviewsCursosClient<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewsCursos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsCursosFindFirstOrThrowArgs} args - Arguments to find a ReviewsCursos
     * @example
     * // Get one ReviewsCursos
     * const reviewsCursos = await prisma.reviewsCursos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reviewsCursosFindFirstOrThrowArgs>(args?: SelectSubset<T, reviewsCursosFindFirstOrThrowArgs<ExtArgs>>): Prisma__reviewsCursosClient<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReviewsCursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsCursosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewsCursos
     * const reviewsCursos = await prisma.reviewsCursos.findMany()
     * 
     * // Get first 10 ReviewsCursos
     * const reviewsCursos = await prisma.reviewsCursos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewsCursosWithIdOnly = await prisma.reviewsCursos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends reviewsCursosFindManyArgs>(args?: SelectSubset<T, reviewsCursosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReviewsCursos.
     * @param {reviewsCursosCreateArgs} args - Arguments to create a ReviewsCursos.
     * @example
     * // Create one ReviewsCursos
     * const ReviewsCursos = await prisma.reviewsCursos.create({
     *   data: {
     *     // ... data to create a ReviewsCursos
     *   }
     * })
     * 
     */
    create<T extends reviewsCursosCreateArgs>(args: SelectSubset<T, reviewsCursosCreateArgs<ExtArgs>>): Prisma__reviewsCursosClient<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReviewsCursos.
     * @param {reviewsCursosCreateManyArgs} args - Arguments to create many ReviewsCursos.
     * @example
     * // Create many ReviewsCursos
     * const reviewsCursos = await prisma.reviewsCursos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reviewsCursosCreateManyArgs>(args?: SelectSubset<T, reviewsCursosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewsCursos and returns the data saved in the database.
     * @param {reviewsCursosCreateManyAndReturnArgs} args - Arguments to create many ReviewsCursos.
     * @example
     * // Create many ReviewsCursos
     * const reviewsCursos = await prisma.reviewsCursos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewsCursos and only return the `id`
     * const reviewsCursosWithIdOnly = await prisma.reviewsCursos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends reviewsCursosCreateManyAndReturnArgs>(args?: SelectSubset<T, reviewsCursosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReviewsCursos.
     * @param {reviewsCursosDeleteArgs} args - Arguments to delete one ReviewsCursos.
     * @example
     * // Delete one ReviewsCursos
     * const ReviewsCursos = await prisma.reviewsCursos.delete({
     *   where: {
     *     // ... filter to delete one ReviewsCursos
     *   }
     * })
     * 
     */
    delete<T extends reviewsCursosDeleteArgs>(args: SelectSubset<T, reviewsCursosDeleteArgs<ExtArgs>>): Prisma__reviewsCursosClient<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReviewsCursos.
     * @param {reviewsCursosUpdateArgs} args - Arguments to update one ReviewsCursos.
     * @example
     * // Update one ReviewsCursos
     * const reviewsCursos = await prisma.reviewsCursos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reviewsCursosUpdateArgs>(args: SelectSubset<T, reviewsCursosUpdateArgs<ExtArgs>>): Prisma__reviewsCursosClient<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReviewsCursos.
     * @param {reviewsCursosDeleteManyArgs} args - Arguments to filter ReviewsCursos to delete.
     * @example
     * // Delete a few ReviewsCursos
     * const { count } = await prisma.reviewsCursos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reviewsCursosDeleteManyArgs>(args?: SelectSubset<T, reviewsCursosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewsCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsCursosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewsCursos
     * const reviewsCursos = await prisma.reviewsCursos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reviewsCursosUpdateManyArgs>(args: SelectSubset<T, reviewsCursosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewsCursos and returns the data updated in the database.
     * @param {reviewsCursosUpdateManyAndReturnArgs} args - Arguments to update many ReviewsCursos.
     * @example
     * // Update many ReviewsCursos
     * const reviewsCursos = await prisma.reviewsCursos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReviewsCursos and only return the `id`
     * const reviewsCursosWithIdOnly = await prisma.reviewsCursos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends reviewsCursosUpdateManyAndReturnArgs>(args: SelectSubset<T, reviewsCursosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReviewsCursos.
     * @param {reviewsCursosUpsertArgs} args - Arguments to update or create a ReviewsCursos.
     * @example
     * // Update or create a ReviewsCursos
     * const reviewsCursos = await prisma.reviewsCursos.upsert({
     *   create: {
     *     // ... data to create a ReviewsCursos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewsCursos we want to update
     *   }
     * })
     */
    upsert<T extends reviewsCursosUpsertArgs>(args: SelectSubset<T, reviewsCursosUpsertArgs<ExtArgs>>): Prisma__reviewsCursosClient<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReviewsCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsCursosCountArgs} args - Arguments to filter ReviewsCursos to count.
     * @example
     * // Count the number of ReviewsCursos
     * const count = await prisma.reviewsCursos.count({
     *   where: {
     *     // ... the filter for the ReviewsCursos we want to count
     *   }
     * })
    **/
    count<T extends reviewsCursosCountArgs>(
      args?: Subset<T, reviewsCursosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewsCursosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewsCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsCursosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewsCursosAggregateArgs>(args: Subset<T, ReviewsCursosAggregateArgs>): Prisma.PrismaPromise<GetReviewsCursosAggregateType<T>>

    /**
     * Group by ReviewsCursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsCursosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reviewsCursosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reviewsCursosGroupByArgs['orderBy'] }
        : { orderBy?: reviewsCursosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reviewsCursosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewsCursosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reviewsCursos model
   */
  readonly fields: reviewsCursosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reviewsCursos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reviewsCursosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cursos<T extends cursosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, cursosDefaultArgs<ExtArgs>>): Prisma__cursosClient<$Result.GetResult<Prisma.$cursosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usuariosEstudiantes<T extends reviewsCursos$usuariosEstudiantesArgs<ExtArgs> = {}>(args?: Subset<T, reviewsCursos$usuariosEstudiantesArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reviewsCursos model
   */
  interface reviewsCursosFieldRefs {
    readonly id: FieldRef<"reviewsCursos", 'String'>
    readonly cursoId: FieldRef<"reviewsCursos", 'String'>
    readonly rating: FieldRef<"reviewsCursos", 'Int'>
    readonly comentario: FieldRef<"reviewsCursos", 'String'>
    readonly creadoEn: FieldRef<"reviewsCursos", 'DateTime'>
    readonly actualizadoEn: FieldRef<"reviewsCursos", 'DateTime'>
    readonly usuariosEstudiantesId: FieldRef<"reviewsCursos", 'String'>
  }
    

  // Custom InputTypes
  /**
   * reviewsCursos findUnique
   */
  export type reviewsCursosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosInclude<ExtArgs> | null
    /**
     * Filter, which reviewsCursos to fetch.
     */
    where: reviewsCursosWhereUniqueInput
  }

  /**
   * reviewsCursos findUniqueOrThrow
   */
  export type reviewsCursosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosInclude<ExtArgs> | null
    /**
     * Filter, which reviewsCursos to fetch.
     */
    where: reviewsCursosWhereUniqueInput
  }

  /**
   * reviewsCursos findFirst
   */
  export type reviewsCursosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosInclude<ExtArgs> | null
    /**
     * Filter, which reviewsCursos to fetch.
     */
    where?: reviewsCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviewsCursos to fetch.
     */
    orderBy?: reviewsCursosOrderByWithRelationInput | reviewsCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviewsCursos.
     */
    cursor?: reviewsCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviewsCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviewsCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviewsCursos.
     */
    distinct?: ReviewsCursosScalarFieldEnum | ReviewsCursosScalarFieldEnum[]
  }

  /**
   * reviewsCursos findFirstOrThrow
   */
  export type reviewsCursosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosInclude<ExtArgs> | null
    /**
     * Filter, which reviewsCursos to fetch.
     */
    where?: reviewsCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviewsCursos to fetch.
     */
    orderBy?: reviewsCursosOrderByWithRelationInput | reviewsCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviewsCursos.
     */
    cursor?: reviewsCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviewsCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviewsCursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviewsCursos.
     */
    distinct?: ReviewsCursosScalarFieldEnum | ReviewsCursosScalarFieldEnum[]
  }

  /**
   * reviewsCursos findMany
   */
  export type reviewsCursosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosInclude<ExtArgs> | null
    /**
     * Filter, which reviewsCursos to fetch.
     */
    where?: reviewsCursosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviewsCursos to fetch.
     */
    orderBy?: reviewsCursosOrderByWithRelationInput | reviewsCursosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reviewsCursos.
     */
    cursor?: reviewsCursosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviewsCursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviewsCursos.
     */
    skip?: number
    distinct?: ReviewsCursosScalarFieldEnum | ReviewsCursosScalarFieldEnum[]
  }

  /**
   * reviewsCursos create
   */
  export type reviewsCursosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosInclude<ExtArgs> | null
    /**
     * The data needed to create a reviewsCursos.
     */
    data: XOR<reviewsCursosCreateInput, reviewsCursosUncheckedCreateInput>
  }

  /**
   * reviewsCursos createMany
   */
  export type reviewsCursosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reviewsCursos.
     */
    data: reviewsCursosCreateManyInput | reviewsCursosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reviewsCursos createManyAndReturn
   */
  export type reviewsCursosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * The data used to create many reviewsCursos.
     */
    data: reviewsCursosCreateManyInput | reviewsCursosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * reviewsCursos update
   */
  export type reviewsCursosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosInclude<ExtArgs> | null
    /**
     * The data needed to update a reviewsCursos.
     */
    data: XOR<reviewsCursosUpdateInput, reviewsCursosUncheckedUpdateInput>
    /**
     * Choose, which reviewsCursos to update.
     */
    where: reviewsCursosWhereUniqueInput
  }

  /**
   * reviewsCursos updateMany
   */
  export type reviewsCursosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reviewsCursos.
     */
    data: XOR<reviewsCursosUpdateManyMutationInput, reviewsCursosUncheckedUpdateManyInput>
    /**
     * Filter which reviewsCursos to update
     */
    where?: reviewsCursosWhereInput
    /**
     * Limit how many reviewsCursos to update.
     */
    limit?: number
  }

  /**
   * reviewsCursos updateManyAndReturn
   */
  export type reviewsCursosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * The data used to update reviewsCursos.
     */
    data: XOR<reviewsCursosUpdateManyMutationInput, reviewsCursosUncheckedUpdateManyInput>
    /**
     * Filter which reviewsCursos to update
     */
    where?: reviewsCursosWhereInput
    /**
     * Limit how many reviewsCursos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * reviewsCursos upsert
   */
  export type reviewsCursosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosInclude<ExtArgs> | null
    /**
     * The filter to search for the reviewsCursos to update in case it exists.
     */
    where: reviewsCursosWhereUniqueInput
    /**
     * In case the reviewsCursos found by the `where` argument doesn't exist, create a new reviewsCursos with this data.
     */
    create: XOR<reviewsCursosCreateInput, reviewsCursosUncheckedCreateInput>
    /**
     * In case the reviewsCursos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reviewsCursosUpdateInput, reviewsCursosUncheckedUpdateInput>
  }

  /**
   * reviewsCursos delete
   */
  export type reviewsCursosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosInclude<ExtArgs> | null
    /**
     * Filter which reviewsCursos to delete.
     */
    where: reviewsCursosWhereUniqueInput
  }

  /**
   * reviewsCursos deleteMany
   */
  export type reviewsCursosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reviewsCursos to delete
     */
    where?: reviewsCursosWhereInput
    /**
     * Limit how many reviewsCursos to delete.
     */
    limit?: number
  }

  /**
   * reviewsCursos.usuariosEstudiantes
   */
  export type reviewsCursos$usuariosEstudiantesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
    where?: usuariosEstudiantesWhereInput
  }

  /**
   * reviewsCursos without action
   */
  export type reviewsCursosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosInclude<ExtArgs> | null
  }


  /**
   * Model usuariosAdministradores
   */

  export type AggregateUsuariosAdministradores = {
    _count: UsuariosAdministradoresCountAggregateOutputType | null
    _min: UsuariosAdministradoresMinAggregateOutputType | null
    _max: UsuariosAdministradoresMaxAggregateOutputType | null
  }

  export type UsuariosAdministradoresMinAggregateOutputType = {
    id: string | null
    correo: string | null
    contrasena: string | null
    encargado: string | null
    estado: boolean | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    tipo: $Enums.TipoCuenta | null
  }

  export type UsuariosAdministradoresMaxAggregateOutputType = {
    id: string | null
    correo: string | null
    contrasena: string | null
    encargado: string | null
    estado: boolean | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    tipo: $Enums.TipoCuenta | null
  }

  export type UsuariosAdministradoresCountAggregateOutputType = {
    id: number
    correo: number
    contrasena: number
    encargado: number
    estado: number
    creadoEn: number
    actualizadoEn: number
    tipo: number
    _all: number
  }


  export type UsuariosAdministradoresMinAggregateInputType = {
    id?: true
    correo?: true
    contrasena?: true
    encargado?: true
    estado?: true
    creadoEn?: true
    actualizadoEn?: true
    tipo?: true
  }

  export type UsuariosAdministradoresMaxAggregateInputType = {
    id?: true
    correo?: true
    contrasena?: true
    encargado?: true
    estado?: true
    creadoEn?: true
    actualizadoEn?: true
    tipo?: true
  }

  export type UsuariosAdministradoresCountAggregateInputType = {
    id?: true
    correo?: true
    contrasena?: true
    encargado?: true
    estado?: true
    creadoEn?: true
    actualizadoEn?: true
    tipo?: true
    _all?: true
  }

  export type UsuariosAdministradoresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuariosAdministradores to aggregate.
     */
    where?: usuariosAdministradoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuariosAdministradores to fetch.
     */
    orderBy?: usuariosAdministradoresOrderByWithRelationInput | usuariosAdministradoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usuariosAdministradoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuariosAdministradores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuariosAdministradores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuariosAdministradores
    **/
    _count?: true | UsuariosAdministradoresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuariosAdministradoresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuariosAdministradoresMaxAggregateInputType
  }

  export type GetUsuariosAdministradoresAggregateType<T extends UsuariosAdministradoresAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuariosAdministradores]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuariosAdministradores[P]>
      : GetScalarType<T[P], AggregateUsuariosAdministradores[P]>
  }




  export type usuariosAdministradoresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuariosAdministradoresWhereInput
    orderBy?: usuariosAdministradoresOrderByWithAggregationInput | usuariosAdministradoresOrderByWithAggregationInput[]
    by: UsuariosAdministradoresScalarFieldEnum[] | UsuariosAdministradoresScalarFieldEnum
    having?: usuariosAdministradoresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuariosAdministradoresCountAggregateInputType | true
    _min?: UsuariosAdministradoresMinAggregateInputType
    _max?: UsuariosAdministradoresMaxAggregateInputType
  }

  export type UsuariosAdministradoresGroupByOutputType = {
    id: string
    correo: string
    contrasena: string
    encargado: string | null
    estado: boolean
    creadoEn: Date
    actualizadoEn: Date
    tipo: $Enums.TipoCuenta
    _count: UsuariosAdministradoresCountAggregateOutputType | null
    _min: UsuariosAdministradoresMinAggregateOutputType | null
    _max: UsuariosAdministradoresMaxAggregateOutputType | null
  }

  type GetUsuariosAdministradoresGroupByPayload<T extends usuariosAdministradoresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuariosAdministradoresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuariosAdministradoresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuariosAdministradoresGroupByOutputType[P]>
            : GetScalarType<T[P], UsuariosAdministradoresGroupByOutputType[P]>
        }
      >
    >


  export type usuariosAdministradoresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    correo?: boolean
    contrasena?: boolean
    encargado?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    tipo?: boolean
    auditoria?: boolean | usuariosAdministradores$auditoriaArgs<ExtArgs>
    docente?: boolean | usuariosAdministradores$docenteArgs<ExtArgs>
    grabaciones?: boolean | usuariosAdministradores$grabacionesArgs<ExtArgs>
    _count?: boolean | UsuariosAdministradoresCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuariosAdministradores"]>

  export type usuariosAdministradoresSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    correo?: boolean
    contrasena?: boolean
    encargado?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    tipo?: boolean
  }, ExtArgs["result"]["usuariosAdministradores"]>

  export type usuariosAdministradoresSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    correo?: boolean
    contrasena?: boolean
    encargado?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    tipo?: boolean
  }, ExtArgs["result"]["usuariosAdministradores"]>

  export type usuariosAdministradoresSelectScalar = {
    id?: boolean
    correo?: boolean
    contrasena?: boolean
    encargado?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    tipo?: boolean
  }

  export type usuariosAdministradoresOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "correo" | "contrasena" | "encargado" | "estado" | "creadoEn" | "actualizadoEn" | "tipo", ExtArgs["result"]["usuariosAdministradores"]>
  export type usuariosAdministradoresInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditoria?: boolean | usuariosAdministradores$auditoriaArgs<ExtArgs>
    docente?: boolean | usuariosAdministradores$docenteArgs<ExtArgs>
    grabaciones?: boolean | usuariosAdministradores$grabacionesArgs<ExtArgs>
    _count?: boolean | UsuariosAdministradoresCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usuariosAdministradoresIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type usuariosAdministradoresIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usuariosAdministradoresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usuariosAdministradores"
    objects: {
      auditoria: Prisma.$auditoriaPayload<ExtArgs>[]
      docente: Prisma.$docentePayload<ExtArgs> | null
      grabaciones: Prisma.$grabacionesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      correo: string
      contrasena: string
      encargado: string | null
      estado: boolean
      creadoEn: Date
      actualizadoEn: Date
      tipo: $Enums.TipoCuenta
    }, ExtArgs["result"]["usuariosAdministradores"]>
    composites: {}
  }

  type usuariosAdministradoresGetPayload<S extends boolean | null | undefined | usuariosAdministradoresDefaultArgs> = $Result.GetResult<Prisma.$usuariosAdministradoresPayload, S>

  type usuariosAdministradoresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usuariosAdministradoresFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuariosAdministradoresCountAggregateInputType | true
    }

  export interface usuariosAdministradoresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usuariosAdministradores'], meta: { name: 'usuariosAdministradores' } }
    /**
     * Find zero or one UsuariosAdministradores that matches the filter.
     * @param {usuariosAdministradoresFindUniqueArgs} args - Arguments to find a UsuariosAdministradores
     * @example
     * // Get one UsuariosAdministradores
     * const usuariosAdministradores = await prisma.usuariosAdministradores.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usuariosAdministradoresFindUniqueArgs>(args: SelectSubset<T, usuariosAdministradoresFindUniqueArgs<ExtArgs>>): Prisma__usuariosAdministradoresClient<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UsuariosAdministradores that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usuariosAdministradoresFindUniqueOrThrowArgs} args - Arguments to find a UsuariosAdministradores
     * @example
     * // Get one UsuariosAdministradores
     * const usuariosAdministradores = await prisma.usuariosAdministradores.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usuariosAdministradoresFindUniqueOrThrowArgs>(args: SelectSubset<T, usuariosAdministradoresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usuariosAdministradoresClient<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsuariosAdministradores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosAdministradoresFindFirstArgs} args - Arguments to find a UsuariosAdministradores
     * @example
     * // Get one UsuariosAdministradores
     * const usuariosAdministradores = await prisma.usuariosAdministradores.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usuariosAdministradoresFindFirstArgs>(args?: SelectSubset<T, usuariosAdministradoresFindFirstArgs<ExtArgs>>): Prisma__usuariosAdministradoresClient<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsuariosAdministradores that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosAdministradoresFindFirstOrThrowArgs} args - Arguments to find a UsuariosAdministradores
     * @example
     * // Get one UsuariosAdministradores
     * const usuariosAdministradores = await prisma.usuariosAdministradores.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usuariosAdministradoresFindFirstOrThrowArgs>(args?: SelectSubset<T, usuariosAdministradoresFindFirstOrThrowArgs<ExtArgs>>): Prisma__usuariosAdministradoresClient<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UsuariosAdministradores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosAdministradoresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsuariosAdministradores
     * const usuariosAdministradores = await prisma.usuariosAdministradores.findMany()
     * 
     * // Get first 10 UsuariosAdministradores
     * const usuariosAdministradores = await prisma.usuariosAdministradores.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuariosAdministradoresWithIdOnly = await prisma.usuariosAdministradores.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usuariosAdministradoresFindManyArgs>(args?: SelectSubset<T, usuariosAdministradoresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UsuariosAdministradores.
     * @param {usuariosAdministradoresCreateArgs} args - Arguments to create a UsuariosAdministradores.
     * @example
     * // Create one UsuariosAdministradores
     * const UsuariosAdministradores = await prisma.usuariosAdministradores.create({
     *   data: {
     *     // ... data to create a UsuariosAdministradores
     *   }
     * })
     * 
     */
    create<T extends usuariosAdministradoresCreateArgs>(args: SelectSubset<T, usuariosAdministradoresCreateArgs<ExtArgs>>): Prisma__usuariosAdministradoresClient<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UsuariosAdministradores.
     * @param {usuariosAdministradoresCreateManyArgs} args - Arguments to create many UsuariosAdministradores.
     * @example
     * // Create many UsuariosAdministradores
     * const usuariosAdministradores = await prisma.usuariosAdministradores.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usuariosAdministradoresCreateManyArgs>(args?: SelectSubset<T, usuariosAdministradoresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsuariosAdministradores and returns the data saved in the database.
     * @param {usuariosAdministradoresCreateManyAndReturnArgs} args - Arguments to create many UsuariosAdministradores.
     * @example
     * // Create many UsuariosAdministradores
     * const usuariosAdministradores = await prisma.usuariosAdministradores.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsuariosAdministradores and only return the `id`
     * const usuariosAdministradoresWithIdOnly = await prisma.usuariosAdministradores.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usuariosAdministradoresCreateManyAndReturnArgs>(args?: SelectSubset<T, usuariosAdministradoresCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UsuariosAdministradores.
     * @param {usuariosAdministradoresDeleteArgs} args - Arguments to delete one UsuariosAdministradores.
     * @example
     * // Delete one UsuariosAdministradores
     * const UsuariosAdministradores = await prisma.usuariosAdministradores.delete({
     *   where: {
     *     // ... filter to delete one UsuariosAdministradores
     *   }
     * })
     * 
     */
    delete<T extends usuariosAdministradoresDeleteArgs>(args: SelectSubset<T, usuariosAdministradoresDeleteArgs<ExtArgs>>): Prisma__usuariosAdministradoresClient<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UsuariosAdministradores.
     * @param {usuariosAdministradoresUpdateArgs} args - Arguments to update one UsuariosAdministradores.
     * @example
     * // Update one UsuariosAdministradores
     * const usuariosAdministradores = await prisma.usuariosAdministradores.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usuariosAdministradoresUpdateArgs>(args: SelectSubset<T, usuariosAdministradoresUpdateArgs<ExtArgs>>): Prisma__usuariosAdministradoresClient<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UsuariosAdministradores.
     * @param {usuariosAdministradoresDeleteManyArgs} args - Arguments to filter UsuariosAdministradores to delete.
     * @example
     * // Delete a few UsuariosAdministradores
     * const { count } = await prisma.usuariosAdministradores.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usuariosAdministradoresDeleteManyArgs>(args?: SelectSubset<T, usuariosAdministradoresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsuariosAdministradores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosAdministradoresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsuariosAdministradores
     * const usuariosAdministradores = await prisma.usuariosAdministradores.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usuariosAdministradoresUpdateManyArgs>(args: SelectSubset<T, usuariosAdministradoresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsuariosAdministradores and returns the data updated in the database.
     * @param {usuariosAdministradoresUpdateManyAndReturnArgs} args - Arguments to update many UsuariosAdministradores.
     * @example
     * // Update many UsuariosAdministradores
     * const usuariosAdministradores = await prisma.usuariosAdministradores.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UsuariosAdministradores and only return the `id`
     * const usuariosAdministradoresWithIdOnly = await prisma.usuariosAdministradores.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usuariosAdministradoresUpdateManyAndReturnArgs>(args: SelectSubset<T, usuariosAdministradoresUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UsuariosAdministradores.
     * @param {usuariosAdministradoresUpsertArgs} args - Arguments to update or create a UsuariosAdministradores.
     * @example
     * // Update or create a UsuariosAdministradores
     * const usuariosAdministradores = await prisma.usuariosAdministradores.upsert({
     *   create: {
     *     // ... data to create a UsuariosAdministradores
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsuariosAdministradores we want to update
     *   }
     * })
     */
    upsert<T extends usuariosAdministradoresUpsertArgs>(args: SelectSubset<T, usuariosAdministradoresUpsertArgs<ExtArgs>>): Prisma__usuariosAdministradoresClient<$Result.GetResult<Prisma.$usuariosAdministradoresPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UsuariosAdministradores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosAdministradoresCountArgs} args - Arguments to filter UsuariosAdministradores to count.
     * @example
     * // Count the number of UsuariosAdministradores
     * const count = await prisma.usuariosAdministradores.count({
     *   where: {
     *     // ... the filter for the UsuariosAdministradores we want to count
     *   }
     * })
    **/
    count<T extends usuariosAdministradoresCountArgs>(
      args?: Subset<T, usuariosAdministradoresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuariosAdministradoresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsuariosAdministradores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosAdministradoresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuariosAdministradoresAggregateArgs>(args: Subset<T, UsuariosAdministradoresAggregateArgs>): Prisma.PrismaPromise<GetUsuariosAdministradoresAggregateType<T>>

    /**
     * Group by UsuariosAdministradores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosAdministradoresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usuariosAdministradoresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usuariosAdministradoresGroupByArgs['orderBy'] }
        : { orderBy?: usuariosAdministradoresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usuariosAdministradoresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuariosAdministradoresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usuariosAdministradores model
   */
  readonly fields: usuariosAdministradoresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usuariosAdministradores.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usuariosAdministradoresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auditoria<T extends usuariosAdministradores$auditoriaArgs<ExtArgs> = {}>(args?: Subset<T, usuariosAdministradores$auditoriaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditoriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    docente<T extends usuariosAdministradores$docenteArgs<ExtArgs> = {}>(args?: Subset<T, usuariosAdministradores$docenteArgs<ExtArgs>>): Prisma__docenteClient<$Result.GetResult<Prisma.$docentePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    grabaciones<T extends usuariosAdministradores$grabacionesArgs<ExtArgs> = {}>(args?: Subset<T, usuariosAdministradores$grabacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$grabacionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the usuariosAdministradores model
   */
  interface usuariosAdministradoresFieldRefs {
    readonly id: FieldRef<"usuariosAdministradores", 'String'>
    readonly correo: FieldRef<"usuariosAdministradores", 'String'>
    readonly contrasena: FieldRef<"usuariosAdministradores", 'String'>
    readonly encargado: FieldRef<"usuariosAdministradores", 'String'>
    readonly estado: FieldRef<"usuariosAdministradores", 'Boolean'>
    readonly creadoEn: FieldRef<"usuariosAdministradores", 'DateTime'>
    readonly actualizadoEn: FieldRef<"usuariosAdministradores", 'DateTime'>
    readonly tipo: FieldRef<"usuariosAdministradores", 'TipoCuenta'>
  }
    

  // Custom InputTypes
  /**
   * usuariosAdministradores findUnique
   */
  export type usuariosAdministradoresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosAdministradores
     */
    select?: usuariosAdministradoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosAdministradores
     */
    omit?: usuariosAdministradoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosAdministradoresInclude<ExtArgs> | null
    /**
     * Filter, which usuariosAdministradores to fetch.
     */
    where: usuariosAdministradoresWhereUniqueInput
  }

  /**
   * usuariosAdministradores findUniqueOrThrow
   */
  export type usuariosAdministradoresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosAdministradores
     */
    select?: usuariosAdministradoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosAdministradores
     */
    omit?: usuariosAdministradoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosAdministradoresInclude<ExtArgs> | null
    /**
     * Filter, which usuariosAdministradores to fetch.
     */
    where: usuariosAdministradoresWhereUniqueInput
  }

  /**
   * usuariosAdministradores findFirst
   */
  export type usuariosAdministradoresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosAdministradores
     */
    select?: usuariosAdministradoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosAdministradores
     */
    omit?: usuariosAdministradoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosAdministradoresInclude<ExtArgs> | null
    /**
     * Filter, which usuariosAdministradores to fetch.
     */
    where?: usuariosAdministradoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuariosAdministradores to fetch.
     */
    orderBy?: usuariosAdministradoresOrderByWithRelationInput | usuariosAdministradoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuariosAdministradores.
     */
    cursor?: usuariosAdministradoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuariosAdministradores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuariosAdministradores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuariosAdministradores.
     */
    distinct?: UsuariosAdministradoresScalarFieldEnum | UsuariosAdministradoresScalarFieldEnum[]
  }

  /**
   * usuariosAdministradores findFirstOrThrow
   */
  export type usuariosAdministradoresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosAdministradores
     */
    select?: usuariosAdministradoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosAdministradores
     */
    omit?: usuariosAdministradoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosAdministradoresInclude<ExtArgs> | null
    /**
     * Filter, which usuariosAdministradores to fetch.
     */
    where?: usuariosAdministradoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuariosAdministradores to fetch.
     */
    orderBy?: usuariosAdministradoresOrderByWithRelationInput | usuariosAdministradoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuariosAdministradores.
     */
    cursor?: usuariosAdministradoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuariosAdministradores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuariosAdministradores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuariosAdministradores.
     */
    distinct?: UsuariosAdministradoresScalarFieldEnum | UsuariosAdministradoresScalarFieldEnum[]
  }

  /**
   * usuariosAdministradores findMany
   */
  export type usuariosAdministradoresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosAdministradores
     */
    select?: usuariosAdministradoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosAdministradores
     */
    omit?: usuariosAdministradoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosAdministradoresInclude<ExtArgs> | null
    /**
     * Filter, which usuariosAdministradores to fetch.
     */
    where?: usuariosAdministradoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuariosAdministradores to fetch.
     */
    orderBy?: usuariosAdministradoresOrderByWithRelationInput | usuariosAdministradoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuariosAdministradores.
     */
    cursor?: usuariosAdministradoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuariosAdministradores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuariosAdministradores.
     */
    skip?: number
    distinct?: UsuariosAdministradoresScalarFieldEnum | UsuariosAdministradoresScalarFieldEnum[]
  }

  /**
   * usuariosAdministradores create
   */
  export type usuariosAdministradoresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosAdministradores
     */
    select?: usuariosAdministradoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosAdministradores
     */
    omit?: usuariosAdministradoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosAdministradoresInclude<ExtArgs> | null
    /**
     * The data needed to create a usuariosAdministradores.
     */
    data: XOR<usuariosAdministradoresCreateInput, usuariosAdministradoresUncheckedCreateInput>
  }

  /**
   * usuariosAdministradores createMany
   */
  export type usuariosAdministradoresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usuariosAdministradores.
     */
    data: usuariosAdministradoresCreateManyInput | usuariosAdministradoresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usuariosAdministradores createManyAndReturn
   */
  export type usuariosAdministradoresCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosAdministradores
     */
    select?: usuariosAdministradoresSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosAdministradores
     */
    omit?: usuariosAdministradoresOmit<ExtArgs> | null
    /**
     * The data used to create many usuariosAdministradores.
     */
    data: usuariosAdministradoresCreateManyInput | usuariosAdministradoresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usuariosAdministradores update
   */
  export type usuariosAdministradoresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosAdministradores
     */
    select?: usuariosAdministradoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosAdministradores
     */
    omit?: usuariosAdministradoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosAdministradoresInclude<ExtArgs> | null
    /**
     * The data needed to update a usuariosAdministradores.
     */
    data: XOR<usuariosAdministradoresUpdateInput, usuariosAdministradoresUncheckedUpdateInput>
    /**
     * Choose, which usuariosAdministradores to update.
     */
    where: usuariosAdministradoresWhereUniqueInput
  }

  /**
   * usuariosAdministradores updateMany
   */
  export type usuariosAdministradoresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usuariosAdministradores.
     */
    data: XOR<usuariosAdministradoresUpdateManyMutationInput, usuariosAdministradoresUncheckedUpdateManyInput>
    /**
     * Filter which usuariosAdministradores to update
     */
    where?: usuariosAdministradoresWhereInput
    /**
     * Limit how many usuariosAdministradores to update.
     */
    limit?: number
  }

  /**
   * usuariosAdministradores updateManyAndReturn
   */
  export type usuariosAdministradoresUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosAdministradores
     */
    select?: usuariosAdministradoresSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosAdministradores
     */
    omit?: usuariosAdministradoresOmit<ExtArgs> | null
    /**
     * The data used to update usuariosAdministradores.
     */
    data: XOR<usuariosAdministradoresUpdateManyMutationInput, usuariosAdministradoresUncheckedUpdateManyInput>
    /**
     * Filter which usuariosAdministradores to update
     */
    where?: usuariosAdministradoresWhereInput
    /**
     * Limit how many usuariosAdministradores to update.
     */
    limit?: number
  }

  /**
   * usuariosAdministradores upsert
   */
  export type usuariosAdministradoresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosAdministradores
     */
    select?: usuariosAdministradoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosAdministradores
     */
    omit?: usuariosAdministradoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosAdministradoresInclude<ExtArgs> | null
    /**
     * The filter to search for the usuariosAdministradores to update in case it exists.
     */
    where: usuariosAdministradoresWhereUniqueInput
    /**
     * In case the usuariosAdministradores found by the `where` argument doesn't exist, create a new usuariosAdministradores with this data.
     */
    create: XOR<usuariosAdministradoresCreateInput, usuariosAdministradoresUncheckedCreateInput>
    /**
     * In case the usuariosAdministradores was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usuariosAdministradoresUpdateInput, usuariosAdministradoresUncheckedUpdateInput>
  }

  /**
   * usuariosAdministradores delete
   */
  export type usuariosAdministradoresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosAdministradores
     */
    select?: usuariosAdministradoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosAdministradores
     */
    omit?: usuariosAdministradoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosAdministradoresInclude<ExtArgs> | null
    /**
     * Filter which usuariosAdministradores to delete.
     */
    where: usuariosAdministradoresWhereUniqueInput
  }

  /**
   * usuariosAdministradores deleteMany
   */
  export type usuariosAdministradoresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuariosAdministradores to delete
     */
    where?: usuariosAdministradoresWhereInput
    /**
     * Limit how many usuariosAdministradores to delete.
     */
    limit?: number
  }

  /**
   * usuariosAdministradores.auditoria
   */
  export type usuariosAdministradores$auditoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditoria
     */
    select?: auditoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditoria
     */
    omit?: auditoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditoriaInclude<ExtArgs> | null
    where?: auditoriaWhereInput
    orderBy?: auditoriaOrderByWithRelationInput | auditoriaOrderByWithRelationInput[]
    cursor?: auditoriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditoriaScalarFieldEnum | AuditoriaScalarFieldEnum[]
  }

  /**
   * usuariosAdministradores.docente
   */
  export type usuariosAdministradores$docenteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docente
     */
    select?: docenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docente
     */
    omit?: docenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docenteInclude<ExtArgs> | null
    where?: docenteWhereInput
  }

  /**
   * usuariosAdministradores.grabaciones
   */
  export type usuariosAdministradores$grabacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the grabaciones
     */
    select?: grabacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the grabaciones
     */
    omit?: grabacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: grabacionesInclude<ExtArgs> | null
    where?: grabacionesWhereInput
    orderBy?: grabacionesOrderByWithRelationInput | grabacionesOrderByWithRelationInput[]
    cursor?: grabacionesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GrabacionesScalarFieldEnum | GrabacionesScalarFieldEnum[]
  }

  /**
   * usuariosAdministradores without action
   */
  export type usuariosAdministradoresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosAdministradores
     */
    select?: usuariosAdministradoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosAdministradores
     */
    omit?: usuariosAdministradoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosAdministradoresInclude<ExtArgs> | null
  }


  /**
   * Model usuariosEstudiantes
   */

  export type AggregateUsuariosEstudiantes = {
    _count: UsuariosEstudiantesCountAggregateOutputType | null
    _min: UsuariosEstudiantesMinAggregateOutputType | null
    _max: UsuariosEstudiantesMaxAggregateOutputType | null
  }

  export type UsuariosEstudiantesMinAggregateOutputType = {
    id: string | null
    correo: string | null
    contrasena: string | null
    usuario: string | null
    estado: boolean | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    avatar: string | null
    estudianteId: string | null
    registrado: boolean | null
  }

  export type UsuariosEstudiantesMaxAggregateOutputType = {
    id: string | null
    correo: string | null
    contrasena: string | null
    usuario: string | null
    estado: boolean | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    avatar: string | null
    estudianteId: string | null
    registrado: boolean | null
  }

  export type UsuariosEstudiantesCountAggregateOutputType = {
    id: number
    correo: number
    contrasena: number
    usuario: number
    estado: number
    creadoEn: number
    actualizadoEn: number
    avatar: number
    estudianteId: number
    registrado: number
    _all: number
  }


  export type UsuariosEstudiantesMinAggregateInputType = {
    id?: true
    correo?: true
    contrasena?: true
    usuario?: true
    estado?: true
    creadoEn?: true
    actualizadoEn?: true
    avatar?: true
    estudianteId?: true
    registrado?: true
  }

  export type UsuariosEstudiantesMaxAggregateInputType = {
    id?: true
    correo?: true
    contrasena?: true
    usuario?: true
    estado?: true
    creadoEn?: true
    actualizadoEn?: true
    avatar?: true
    estudianteId?: true
    registrado?: true
  }

  export type UsuariosEstudiantesCountAggregateInputType = {
    id?: true
    correo?: true
    contrasena?: true
    usuario?: true
    estado?: true
    creadoEn?: true
    actualizadoEn?: true
    avatar?: true
    estudianteId?: true
    registrado?: true
    _all?: true
  }

  export type UsuariosEstudiantesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuariosEstudiantes to aggregate.
     */
    where?: usuariosEstudiantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuariosEstudiantes to fetch.
     */
    orderBy?: usuariosEstudiantesOrderByWithRelationInput | usuariosEstudiantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usuariosEstudiantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuariosEstudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuariosEstudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuariosEstudiantes
    **/
    _count?: true | UsuariosEstudiantesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuariosEstudiantesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuariosEstudiantesMaxAggregateInputType
  }

  export type GetUsuariosEstudiantesAggregateType<T extends UsuariosEstudiantesAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuariosEstudiantes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuariosEstudiantes[P]>
      : GetScalarType<T[P], AggregateUsuariosEstudiantes[P]>
  }




  export type usuariosEstudiantesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuariosEstudiantesWhereInput
    orderBy?: usuariosEstudiantesOrderByWithAggregationInput | usuariosEstudiantesOrderByWithAggregationInput[]
    by: UsuariosEstudiantesScalarFieldEnum[] | UsuariosEstudiantesScalarFieldEnum
    having?: usuariosEstudiantesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuariosEstudiantesCountAggregateInputType | true
    _min?: UsuariosEstudiantesMinAggregateInputType
    _max?: UsuariosEstudiantesMaxAggregateInputType
  }

  export type UsuariosEstudiantesGroupByOutputType = {
    id: string
    correo: string
    contrasena: string
    usuario: string
    estado: boolean
    creadoEn: Date
    actualizadoEn: Date
    avatar: string | null
    estudianteId: string | null
    registrado: boolean
    _count: UsuariosEstudiantesCountAggregateOutputType | null
    _min: UsuariosEstudiantesMinAggregateOutputType | null
    _max: UsuariosEstudiantesMaxAggregateOutputType | null
  }

  type GetUsuariosEstudiantesGroupByPayload<T extends usuariosEstudiantesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuariosEstudiantesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuariosEstudiantesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuariosEstudiantesGroupByOutputType[P]>
            : GetScalarType<T[P], UsuariosEstudiantesGroupByOutputType[P]>
        }
      >
    >


  export type usuariosEstudiantesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    correo?: boolean
    contrasena?: boolean
    usuario?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    avatar?: boolean
    estudianteId?: boolean
    registrado?: boolean
    compras?: boolean | usuariosEstudiantes$comprasArgs<ExtArgs>
    intentos?: boolean | usuariosEstudiantes$intentosArgs<ExtArgs>
    reaccionesPreguntas?: boolean | usuariosEstudiantes$reaccionesPreguntasArgs<ExtArgs>
    repasoRegistros?: boolean | usuariosEstudiantes$repasoRegistrosArgs<ExtArgs>
    reviewsCursos?: boolean | usuariosEstudiantes$reviewsCursosArgs<ExtArgs>
    suscripciones?: boolean | usuariosEstudiantes$suscripcionesArgs<ExtArgs>
    estudiantes?: boolean | usuariosEstudiantes$estudiantesArgs<ExtArgs>
    _count?: boolean | UsuariosEstudiantesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuariosEstudiantes"]>

  export type usuariosEstudiantesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    correo?: boolean
    contrasena?: boolean
    usuario?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    avatar?: boolean
    estudianteId?: boolean
    registrado?: boolean
    estudiantes?: boolean | usuariosEstudiantes$estudiantesArgs<ExtArgs>
  }, ExtArgs["result"]["usuariosEstudiantes"]>

  export type usuariosEstudiantesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    correo?: boolean
    contrasena?: boolean
    usuario?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    avatar?: boolean
    estudianteId?: boolean
    registrado?: boolean
    estudiantes?: boolean | usuariosEstudiantes$estudiantesArgs<ExtArgs>
  }, ExtArgs["result"]["usuariosEstudiantes"]>

  export type usuariosEstudiantesSelectScalar = {
    id?: boolean
    correo?: boolean
    contrasena?: boolean
    usuario?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    avatar?: boolean
    estudianteId?: boolean
    registrado?: boolean
  }

  export type usuariosEstudiantesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "correo" | "contrasena" | "usuario" | "estado" | "creadoEn" | "actualizadoEn" | "avatar" | "estudianteId" | "registrado", ExtArgs["result"]["usuariosEstudiantes"]>
  export type usuariosEstudiantesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    compras?: boolean | usuariosEstudiantes$comprasArgs<ExtArgs>
    intentos?: boolean | usuariosEstudiantes$intentosArgs<ExtArgs>
    reaccionesPreguntas?: boolean | usuariosEstudiantes$reaccionesPreguntasArgs<ExtArgs>
    repasoRegistros?: boolean | usuariosEstudiantes$repasoRegistrosArgs<ExtArgs>
    reviewsCursos?: boolean | usuariosEstudiantes$reviewsCursosArgs<ExtArgs>
    suscripciones?: boolean | usuariosEstudiantes$suscripcionesArgs<ExtArgs>
    estudiantes?: boolean | usuariosEstudiantes$estudiantesArgs<ExtArgs>
    _count?: boolean | UsuariosEstudiantesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usuariosEstudiantesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiantes?: boolean | usuariosEstudiantes$estudiantesArgs<ExtArgs>
  }
  export type usuariosEstudiantesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estudiantes?: boolean | usuariosEstudiantes$estudiantesArgs<ExtArgs>
  }

  export type $usuariosEstudiantesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usuariosEstudiantes"
    objects: {
      compras: Prisma.$comprasPayload<ExtArgs>[]
      intentos: Prisma.$intentosPayload<ExtArgs>[]
      reaccionesPreguntas: Prisma.$reaccionesPreguntasPayload<ExtArgs>[]
      repasoRegistros: Prisma.$repasoRegistrosPayload<ExtArgs>[]
      reviewsCursos: Prisma.$reviewsCursosPayload<ExtArgs>[]
      suscripciones: Prisma.$suscripcionesPayload<ExtArgs>[]
      estudiantes: Prisma.$estudiantesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      correo: string
      contrasena: string
      usuario: string
      estado: boolean
      creadoEn: Date
      actualizadoEn: Date
      avatar: string | null
      estudianteId: string | null
      registrado: boolean
    }, ExtArgs["result"]["usuariosEstudiantes"]>
    composites: {}
  }

  type usuariosEstudiantesGetPayload<S extends boolean | null | undefined | usuariosEstudiantesDefaultArgs> = $Result.GetResult<Prisma.$usuariosEstudiantesPayload, S>

  type usuariosEstudiantesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usuariosEstudiantesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuariosEstudiantesCountAggregateInputType | true
    }

  export interface usuariosEstudiantesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usuariosEstudiantes'], meta: { name: 'usuariosEstudiantes' } }
    /**
     * Find zero or one UsuariosEstudiantes that matches the filter.
     * @param {usuariosEstudiantesFindUniqueArgs} args - Arguments to find a UsuariosEstudiantes
     * @example
     * // Get one UsuariosEstudiantes
     * const usuariosEstudiantes = await prisma.usuariosEstudiantes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usuariosEstudiantesFindUniqueArgs>(args: SelectSubset<T, usuariosEstudiantesFindUniqueArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UsuariosEstudiantes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usuariosEstudiantesFindUniqueOrThrowArgs} args - Arguments to find a UsuariosEstudiantes
     * @example
     * // Get one UsuariosEstudiantes
     * const usuariosEstudiantes = await prisma.usuariosEstudiantes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usuariosEstudiantesFindUniqueOrThrowArgs>(args: SelectSubset<T, usuariosEstudiantesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsuariosEstudiantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosEstudiantesFindFirstArgs} args - Arguments to find a UsuariosEstudiantes
     * @example
     * // Get one UsuariosEstudiantes
     * const usuariosEstudiantes = await prisma.usuariosEstudiantes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usuariosEstudiantesFindFirstArgs>(args?: SelectSubset<T, usuariosEstudiantesFindFirstArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsuariosEstudiantes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosEstudiantesFindFirstOrThrowArgs} args - Arguments to find a UsuariosEstudiantes
     * @example
     * // Get one UsuariosEstudiantes
     * const usuariosEstudiantes = await prisma.usuariosEstudiantes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usuariosEstudiantesFindFirstOrThrowArgs>(args?: SelectSubset<T, usuariosEstudiantesFindFirstOrThrowArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UsuariosEstudiantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosEstudiantesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsuariosEstudiantes
     * const usuariosEstudiantes = await prisma.usuariosEstudiantes.findMany()
     * 
     * // Get first 10 UsuariosEstudiantes
     * const usuariosEstudiantes = await prisma.usuariosEstudiantes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuariosEstudiantesWithIdOnly = await prisma.usuariosEstudiantes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usuariosEstudiantesFindManyArgs>(args?: SelectSubset<T, usuariosEstudiantesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UsuariosEstudiantes.
     * @param {usuariosEstudiantesCreateArgs} args - Arguments to create a UsuariosEstudiantes.
     * @example
     * // Create one UsuariosEstudiantes
     * const UsuariosEstudiantes = await prisma.usuariosEstudiantes.create({
     *   data: {
     *     // ... data to create a UsuariosEstudiantes
     *   }
     * })
     * 
     */
    create<T extends usuariosEstudiantesCreateArgs>(args: SelectSubset<T, usuariosEstudiantesCreateArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UsuariosEstudiantes.
     * @param {usuariosEstudiantesCreateManyArgs} args - Arguments to create many UsuariosEstudiantes.
     * @example
     * // Create many UsuariosEstudiantes
     * const usuariosEstudiantes = await prisma.usuariosEstudiantes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usuariosEstudiantesCreateManyArgs>(args?: SelectSubset<T, usuariosEstudiantesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsuariosEstudiantes and returns the data saved in the database.
     * @param {usuariosEstudiantesCreateManyAndReturnArgs} args - Arguments to create many UsuariosEstudiantes.
     * @example
     * // Create many UsuariosEstudiantes
     * const usuariosEstudiantes = await prisma.usuariosEstudiantes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsuariosEstudiantes and only return the `id`
     * const usuariosEstudiantesWithIdOnly = await prisma.usuariosEstudiantes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usuariosEstudiantesCreateManyAndReturnArgs>(args?: SelectSubset<T, usuariosEstudiantesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UsuariosEstudiantes.
     * @param {usuariosEstudiantesDeleteArgs} args - Arguments to delete one UsuariosEstudiantes.
     * @example
     * // Delete one UsuariosEstudiantes
     * const UsuariosEstudiantes = await prisma.usuariosEstudiantes.delete({
     *   where: {
     *     // ... filter to delete one UsuariosEstudiantes
     *   }
     * })
     * 
     */
    delete<T extends usuariosEstudiantesDeleteArgs>(args: SelectSubset<T, usuariosEstudiantesDeleteArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UsuariosEstudiantes.
     * @param {usuariosEstudiantesUpdateArgs} args - Arguments to update one UsuariosEstudiantes.
     * @example
     * // Update one UsuariosEstudiantes
     * const usuariosEstudiantes = await prisma.usuariosEstudiantes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usuariosEstudiantesUpdateArgs>(args: SelectSubset<T, usuariosEstudiantesUpdateArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UsuariosEstudiantes.
     * @param {usuariosEstudiantesDeleteManyArgs} args - Arguments to filter UsuariosEstudiantes to delete.
     * @example
     * // Delete a few UsuariosEstudiantes
     * const { count } = await prisma.usuariosEstudiantes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usuariosEstudiantesDeleteManyArgs>(args?: SelectSubset<T, usuariosEstudiantesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsuariosEstudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosEstudiantesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsuariosEstudiantes
     * const usuariosEstudiantes = await prisma.usuariosEstudiantes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usuariosEstudiantesUpdateManyArgs>(args: SelectSubset<T, usuariosEstudiantesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsuariosEstudiantes and returns the data updated in the database.
     * @param {usuariosEstudiantesUpdateManyAndReturnArgs} args - Arguments to update many UsuariosEstudiantes.
     * @example
     * // Update many UsuariosEstudiantes
     * const usuariosEstudiantes = await prisma.usuariosEstudiantes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UsuariosEstudiantes and only return the `id`
     * const usuariosEstudiantesWithIdOnly = await prisma.usuariosEstudiantes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usuariosEstudiantesUpdateManyAndReturnArgs>(args: SelectSubset<T, usuariosEstudiantesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UsuariosEstudiantes.
     * @param {usuariosEstudiantesUpsertArgs} args - Arguments to update or create a UsuariosEstudiantes.
     * @example
     * // Update or create a UsuariosEstudiantes
     * const usuariosEstudiantes = await prisma.usuariosEstudiantes.upsert({
     *   create: {
     *     // ... data to create a UsuariosEstudiantes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsuariosEstudiantes we want to update
     *   }
     * })
     */
    upsert<T extends usuariosEstudiantesUpsertArgs>(args: SelectSubset<T, usuariosEstudiantesUpsertArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UsuariosEstudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosEstudiantesCountArgs} args - Arguments to filter UsuariosEstudiantes to count.
     * @example
     * // Count the number of UsuariosEstudiantes
     * const count = await prisma.usuariosEstudiantes.count({
     *   where: {
     *     // ... the filter for the UsuariosEstudiantes we want to count
     *   }
     * })
    **/
    count<T extends usuariosEstudiantesCountArgs>(
      args?: Subset<T, usuariosEstudiantesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuariosEstudiantesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsuariosEstudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosEstudiantesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuariosEstudiantesAggregateArgs>(args: Subset<T, UsuariosEstudiantesAggregateArgs>): Prisma.PrismaPromise<GetUsuariosEstudiantesAggregateType<T>>

    /**
     * Group by UsuariosEstudiantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuariosEstudiantesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usuariosEstudiantesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usuariosEstudiantesGroupByArgs['orderBy'] }
        : { orderBy?: usuariosEstudiantesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usuariosEstudiantesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuariosEstudiantesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usuariosEstudiantes model
   */
  readonly fields: usuariosEstudiantesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usuariosEstudiantes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usuariosEstudiantesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    compras<T extends usuariosEstudiantes$comprasArgs<ExtArgs> = {}>(args?: Subset<T, usuariosEstudiantes$comprasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    intentos<T extends usuariosEstudiantes$intentosArgs<ExtArgs> = {}>(args?: Subset<T, usuariosEstudiantes$intentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$intentosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reaccionesPreguntas<T extends usuariosEstudiantes$reaccionesPreguntasArgs<ExtArgs> = {}>(args?: Subset<T, usuariosEstudiantes$reaccionesPreguntasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reaccionesPreguntasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    repasoRegistros<T extends usuariosEstudiantes$repasoRegistrosArgs<ExtArgs> = {}>(args?: Subset<T, usuariosEstudiantes$repasoRegistrosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$repasoRegistrosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewsCursos<T extends usuariosEstudiantes$reviewsCursosArgs<ExtArgs> = {}>(args?: Subset<T, usuariosEstudiantes$reviewsCursosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsCursosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    suscripciones<T extends usuariosEstudiantes$suscripcionesArgs<ExtArgs> = {}>(args?: Subset<T, usuariosEstudiantes$suscripcionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$suscripcionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    estudiantes<T extends usuariosEstudiantes$estudiantesArgs<ExtArgs> = {}>(args?: Subset<T, usuariosEstudiantes$estudiantesArgs<ExtArgs>>): Prisma__estudiantesClient<$Result.GetResult<Prisma.$estudiantesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the usuariosEstudiantes model
   */
  interface usuariosEstudiantesFieldRefs {
    readonly id: FieldRef<"usuariosEstudiantes", 'String'>
    readonly correo: FieldRef<"usuariosEstudiantes", 'String'>
    readonly contrasena: FieldRef<"usuariosEstudiantes", 'String'>
    readonly usuario: FieldRef<"usuariosEstudiantes", 'String'>
    readonly estado: FieldRef<"usuariosEstudiantes", 'Boolean'>
    readonly creadoEn: FieldRef<"usuariosEstudiantes", 'DateTime'>
    readonly actualizadoEn: FieldRef<"usuariosEstudiantes", 'DateTime'>
    readonly avatar: FieldRef<"usuariosEstudiantes", 'String'>
    readonly estudianteId: FieldRef<"usuariosEstudiantes", 'String'>
    readonly registrado: FieldRef<"usuariosEstudiantes", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * usuariosEstudiantes findUnique
   */
  export type usuariosEstudiantesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
    /**
     * Filter, which usuariosEstudiantes to fetch.
     */
    where: usuariosEstudiantesWhereUniqueInput
  }

  /**
   * usuariosEstudiantes findUniqueOrThrow
   */
  export type usuariosEstudiantesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
    /**
     * Filter, which usuariosEstudiantes to fetch.
     */
    where: usuariosEstudiantesWhereUniqueInput
  }

  /**
   * usuariosEstudiantes findFirst
   */
  export type usuariosEstudiantesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
    /**
     * Filter, which usuariosEstudiantes to fetch.
     */
    where?: usuariosEstudiantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuariosEstudiantes to fetch.
     */
    orderBy?: usuariosEstudiantesOrderByWithRelationInput | usuariosEstudiantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuariosEstudiantes.
     */
    cursor?: usuariosEstudiantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuariosEstudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuariosEstudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuariosEstudiantes.
     */
    distinct?: UsuariosEstudiantesScalarFieldEnum | UsuariosEstudiantesScalarFieldEnum[]
  }

  /**
   * usuariosEstudiantes findFirstOrThrow
   */
  export type usuariosEstudiantesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
    /**
     * Filter, which usuariosEstudiantes to fetch.
     */
    where?: usuariosEstudiantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuariosEstudiantes to fetch.
     */
    orderBy?: usuariosEstudiantesOrderByWithRelationInput | usuariosEstudiantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuariosEstudiantes.
     */
    cursor?: usuariosEstudiantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuariosEstudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuariosEstudiantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuariosEstudiantes.
     */
    distinct?: UsuariosEstudiantesScalarFieldEnum | UsuariosEstudiantesScalarFieldEnum[]
  }

  /**
   * usuariosEstudiantes findMany
   */
  export type usuariosEstudiantesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
    /**
     * Filter, which usuariosEstudiantes to fetch.
     */
    where?: usuariosEstudiantesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuariosEstudiantes to fetch.
     */
    orderBy?: usuariosEstudiantesOrderByWithRelationInput | usuariosEstudiantesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuariosEstudiantes.
     */
    cursor?: usuariosEstudiantesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuariosEstudiantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuariosEstudiantes.
     */
    skip?: number
    distinct?: UsuariosEstudiantesScalarFieldEnum | UsuariosEstudiantesScalarFieldEnum[]
  }

  /**
   * usuariosEstudiantes create
   */
  export type usuariosEstudiantesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
    /**
     * The data needed to create a usuariosEstudiantes.
     */
    data: XOR<usuariosEstudiantesCreateInput, usuariosEstudiantesUncheckedCreateInput>
  }

  /**
   * usuariosEstudiantes createMany
   */
  export type usuariosEstudiantesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usuariosEstudiantes.
     */
    data: usuariosEstudiantesCreateManyInput | usuariosEstudiantesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usuariosEstudiantes createManyAndReturn
   */
  export type usuariosEstudiantesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * The data used to create many usuariosEstudiantes.
     */
    data: usuariosEstudiantesCreateManyInput | usuariosEstudiantesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * usuariosEstudiantes update
   */
  export type usuariosEstudiantesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
    /**
     * The data needed to update a usuariosEstudiantes.
     */
    data: XOR<usuariosEstudiantesUpdateInput, usuariosEstudiantesUncheckedUpdateInput>
    /**
     * Choose, which usuariosEstudiantes to update.
     */
    where: usuariosEstudiantesWhereUniqueInput
  }

  /**
   * usuariosEstudiantes updateMany
   */
  export type usuariosEstudiantesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usuariosEstudiantes.
     */
    data: XOR<usuariosEstudiantesUpdateManyMutationInput, usuariosEstudiantesUncheckedUpdateManyInput>
    /**
     * Filter which usuariosEstudiantes to update
     */
    where?: usuariosEstudiantesWhereInput
    /**
     * Limit how many usuariosEstudiantes to update.
     */
    limit?: number
  }

  /**
   * usuariosEstudiantes updateManyAndReturn
   */
  export type usuariosEstudiantesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * The data used to update usuariosEstudiantes.
     */
    data: XOR<usuariosEstudiantesUpdateManyMutationInput, usuariosEstudiantesUncheckedUpdateManyInput>
    /**
     * Filter which usuariosEstudiantes to update
     */
    where?: usuariosEstudiantesWhereInput
    /**
     * Limit how many usuariosEstudiantes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * usuariosEstudiantes upsert
   */
  export type usuariosEstudiantesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
    /**
     * The filter to search for the usuariosEstudiantes to update in case it exists.
     */
    where: usuariosEstudiantesWhereUniqueInput
    /**
     * In case the usuariosEstudiantes found by the `where` argument doesn't exist, create a new usuariosEstudiantes with this data.
     */
    create: XOR<usuariosEstudiantesCreateInput, usuariosEstudiantesUncheckedCreateInput>
    /**
     * In case the usuariosEstudiantes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usuariosEstudiantesUpdateInput, usuariosEstudiantesUncheckedUpdateInput>
  }

  /**
   * usuariosEstudiantes delete
   */
  export type usuariosEstudiantesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
    /**
     * Filter which usuariosEstudiantes to delete.
     */
    where: usuariosEstudiantesWhereUniqueInput
  }

  /**
   * usuariosEstudiantes deleteMany
   */
  export type usuariosEstudiantesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuariosEstudiantes to delete
     */
    where?: usuariosEstudiantesWhereInput
    /**
     * Limit how many usuariosEstudiantes to delete.
     */
    limit?: number
  }

  /**
   * usuariosEstudiantes.compras
   */
  export type usuariosEstudiantes$comprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the compras
     */
    omit?: comprasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comprasInclude<ExtArgs> | null
    where?: comprasWhereInput
    orderBy?: comprasOrderByWithRelationInput | comprasOrderByWithRelationInput[]
    cursor?: comprasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComprasScalarFieldEnum | ComprasScalarFieldEnum[]
  }

  /**
   * usuariosEstudiantes.intentos
   */
  export type usuariosEstudiantes$intentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intentos
     */
    select?: intentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the intentos
     */
    omit?: intentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intentosInclude<ExtArgs> | null
    where?: intentosWhereInput
    orderBy?: intentosOrderByWithRelationInput | intentosOrderByWithRelationInput[]
    cursor?: intentosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntentosScalarFieldEnum | IntentosScalarFieldEnum[]
  }

  /**
   * usuariosEstudiantes.reaccionesPreguntas
   */
  export type usuariosEstudiantes$reaccionesPreguntasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reaccionesPreguntas
     */
    select?: reaccionesPreguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reaccionesPreguntas
     */
    omit?: reaccionesPreguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reaccionesPreguntasInclude<ExtArgs> | null
    where?: reaccionesPreguntasWhereInput
    orderBy?: reaccionesPreguntasOrderByWithRelationInput | reaccionesPreguntasOrderByWithRelationInput[]
    cursor?: reaccionesPreguntasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReaccionesPreguntasScalarFieldEnum | ReaccionesPreguntasScalarFieldEnum[]
  }

  /**
   * usuariosEstudiantes.repasoRegistros
   */
  export type usuariosEstudiantes$repasoRegistrosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repasoRegistros
     */
    select?: repasoRegistrosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repasoRegistros
     */
    omit?: repasoRegistrosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: repasoRegistrosInclude<ExtArgs> | null
    where?: repasoRegistrosWhereInput
    orderBy?: repasoRegistrosOrderByWithRelationInput | repasoRegistrosOrderByWithRelationInput[]
    cursor?: repasoRegistrosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RepasoRegistrosScalarFieldEnum | RepasoRegistrosScalarFieldEnum[]
  }

  /**
   * usuariosEstudiantes.reviewsCursos
   */
  export type usuariosEstudiantes$reviewsCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviewsCursos
     */
    select?: reviewsCursosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviewsCursos
     */
    omit?: reviewsCursosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsCursosInclude<ExtArgs> | null
    where?: reviewsCursosWhereInput
    orderBy?: reviewsCursosOrderByWithRelationInput | reviewsCursosOrderByWithRelationInput[]
    cursor?: reviewsCursosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewsCursosScalarFieldEnum | ReviewsCursosScalarFieldEnum[]
  }

  /**
   * usuariosEstudiantes.suscripciones
   */
  export type usuariosEstudiantes$suscripcionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suscripciones
     */
    select?: suscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suscripciones
     */
    omit?: suscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suscripcionesInclude<ExtArgs> | null
    where?: suscripcionesWhereInput
    orderBy?: suscripcionesOrderByWithRelationInput | suscripcionesOrderByWithRelationInput[]
    cursor?: suscripcionesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SuscripcionesScalarFieldEnum | SuscripcionesScalarFieldEnum[]
  }

  /**
   * usuariosEstudiantes.estudiantes
   */
  export type usuariosEstudiantes$estudiantesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estudiantes
     */
    select?: estudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estudiantes
     */
    omit?: estudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estudiantesInclude<ExtArgs> | null
    where?: estudiantesWhereInput
  }

  /**
   * usuariosEstudiantes without action
   */
  export type usuariosEstudiantesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
  }


  /**
   * Model areas
   */

  export type AggregateAreas = {
    _count: AreasCountAggregateOutputType | null
    _min: AreasMinAggregateOutputType | null
    _max: AreasMaxAggregateOutputType | null
  }

  export type AreasMinAggregateOutputType = {
    id: string | null
    titulo: string | null
    descripcion: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type AreasMaxAggregateOutputType = {
    id: string | null
    titulo: string | null
    descripcion: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type AreasCountAggregateOutputType = {
    id: number
    titulo: number
    descripcion: number
    creadoEn: number
    actualizadoEn: number
    _all: number
  }


  export type AreasMinAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type AreasMaxAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type AreasCountAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    creadoEn?: true
    actualizadoEn?: true
    _all?: true
  }

  export type AreasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which areas to aggregate.
     */
    where?: areasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of areas to fetch.
     */
    orderBy?: areasOrderByWithRelationInput | areasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: areasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned areas
    **/
    _count?: true | AreasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AreasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AreasMaxAggregateInputType
  }

  export type GetAreasAggregateType<T extends AreasAggregateArgs> = {
        [P in keyof T & keyof AggregateAreas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAreas[P]>
      : GetScalarType<T[P], AggregateAreas[P]>
  }




  export type areasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: areasWhereInput
    orderBy?: areasOrderByWithAggregationInput | areasOrderByWithAggregationInput[]
    by: AreasScalarFieldEnum[] | AreasScalarFieldEnum
    having?: areasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AreasCountAggregateInputType | true
    _min?: AreasMinAggregateInputType
    _max?: AreasMaxAggregateInputType
  }

  export type AreasGroupByOutputType = {
    id: string
    titulo: string
    descripcion: string | null
    creadoEn: Date
    actualizadoEn: Date
    _count: AreasCountAggregateOutputType | null
    _min: AreasMinAggregateOutputType | null
    _max: AreasMaxAggregateOutputType | null
  }

  type GetAreasGroupByPayload<T extends areasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AreasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AreasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AreasGroupByOutputType[P]>
            : GetScalarType<T[P], AreasGroupByOutputType[P]>
        }
      >
    >


  export type areasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    capitulos?: boolean | areas$capitulosArgs<ExtArgs>
    preguntas?: boolean | areas$preguntasArgs<ExtArgs>
    _count?: boolean | AreasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["areas"]>

  export type areasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }, ExtArgs["result"]["areas"]>

  export type areasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }, ExtArgs["result"]["areas"]>

  export type areasSelectScalar = {
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }

  export type areasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "titulo" | "descripcion" | "creadoEn" | "actualizadoEn", ExtArgs["result"]["areas"]>
  export type areasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    capitulos?: boolean | areas$capitulosArgs<ExtArgs>
    preguntas?: boolean | areas$preguntasArgs<ExtArgs>
    _count?: boolean | AreasCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type areasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type areasIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $areasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "areas"
    objects: {
      capitulos: Prisma.$capitulosPayload<ExtArgs>[]
      preguntas: Prisma.$preguntasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      titulo: string
      descripcion: string | null
      creadoEn: Date
      actualizadoEn: Date
    }, ExtArgs["result"]["areas"]>
    composites: {}
  }

  type areasGetPayload<S extends boolean | null | undefined | areasDefaultArgs> = $Result.GetResult<Prisma.$areasPayload, S>

  type areasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<areasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AreasCountAggregateInputType | true
    }

  export interface areasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['areas'], meta: { name: 'areas' } }
    /**
     * Find zero or one Areas that matches the filter.
     * @param {areasFindUniqueArgs} args - Arguments to find a Areas
     * @example
     * // Get one Areas
     * const areas = await prisma.areas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends areasFindUniqueArgs>(args: SelectSubset<T, areasFindUniqueArgs<ExtArgs>>): Prisma__areasClient<$Result.GetResult<Prisma.$areasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Areas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {areasFindUniqueOrThrowArgs} args - Arguments to find a Areas
     * @example
     * // Get one Areas
     * const areas = await prisma.areas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends areasFindUniqueOrThrowArgs>(args: SelectSubset<T, areasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__areasClient<$Result.GetResult<Prisma.$areasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Areas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {areasFindFirstArgs} args - Arguments to find a Areas
     * @example
     * // Get one Areas
     * const areas = await prisma.areas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends areasFindFirstArgs>(args?: SelectSubset<T, areasFindFirstArgs<ExtArgs>>): Prisma__areasClient<$Result.GetResult<Prisma.$areasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Areas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {areasFindFirstOrThrowArgs} args - Arguments to find a Areas
     * @example
     * // Get one Areas
     * const areas = await prisma.areas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends areasFindFirstOrThrowArgs>(args?: SelectSubset<T, areasFindFirstOrThrowArgs<ExtArgs>>): Prisma__areasClient<$Result.GetResult<Prisma.$areasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Areas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {areasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Areas
     * const areas = await prisma.areas.findMany()
     * 
     * // Get first 10 Areas
     * const areas = await prisma.areas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const areasWithIdOnly = await prisma.areas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends areasFindManyArgs>(args?: SelectSubset<T, areasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$areasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Areas.
     * @param {areasCreateArgs} args - Arguments to create a Areas.
     * @example
     * // Create one Areas
     * const Areas = await prisma.areas.create({
     *   data: {
     *     // ... data to create a Areas
     *   }
     * })
     * 
     */
    create<T extends areasCreateArgs>(args: SelectSubset<T, areasCreateArgs<ExtArgs>>): Prisma__areasClient<$Result.GetResult<Prisma.$areasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Areas.
     * @param {areasCreateManyArgs} args - Arguments to create many Areas.
     * @example
     * // Create many Areas
     * const areas = await prisma.areas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends areasCreateManyArgs>(args?: SelectSubset<T, areasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Areas and returns the data saved in the database.
     * @param {areasCreateManyAndReturnArgs} args - Arguments to create many Areas.
     * @example
     * // Create many Areas
     * const areas = await prisma.areas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Areas and only return the `id`
     * const areasWithIdOnly = await prisma.areas.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends areasCreateManyAndReturnArgs>(args?: SelectSubset<T, areasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$areasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Areas.
     * @param {areasDeleteArgs} args - Arguments to delete one Areas.
     * @example
     * // Delete one Areas
     * const Areas = await prisma.areas.delete({
     *   where: {
     *     // ... filter to delete one Areas
     *   }
     * })
     * 
     */
    delete<T extends areasDeleteArgs>(args: SelectSubset<T, areasDeleteArgs<ExtArgs>>): Prisma__areasClient<$Result.GetResult<Prisma.$areasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Areas.
     * @param {areasUpdateArgs} args - Arguments to update one Areas.
     * @example
     * // Update one Areas
     * const areas = await prisma.areas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends areasUpdateArgs>(args: SelectSubset<T, areasUpdateArgs<ExtArgs>>): Prisma__areasClient<$Result.GetResult<Prisma.$areasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Areas.
     * @param {areasDeleteManyArgs} args - Arguments to filter Areas to delete.
     * @example
     * // Delete a few Areas
     * const { count } = await prisma.areas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends areasDeleteManyArgs>(args?: SelectSubset<T, areasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {areasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Areas
     * const areas = await prisma.areas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends areasUpdateManyArgs>(args: SelectSubset<T, areasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Areas and returns the data updated in the database.
     * @param {areasUpdateManyAndReturnArgs} args - Arguments to update many Areas.
     * @example
     * // Update many Areas
     * const areas = await prisma.areas.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Areas and only return the `id`
     * const areasWithIdOnly = await prisma.areas.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends areasUpdateManyAndReturnArgs>(args: SelectSubset<T, areasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$areasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Areas.
     * @param {areasUpsertArgs} args - Arguments to update or create a Areas.
     * @example
     * // Update or create a Areas
     * const areas = await prisma.areas.upsert({
     *   create: {
     *     // ... data to create a Areas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Areas we want to update
     *   }
     * })
     */
    upsert<T extends areasUpsertArgs>(args: SelectSubset<T, areasUpsertArgs<ExtArgs>>): Prisma__areasClient<$Result.GetResult<Prisma.$areasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {areasCountArgs} args - Arguments to filter Areas to count.
     * @example
     * // Count the number of Areas
     * const count = await prisma.areas.count({
     *   where: {
     *     // ... the filter for the Areas we want to count
     *   }
     * })
    **/
    count<T extends areasCountArgs>(
      args?: Subset<T, areasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AreasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AreasAggregateArgs>(args: Subset<T, AreasAggregateArgs>): Prisma.PrismaPromise<GetAreasAggregateType<T>>

    /**
     * Group by Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {areasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends areasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: areasGroupByArgs['orderBy'] }
        : { orderBy?: areasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, areasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAreasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the areas model
   */
  readonly fields: areasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for areas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__areasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    capitulos<T extends areas$capitulosArgs<ExtArgs> = {}>(args?: Subset<T, areas$capitulosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$capitulosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    preguntas<T extends areas$preguntasArgs<ExtArgs> = {}>(args?: Subset<T, areas$preguntasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$preguntasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the areas model
   */
  interface areasFieldRefs {
    readonly id: FieldRef<"areas", 'String'>
    readonly titulo: FieldRef<"areas", 'String'>
    readonly descripcion: FieldRef<"areas", 'String'>
    readonly creadoEn: FieldRef<"areas", 'DateTime'>
    readonly actualizadoEn: FieldRef<"areas", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * areas findUnique
   */
  export type areasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the areas
     */
    select?: areasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the areas
     */
    omit?: areasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: areasInclude<ExtArgs> | null
    /**
     * Filter, which areas to fetch.
     */
    where: areasWhereUniqueInput
  }

  /**
   * areas findUniqueOrThrow
   */
  export type areasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the areas
     */
    select?: areasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the areas
     */
    omit?: areasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: areasInclude<ExtArgs> | null
    /**
     * Filter, which areas to fetch.
     */
    where: areasWhereUniqueInput
  }

  /**
   * areas findFirst
   */
  export type areasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the areas
     */
    select?: areasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the areas
     */
    omit?: areasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: areasInclude<ExtArgs> | null
    /**
     * Filter, which areas to fetch.
     */
    where?: areasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of areas to fetch.
     */
    orderBy?: areasOrderByWithRelationInput | areasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for areas.
     */
    cursor?: areasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of areas.
     */
    distinct?: AreasScalarFieldEnum | AreasScalarFieldEnum[]
  }

  /**
   * areas findFirstOrThrow
   */
  export type areasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the areas
     */
    select?: areasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the areas
     */
    omit?: areasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: areasInclude<ExtArgs> | null
    /**
     * Filter, which areas to fetch.
     */
    where?: areasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of areas to fetch.
     */
    orderBy?: areasOrderByWithRelationInput | areasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for areas.
     */
    cursor?: areasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of areas.
     */
    distinct?: AreasScalarFieldEnum | AreasScalarFieldEnum[]
  }

  /**
   * areas findMany
   */
  export type areasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the areas
     */
    select?: areasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the areas
     */
    omit?: areasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: areasInclude<ExtArgs> | null
    /**
     * Filter, which areas to fetch.
     */
    where?: areasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of areas to fetch.
     */
    orderBy?: areasOrderByWithRelationInput | areasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing areas.
     */
    cursor?: areasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` areas.
     */
    skip?: number
    distinct?: AreasScalarFieldEnum | AreasScalarFieldEnum[]
  }

  /**
   * areas create
   */
  export type areasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the areas
     */
    select?: areasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the areas
     */
    omit?: areasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: areasInclude<ExtArgs> | null
    /**
     * The data needed to create a areas.
     */
    data: XOR<areasCreateInput, areasUncheckedCreateInput>
  }

  /**
   * areas createMany
   */
  export type areasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many areas.
     */
    data: areasCreateManyInput | areasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * areas createManyAndReturn
   */
  export type areasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the areas
     */
    select?: areasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the areas
     */
    omit?: areasOmit<ExtArgs> | null
    /**
     * The data used to create many areas.
     */
    data: areasCreateManyInput | areasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * areas update
   */
  export type areasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the areas
     */
    select?: areasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the areas
     */
    omit?: areasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: areasInclude<ExtArgs> | null
    /**
     * The data needed to update a areas.
     */
    data: XOR<areasUpdateInput, areasUncheckedUpdateInput>
    /**
     * Choose, which areas to update.
     */
    where: areasWhereUniqueInput
  }

  /**
   * areas updateMany
   */
  export type areasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update areas.
     */
    data: XOR<areasUpdateManyMutationInput, areasUncheckedUpdateManyInput>
    /**
     * Filter which areas to update
     */
    where?: areasWhereInput
    /**
     * Limit how many areas to update.
     */
    limit?: number
  }

  /**
   * areas updateManyAndReturn
   */
  export type areasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the areas
     */
    select?: areasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the areas
     */
    omit?: areasOmit<ExtArgs> | null
    /**
     * The data used to update areas.
     */
    data: XOR<areasUpdateManyMutationInput, areasUncheckedUpdateManyInput>
    /**
     * Filter which areas to update
     */
    where?: areasWhereInput
    /**
     * Limit how many areas to update.
     */
    limit?: number
  }

  /**
   * areas upsert
   */
  export type areasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the areas
     */
    select?: areasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the areas
     */
    omit?: areasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: areasInclude<ExtArgs> | null
    /**
     * The filter to search for the areas to update in case it exists.
     */
    where: areasWhereUniqueInput
    /**
     * In case the areas found by the `where` argument doesn't exist, create a new areas with this data.
     */
    create: XOR<areasCreateInput, areasUncheckedCreateInput>
    /**
     * In case the areas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<areasUpdateInput, areasUncheckedUpdateInput>
  }

  /**
   * areas delete
   */
  export type areasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the areas
     */
    select?: areasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the areas
     */
    omit?: areasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: areasInclude<ExtArgs> | null
    /**
     * Filter which areas to delete.
     */
    where: areasWhereUniqueInput
  }

  /**
   * areas deleteMany
   */
  export type areasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which areas to delete
     */
    where?: areasWhereInput
    /**
     * Limit how many areas to delete.
     */
    limit?: number
  }

  /**
   * areas.capitulos
   */
  export type areas$capitulosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capitulos
     */
    select?: capitulosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capitulos
     */
    omit?: capitulosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capitulosInclude<ExtArgs> | null
    where?: capitulosWhereInput
    orderBy?: capitulosOrderByWithRelationInput | capitulosOrderByWithRelationInput[]
    cursor?: capitulosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CapitulosScalarFieldEnum | CapitulosScalarFieldEnum[]
  }

  /**
   * areas.preguntas
   */
  export type areas$preguntasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preguntas
     */
    select?: preguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preguntas
     */
    omit?: preguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preguntasInclude<ExtArgs> | null
    where?: preguntasWhereInput
    orderBy?: preguntasOrderByWithRelationInput | preguntasOrderByWithRelationInput[]
    cursor?: preguntasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreguntasScalarFieldEnum | PreguntasScalarFieldEnum[]
  }

  /**
   * areas without action
   */
  export type areasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the areas
     */
    select?: areasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the areas
     */
    omit?: areasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: areasInclude<ExtArgs> | null
  }


  /**
   * Model banqueo
   */

  export type AggregateBanqueo = {
    _count: BanqueoCountAggregateOutputType | null
    _avg: BanqueoAvgAggregateOutputType | null
    _sum: BanqueoSumAggregateOutputType | null
    _min: BanqueoMinAggregateOutputType | null
    _max: BanqueoMaxAggregateOutputType | null
  }

  export type BanqueoAvgAggregateOutputType = {
    duracion: number | null
    maxPreguntas: number | null
  }

  export type BanqueoSumAggregateOutputType = {
    duracion: number | null
    maxPreguntas: number | null
  }

  export type BanqueoMinAggregateOutputType = {
    id: string | null
    titulo: string | null
    tipo: $Enums.BanqueoTipo | null
    tipoCreado: $Enums.BanqueoTipoCreado | null
    duracion: number | null
    maxPreguntas: number | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type BanqueoMaxAggregateOutputType = {
    id: string | null
    titulo: string | null
    tipo: $Enums.BanqueoTipo | null
    tipoCreado: $Enums.BanqueoTipoCreado | null
    duracion: number | null
    maxPreguntas: number | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type BanqueoCountAggregateOutputType = {
    id: number
    titulo: number
    tipo: number
    tipoCreado: number
    duracion: number
    maxPreguntas: number
    creadoEn: number
    actualizadoEn: number
    _all: number
  }


  export type BanqueoAvgAggregateInputType = {
    duracion?: true
    maxPreguntas?: true
  }

  export type BanqueoSumAggregateInputType = {
    duracion?: true
    maxPreguntas?: true
  }

  export type BanqueoMinAggregateInputType = {
    id?: true
    titulo?: true
    tipo?: true
    tipoCreado?: true
    duracion?: true
    maxPreguntas?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type BanqueoMaxAggregateInputType = {
    id?: true
    titulo?: true
    tipo?: true
    tipoCreado?: true
    duracion?: true
    maxPreguntas?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type BanqueoCountAggregateInputType = {
    id?: true
    titulo?: true
    tipo?: true
    tipoCreado?: true
    duracion?: true
    maxPreguntas?: true
    creadoEn?: true
    actualizadoEn?: true
    _all?: true
  }

  export type BanqueoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which banqueo to aggregate.
     */
    where?: banqueoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banqueos to fetch.
     */
    orderBy?: banqueoOrderByWithRelationInput | banqueoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: banqueoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banqueos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banqueos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned banqueos
    **/
    _count?: true | BanqueoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BanqueoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BanqueoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BanqueoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BanqueoMaxAggregateInputType
  }

  export type GetBanqueoAggregateType<T extends BanqueoAggregateArgs> = {
        [P in keyof T & keyof AggregateBanqueo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanqueo[P]>
      : GetScalarType<T[P], AggregateBanqueo[P]>
  }




  export type banqueoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: banqueoWhereInput
    orderBy?: banqueoOrderByWithAggregationInput | banqueoOrderByWithAggregationInput[]
    by: BanqueoScalarFieldEnum[] | BanqueoScalarFieldEnum
    having?: banqueoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BanqueoCountAggregateInputType | true
    _avg?: BanqueoAvgAggregateInputType
    _sum?: BanqueoSumAggregateInputType
    _min?: BanqueoMinAggregateInputType
    _max?: BanqueoMaxAggregateInputType
  }

  export type BanqueoGroupByOutputType = {
    id: string
    titulo: string
    tipo: $Enums.BanqueoTipo
    tipoCreado: $Enums.BanqueoTipoCreado
    duracion: number
    maxPreguntas: number
    creadoEn: Date
    actualizadoEn: Date
    _count: BanqueoCountAggregateOutputType | null
    _avg: BanqueoAvgAggregateOutputType | null
    _sum: BanqueoSumAggregateOutputType | null
    _min: BanqueoMinAggregateOutputType | null
    _max: BanqueoMaxAggregateOutputType | null
  }

  type GetBanqueoGroupByPayload<T extends banqueoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BanqueoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BanqueoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BanqueoGroupByOutputType[P]>
            : GetScalarType<T[P], BanqueoGroupByOutputType[P]>
        }
      >
    >


  export type banqueoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    tipo?: boolean
    tipoCreado?: boolean
    duracion?: boolean
    maxPreguntas?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    intentos?: boolean | banqueo$intentosArgs<ExtArgs>
    repasoRegistros?: boolean | banqueo$repasoRegistrosArgs<ExtArgs>
    preguntas?: boolean | banqueo$preguntasArgs<ExtArgs>
    _count?: boolean | BanqueoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["banqueo"]>

  export type banqueoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    tipo?: boolean
    tipoCreado?: boolean
    duracion?: boolean
    maxPreguntas?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }, ExtArgs["result"]["banqueo"]>

  export type banqueoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    tipo?: boolean
    tipoCreado?: boolean
    duracion?: boolean
    maxPreguntas?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }, ExtArgs["result"]["banqueo"]>

  export type banqueoSelectScalar = {
    id?: boolean
    titulo?: boolean
    tipo?: boolean
    tipoCreado?: boolean
    duracion?: boolean
    maxPreguntas?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }

  export type banqueoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "titulo" | "tipo" | "tipoCreado" | "duracion" | "maxPreguntas" | "creadoEn" | "actualizadoEn", ExtArgs["result"]["banqueo"]>
  export type banqueoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    intentos?: boolean | banqueo$intentosArgs<ExtArgs>
    repasoRegistros?: boolean | banqueo$repasoRegistrosArgs<ExtArgs>
    preguntas?: boolean | banqueo$preguntasArgs<ExtArgs>
    _count?: boolean | BanqueoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type banqueoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type banqueoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $banqueoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "banqueo"
    objects: {
      intentos: Prisma.$intentosPayload<ExtArgs>[]
      repasoRegistros: Prisma.$repasoRegistrosPayload<ExtArgs>[]
      preguntas: Prisma.$preguntasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      titulo: string
      tipo: $Enums.BanqueoTipo
      tipoCreado: $Enums.BanqueoTipoCreado
      duracion: number
      maxPreguntas: number
      creadoEn: Date
      actualizadoEn: Date
    }, ExtArgs["result"]["banqueo"]>
    composites: {}
  }

  type banqueoGetPayload<S extends boolean | null | undefined | banqueoDefaultArgs> = $Result.GetResult<Prisma.$banqueoPayload, S>

  type banqueoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<banqueoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BanqueoCountAggregateInputType | true
    }

  export interface banqueoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['banqueo'], meta: { name: 'banqueo' } }
    /**
     * Find zero or one Banqueo that matches the filter.
     * @param {banqueoFindUniqueArgs} args - Arguments to find a Banqueo
     * @example
     * // Get one Banqueo
     * const banqueo = await prisma.banqueo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends banqueoFindUniqueArgs>(args: SelectSubset<T, banqueoFindUniqueArgs<ExtArgs>>): Prisma__banqueoClient<$Result.GetResult<Prisma.$banqueoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Banqueo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {banqueoFindUniqueOrThrowArgs} args - Arguments to find a Banqueo
     * @example
     * // Get one Banqueo
     * const banqueo = await prisma.banqueo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends banqueoFindUniqueOrThrowArgs>(args: SelectSubset<T, banqueoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__banqueoClient<$Result.GetResult<Prisma.$banqueoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Banqueo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banqueoFindFirstArgs} args - Arguments to find a Banqueo
     * @example
     * // Get one Banqueo
     * const banqueo = await prisma.banqueo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends banqueoFindFirstArgs>(args?: SelectSubset<T, banqueoFindFirstArgs<ExtArgs>>): Prisma__banqueoClient<$Result.GetResult<Prisma.$banqueoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Banqueo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banqueoFindFirstOrThrowArgs} args - Arguments to find a Banqueo
     * @example
     * // Get one Banqueo
     * const banqueo = await prisma.banqueo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends banqueoFindFirstOrThrowArgs>(args?: SelectSubset<T, banqueoFindFirstOrThrowArgs<ExtArgs>>): Prisma__banqueoClient<$Result.GetResult<Prisma.$banqueoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Banqueos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banqueoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banqueos
     * const banqueos = await prisma.banqueo.findMany()
     * 
     * // Get first 10 Banqueos
     * const banqueos = await prisma.banqueo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const banqueoWithIdOnly = await prisma.banqueo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends banqueoFindManyArgs>(args?: SelectSubset<T, banqueoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$banqueoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Banqueo.
     * @param {banqueoCreateArgs} args - Arguments to create a Banqueo.
     * @example
     * // Create one Banqueo
     * const Banqueo = await prisma.banqueo.create({
     *   data: {
     *     // ... data to create a Banqueo
     *   }
     * })
     * 
     */
    create<T extends banqueoCreateArgs>(args: SelectSubset<T, banqueoCreateArgs<ExtArgs>>): Prisma__banqueoClient<$Result.GetResult<Prisma.$banqueoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Banqueos.
     * @param {banqueoCreateManyArgs} args - Arguments to create many Banqueos.
     * @example
     * // Create many Banqueos
     * const banqueo = await prisma.banqueo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends banqueoCreateManyArgs>(args?: SelectSubset<T, banqueoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Banqueos and returns the data saved in the database.
     * @param {banqueoCreateManyAndReturnArgs} args - Arguments to create many Banqueos.
     * @example
     * // Create many Banqueos
     * const banqueo = await prisma.banqueo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Banqueos and only return the `id`
     * const banqueoWithIdOnly = await prisma.banqueo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends banqueoCreateManyAndReturnArgs>(args?: SelectSubset<T, banqueoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$banqueoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Banqueo.
     * @param {banqueoDeleteArgs} args - Arguments to delete one Banqueo.
     * @example
     * // Delete one Banqueo
     * const Banqueo = await prisma.banqueo.delete({
     *   where: {
     *     // ... filter to delete one Banqueo
     *   }
     * })
     * 
     */
    delete<T extends banqueoDeleteArgs>(args: SelectSubset<T, banqueoDeleteArgs<ExtArgs>>): Prisma__banqueoClient<$Result.GetResult<Prisma.$banqueoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Banqueo.
     * @param {banqueoUpdateArgs} args - Arguments to update one Banqueo.
     * @example
     * // Update one Banqueo
     * const banqueo = await prisma.banqueo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends banqueoUpdateArgs>(args: SelectSubset<T, banqueoUpdateArgs<ExtArgs>>): Prisma__banqueoClient<$Result.GetResult<Prisma.$banqueoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Banqueos.
     * @param {banqueoDeleteManyArgs} args - Arguments to filter Banqueos to delete.
     * @example
     * // Delete a few Banqueos
     * const { count } = await prisma.banqueo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends banqueoDeleteManyArgs>(args?: SelectSubset<T, banqueoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banqueos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banqueoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banqueos
     * const banqueo = await prisma.banqueo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends banqueoUpdateManyArgs>(args: SelectSubset<T, banqueoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banqueos and returns the data updated in the database.
     * @param {banqueoUpdateManyAndReturnArgs} args - Arguments to update many Banqueos.
     * @example
     * // Update many Banqueos
     * const banqueo = await prisma.banqueo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Banqueos and only return the `id`
     * const banqueoWithIdOnly = await prisma.banqueo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends banqueoUpdateManyAndReturnArgs>(args: SelectSubset<T, banqueoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$banqueoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Banqueo.
     * @param {banqueoUpsertArgs} args - Arguments to update or create a Banqueo.
     * @example
     * // Update or create a Banqueo
     * const banqueo = await prisma.banqueo.upsert({
     *   create: {
     *     // ... data to create a Banqueo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banqueo we want to update
     *   }
     * })
     */
    upsert<T extends banqueoUpsertArgs>(args: SelectSubset<T, banqueoUpsertArgs<ExtArgs>>): Prisma__banqueoClient<$Result.GetResult<Prisma.$banqueoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Banqueos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banqueoCountArgs} args - Arguments to filter Banqueos to count.
     * @example
     * // Count the number of Banqueos
     * const count = await prisma.banqueo.count({
     *   where: {
     *     // ... the filter for the Banqueos we want to count
     *   }
     * })
    **/
    count<T extends banqueoCountArgs>(
      args?: Subset<T, banqueoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BanqueoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banqueo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanqueoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BanqueoAggregateArgs>(args: Subset<T, BanqueoAggregateArgs>): Prisma.PrismaPromise<GetBanqueoAggregateType<T>>

    /**
     * Group by Banqueo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {banqueoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends banqueoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: banqueoGroupByArgs['orderBy'] }
        : { orderBy?: banqueoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, banqueoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBanqueoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the banqueo model
   */
  readonly fields: banqueoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for banqueo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__banqueoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    intentos<T extends banqueo$intentosArgs<ExtArgs> = {}>(args?: Subset<T, banqueo$intentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$intentosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    repasoRegistros<T extends banqueo$repasoRegistrosArgs<ExtArgs> = {}>(args?: Subset<T, banqueo$repasoRegistrosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$repasoRegistrosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    preguntas<T extends banqueo$preguntasArgs<ExtArgs> = {}>(args?: Subset<T, banqueo$preguntasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$preguntasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the banqueo model
   */
  interface banqueoFieldRefs {
    readonly id: FieldRef<"banqueo", 'String'>
    readonly titulo: FieldRef<"banqueo", 'String'>
    readonly tipo: FieldRef<"banqueo", 'BanqueoTipo'>
    readonly tipoCreado: FieldRef<"banqueo", 'BanqueoTipoCreado'>
    readonly duracion: FieldRef<"banqueo", 'Int'>
    readonly maxPreguntas: FieldRef<"banqueo", 'Int'>
    readonly creadoEn: FieldRef<"banqueo", 'DateTime'>
    readonly actualizadoEn: FieldRef<"banqueo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * banqueo findUnique
   */
  export type banqueoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banqueo
     */
    select?: banqueoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banqueo
     */
    omit?: banqueoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banqueoInclude<ExtArgs> | null
    /**
     * Filter, which banqueo to fetch.
     */
    where: banqueoWhereUniqueInput
  }

  /**
   * banqueo findUniqueOrThrow
   */
  export type banqueoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banqueo
     */
    select?: banqueoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banqueo
     */
    omit?: banqueoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banqueoInclude<ExtArgs> | null
    /**
     * Filter, which banqueo to fetch.
     */
    where: banqueoWhereUniqueInput
  }

  /**
   * banqueo findFirst
   */
  export type banqueoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banqueo
     */
    select?: banqueoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banqueo
     */
    omit?: banqueoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banqueoInclude<ExtArgs> | null
    /**
     * Filter, which banqueo to fetch.
     */
    where?: banqueoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banqueos to fetch.
     */
    orderBy?: banqueoOrderByWithRelationInput | banqueoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banqueos.
     */
    cursor?: banqueoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banqueos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banqueos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banqueos.
     */
    distinct?: BanqueoScalarFieldEnum | BanqueoScalarFieldEnum[]
  }

  /**
   * banqueo findFirstOrThrow
   */
  export type banqueoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banqueo
     */
    select?: banqueoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banqueo
     */
    omit?: banqueoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banqueoInclude<ExtArgs> | null
    /**
     * Filter, which banqueo to fetch.
     */
    where?: banqueoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banqueos to fetch.
     */
    orderBy?: banqueoOrderByWithRelationInput | banqueoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banqueos.
     */
    cursor?: banqueoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banqueos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banqueos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banqueos.
     */
    distinct?: BanqueoScalarFieldEnum | BanqueoScalarFieldEnum[]
  }

  /**
   * banqueo findMany
   */
  export type banqueoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banqueo
     */
    select?: banqueoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banqueo
     */
    omit?: banqueoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banqueoInclude<ExtArgs> | null
    /**
     * Filter, which banqueos to fetch.
     */
    where?: banqueoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banqueos to fetch.
     */
    orderBy?: banqueoOrderByWithRelationInput | banqueoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing banqueos.
     */
    cursor?: banqueoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banqueos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banqueos.
     */
    skip?: number
    distinct?: BanqueoScalarFieldEnum | BanqueoScalarFieldEnum[]
  }

  /**
   * banqueo create
   */
  export type banqueoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banqueo
     */
    select?: banqueoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banqueo
     */
    omit?: banqueoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banqueoInclude<ExtArgs> | null
    /**
     * The data needed to create a banqueo.
     */
    data: XOR<banqueoCreateInput, banqueoUncheckedCreateInput>
  }

  /**
   * banqueo createMany
   */
  export type banqueoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many banqueos.
     */
    data: banqueoCreateManyInput | banqueoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * banqueo createManyAndReturn
   */
  export type banqueoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banqueo
     */
    select?: banqueoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the banqueo
     */
    omit?: banqueoOmit<ExtArgs> | null
    /**
     * The data used to create many banqueos.
     */
    data: banqueoCreateManyInput | banqueoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * banqueo update
   */
  export type banqueoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banqueo
     */
    select?: banqueoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banqueo
     */
    omit?: banqueoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banqueoInclude<ExtArgs> | null
    /**
     * The data needed to update a banqueo.
     */
    data: XOR<banqueoUpdateInput, banqueoUncheckedUpdateInput>
    /**
     * Choose, which banqueo to update.
     */
    where: banqueoWhereUniqueInput
  }

  /**
   * banqueo updateMany
   */
  export type banqueoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update banqueos.
     */
    data: XOR<banqueoUpdateManyMutationInput, banqueoUncheckedUpdateManyInput>
    /**
     * Filter which banqueos to update
     */
    where?: banqueoWhereInput
    /**
     * Limit how many banqueos to update.
     */
    limit?: number
  }

  /**
   * banqueo updateManyAndReturn
   */
  export type banqueoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banqueo
     */
    select?: banqueoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the banqueo
     */
    omit?: banqueoOmit<ExtArgs> | null
    /**
     * The data used to update banqueos.
     */
    data: XOR<banqueoUpdateManyMutationInput, banqueoUncheckedUpdateManyInput>
    /**
     * Filter which banqueos to update
     */
    where?: banqueoWhereInput
    /**
     * Limit how many banqueos to update.
     */
    limit?: number
  }

  /**
   * banqueo upsert
   */
  export type banqueoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banqueo
     */
    select?: banqueoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banqueo
     */
    omit?: banqueoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banqueoInclude<ExtArgs> | null
    /**
     * The filter to search for the banqueo to update in case it exists.
     */
    where: banqueoWhereUniqueInput
    /**
     * In case the banqueo found by the `where` argument doesn't exist, create a new banqueo with this data.
     */
    create: XOR<banqueoCreateInput, banqueoUncheckedCreateInput>
    /**
     * In case the banqueo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<banqueoUpdateInput, banqueoUncheckedUpdateInput>
  }

  /**
   * banqueo delete
   */
  export type banqueoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banqueo
     */
    select?: banqueoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banqueo
     */
    omit?: banqueoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banqueoInclude<ExtArgs> | null
    /**
     * Filter which banqueo to delete.
     */
    where: banqueoWhereUniqueInput
  }

  /**
   * banqueo deleteMany
   */
  export type banqueoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which banqueos to delete
     */
    where?: banqueoWhereInput
    /**
     * Limit how many banqueos to delete.
     */
    limit?: number
  }

  /**
   * banqueo.intentos
   */
  export type banqueo$intentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intentos
     */
    select?: intentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the intentos
     */
    omit?: intentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intentosInclude<ExtArgs> | null
    where?: intentosWhereInput
    orderBy?: intentosOrderByWithRelationInput | intentosOrderByWithRelationInput[]
    cursor?: intentosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntentosScalarFieldEnum | IntentosScalarFieldEnum[]
  }

  /**
   * banqueo.repasoRegistros
   */
  export type banqueo$repasoRegistrosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repasoRegistros
     */
    select?: repasoRegistrosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repasoRegistros
     */
    omit?: repasoRegistrosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: repasoRegistrosInclude<ExtArgs> | null
    where?: repasoRegistrosWhereInput
    orderBy?: repasoRegistrosOrderByWithRelationInput | repasoRegistrosOrderByWithRelationInput[]
    cursor?: repasoRegistrosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RepasoRegistrosScalarFieldEnum | RepasoRegistrosScalarFieldEnum[]
  }

  /**
   * banqueo.preguntas
   */
  export type banqueo$preguntasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preguntas
     */
    select?: preguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preguntas
     */
    omit?: preguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preguntasInclude<ExtArgs> | null
    where?: preguntasWhereInput
    orderBy?: preguntasOrderByWithRelationInput | preguntasOrderByWithRelationInput[]
    cursor?: preguntasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreguntasScalarFieldEnum | PreguntasScalarFieldEnum[]
  }

  /**
   * banqueo without action
   */
  export type banqueoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banqueo
     */
    select?: banqueoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the banqueo
     */
    omit?: banqueoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: banqueoInclude<ExtArgs> | null
  }


  /**
   * Model capitulos
   */

  export type AggregateCapitulos = {
    _count: CapitulosCountAggregateOutputType | null
    _min: CapitulosMinAggregateOutputType | null
    _max: CapitulosMaxAggregateOutputType | null
  }

  export type CapitulosMinAggregateOutputType = {
    id: string | null
    titulo: string | null
    descripcion: string | null
    areaId: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type CapitulosMaxAggregateOutputType = {
    id: string | null
    titulo: string | null
    descripcion: string | null
    areaId: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type CapitulosCountAggregateOutputType = {
    id: number
    titulo: number
    descripcion: number
    areaId: number
    creadoEn: number
    actualizadoEn: number
    _all: number
  }


  export type CapitulosMinAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    areaId?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type CapitulosMaxAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    areaId?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type CapitulosCountAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    areaId?: true
    creadoEn?: true
    actualizadoEn?: true
    _all?: true
  }

  export type CapitulosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which capitulos to aggregate.
     */
    where?: capitulosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capitulos to fetch.
     */
    orderBy?: capitulosOrderByWithRelationInput | capitulosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: capitulosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capitulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capitulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned capitulos
    **/
    _count?: true | CapitulosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CapitulosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CapitulosMaxAggregateInputType
  }

  export type GetCapitulosAggregateType<T extends CapitulosAggregateArgs> = {
        [P in keyof T & keyof AggregateCapitulos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCapitulos[P]>
      : GetScalarType<T[P], AggregateCapitulos[P]>
  }




  export type capitulosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: capitulosWhereInput
    orderBy?: capitulosOrderByWithAggregationInput | capitulosOrderByWithAggregationInput[]
    by: CapitulosScalarFieldEnum[] | CapitulosScalarFieldEnum
    having?: capitulosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CapitulosCountAggregateInputType | true
    _min?: CapitulosMinAggregateInputType
    _max?: CapitulosMaxAggregateInputType
  }

  export type CapitulosGroupByOutputType = {
    id: string
    titulo: string
    descripcion: string | null
    areaId: string | null
    creadoEn: Date
    actualizadoEn: Date
    _count: CapitulosCountAggregateOutputType | null
    _min: CapitulosMinAggregateOutputType | null
    _max: CapitulosMaxAggregateOutputType | null
  }

  type GetCapitulosGroupByPayload<T extends capitulosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CapitulosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CapitulosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CapitulosGroupByOutputType[P]>
            : GetScalarType<T[P], CapitulosGroupByOutputType[P]>
        }
      >
    >


  export type capitulosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    areaId?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    areas?: boolean | capitulos$areasArgs<ExtArgs>
    temas?: boolean | capitulos$temasArgs<ExtArgs>
    preguntas?: boolean | capitulos$preguntasArgs<ExtArgs>
    _count?: boolean | CapitulosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["capitulos"]>

  export type capitulosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    areaId?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    areas?: boolean | capitulos$areasArgs<ExtArgs>
  }, ExtArgs["result"]["capitulos"]>

  export type capitulosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    areaId?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    areas?: boolean | capitulos$areasArgs<ExtArgs>
  }, ExtArgs["result"]["capitulos"]>

  export type capitulosSelectScalar = {
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    areaId?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }

  export type capitulosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "titulo" | "descripcion" | "areaId" | "creadoEn" | "actualizadoEn", ExtArgs["result"]["capitulos"]>
  export type capitulosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    areas?: boolean | capitulos$areasArgs<ExtArgs>
    temas?: boolean | capitulos$temasArgs<ExtArgs>
    preguntas?: boolean | capitulos$preguntasArgs<ExtArgs>
    _count?: boolean | CapitulosCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type capitulosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    areas?: boolean | capitulos$areasArgs<ExtArgs>
  }
  export type capitulosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    areas?: boolean | capitulos$areasArgs<ExtArgs>
  }

  export type $capitulosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "capitulos"
    objects: {
      areas: Prisma.$areasPayload<ExtArgs> | null
      temas: Prisma.$temasPayload<ExtArgs>[]
      preguntas: Prisma.$preguntasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      titulo: string
      descripcion: string | null
      areaId: string | null
      creadoEn: Date
      actualizadoEn: Date
    }, ExtArgs["result"]["capitulos"]>
    composites: {}
  }

  type capitulosGetPayload<S extends boolean | null | undefined | capitulosDefaultArgs> = $Result.GetResult<Prisma.$capitulosPayload, S>

  type capitulosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<capitulosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CapitulosCountAggregateInputType | true
    }

  export interface capitulosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['capitulos'], meta: { name: 'capitulos' } }
    /**
     * Find zero or one Capitulos that matches the filter.
     * @param {capitulosFindUniqueArgs} args - Arguments to find a Capitulos
     * @example
     * // Get one Capitulos
     * const capitulos = await prisma.capitulos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends capitulosFindUniqueArgs>(args: SelectSubset<T, capitulosFindUniqueArgs<ExtArgs>>): Prisma__capitulosClient<$Result.GetResult<Prisma.$capitulosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Capitulos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {capitulosFindUniqueOrThrowArgs} args - Arguments to find a Capitulos
     * @example
     * // Get one Capitulos
     * const capitulos = await prisma.capitulos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends capitulosFindUniqueOrThrowArgs>(args: SelectSubset<T, capitulosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__capitulosClient<$Result.GetResult<Prisma.$capitulosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Capitulos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capitulosFindFirstArgs} args - Arguments to find a Capitulos
     * @example
     * // Get one Capitulos
     * const capitulos = await prisma.capitulos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends capitulosFindFirstArgs>(args?: SelectSubset<T, capitulosFindFirstArgs<ExtArgs>>): Prisma__capitulosClient<$Result.GetResult<Prisma.$capitulosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Capitulos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capitulosFindFirstOrThrowArgs} args - Arguments to find a Capitulos
     * @example
     * // Get one Capitulos
     * const capitulos = await prisma.capitulos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends capitulosFindFirstOrThrowArgs>(args?: SelectSubset<T, capitulosFindFirstOrThrowArgs<ExtArgs>>): Prisma__capitulosClient<$Result.GetResult<Prisma.$capitulosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Capitulos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capitulosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Capitulos
     * const capitulos = await prisma.capitulos.findMany()
     * 
     * // Get first 10 Capitulos
     * const capitulos = await prisma.capitulos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const capitulosWithIdOnly = await prisma.capitulos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends capitulosFindManyArgs>(args?: SelectSubset<T, capitulosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$capitulosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Capitulos.
     * @param {capitulosCreateArgs} args - Arguments to create a Capitulos.
     * @example
     * // Create one Capitulos
     * const Capitulos = await prisma.capitulos.create({
     *   data: {
     *     // ... data to create a Capitulos
     *   }
     * })
     * 
     */
    create<T extends capitulosCreateArgs>(args: SelectSubset<T, capitulosCreateArgs<ExtArgs>>): Prisma__capitulosClient<$Result.GetResult<Prisma.$capitulosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Capitulos.
     * @param {capitulosCreateManyArgs} args - Arguments to create many Capitulos.
     * @example
     * // Create many Capitulos
     * const capitulos = await prisma.capitulos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends capitulosCreateManyArgs>(args?: SelectSubset<T, capitulosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Capitulos and returns the data saved in the database.
     * @param {capitulosCreateManyAndReturnArgs} args - Arguments to create many Capitulos.
     * @example
     * // Create many Capitulos
     * const capitulos = await prisma.capitulos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Capitulos and only return the `id`
     * const capitulosWithIdOnly = await prisma.capitulos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends capitulosCreateManyAndReturnArgs>(args?: SelectSubset<T, capitulosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$capitulosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Capitulos.
     * @param {capitulosDeleteArgs} args - Arguments to delete one Capitulos.
     * @example
     * // Delete one Capitulos
     * const Capitulos = await prisma.capitulos.delete({
     *   where: {
     *     // ... filter to delete one Capitulos
     *   }
     * })
     * 
     */
    delete<T extends capitulosDeleteArgs>(args: SelectSubset<T, capitulosDeleteArgs<ExtArgs>>): Prisma__capitulosClient<$Result.GetResult<Prisma.$capitulosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Capitulos.
     * @param {capitulosUpdateArgs} args - Arguments to update one Capitulos.
     * @example
     * // Update one Capitulos
     * const capitulos = await prisma.capitulos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends capitulosUpdateArgs>(args: SelectSubset<T, capitulosUpdateArgs<ExtArgs>>): Prisma__capitulosClient<$Result.GetResult<Prisma.$capitulosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Capitulos.
     * @param {capitulosDeleteManyArgs} args - Arguments to filter Capitulos to delete.
     * @example
     * // Delete a few Capitulos
     * const { count } = await prisma.capitulos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends capitulosDeleteManyArgs>(args?: SelectSubset<T, capitulosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Capitulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capitulosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Capitulos
     * const capitulos = await prisma.capitulos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends capitulosUpdateManyArgs>(args: SelectSubset<T, capitulosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Capitulos and returns the data updated in the database.
     * @param {capitulosUpdateManyAndReturnArgs} args - Arguments to update many Capitulos.
     * @example
     * // Update many Capitulos
     * const capitulos = await prisma.capitulos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Capitulos and only return the `id`
     * const capitulosWithIdOnly = await prisma.capitulos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends capitulosUpdateManyAndReturnArgs>(args: SelectSubset<T, capitulosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$capitulosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Capitulos.
     * @param {capitulosUpsertArgs} args - Arguments to update or create a Capitulos.
     * @example
     * // Update or create a Capitulos
     * const capitulos = await prisma.capitulos.upsert({
     *   create: {
     *     // ... data to create a Capitulos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Capitulos we want to update
     *   }
     * })
     */
    upsert<T extends capitulosUpsertArgs>(args: SelectSubset<T, capitulosUpsertArgs<ExtArgs>>): Prisma__capitulosClient<$Result.GetResult<Prisma.$capitulosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Capitulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capitulosCountArgs} args - Arguments to filter Capitulos to count.
     * @example
     * // Count the number of Capitulos
     * const count = await prisma.capitulos.count({
     *   where: {
     *     // ... the filter for the Capitulos we want to count
     *   }
     * })
    **/
    count<T extends capitulosCountArgs>(
      args?: Subset<T, capitulosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CapitulosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Capitulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapitulosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CapitulosAggregateArgs>(args: Subset<T, CapitulosAggregateArgs>): Prisma.PrismaPromise<GetCapitulosAggregateType<T>>

    /**
     * Group by Capitulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {capitulosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends capitulosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: capitulosGroupByArgs['orderBy'] }
        : { orderBy?: capitulosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, capitulosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCapitulosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the capitulos model
   */
  readonly fields: capitulosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for capitulos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__capitulosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    areas<T extends capitulos$areasArgs<ExtArgs> = {}>(args?: Subset<T, capitulos$areasArgs<ExtArgs>>): Prisma__areasClient<$Result.GetResult<Prisma.$areasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    temas<T extends capitulos$temasArgs<ExtArgs> = {}>(args?: Subset<T, capitulos$temasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$temasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    preguntas<T extends capitulos$preguntasArgs<ExtArgs> = {}>(args?: Subset<T, capitulos$preguntasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$preguntasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the capitulos model
   */
  interface capitulosFieldRefs {
    readonly id: FieldRef<"capitulos", 'String'>
    readonly titulo: FieldRef<"capitulos", 'String'>
    readonly descripcion: FieldRef<"capitulos", 'String'>
    readonly areaId: FieldRef<"capitulos", 'String'>
    readonly creadoEn: FieldRef<"capitulos", 'DateTime'>
    readonly actualizadoEn: FieldRef<"capitulos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * capitulos findUnique
   */
  export type capitulosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capitulos
     */
    select?: capitulosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capitulos
     */
    omit?: capitulosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capitulosInclude<ExtArgs> | null
    /**
     * Filter, which capitulos to fetch.
     */
    where: capitulosWhereUniqueInput
  }

  /**
   * capitulos findUniqueOrThrow
   */
  export type capitulosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capitulos
     */
    select?: capitulosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capitulos
     */
    omit?: capitulosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capitulosInclude<ExtArgs> | null
    /**
     * Filter, which capitulos to fetch.
     */
    where: capitulosWhereUniqueInput
  }

  /**
   * capitulos findFirst
   */
  export type capitulosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capitulos
     */
    select?: capitulosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capitulos
     */
    omit?: capitulosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capitulosInclude<ExtArgs> | null
    /**
     * Filter, which capitulos to fetch.
     */
    where?: capitulosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capitulos to fetch.
     */
    orderBy?: capitulosOrderByWithRelationInput | capitulosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for capitulos.
     */
    cursor?: capitulosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capitulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capitulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of capitulos.
     */
    distinct?: CapitulosScalarFieldEnum | CapitulosScalarFieldEnum[]
  }

  /**
   * capitulos findFirstOrThrow
   */
  export type capitulosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capitulos
     */
    select?: capitulosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capitulos
     */
    omit?: capitulosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capitulosInclude<ExtArgs> | null
    /**
     * Filter, which capitulos to fetch.
     */
    where?: capitulosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capitulos to fetch.
     */
    orderBy?: capitulosOrderByWithRelationInput | capitulosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for capitulos.
     */
    cursor?: capitulosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capitulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capitulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of capitulos.
     */
    distinct?: CapitulosScalarFieldEnum | CapitulosScalarFieldEnum[]
  }

  /**
   * capitulos findMany
   */
  export type capitulosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capitulos
     */
    select?: capitulosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capitulos
     */
    omit?: capitulosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capitulosInclude<ExtArgs> | null
    /**
     * Filter, which capitulos to fetch.
     */
    where?: capitulosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of capitulos to fetch.
     */
    orderBy?: capitulosOrderByWithRelationInput | capitulosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing capitulos.
     */
    cursor?: capitulosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` capitulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` capitulos.
     */
    skip?: number
    distinct?: CapitulosScalarFieldEnum | CapitulosScalarFieldEnum[]
  }

  /**
   * capitulos create
   */
  export type capitulosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capitulos
     */
    select?: capitulosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capitulos
     */
    omit?: capitulosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capitulosInclude<ExtArgs> | null
    /**
     * The data needed to create a capitulos.
     */
    data: XOR<capitulosCreateInput, capitulosUncheckedCreateInput>
  }

  /**
   * capitulos createMany
   */
  export type capitulosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many capitulos.
     */
    data: capitulosCreateManyInput | capitulosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * capitulos createManyAndReturn
   */
  export type capitulosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capitulos
     */
    select?: capitulosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the capitulos
     */
    omit?: capitulosOmit<ExtArgs> | null
    /**
     * The data used to create many capitulos.
     */
    data: capitulosCreateManyInput | capitulosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capitulosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * capitulos update
   */
  export type capitulosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capitulos
     */
    select?: capitulosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capitulos
     */
    omit?: capitulosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capitulosInclude<ExtArgs> | null
    /**
     * The data needed to update a capitulos.
     */
    data: XOR<capitulosUpdateInput, capitulosUncheckedUpdateInput>
    /**
     * Choose, which capitulos to update.
     */
    where: capitulosWhereUniqueInput
  }

  /**
   * capitulos updateMany
   */
  export type capitulosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update capitulos.
     */
    data: XOR<capitulosUpdateManyMutationInput, capitulosUncheckedUpdateManyInput>
    /**
     * Filter which capitulos to update
     */
    where?: capitulosWhereInput
    /**
     * Limit how many capitulos to update.
     */
    limit?: number
  }

  /**
   * capitulos updateManyAndReturn
   */
  export type capitulosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capitulos
     */
    select?: capitulosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the capitulos
     */
    omit?: capitulosOmit<ExtArgs> | null
    /**
     * The data used to update capitulos.
     */
    data: XOR<capitulosUpdateManyMutationInput, capitulosUncheckedUpdateManyInput>
    /**
     * Filter which capitulos to update
     */
    where?: capitulosWhereInput
    /**
     * Limit how many capitulos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capitulosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * capitulos upsert
   */
  export type capitulosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capitulos
     */
    select?: capitulosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capitulos
     */
    omit?: capitulosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capitulosInclude<ExtArgs> | null
    /**
     * The filter to search for the capitulos to update in case it exists.
     */
    where: capitulosWhereUniqueInput
    /**
     * In case the capitulos found by the `where` argument doesn't exist, create a new capitulos with this data.
     */
    create: XOR<capitulosCreateInput, capitulosUncheckedCreateInput>
    /**
     * In case the capitulos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<capitulosUpdateInput, capitulosUncheckedUpdateInput>
  }

  /**
   * capitulos delete
   */
  export type capitulosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capitulos
     */
    select?: capitulosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capitulos
     */
    omit?: capitulosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capitulosInclude<ExtArgs> | null
    /**
     * Filter which capitulos to delete.
     */
    where: capitulosWhereUniqueInput
  }

  /**
   * capitulos deleteMany
   */
  export type capitulosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which capitulos to delete
     */
    where?: capitulosWhereInput
    /**
     * Limit how many capitulos to delete.
     */
    limit?: number
  }

  /**
   * capitulos.areas
   */
  export type capitulos$areasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the areas
     */
    select?: areasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the areas
     */
    omit?: areasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: areasInclude<ExtArgs> | null
    where?: areasWhereInput
  }

  /**
   * capitulos.temas
   */
  export type capitulos$temasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the temas
     */
    select?: temasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the temas
     */
    omit?: temasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: temasInclude<ExtArgs> | null
    where?: temasWhereInput
    orderBy?: temasOrderByWithRelationInput | temasOrderByWithRelationInput[]
    cursor?: temasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemasScalarFieldEnum | TemasScalarFieldEnum[]
  }

  /**
   * capitulos.preguntas
   */
  export type capitulos$preguntasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the preguntas
     */
    select?: preguntasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the preguntas
     */
    omit?: preguntasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: preguntasInclude<ExtArgs> | null
    where?: preguntasWhereInput
    orderBy?: preguntasOrderByWithRelationInput | preguntasOrderByWithRelationInput[]
    cursor?: preguntasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreguntasScalarFieldEnum | PreguntasScalarFieldEnum[]
  }

  /**
   * capitulos without action
   */
  export type capitulosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the capitulos
     */
    select?: capitulosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the capitulos
     */
    omit?: capitulosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: capitulosInclude<ExtArgs> | null
  }


  /**
   * Model intentos
   */

  export type AggregateIntentos = {
    _count: IntentosCountAggregateOutputType | null
    _avg: IntentosAvgAggregateOutputType | null
    _sum: IntentosSumAggregateOutputType | null
    _min: IntentosMinAggregateOutputType | null
    _max: IntentosMaxAggregateOutputType | null
  }

  export type IntentosAvgAggregateOutputType = {
    tiempoDuracion: number | null
    correctas: number | null
    incorrectas: number | null
  }

  export type IntentosSumAggregateOutputType = {
    tiempoDuracion: number | null
    correctas: number | null
    incorrectas: number | null
  }

  export type IntentosMinAggregateOutputType = {
    id: string | null
    banqueoId: string | null
    usuarioEstudianteId: string | null
    tiempoDuracion: number | null
    correctas: number | null
    incorrectas: number | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    estado: $Enums.EstadoIntento | null
  }

  export type IntentosMaxAggregateOutputType = {
    id: string | null
    banqueoId: string | null
    usuarioEstudianteId: string | null
    tiempoDuracion: number | null
    correctas: number | null
    incorrectas: number | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    estado: $Enums.EstadoIntento | null
  }

  export type IntentosCountAggregateOutputType = {
    id: number
    banqueoId: number
    usuarioEstudianteId: number
    tiempoDuracion: number
    correctas: number
    incorrectas: number
    creadoEn: number
    actualizadoEn: number
    estado: number
    _all: number
  }


  export type IntentosAvgAggregateInputType = {
    tiempoDuracion?: true
    correctas?: true
    incorrectas?: true
  }

  export type IntentosSumAggregateInputType = {
    tiempoDuracion?: true
    correctas?: true
    incorrectas?: true
  }

  export type IntentosMinAggregateInputType = {
    id?: true
    banqueoId?: true
    usuarioEstudianteId?: true
    tiempoDuracion?: true
    correctas?: true
    incorrectas?: true
    creadoEn?: true
    actualizadoEn?: true
    estado?: true
  }

  export type IntentosMaxAggregateInputType = {
    id?: true
    banqueoId?: true
    usuarioEstudianteId?: true
    tiempoDuracion?: true
    correctas?: true
    incorrectas?: true
    creadoEn?: true
    actualizadoEn?: true
    estado?: true
  }

  export type IntentosCountAggregateInputType = {
    id?: true
    banqueoId?: true
    usuarioEstudianteId?: true
    tiempoDuracion?: true
    correctas?: true
    incorrectas?: true
    creadoEn?: true
    actualizadoEn?: true
    estado?: true
    _all?: true
  }

  export type IntentosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which intentos to aggregate.
     */
    where?: intentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of intentos to fetch.
     */
    orderBy?: intentosOrderByWithRelationInput | intentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: intentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` intentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` intentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned intentos
    **/
    _count?: true | IntentosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntentosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntentosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntentosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntentosMaxAggregateInputType
  }

  export type GetIntentosAggregateType<T extends IntentosAggregateArgs> = {
        [P in keyof T & keyof AggregateIntentos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntentos[P]>
      : GetScalarType<T[P], AggregateIntentos[P]>
  }




  export type intentosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: intentosWhereInput
    orderBy?: intentosOrderByWithAggregationInput | intentosOrderByWithAggregationInput[]
    by: IntentosScalarFieldEnum[] | IntentosScalarFieldEnum
    having?: intentosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntentosCountAggregateInputType | true
    _avg?: IntentosAvgAggregateInputType
    _sum?: IntentosSumAggregateInputType
    _min?: IntentosMinAggregateInputType
    _max?: IntentosMaxAggregateInputType
  }

  export type IntentosGroupByOutputType = {
    id: string
    banqueoId: string
    usuarioEstudianteId: string | null
    tiempoDuracion: number
    correctas: number
    incorrectas: number
    creadoEn: Date
    actualizadoEn: Date
    estado: $Enums.EstadoIntento
    _count: IntentosCountAggregateOutputType | null
    _avg: IntentosAvgAggregateOutputType | null
    _sum: IntentosSumAggregateOutputType | null
    _min: IntentosMinAggregateOutputType | null
    _max: IntentosMaxAggregateOutputType | null
  }

  type GetIntentosGroupByPayload<T extends intentosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntentosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntentosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntentosGroupByOutputType[P]>
            : GetScalarType<T[P], IntentosGroupByOutputType[P]>
        }
      >
    >


  export type intentosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    banqueoId?: boolean
    usuarioEstudianteId?: boolean
    tiempoDuracion?: boolean
    correctas?: boolean
    incorrectas?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    estado?: boolean
    banqueo?: boolean | banqueoDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | intentos$usuariosEstudiantesArgs<ExtArgs>
    respuestasIntentos?: boolean | intentos$respuestasIntentosArgs<ExtArgs>
    _count?: boolean | IntentosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["intentos"]>

  export type intentosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    banqueoId?: boolean
    usuarioEstudianteId?: boolean
    tiempoDuracion?: boolean
    correctas?: boolean
    incorrectas?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    estado?: boolean
    banqueo?: boolean | banqueoDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | intentos$usuariosEstudiantesArgs<ExtArgs>
  }, ExtArgs["result"]["intentos"]>

  export type intentosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    banqueoId?: boolean
    usuarioEstudianteId?: boolean
    tiempoDuracion?: boolean
    correctas?: boolean
    incorrectas?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    estado?: boolean
    banqueo?: boolean | banqueoDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | intentos$usuariosEstudiantesArgs<ExtArgs>
  }, ExtArgs["result"]["intentos"]>

  export type intentosSelectScalar = {
    id?: boolean
    banqueoId?: boolean
    usuarioEstudianteId?: boolean
    tiempoDuracion?: boolean
    correctas?: boolean
    incorrectas?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    estado?: boolean
  }

  export type intentosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "banqueoId" | "usuarioEstudianteId" | "tiempoDuracion" | "correctas" | "incorrectas" | "creadoEn" | "actualizadoEn" | "estado", ExtArgs["result"]["intentos"]>
  export type intentosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banqueo?: boolean | banqueoDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | intentos$usuariosEstudiantesArgs<ExtArgs>
    respuestasIntentos?: boolean | intentos$respuestasIntentosArgs<ExtArgs>
    _count?: boolean | IntentosCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type intentosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banqueo?: boolean | banqueoDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | intentos$usuariosEstudiantesArgs<ExtArgs>
  }
  export type intentosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banqueo?: boolean | banqueoDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | intentos$usuariosEstudiantesArgs<ExtArgs>
  }

  export type $intentosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "intentos"
    objects: {
      banqueo: Prisma.$banqueoPayload<ExtArgs>
      usuariosEstudiantes: Prisma.$usuariosEstudiantesPayload<ExtArgs> | null
      respuestasIntentos: Prisma.$respuestasIntentosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      banqueoId: string
      usuarioEstudianteId: string | null
      tiempoDuracion: number
      correctas: number
      incorrectas: number
      creadoEn: Date
      actualizadoEn: Date
      estado: $Enums.EstadoIntento
    }, ExtArgs["result"]["intentos"]>
    composites: {}
  }

  type intentosGetPayload<S extends boolean | null | undefined | intentosDefaultArgs> = $Result.GetResult<Prisma.$intentosPayload, S>

  type intentosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<intentosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IntentosCountAggregateInputType | true
    }

  export interface intentosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['intentos'], meta: { name: 'intentos' } }
    /**
     * Find zero or one Intentos that matches the filter.
     * @param {intentosFindUniqueArgs} args - Arguments to find a Intentos
     * @example
     * // Get one Intentos
     * const intentos = await prisma.intentos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends intentosFindUniqueArgs>(args: SelectSubset<T, intentosFindUniqueArgs<ExtArgs>>): Prisma__intentosClient<$Result.GetResult<Prisma.$intentosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Intentos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {intentosFindUniqueOrThrowArgs} args - Arguments to find a Intentos
     * @example
     * // Get one Intentos
     * const intentos = await prisma.intentos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends intentosFindUniqueOrThrowArgs>(args: SelectSubset<T, intentosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__intentosClient<$Result.GetResult<Prisma.$intentosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Intentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {intentosFindFirstArgs} args - Arguments to find a Intentos
     * @example
     * // Get one Intentos
     * const intentos = await prisma.intentos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends intentosFindFirstArgs>(args?: SelectSubset<T, intentosFindFirstArgs<ExtArgs>>): Prisma__intentosClient<$Result.GetResult<Prisma.$intentosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Intentos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {intentosFindFirstOrThrowArgs} args - Arguments to find a Intentos
     * @example
     * // Get one Intentos
     * const intentos = await prisma.intentos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends intentosFindFirstOrThrowArgs>(args?: SelectSubset<T, intentosFindFirstOrThrowArgs<ExtArgs>>): Prisma__intentosClient<$Result.GetResult<Prisma.$intentosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Intentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {intentosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Intentos
     * const intentos = await prisma.intentos.findMany()
     * 
     * // Get first 10 Intentos
     * const intentos = await prisma.intentos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const intentosWithIdOnly = await prisma.intentos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends intentosFindManyArgs>(args?: SelectSubset<T, intentosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$intentosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Intentos.
     * @param {intentosCreateArgs} args - Arguments to create a Intentos.
     * @example
     * // Create one Intentos
     * const Intentos = await prisma.intentos.create({
     *   data: {
     *     // ... data to create a Intentos
     *   }
     * })
     * 
     */
    create<T extends intentosCreateArgs>(args: SelectSubset<T, intentosCreateArgs<ExtArgs>>): Prisma__intentosClient<$Result.GetResult<Prisma.$intentosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Intentos.
     * @param {intentosCreateManyArgs} args - Arguments to create many Intentos.
     * @example
     * // Create many Intentos
     * const intentos = await prisma.intentos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends intentosCreateManyArgs>(args?: SelectSubset<T, intentosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Intentos and returns the data saved in the database.
     * @param {intentosCreateManyAndReturnArgs} args - Arguments to create many Intentos.
     * @example
     * // Create many Intentos
     * const intentos = await prisma.intentos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Intentos and only return the `id`
     * const intentosWithIdOnly = await prisma.intentos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends intentosCreateManyAndReturnArgs>(args?: SelectSubset<T, intentosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$intentosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Intentos.
     * @param {intentosDeleteArgs} args - Arguments to delete one Intentos.
     * @example
     * // Delete one Intentos
     * const Intentos = await prisma.intentos.delete({
     *   where: {
     *     // ... filter to delete one Intentos
     *   }
     * })
     * 
     */
    delete<T extends intentosDeleteArgs>(args: SelectSubset<T, intentosDeleteArgs<ExtArgs>>): Prisma__intentosClient<$Result.GetResult<Prisma.$intentosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Intentos.
     * @param {intentosUpdateArgs} args - Arguments to update one Intentos.
     * @example
     * // Update one Intentos
     * const intentos = await prisma.intentos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends intentosUpdateArgs>(args: SelectSubset<T, intentosUpdateArgs<ExtArgs>>): Prisma__intentosClient<$Result.GetResult<Prisma.$intentosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Intentos.
     * @param {intentosDeleteManyArgs} args - Arguments to filter Intentos to delete.
     * @example
     * // Delete a few Intentos
     * const { count } = await prisma.intentos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends intentosDeleteManyArgs>(args?: SelectSubset<T, intentosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Intentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {intentosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Intentos
     * const intentos = await prisma.intentos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends intentosUpdateManyArgs>(args: SelectSubset<T, intentosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Intentos and returns the data updated in the database.
     * @param {intentosUpdateManyAndReturnArgs} args - Arguments to update many Intentos.
     * @example
     * // Update many Intentos
     * const intentos = await prisma.intentos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Intentos and only return the `id`
     * const intentosWithIdOnly = await prisma.intentos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends intentosUpdateManyAndReturnArgs>(args: SelectSubset<T, intentosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$intentosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Intentos.
     * @param {intentosUpsertArgs} args - Arguments to update or create a Intentos.
     * @example
     * // Update or create a Intentos
     * const intentos = await prisma.intentos.upsert({
     *   create: {
     *     // ... data to create a Intentos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Intentos we want to update
     *   }
     * })
     */
    upsert<T extends intentosUpsertArgs>(args: SelectSubset<T, intentosUpsertArgs<ExtArgs>>): Prisma__intentosClient<$Result.GetResult<Prisma.$intentosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Intentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {intentosCountArgs} args - Arguments to filter Intentos to count.
     * @example
     * // Count the number of Intentos
     * const count = await prisma.intentos.count({
     *   where: {
     *     // ... the filter for the Intentos we want to count
     *   }
     * })
    **/
    count<T extends intentosCountArgs>(
      args?: Subset<T, intentosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntentosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Intentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntentosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntentosAggregateArgs>(args: Subset<T, IntentosAggregateArgs>): Prisma.PrismaPromise<GetIntentosAggregateType<T>>

    /**
     * Group by Intentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {intentosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends intentosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: intentosGroupByArgs['orderBy'] }
        : { orderBy?: intentosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, intentosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntentosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the intentos model
   */
  readonly fields: intentosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for intentos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__intentosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    banqueo<T extends banqueoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, banqueoDefaultArgs<ExtArgs>>): Prisma__banqueoClient<$Result.GetResult<Prisma.$banqueoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usuariosEstudiantes<T extends intentos$usuariosEstudiantesArgs<ExtArgs> = {}>(args?: Subset<T, intentos$usuariosEstudiantesArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    respuestasIntentos<T extends intentos$respuestasIntentosArgs<ExtArgs> = {}>(args?: Subset<T, intentos$respuestasIntentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$respuestasIntentosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the intentos model
   */
  interface intentosFieldRefs {
    readonly id: FieldRef<"intentos", 'String'>
    readonly banqueoId: FieldRef<"intentos", 'String'>
    readonly usuarioEstudianteId: FieldRef<"intentos", 'String'>
    readonly tiempoDuracion: FieldRef<"intentos", 'Int'>
    readonly correctas: FieldRef<"intentos", 'Int'>
    readonly incorrectas: FieldRef<"intentos", 'Int'>
    readonly creadoEn: FieldRef<"intentos", 'DateTime'>
    readonly actualizadoEn: FieldRef<"intentos", 'DateTime'>
    readonly estado: FieldRef<"intentos", 'EstadoIntento'>
  }
    

  // Custom InputTypes
  /**
   * intentos findUnique
   */
  export type intentosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intentos
     */
    select?: intentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the intentos
     */
    omit?: intentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intentosInclude<ExtArgs> | null
    /**
     * Filter, which intentos to fetch.
     */
    where: intentosWhereUniqueInput
  }

  /**
   * intentos findUniqueOrThrow
   */
  export type intentosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intentos
     */
    select?: intentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the intentos
     */
    omit?: intentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intentosInclude<ExtArgs> | null
    /**
     * Filter, which intentos to fetch.
     */
    where: intentosWhereUniqueInput
  }

  /**
   * intentos findFirst
   */
  export type intentosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intentos
     */
    select?: intentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the intentos
     */
    omit?: intentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intentosInclude<ExtArgs> | null
    /**
     * Filter, which intentos to fetch.
     */
    where?: intentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of intentos to fetch.
     */
    orderBy?: intentosOrderByWithRelationInput | intentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for intentos.
     */
    cursor?: intentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` intentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` intentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of intentos.
     */
    distinct?: IntentosScalarFieldEnum | IntentosScalarFieldEnum[]
  }

  /**
   * intentos findFirstOrThrow
   */
  export type intentosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intentos
     */
    select?: intentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the intentos
     */
    omit?: intentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intentosInclude<ExtArgs> | null
    /**
     * Filter, which intentos to fetch.
     */
    where?: intentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of intentos to fetch.
     */
    orderBy?: intentosOrderByWithRelationInput | intentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for intentos.
     */
    cursor?: intentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` intentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` intentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of intentos.
     */
    distinct?: IntentosScalarFieldEnum | IntentosScalarFieldEnum[]
  }

  /**
   * intentos findMany
   */
  export type intentosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intentos
     */
    select?: intentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the intentos
     */
    omit?: intentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intentosInclude<ExtArgs> | null
    /**
     * Filter, which intentos to fetch.
     */
    where?: intentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of intentos to fetch.
     */
    orderBy?: intentosOrderByWithRelationInput | intentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing intentos.
     */
    cursor?: intentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` intentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` intentos.
     */
    skip?: number
    distinct?: IntentosScalarFieldEnum | IntentosScalarFieldEnum[]
  }

  /**
   * intentos create
   */
  export type intentosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intentos
     */
    select?: intentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the intentos
     */
    omit?: intentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intentosInclude<ExtArgs> | null
    /**
     * The data needed to create a intentos.
     */
    data: XOR<intentosCreateInput, intentosUncheckedCreateInput>
  }

  /**
   * intentos createMany
   */
  export type intentosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many intentos.
     */
    data: intentosCreateManyInput | intentosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * intentos createManyAndReturn
   */
  export type intentosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intentos
     */
    select?: intentosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the intentos
     */
    omit?: intentosOmit<ExtArgs> | null
    /**
     * The data used to create many intentos.
     */
    data: intentosCreateManyInput | intentosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intentosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * intentos update
   */
  export type intentosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intentos
     */
    select?: intentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the intentos
     */
    omit?: intentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intentosInclude<ExtArgs> | null
    /**
     * The data needed to update a intentos.
     */
    data: XOR<intentosUpdateInput, intentosUncheckedUpdateInput>
    /**
     * Choose, which intentos to update.
     */
    where: intentosWhereUniqueInput
  }

  /**
   * intentos updateMany
   */
  export type intentosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update intentos.
     */
    data: XOR<intentosUpdateManyMutationInput, intentosUncheckedUpdateManyInput>
    /**
     * Filter which intentos to update
     */
    where?: intentosWhereInput
    /**
     * Limit how many intentos to update.
     */
    limit?: number
  }

  /**
   * intentos updateManyAndReturn
   */
  export type intentosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intentos
     */
    select?: intentosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the intentos
     */
    omit?: intentosOmit<ExtArgs> | null
    /**
     * The data used to update intentos.
     */
    data: XOR<intentosUpdateManyMutationInput, intentosUncheckedUpdateManyInput>
    /**
     * Filter which intentos to update
     */
    where?: intentosWhereInput
    /**
     * Limit how many intentos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intentosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * intentos upsert
   */
  export type intentosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intentos
     */
    select?: intentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the intentos
     */
    omit?: intentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intentosInclude<ExtArgs> | null
    /**
     * The filter to search for the intentos to update in case it exists.
     */
    where: intentosWhereUniqueInput
    /**
     * In case the intentos found by the `where` argument doesn't exist, create a new intentos with this data.
     */
    create: XOR<intentosCreateInput, intentosUncheckedCreateInput>
    /**
     * In case the intentos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<intentosUpdateInput, intentosUncheckedUpdateInput>
  }

  /**
   * intentos delete
   */
  export type intentosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intentos
     */
    select?: intentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the intentos
     */
    omit?: intentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intentosInclude<ExtArgs> | null
    /**
     * Filter which intentos to delete.
     */
    where: intentosWhereUniqueInput
  }

  /**
   * intentos deleteMany
   */
  export type intentosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which intentos to delete
     */
    where?: intentosWhereInput
    /**
     * Limit how many intentos to delete.
     */
    limit?: number
  }

  /**
   * intentos.usuariosEstudiantes
   */
  export type intentos$usuariosEstudiantesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuariosEstudiantes
     */
    select?: usuariosEstudiantesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usuariosEstudiantes
     */
    omit?: usuariosEstudiantesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuariosEstudiantesInclude<ExtArgs> | null
    where?: usuariosEstudiantesWhereInput
  }

  /**
   * intentos.respuestasIntentos
   */
  export type intentos$respuestasIntentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the respuestasIntentos
     */
    select?: respuestasIntentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the respuestasIntentos
     */
    omit?: respuestasIntentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: respuestasIntentosInclude<ExtArgs> | null
    where?: respuestasIntentosWhereInput
    orderBy?: respuestasIntentosOrderByWithRelationInput | respuestasIntentosOrderByWithRelationInput[]
    cursor?: respuestasIntentosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RespuestasIntentosScalarFieldEnum | RespuestasIntentosScalarFieldEnum[]
  }

  /**
   * intentos without action
   */
  export type intentosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intentos
     */
    select?: intentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the intentos
     */
    omit?: intentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: intentosInclude<ExtArgs> | null
  }


  /**
   * Model respuestasIntentos
   */

  export type AggregateRespuestasIntentos = {
    _count: RespuestasIntentosCountAggregateOutputType | null
    _avg: RespuestasIntentosAvgAggregateOutputType | null
    _sum: RespuestasIntentosSumAggregateOutputType | null
    _min: RespuestasIntentosMinAggregateOutputType | null
    _max: RespuestasIntentosMaxAggregateOutputType | null
  }

  export type RespuestasIntentosAvgAggregateOutputType = {
    tiempoConsumidoSeg: number | null
    orden: number | null
  }

  export type RespuestasIntentosSumAggregateOutputType = {
    tiempoConsumidoSeg: number | null
    orden: number | null
  }

  export type RespuestasIntentosMinAggregateOutputType = {
    id: string | null
    intentoId: string | null
    preguntaId: string | null
    resultado: $Enums.ResultadoRespuesta | null
    esCorrecta: boolean | null
    respondida: boolean | null
    visitada: boolean | null
    marcadaRevision: boolean | null
    tiempoConsumidoSeg: number | null
    orden: number | null
    respondidaEn: Date | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type RespuestasIntentosMaxAggregateOutputType = {
    id: string | null
    intentoId: string | null
    preguntaId: string | null
    resultado: $Enums.ResultadoRespuesta | null
    esCorrecta: boolean | null
    respondida: boolean | null
    visitada: boolean | null
    marcadaRevision: boolean | null
    tiempoConsumidoSeg: number | null
    orden: number | null
    respondidaEn: Date | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type RespuestasIntentosCountAggregateOutputType = {
    id: number
    intentoId: number
    preguntaId: number
    respuesta: number
    resultado: number
    esCorrecta: number
    respondida: number
    visitada: number
    marcadaRevision: number
    tiempoConsumidoSeg: number
    orden: number
    respondidaEn: number
    creadoEn: number
    actualizadoEn: number
    _all: number
  }


  export type RespuestasIntentosAvgAggregateInputType = {
    tiempoConsumidoSeg?: true
    orden?: true
  }

  export type RespuestasIntentosSumAggregateInputType = {
    tiempoConsumidoSeg?: true
    orden?: true
  }

  export type RespuestasIntentosMinAggregateInputType = {
    id?: true
    intentoId?: true
    preguntaId?: true
    resultado?: true
    esCorrecta?: true
    respondida?: true
    visitada?: true
    marcadaRevision?: true
    tiempoConsumidoSeg?: true
    orden?: true
    respondidaEn?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type RespuestasIntentosMaxAggregateInputType = {
    id?: true
    intentoId?: true
    preguntaId?: true
    resultado?: true
    esCorrecta?: true
    respondida?: true
    visitada?: true
    marcadaRevision?: true
    tiempoConsumidoSeg?: true
    orden?: true
    respondidaEn?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type RespuestasIntentosCountAggregateInputType = {
    id?: true
    intentoId?: true
    preguntaId?: true
    respuesta?: true
    resultado?: true
    esCorrecta?: true
    respondida?: true
    visitada?: true
    marcadaRevision?: true
    tiempoConsumidoSeg?: true
    orden?: true
    respondidaEn?: true
    creadoEn?: true
    actualizadoEn?: true
    _all?: true
  }

  export type RespuestasIntentosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which respuestasIntentos to aggregate.
     */
    where?: respuestasIntentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of respuestasIntentos to fetch.
     */
    orderBy?: respuestasIntentosOrderByWithRelationInput | respuestasIntentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: respuestasIntentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` respuestasIntentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` respuestasIntentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned respuestasIntentos
    **/
    _count?: true | RespuestasIntentosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RespuestasIntentosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RespuestasIntentosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RespuestasIntentosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RespuestasIntentosMaxAggregateInputType
  }

  export type GetRespuestasIntentosAggregateType<T extends RespuestasIntentosAggregateArgs> = {
        [P in keyof T & keyof AggregateRespuestasIntentos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRespuestasIntentos[P]>
      : GetScalarType<T[P], AggregateRespuestasIntentos[P]>
  }




  export type respuestasIntentosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: respuestasIntentosWhereInput
    orderBy?: respuestasIntentosOrderByWithAggregationInput | respuestasIntentosOrderByWithAggregationInput[]
    by: RespuestasIntentosScalarFieldEnum[] | RespuestasIntentosScalarFieldEnum
    having?: respuestasIntentosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RespuestasIntentosCountAggregateInputType | true
    _avg?: RespuestasIntentosAvgAggregateInputType
    _sum?: RespuestasIntentosSumAggregateInputType
    _min?: RespuestasIntentosMinAggregateInputType
    _max?: RespuestasIntentosMaxAggregateInputType
  }

  export type RespuestasIntentosGroupByOutputType = {
    id: string
    intentoId: string
    preguntaId: string
    respuesta: JsonValue | null
    resultado: $Enums.ResultadoRespuesta
    esCorrecta: boolean | null
    respondida: boolean
    visitada: boolean
    marcadaRevision: boolean
    tiempoConsumidoSeg: number
    orden: number | null
    respondidaEn: Date | null
    creadoEn: Date
    actualizadoEn: Date
    _count: RespuestasIntentosCountAggregateOutputType | null
    _avg: RespuestasIntentosAvgAggregateOutputType | null
    _sum: RespuestasIntentosSumAggregateOutputType | null
    _min: RespuestasIntentosMinAggregateOutputType | null
    _max: RespuestasIntentosMaxAggregateOutputType | null
  }

  type GetRespuestasIntentosGroupByPayload<T extends respuestasIntentosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RespuestasIntentosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RespuestasIntentosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RespuestasIntentosGroupByOutputType[P]>
            : GetScalarType<T[P], RespuestasIntentosGroupByOutputType[P]>
        }
      >
    >


  export type respuestasIntentosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    intentoId?: boolean
    preguntaId?: boolean
    respuesta?: boolean
    resultado?: boolean
    esCorrecta?: boolean
    respondida?: boolean
    visitada?: boolean
    marcadaRevision?: boolean
    tiempoConsumidoSeg?: boolean
    orden?: boolean
    respondidaEn?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    intentos?: boolean | intentosDefaultArgs<ExtArgs>
    preguntas?: boolean | preguntasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["respuestasIntentos"]>

  export type respuestasIntentosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    intentoId?: boolean
    preguntaId?: boolean
    respuesta?: boolean
    resultado?: boolean
    esCorrecta?: boolean
    respondida?: boolean
    visitada?: boolean
    marcadaRevision?: boolean
    tiempoConsumidoSeg?: boolean
    orden?: boolean
    respondidaEn?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    intentos?: boolean | intentosDefaultArgs<ExtArgs>
    preguntas?: boolean | preguntasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["respuestasIntentos"]>

  export type respuestasIntentosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    intentoId?: boolean
    preguntaId?: boolean
    respuesta?: boolean
    resultado?: boolean
    esCorrecta?: boolean
    respondida?: boolean
    visitada?: boolean
    marcadaRevision?: boolean
    tiempoConsumidoSeg?: boolean
    orden?: boolean
    respondidaEn?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    intentos?: boolean | intentosDefaultArgs<ExtArgs>
    preguntas?: boolean | preguntasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["respuestasIntentos"]>

  export type respuestasIntentosSelectScalar = {
    id?: boolean
    intentoId?: boolean
    preguntaId?: boolean
    respuesta?: boolean
    resultado?: boolean
    esCorrecta?: boolean
    respondida?: boolean
    visitada?: boolean
    marcadaRevision?: boolean
    tiempoConsumidoSeg?: boolean
    orden?: boolean
    respondidaEn?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }

  export type respuestasIntentosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "intentoId" | "preguntaId" | "respuesta" | "resultado" | "esCorrecta" | "respondida" | "visitada" | "marcadaRevision" | "tiempoConsumidoSeg" | "orden" | "respondidaEn" | "creadoEn" | "actualizadoEn", ExtArgs["result"]["respuestasIntentos"]>
  export type respuestasIntentosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    intentos?: boolean | intentosDefaultArgs<ExtArgs>
    preguntas?: boolean | preguntasDefaultArgs<ExtArgs>
  }
  export type respuestasIntentosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    intentos?: boolean | intentosDefaultArgs<ExtArgs>
    preguntas?: boolean | preguntasDefaultArgs<ExtArgs>
  }
  export type respuestasIntentosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    intentos?: boolean | intentosDefaultArgs<ExtArgs>
    preguntas?: boolean | preguntasDefaultArgs<ExtArgs>
  }

  export type $respuestasIntentosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "respuestasIntentos"
    objects: {
      intentos: Prisma.$intentosPayload<ExtArgs>
      preguntas: Prisma.$preguntasPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      intentoId: string
      preguntaId: string
      respuesta: Prisma.JsonValue | null
      resultado: $Enums.ResultadoRespuesta
      esCorrecta: boolean | null
      respondida: boolean
      visitada: boolean
      marcadaRevision: boolean
      tiempoConsumidoSeg: number
      orden: number | null
      respondidaEn: Date | null
      creadoEn: Date
      actualizadoEn: Date
    }, ExtArgs["result"]["respuestasIntentos"]>
    composites: {}
  }

  type respuestasIntentosGetPayload<S extends boolean | null | undefined | respuestasIntentosDefaultArgs> = $Result.GetResult<Prisma.$respuestasIntentosPayload, S>

  type respuestasIntentosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<respuestasIntentosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RespuestasIntentosCountAggregateInputType | true
    }

  export interface respuestasIntentosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['respuestasIntentos'], meta: { name: 'respuestasIntentos' } }
    /**
     * Find zero or one RespuestasIntentos that matches the filter.
     * @param {respuestasIntentosFindUniqueArgs} args - Arguments to find a RespuestasIntentos
     * @example
     * // Get one RespuestasIntentos
     * const respuestasIntentos = await prisma.respuestasIntentos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends respuestasIntentosFindUniqueArgs>(args: SelectSubset<T, respuestasIntentosFindUniqueArgs<ExtArgs>>): Prisma__respuestasIntentosClient<$Result.GetResult<Prisma.$respuestasIntentosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RespuestasIntentos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {respuestasIntentosFindUniqueOrThrowArgs} args - Arguments to find a RespuestasIntentos
     * @example
     * // Get one RespuestasIntentos
     * const respuestasIntentos = await prisma.respuestasIntentos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends respuestasIntentosFindUniqueOrThrowArgs>(args: SelectSubset<T, respuestasIntentosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__respuestasIntentosClient<$Result.GetResult<Prisma.$respuestasIntentosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RespuestasIntentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {respuestasIntentosFindFirstArgs} args - Arguments to find a RespuestasIntentos
     * @example
     * // Get one RespuestasIntentos
     * const respuestasIntentos = await prisma.respuestasIntentos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends respuestasIntentosFindFirstArgs>(args?: SelectSubset<T, respuestasIntentosFindFirstArgs<ExtArgs>>): Prisma__respuestasIntentosClient<$Result.GetResult<Prisma.$respuestasIntentosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RespuestasIntentos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {respuestasIntentosFindFirstOrThrowArgs} args - Arguments to find a RespuestasIntentos
     * @example
     * // Get one RespuestasIntentos
     * const respuestasIntentos = await prisma.respuestasIntentos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends respuestasIntentosFindFirstOrThrowArgs>(args?: SelectSubset<T, respuestasIntentosFindFirstOrThrowArgs<ExtArgs>>): Prisma__respuestasIntentosClient<$Result.GetResult<Prisma.$respuestasIntentosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RespuestasIntentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {respuestasIntentosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RespuestasIntentos
     * const respuestasIntentos = await prisma.respuestasIntentos.findMany()
     * 
     * // Get first 10 RespuestasIntentos
     * const respuestasIntentos = await prisma.respuestasIntentos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const respuestasIntentosWithIdOnly = await prisma.respuestasIntentos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends respuestasIntentosFindManyArgs>(args?: SelectSubset<T, respuestasIntentosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$respuestasIntentosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RespuestasIntentos.
     * @param {respuestasIntentosCreateArgs} args - Arguments to create a RespuestasIntentos.
     * @example
     * // Create one RespuestasIntentos
     * const RespuestasIntentos = await prisma.respuestasIntentos.create({
     *   data: {
     *     // ... data to create a RespuestasIntentos
     *   }
     * })
     * 
     */
    create<T extends respuestasIntentosCreateArgs>(args: SelectSubset<T, respuestasIntentosCreateArgs<ExtArgs>>): Prisma__respuestasIntentosClient<$Result.GetResult<Prisma.$respuestasIntentosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RespuestasIntentos.
     * @param {respuestasIntentosCreateManyArgs} args - Arguments to create many RespuestasIntentos.
     * @example
     * // Create many RespuestasIntentos
     * const respuestasIntentos = await prisma.respuestasIntentos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends respuestasIntentosCreateManyArgs>(args?: SelectSubset<T, respuestasIntentosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RespuestasIntentos and returns the data saved in the database.
     * @param {respuestasIntentosCreateManyAndReturnArgs} args - Arguments to create many RespuestasIntentos.
     * @example
     * // Create many RespuestasIntentos
     * const respuestasIntentos = await prisma.respuestasIntentos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RespuestasIntentos and only return the `id`
     * const respuestasIntentosWithIdOnly = await prisma.respuestasIntentos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends respuestasIntentosCreateManyAndReturnArgs>(args?: SelectSubset<T, respuestasIntentosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$respuestasIntentosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RespuestasIntentos.
     * @param {respuestasIntentosDeleteArgs} args - Arguments to delete one RespuestasIntentos.
     * @example
     * // Delete one RespuestasIntentos
     * const RespuestasIntentos = await prisma.respuestasIntentos.delete({
     *   where: {
     *     // ... filter to delete one RespuestasIntentos
     *   }
     * })
     * 
     */
    delete<T extends respuestasIntentosDeleteArgs>(args: SelectSubset<T, respuestasIntentosDeleteArgs<ExtArgs>>): Prisma__respuestasIntentosClient<$Result.GetResult<Prisma.$respuestasIntentosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RespuestasIntentos.
     * @param {respuestasIntentosUpdateArgs} args - Arguments to update one RespuestasIntentos.
     * @example
     * // Update one RespuestasIntentos
     * const respuestasIntentos = await prisma.respuestasIntentos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends respuestasIntentosUpdateArgs>(args: SelectSubset<T, respuestasIntentosUpdateArgs<ExtArgs>>): Prisma__respuestasIntentosClient<$Result.GetResult<Prisma.$respuestasIntentosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RespuestasIntentos.
     * @param {respuestasIntentosDeleteManyArgs} args - Arguments to filter RespuestasIntentos to delete.
     * @example
     * // Delete a few RespuestasIntentos
     * const { count } = await prisma.respuestasIntentos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends respuestasIntentosDeleteManyArgs>(args?: SelectSubset<T, respuestasIntentosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RespuestasIntentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {respuestasIntentosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RespuestasIntentos
     * const respuestasIntentos = await prisma.respuestasIntentos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends respuestasIntentosUpdateManyArgs>(args: SelectSubset<T, respuestasIntentosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RespuestasIntentos and returns the data updated in the database.
     * @param {respuestasIntentosUpdateManyAndReturnArgs} args - Arguments to update many RespuestasIntentos.
     * @example
     * // Update many RespuestasIntentos
     * const respuestasIntentos = await prisma.respuestasIntentos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RespuestasIntentos and only return the `id`
     * const respuestasIntentosWithIdOnly = await prisma.respuestasIntentos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends respuestasIntentosUpdateManyAndReturnArgs>(args: SelectSubset<T, respuestasIntentosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$respuestasIntentosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RespuestasIntentos.
     * @param {respuestasIntentosUpsertArgs} args - Arguments to update or create a RespuestasIntentos.
     * @example
     * // Update or create a RespuestasIntentos
     * const respuestasIntentos = await prisma.respuestasIntentos.upsert({
     *   create: {
     *     // ... data to create a RespuestasIntentos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RespuestasIntentos we want to update
     *   }
     * })
     */
    upsert<T extends respuestasIntentosUpsertArgs>(args: SelectSubset<T, respuestasIntentosUpsertArgs<ExtArgs>>): Prisma__respuestasIntentosClient<$Result.GetResult<Prisma.$respuestasIntentosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RespuestasIntentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {respuestasIntentosCountArgs} args - Arguments to filter RespuestasIntentos to count.
     * @example
     * // Count the number of RespuestasIntentos
     * const count = await prisma.respuestasIntentos.count({
     *   where: {
     *     // ... the filter for the RespuestasIntentos we want to count
     *   }
     * })
    **/
    count<T extends respuestasIntentosCountArgs>(
      args?: Subset<T, respuestasIntentosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RespuestasIntentosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RespuestasIntentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RespuestasIntentosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RespuestasIntentosAggregateArgs>(args: Subset<T, RespuestasIntentosAggregateArgs>): Prisma.PrismaPromise<GetRespuestasIntentosAggregateType<T>>

    /**
     * Group by RespuestasIntentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {respuestasIntentosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends respuestasIntentosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: respuestasIntentosGroupByArgs['orderBy'] }
        : { orderBy?: respuestasIntentosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, respuestasIntentosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRespuestasIntentosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the respuestasIntentos model
   */
  readonly fields: respuestasIntentosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for respuestasIntentos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__respuestasIntentosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    intentos<T extends intentosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, intentosDefaultArgs<ExtArgs>>): Prisma__intentosClient<$Result.GetResult<Prisma.$intentosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    preguntas<T extends preguntasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, preguntasDefaultArgs<ExtArgs>>): Prisma__preguntasClient<$Result.GetResult<Prisma.$preguntasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the respuestasIntentos model
   */
  interface respuestasIntentosFieldRefs {
    readonly id: FieldRef<"respuestasIntentos", 'String'>
    readonly intentoId: FieldRef<"respuestasIntentos", 'String'>
    readonly preguntaId: FieldRef<"respuestasIntentos", 'String'>
    readonly respuesta: FieldRef<"respuestasIntentos", 'Json'>
    readonly resultado: FieldRef<"respuestasIntentos", 'ResultadoRespuesta'>
    readonly esCorrecta: FieldRef<"respuestasIntentos", 'Boolean'>
    readonly respondida: FieldRef<"respuestasIntentos", 'Boolean'>
    readonly visitada: FieldRef<"respuestasIntentos", 'Boolean'>
    readonly marcadaRevision: FieldRef<"respuestasIntentos", 'Boolean'>
    readonly tiempoConsumidoSeg: FieldRef<"respuestasIntentos", 'Int'>
    readonly orden: FieldRef<"respuestasIntentos", 'Int'>
    readonly respondidaEn: FieldRef<"respuestasIntentos", 'DateTime'>
    readonly creadoEn: FieldRef<"respuestasIntentos", 'DateTime'>
    readonly actualizadoEn: FieldRef<"respuestasIntentos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * respuestasIntentos findUnique
   */
  export type respuestasIntentosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the respuestasIntentos
     */
    select?: respuestasIntentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the respuestasIntentos
     */
    omit?: respuestasIntentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: respuestasIntentosInclude<ExtArgs> | null
    /**
     * Filter, which respuestasIntentos to fetch.
     */
    where: respuestasIntentosWhereUniqueInput
  }

  /**
   * respuestasIntentos findUniqueOrThrow
   */
  export type respuestasIntentosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the respuestasIntentos
     */
    select?: respuestasIntentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the respuestasIntentos
     */
    omit?: respuestasIntentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: respuestasIntentosInclude<ExtArgs> | null
    /**
     * Filter, which respuestasIntentos to fetch.
     */
    where: respuestasIntentosWhereUniqueInput
  }

  /**
   * respuestasIntentos findFirst
   */
  export type respuestasIntentosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the respuestasIntentos
     */
    select?: respuestasIntentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the respuestasIntentos
     */
    omit?: respuestasIntentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: respuestasIntentosInclude<ExtArgs> | null
    /**
     * Filter, which respuestasIntentos to fetch.
     */
    where?: respuestasIntentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of respuestasIntentos to fetch.
     */
    orderBy?: respuestasIntentosOrderByWithRelationInput | respuestasIntentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for respuestasIntentos.
     */
    cursor?: respuestasIntentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` respuestasIntentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` respuestasIntentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of respuestasIntentos.
     */
    distinct?: RespuestasIntentosScalarFieldEnum | RespuestasIntentosScalarFieldEnum[]
  }

  /**
   * respuestasIntentos findFirstOrThrow
   */
  export type respuestasIntentosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the respuestasIntentos
     */
    select?: respuestasIntentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the respuestasIntentos
     */
    omit?: respuestasIntentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: respuestasIntentosInclude<ExtArgs> | null
    /**
     * Filter, which respuestasIntentos to fetch.
     */
    where?: respuestasIntentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of respuestasIntentos to fetch.
     */
    orderBy?: respuestasIntentosOrderByWithRelationInput | respuestasIntentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for respuestasIntentos.
     */
    cursor?: respuestasIntentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` respuestasIntentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` respuestasIntentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of respuestasIntentos.
     */
    distinct?: RespuestasIntentosScalarFieldEnum | RespuestasIntentosScalarFieldEnum[]
  }

  /**
   * respuestasIntentos findMany
   */
  export type respuestasIntentosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the respuestasIntentos
     */
    select?: respuestasIntentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the respuestasIntentos
     */
    omit?: respuestasIntentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: respuestasIntentosInclude<ExtArgs> | null
    /**
     * Filter, which respuestasIntentos to fetch.
     */
    where?: respuestasIntentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of respuestasIntentos to fetch.
     */
    orderBy?: respuestasIntentosOrderByWithRelationInput | respuestasIntentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing respuestasIntentos.
     */
    cursor?: respuestasIntentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` respuestasIntentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` respuestasIntentos.
     */
    skip?: number
    distinct?: RespuestasIntentosScalarFieldEnum | RespuestasIntentosScalarFieldEnum[]
  }

  /**
   * respuestasIntentos create
   */
  export type respuestasIntentosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the respuestasIntentos
     */
    select?: respuestasIntentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the respuestasIntentos
     */
    omit?: respuestasIntentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: respuestasIntentosInclude<ExtArgs> | null
    /**
     * The data needed to create a respuestasIntentos.
     */
    data: XOR<respuestasIntentosCreateInput, respuestasIntentosUncheckedCreateInput>
  }

  /**
   * respuestasIntentos createMany
   */
  export type respuestasIntentosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many respuestasIntentos.
     */
    data: respuestasIntentosCreateManyInput | respuestasIntentosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * respuestasIntentos createManyAndReturn
   */
  export type respuestasIntentosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the respuestasIntentos
     */
    select?: respuestasIntentosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the respuestasIntentos
     */
    omit?: respuestasIntentosOmit<ExtArgs> | null
    /**
     * The data used to create many respuestasIntentos.
     */
    data: respuestasIntentosCreateManyInput | respuestasIntentosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: respuestasIntentosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * respuestasIntentos update
   */
  export type respuestasIntentosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the respuestasIntentos
     */
    select?: respuestasIntentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the respuestasIntentos
     */
    omit?: respuestasIntentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: respuestasIntentosInclude<ExtArgs> | null
    /**
     * The data needed to update a respuestasIntentos.
     */
    data: XOR<respuestasIntentosUpdateInput, respuestasIntentosUncheckedUpdateInput>
    /**
     * Choose, which respuestasIntentos to update.
     */
    where: respuestasIntentosWhereUniqueInput
  }

  /**
   * respuestasIntentos updateMany
   */
  export type respuestasIntentosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update respuestasIntentos.
     */
    data: XOR<respuestasIntentosUpdateManyMutationInput, respuestasIntentosUncheckedUpdateManyInput>
    /**
     * Filter which respuestasIntentos to update
     */
    where?: respuestasIntentosWhereInput
    /**
     * Limit how many respuestasIntentos to update.
     */
    limit?: number
  }

  /**
   * respuestasIntentos updateManyAndReturn
   */
  export type respuestasIntentosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the respuestasIntentos
     */
    select?: respuestasIntentosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the respuestasIntentos
     */
    omit?: respuestasIntentosOmit<ExtArgs> | null
    /**
     * The data used to update respuestasIntentos.
     */
    data: XOR<respuestasIntentosUpdateManyMutationInput, respuestasIntentosUncheckedUpdateManyInput>
    /**
     * Filter which respuestasIntentos to update
     */
    where?: respuestasIntentosWhereInput
    /**
     * Limit how many respuestasIntentos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: respuestasIntentosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * respuestasIntentos upsert
   */
  export type respuestasIntentosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the respuestasIntentos
     */
    select?: respuestasIntentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the respuestasIntentos
     */
    omit?: respuestasIntentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: respuestasIntentosInclude<ExtArgs> | null
    /**
     * The filter to search for the respuestasIntentos to update in case it exists.
     */
    where: respuestasIntentosWhereUniqueInput
    /**
     * In case the respuestasIntentos found by the `where` argument doesn't exist, create a new respuestasIntentos with this data.
     */
    create: XOR<respuestasIntentosCreateInput, respuestasIntentosUncheckedCreateInput>
    /**
     * In case the respuestasIntentos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<respuestasIntentosUpdateInput, respuestasIntentosUncheckedUpdateInput>
  }

  /**
   * respuestasIntentos delete
   */
  export type respuestasIntentosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the respuestasIntentos
     */
    select?: respuestasIntentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the respuestasIntentos
     */
    omit?: respuestasIntentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: respuestasIntentosInclude<ExtArgs> | null
    /**
     * Filter which respuestasIntentos to delete.
     */
    where: respuestasIntentosWhereUniqueInput
  }

  /**
   * respuestasIntentos deleteMany
   */
  export type respuestasIntentosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which respuestasIntentos to delete
     */
    where?: respuestasIntentosWhereInput
    /**
     * Limit how many respuestasIntentos to delete.
     */
    limit?: number
  }

  /**
   * respuestasIntentos without action
   */
  export type respuestasIntentosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the respuestasIntentos
     */
    select?: respuestasIntentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the respuestasIntentos
     */
    omit?: respuestasIntentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: respuestasIntentosInclude<ExtArgs> | null
  }


  /**
   * Model repasoRegistros
   */

  export type AggregateRepasoRegistros = {
    _count: RepasoRegistrosCountAggregateOutputType | null
    _min: RepasoRegistrosMinAggregateOutputType | null
    _max: RepasoRegistrosMaxAggregateOutputType | null
  }

  export type RepasoRegistrosMinAggregateOutputType = {
    id: string | null
    usuarioEstudianteId: string | null
    banqueoId: string | null
    preguntaId: string | null
    esCorrecta: boolean | null
    creadoEn: Date | null
  }

  export type RepasoRegistrosMaxAggregateOutputType = {
    id: string | null
    usuarioEstudianteId: string | null
    banqueoId: string | null
    preguntaId: string | null
    esCorrecta: boolean | null
    creadoEn: Date | null
  }

  export type RepasoRegistrosCountAggregateOutputType = {
    id: number
    usuarioEstudianteId: number
    banqueoId: number
    preguntaId: number
    esCorrecta: number
    creadoEn: number
    _all: number
  }


  export type RepasoRegistrosMinAggregateInputType = {
    id?: true
    usuarioEstudianteId?: true
    banqueoId?: true
    preguntaId?: true
    esCorrecta?: true
    creadoEn?: true
  }

  export type RepasoRegistrosMaxAggregateInputType = {
    id?: true
    usuarioEstudianteId?: true
    banqueoId?: true
    preguntaId?: true
    esCorrecta?: true
    creadoEn?: true
  }

  export type RepasoRegistrosCountAggregateInputType = {
    id?: true
    usuarioEstudianteId?: true
    banqueoId?: true
    preguntaId?: true
    esCorrecta?: true
    creadoEn?: true
    _all?: true
  }

  export type RepasoRegistrosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which repasoRegistros to aggregate.
     */
    where?: repasoRegistrosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of repasoRegistros to fetch.
     */
    orderBy?: repasoRegistrosOrderByWithRelationInput | repasoRegistrosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: repasoRegistrosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` repasoRegistros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` repasoRegistros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned repasoRegistros
    **/
    _count?: true | RepasoRegistrosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RepasoRegistrosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RepasoRegistrosMaxAggregateInputType
  }

  export type GetRepasoRegistrosAggregateType<T extends RepasoRegistrosAggregateArgs> = {
        [P in keyof T & keyof AggregateRepasoRegistros]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepasoRegistros[P]>
      : GetScalarType<T[P], AggregateRepasoRegistros[P]>
  }




  export type repasoRegistrosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: repasoRegistrosWhereInput
    orderBy?: repasoRegistrosOrderByWithAggregationInput | repasoRegistrosOrderByWithAggregationInput[]
    by: RepasoRegistrosScalarFieldEnum[] | RepasoRegistrosScalarFieldEnum
    having?: repasoRegistrosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RepasoRegistrosCountAggregateInputType | true
    _min?: RepasoRegistrosMinAggregateInputType
    _max?: RepasoRegistrosMaxAggregateInputType
  }

  export type RepasoRegistrosGroupByOutputType = {
    id: string
    usuarioEstudianteId: string
    banqueoId: string
    preguntaId: string
    esCorrecta: boolean
    creadoEn: Date
    _count: RepasoRegistrosCountAggregateOutputType | null
    _min: RepasoRegistrosMinAggregateOutputType | null
    _max: RepasoRegistrosMaxAggregateOutputType | null
  }

  type GetRepasoRegistrosGroupByPayload<T extends repasoRegistrosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RepasoRegistrosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RepasoRegistrosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RepasoRegistrosGroupByOutputType[P]>
            : GetScalarType<T[P], RepasoRegistrosGroupByOutputType[P]>
        }
      >
    >


  export type repasoRegistrosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioEstudianteId?: boolean
    banqueoId?: boolean
    preguntaId?: boolean
    esCorrecta?: boolean
    creadoEn?: boolean
    banqueo?: boolean | banqueoDefaultArgs<ExtArgs>
    preguntas?: boolean | preguntasDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | usuariosEstudiantesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["repasoRegistros"]>

  export type repasoRegistrosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioEstudianteId?: boolean
    banqueoId?: boolean
    preguntaId?: boolean
    esCorrecta?: boolean
    creadoEn?: boolean
    banqueo?: boolean | banqueoDefaultArgs<ExtArgs>
    preguntas?: boolean | preguntasDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | usuariosEstudiantesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["repasoRegistros"]>

  export type repasoRegistrosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioEstudianteId?: boolean
    banqueoId?: boolean
    preguntaId?: boolean
    esCorrecta?: boolean
    creadoEn?: boolean
    banqueo?: boolean | banqueoDefaultArgs<ExtArgs>
    preguntas?: boolean | preguntasDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | usuariosEstudiantesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["repasoRegistros"]>

  export type repasoRegistrosSelectScalar = {
    id?: boolean
    usuarioEstudianteId?: boolean
    banqueoId?: boolean
    preguntaId?: boolean
    esCorrecta?: boolean
    creadoEn?: boolean
  }

  export type repasoRegistrosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuarioEstudianteId" | "banqueoId" | "preguntaId" | "esCorrecta" | "creadoEn", ExtArgs["result"]["repasoRegistros"]>
  export type repasoRegistrosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banqueo?: boolean | banqueoDefaultArgs<ExtArgs>
    preguntas?: boolean | preguntasDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | usuariosEstudiantesDefaultArgs<ExtArgs>
  }
  export type repasoRegistrosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banqueo?: boolean | banqueoDefaultArgs<ExtArgs>
    preguntas?: boolean | preguntasDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | usuariosEstudiantesDefaultArgs<ExtArgs>
  }
  export type repasoRegistrosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banqueo?: boolean | banqueoDefaultArgs<ExtArgs>
    preguntas?: boolean | preguntasDefaultArgs<ExtArgs>
    usuariosEstudiantes?: boolean | usuariosEstudiantesDefaultArgs<ExtArgs>
  }

  export type $repasoRegistrosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "repasoRegistros"
    objects: {
      banqueo: Prisma.$banqueoPayload<ExtArgs>
      preguntas: Prisma.$preguntasPayload<ExtArgs>
      usuariosEstudiantes: Prisma.$usuariosEstudiantesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usuarioEstudianteId: string
      banqueoId: string
      preguntaId: string
      esCorrecta: boolean
      creadoEn: Date
    }, ExtArgs["result"]["repasoRegistros"]>
    composites: {}
  }

  type repasoRegistrosGetPayload<S extends boolean | null | undefined | repasoRegistrosDefaultArgs> = $Result.GetResult<Prisma.$repasoRegistrosPayload, S>

  type repasoRegistrosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<repasoRegistrosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RepasoRegistrosCountAggregateInputType | true
    }

  export interface repasoRegistrosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['repasoRegistros'], meta: { name: 'repasoRegistros' } }
    /**
     * Find zero or one RepasoRegistros that matches the filter.
     * @param {repasoRegistrosFindUniqueArgs} args - Arguments to find a RepasoRegistros
     * @example
     * // Get one RepasoRegistros
     * const repasoRegistros = await prisma.repasoRegistros.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends repasoRegistrosFindUniqueArgs>(args: SelectSubset<T, repasoRegistrosFindUniqueArgs<ExtArgs>>): Prisma__repasoRegistrosClient<$Result.GetResult<Prisma.$repasoRegistrosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RepasoRegistros that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {repasoRegistrosFindUniqueOrThrowArgs} args - Arguments to find a RepasoRegistros
     * @example
     * // Get one RepasoRegistros
     * const repasoRegistros = await prisma.repasoRegistros.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends repasoRegistrosFindUniqueOrThrowArgs>(args: SelectSubset<T, repasoRegistrosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__repasoRegistrosClient<$Result.GetResult<Prisma.$repasoRegistrosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RepasoRegistros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {repasoRegistrosFindFirstArgs} args - Arguments to find a RepasoRegistros
     * @example
     * // Get one RepasoRegistros
     * const repasoRegistros = await prisma.repasoRegistros.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends repasoRegistrosFindFirstArgs>(args?: SelectSubset<T, repasoRegistrosFindFirstArgs<ExtArgs>>): Prisma__repasoRegistrosClient<$Result.GetResult<Prisma.$repasoRegistrosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RepasoRegistros that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {repasoRegistrosFindFirstOrThrowArgs} args - Arguments to find a RepasoRegistros
     * @example
     * // Get one RepasoRegistros
     * const repasoRegistros = await prisma.repasoRegistros.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends repasoRegistrosFindFirstOrThrowArgs>(args?: SelectSubset<T, repasoRegistrosFindFirstOrThrowArgs<ExtArgs>>): Prisma__repasoRegistrosClient<$Result.GetResult<Prisma.$repasoRegistrosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RepasoRegistros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {repasoRegistrosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RepasoRegistros
     * const repasoRegistros = await prisma.repasoRegistros.findMany()
     * 
     * // Get first 10 RepasoRegistros
     * const repasoRegistros = await prisma.repasoRegistros.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const repasoRegistrosWithIdOnly = await prisma.repasoRegistros.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends repasoRegistrosFindManyArgs>(args?: SelectSubset<T, repasoRegistrosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$repasoRegistrosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RepasoRegistros.
     * @param {repasoRegistrosCreateArgs} args - Arguments to create a RepasoRegistros.
     * @example
     * // Create one RepasoRegistros
     * const RepasoRegistros = await prisma.repasoRegistros.create({
     *   data: {
     *     // ... data to create a RepasoRegistros
     *   }
     * })
     * 
     */
    create<T extends repasoRegistrosCreateArgs>(args: SelectSubset<T, repasoRegistrosCreateArgs<ExtArgs>>): Prisma__repasoRegistrosClient<$Result.GetResult<Prisma.$repasoRegistrosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RepasoRegistros.
     * @param {repasoRegistrosCreateManyArgs} args - Arguments to create many RepasoRegistros.
     * @example
     * // Create many RepasoRegistros
     * const repasoRegistros = await prisma.repasoRegistros.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends repasoRegistrosCreateManyArgs>(args?: SelectSubset<T, repasoRegistrosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RepasoRegistros and returns the data saved in the database.
     * @param {repasoRegistrosCreateManyAndReturnArgs} args - Arguments to create many RepasoRegistros.
     * @example
     * // Create many RepasoRegistros
     * const repasoRegistros = await prisma.repasoRegistros.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RepasoRegistros and only return the `id`
     * const repasoRegistrosWithIdOnly = await prisma.repasoRegistros.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends repasoRegistrosCreateManyAndReturnArgs>(args?: SelectSubset<T, repasoRegistrosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$repasoRegistrosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RepasoRegistros.
     * @param {repasoRegistrosDeleteArgs} args - Arguments to delete one RepasoRegistros.
     * @example
     * // Delete one RepasoRegistros
     * const RepasoRegistros = await prisma.repasoRegistros.delete({
     *   where: {
     *     // ... filter to delete one RepasoRegistros
     *   }
     * })
     * 
     */
    delete<T extends repasoRegistrosDeleteArgs>(args: SelectSubset<T, repasoRegistrosDeleteArgs<ExtArgs>>): Prisma__repasoRegistrosClient<$Result.GetResult<Prisma.$repasoRegistrosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RepasoRegistros.
     * @param {repasoRegistrosUpdateArgs} args - Arguments to update one RepasoRegistros.
     * @example
     * // Update one RepasoRegistros
     * const repasoRegistros = await prisma.repasoRegistros.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends repasoRegistrosUpdateArgs>(args: SelectSubset<T, repasoRegistrosUpdateArgs<ExtArgs>>): Prisma__repasoRegistrosClient<$Result.GetResult<Prisma.$repasoRegistrosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RepasoRegistros.
     * @param {repasoRegistrosDeleteManyArgs} args - Arguments to filter RepasoRegistros to delete.
     * @example
     * // Delete a few RepasoRegistros
     * const { count } = await prisma.repasoRegistros.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends repasoRegistrosDeleteManyArgs>(args?: SelectSubset<T, repasoRegistrosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RepasoRegistros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {repasoRegistrosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RepasoRegistros
     * const repasoRegistros = await prisma.repasoRegistros.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends repasoRegistrosUpdateManyArgs>(args: SelectSubset<T, repasoRegistrosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RepasoRegistros and returns the data updated in the database.
     * @param {repasoRegistrosUpdateManyAndReturnArgs} args - Arguments to update many RepasoRegistros.
     * @example
     * // Update many RepasoRegistros
     * const repasoRegistros = await prisma.repasoRegistros.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RepasoRegistros and only return the `id`
     * const repasoRegistrosWithIdOnly = await prisma.repasoRegistros.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends repasoRegistrosUpdateManyAndReturnArgs>(args: SelectSubset<T, repasoRegistrosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$repasoRegistrosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RepasoRegistros.
     * @param {repasoRegistrosUpsertArgs} args - Arguments to update or create a RepasoRegistros.
     * @example
     * // Update or create a RepasoRegistros
     * const repasoRegistros = await prisma.repasoRegistros.upsert({
     *   create: {
     *     // ... data to create a RepasoRegistros
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RepasoRegistros we want to update
     *   }
     * })
     */
    upsert<T extends repasoRegistrosUpsertArgs>(args: SelectSubset<T, repasoRegistrosUpsertArgs<ExtArgs>>): Prisma__repasoRegistrosClient<$Result.GetResult<Prisma.$repasoRegistrosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RepasoRegistros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {repasoRegistrosCountArgs} args - Arguments to filter RepasoRegistros to count.
     * @example
     * // Count the number of RepasoRegistros
     * const count = await prisma.repasoRegistros.count({
     *   where: {
     *     // ... the filter for the RepasoRegistros we want to count
     *   }
     * })
    **/
    count<T extends repasoRegistrosCountArgs>(
      args?: Subset<T, repasoRegistrosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RepasoRegistrosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RepasoRegistros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepasoRegistrosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RepasoRegistrosAggregateArgs>(args: Subset<T, RepasoRegistrosAggregateArgs>): Prisma.PrismaPromise<GetRepasoRegistrosAggregateType<T>>

    /**
     * Group by RepasoRegistros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {repasoRegistrosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends repasoRegistrosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: repasoRegistrosGroupByArgs['orderBy'] }
        : { orderBy?: repasoRegistrosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, repasoRegistrosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepasoRegistrosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the repasoRegistros model
   */
  readonly fields: repasoRegistrosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for repasoRegistros.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__repasoRegistrosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    banqueo<T extends banqueoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, banqueoDefaultArgs<ExtArgs>>): Prisma__banqueoClient<$Result.GetResult<Prisma.$banqueoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    preguntas<T extends preguntasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, preguntasDefaultArgs<ExtArgs>>): Prisma__preguntasClient<$Result.GetResult<Prisma.$preguntasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usuariosEstudiantes<T extends usuariosEstudiantesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usuariosEstudiantesDefaultArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the repasoRegistros model
   */
  interface repasoRegistrosFieldRefs {
    readonly id: FieldRef<"repasoRegistros", 'String'>
    readonly usuarioEstudianteId: FieldRef<"repasoRegistros", 'String'>
    readonly banqueoId: FieldRef<"repasoRegistros", 'String'>
    readonly preguntaId: FieldRef<"repasoRegistros", 'String'>
    readonly esCorrecta: FieldRef<"repasoRegistros", 'Boolean'>
    readonly creadoEn: FieldRef<"repasoRegistros", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * repasoRegistros findUnique
   */
  export type repasoRegistrosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repasoRegistros
     */
    select?: repasoRegistrosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repasoRegistros
     */
    omit?: repasoRegistrosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: repasoRegistrosInclude<ExtArgs> | null
    /**
     * Filter, which repasoRegistros to fetch.
     */
    where: repasoRegistrosWhereUniqueInput
  }

  /**
   * repasoRegistros findUniqueOrThrow
   */
  export type repasoRegistrosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repasoRegistros
     */
    select?: repasoRegistrosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repasoRegistros
     */
    omit?: repasoRegistrosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: repasoRegistrosInclude<ExtArgs> | null
    /**
     * Filter, which repasoRegistros to fetch.
     */
    where: repasoRegistrosWhereUniqueInput
  }

  /**
   * repasoRegistros findFirst
   */
  export type repasoRegistrosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repasoRegistros
     */
    select?: repasoRegistrosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repasoRegistros
     */
    omit?: repasoRegistrosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: repasoRegistrosInclude<ExtArgs> | null
    /**
     * Filter, which repasoRegistros to fetch.
     */
    where?: repasoRegistrosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of repasoRegistros to fetch.
     */
    orderBy?: repasoRegistrosOrderByWithRelationInput | repasoRegistrosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for repasoRegistros.
     */
    cursor?: repasoRegistrosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` repasoRegistros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` repasoRegistros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of repasoRegistros.
     */
    distinct?: RepasoRegistrosScalarFieldEnum | RepasoRegistrosScalarFieldEnum[]
  }

  /**
   * repasoRegistros findFirstOrThrow
   */
  export type repasoRegistrosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repasoRegistros
     */
    select?: repasoRegistrosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repasoRegistros
     */
    omit?: repasoRegistrosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: repasoRegistrosInclude<ExtArgs> | null
    /**
     * Filter, which repasoRegistros to fetch.
     */
    where?: repasoRegistrosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of repasoRegistros to fetch.
     */
    orderBy?: repasoRegistrosOrderByWithRelationInput | repasoRegistrosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for repasoRegistros.
     */
    cursor?: repasoRegistrosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` repasoRegistros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` repasoRegistros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of repasoRegistros.
     */
    distinct?: RepasoRegistrosScalarFieldEnum | RepasoRegistrosScalarFieldEnum[]
  }

  /**
   * repasoRegistros findMany
   */
  export type repasoRegistrosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repasoRegistros
     */
    select?: repasoRegistrosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repasoRegistros
     */
    omit?: repasoRegistrosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: repasoRegistrosInclude<ExtArgs> | null
    /**
     * Filter, which repasoRegistros to fetch.
     */
    where?: repasoRegistrosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of repasoRegistros to fetch.
     */
    orderBy?: repasoRegistrosOrderByWithRelationInput | repasoRegistrosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing repasoRegistros.
     */
    cursor?: repasoRegistrosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` repasoRegistros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` repasoRegistros.
     */
    skip?: number
    distinct?: RepasoRegistrosScalarFieldEnum | RepasoRegistrosScalarFieldEnum[]
  }

  /**
   * repasoRegistros create
   */
  export type repasoRegistrosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repasoRegistros
     */
    select?: repasoRegistrosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repasoRegistros
     */
    omit?: repasoRegistrosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: repasoRegistrosInclude<ExtArgs> | null
    /**
     * The data needed to create a repasoRegistros.
     */
    data: XOR<repasoRegistrosCreateInput, repasoRegistrosUncheckedCreateInput>
  }

  /**
   * repasoRegistros createMany
   */
  export type repasoRegistrosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many repasoRegistros.
     */
    data: repasoRegistrosCreateManyInput | repasoRegistrosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * repasoRegistros createManyAndReturn
   */
  export type repasoRegistrosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repasoRegistros
     */
    select?: repasoRegistrosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the repasoRegistros
     */
    omit?: repasoRegistrosOmit<ExtArgs> | null
    /**
     * The data used to create many repasoRegistros.
     */
    data: repasoRegistrosCreateManyInput | repasoRegistrosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: repasoRegistrosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * repasoRegistros update
   */
  export type repasoRegistrosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repasoRegistros
     */
    select?: repasoRegistrosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repasoRegistros
     */
    omit?: repasoRegistrosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: repasoRegistrosInclude<ExtArgs> | null
    /**
     * The data needed to update a repasoRegistros.
     */
    data: XOR<repasoRegistrosUpdateInput, repasoRegistrosUncheckedUpdateInput>
    /**
     * Choose, which repasoRegistros to update.
     */
    where: repasoRegistrosWhereUniqueInput
  }

  /**
   * repasoRegistros updateMany
   */
  export type repasoRegistrosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update repasoRegistros.
     */
    data: XOR<repasoRegistrosUpdateManyMutationInput, repasoRegistrosUncheckedUpdateManyInput>
    /**
     * Filter which repasoRegistros to update
     */
    where?: repasoRegistrosWhereInput
    /**
     * Limit how many repasoRegistros to update.
     */
    limit?: number
  }

  /**
   * repasoRegistros updateManyAndReturn
   */
  export type repasoRegistrosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repasoRegistros
     */
    select?: repasoRegistrosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the repasoRegistros
     */
    omit?: repasoRegistrosOmit<ExtArgs> | null
    /**
     * The data used to update repasoRegistros.
     */
    data: XOR<repasoRegistrosUpdateManyMutationInput, repasoRegistrosUncheckedUpdateManyInput>
    /**
     * Filter which repasoRegistros to update
     */
    where?: repasoRegistrosWhereInput
    /**
     * Limit how many repasoRegistros to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: repasoRegistrosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * repasoRegistros upsert
   */
  export type repasoRegistrosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repasoRegistros
     */
    select?: repasoRegistrosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repasoRegistros
     */
    omit?: repasoRegistrosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: repasoRegistrosInclude<ExtArgs> | null
    /**
     * The filter to search for the repasoRegistros to update in case it exists.
     */
    where: repasoRegistrosWhereUniqueInput
    /**
     * In case the repasoRegistros found by the `where` argument doesn't exist, create a new repasoRegistros with this data.
     */
    create: XOR<repasoRegistrosCreateInput, repasoRegistrosUncheckedCreateInput>
    /**
     * In case the repasoRegistros was found with the provided `where` argument, update it with this data.
     */
    update: XOR<repasoRegistrosUpdateInput, repasoRegistrosUncheckedUpdateInput>
  }

  /**
   * repasoRegistros delete
   */
  export type repasoRegistrosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repasoRegistros
     */
    select?: repasoRegistrosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repasoRegistros
     */
    omit?: repasoRegistrosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: repasoRegistrosInclude<ExtArgs> | null
    /**
     * Filter which repasoRegistros to delete.
     */
    where: repasoRegistrosWhereUniqueInput
  }

  /**
   * repasoRegistros deleteMany
   */
  export type repasoRegistrosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which repasoRegistros to delete
     */
    where?: repasoRegistrosWhereInput
    /**
     * Limit how many repasoRegistros to delete.
     */
    limit?: number
  }

  /**
   * repasoRegistros without action
   */
  export type repasoRegistrosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repasoRegistros
     */
    select?: repasoRegistrosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repasoRegistros
     */
    omit?: repasoRegistrosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: repasoRegistrosInclude<ExtArgs> | null
  }


  /**
   * Model suscripciones
   */

  export type AggregateSuscripciones = {
    _count: SuscripcionesCountAggregateOutputType | null
    _avg: SuscripcionesAvgAggregateOutputType | null
    _sum: SuscripcionesSumAggregateOutputType | null
    _min: SuscripcionesMinAggregateOutputType | null
    _max: SuscripcionesMaxAggregateOutputType | null
  }

  export type SuscripcionesAvgAggregateOutputType = {
    montoUsd: number | null
  }

  export type SuscripcionesSumAggregateOutputType = {
    montoUsd: number | null
  }

  export type SuscripcionesMinAggregateOutputType = {
    id: string | null
    usuarioEstudianteId: string | null
    montoUsd: number | null
    fechaInicio: Date | null
    fechaFin: Date | null
    estado: $Enums.EstadoSuscripcion | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type SuscripcionesMaxAggregateOutputType = {
    id: string | null
    usuarioEstudianteId: string | null
    montoUsd: number | null
    fechaInicio: Date | null
    fechaFin: Date | null
    estado: $Enums.EstadoSuscripcion | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type SuscripcionesCountAggregateOutputType = {
    id: number
    usuarioEstudianteId: number
    montoUsd: number
    fechaInicio: number
    fechaFin: number
    estado: number
    creadoEn: number
    actualizadoEn: number
    _all: number
  }


  export type SuscripcionesAvgAggregateInputType = {
    montoUsd?: true
  }

  export type SuscripcionesSumAggregateInputType = {
    montoUsd?: true
  }

  export type SuscripcionesMinAggregateInputType = {
    id?: true
    usuarioEstudianteId?: true
    montoUsd?: true
    fechaInicio?: true
    fechaFin?: true
    estado?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type SuscripcionesMaxAggregateInputType = {
    id?: true
    usuarioEstudianteId?: true
    montoUsd?: true
    fechaInicio?: true
    fechaFin?: true
    estado?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type SuscripcionesCountAggregateInputType = {
    id?: true
    usuarioEstudianteId?: true
    montoUsd?: true
    fechaInicio?: true
    fechaFin?: true
    estado?: true
    creadoEn?: true
    actualizadoEn?: true
    _all?: true
  }

  export type SuscripcionesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which suscripciones to aggregate.
     */
    where?: suscripcionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suscripciones to fetch.
     */
    orderBy?: suscripcionesOrderByWithRelationInput | suscripcionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: suscripcionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suscripciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suscripciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned suscripciones
    **/
    _count?: true | SuscripcionesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SuscripcionesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SuscripcionesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuscripcionesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuscripcionesMaxAggregateInputType
  }

  export type GetSuscripcionesAggregateType<T extends SuscripcionesAggregateArgs> = {
        [P in keyof T & keyof AggregateSuscripciones]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuscripciones[P]>
      : GetScalarType<T[P], AggregateSuscripciones[P]>
  }




  export type suscripcionesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: suscripcionesWhereInput
    orderBy?: suscripcionesOrderByWithAggregationInput | suscripcionesOrderByWithAggregationInput[]
    by: SuscripcionesScalarFieldEnum[] | SuscripcionesScalarFieldEnum
    having?: suscripcionesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuscripcionesCountAggregateInputType | true
    _avg?: SuscripcionesAvgAggregateInputType
    _sum?: SuscripcionesSumAggregateInputType
    _min?: SuscripcionesMinAggregateInputType
    _max?: SuscripcionesMaxAggregateInputType
  }

  export type SuscripcionesGroupByOutputType = {
    id: string
    usuarioEstudianteId: string
    montoUsd: number
    fechaInicio: Date
    fechaFin: Date
    estado: $Enums.EstadoSuscripcion
    creadoEn: Date
    actualizadoEn: Date
    _count: SuscripcionesCountAggregateOutputType | null
    _avg: SuscripcionesAvgAggregateOutputType | null
    _sum: SuscripcionesSumAggregateOutputType | null
    _min: SuscripcionesMinAggregateOutputType | null
    _max: SuscripcionesMaxAggregateOutputType | null
  }

  type GetSuscripcionesGroupByPayload<T extends suscripcionesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuscripcionesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuscripcionesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuscripcionesGroupByOutputType[P]>
            : GetScalarType<T[P], SuscripcionesGroupByOutputType[P]>
        }
      >
    >


  export type suscripcionesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioEstudianteId?: boolean
    montoUsd?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    usuariosEstudiantes?: boolean | usuariosEstudiantesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["suscripciones"]>

  export type suscripcionesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioEstudianteId?: boolean
    montoUsd?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    usuariosEstudiantes?: boolean | usuariosEstudiantesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["suscripciones"]>

  export type suscripcionesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioEstudianteId?: boolean
    montoUsd?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    usuariosEstudiantes?: boolean | usuariosEstudiantesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["suscripciones"]>

  export type suscripcionesSelectScalar = {
    id?: boolean
    usuarioEstudianteId?: boolean
    montoUsd?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    estado?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }

  export type suscripcionesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuarioEstudianteId" | "montoUsd" | "fechaInicio" | "fechaFin" | "estado" | "creadoEn" | "actualizadoEn", ExtArgs["result"]["suscripciones"]>
  export type suscripcionesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuariosEstudiantes?: boolean | usuariosEstudiantesDefaultArgs<ExtArgs>
  }
  export type suscripcionesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuariosEstudiantes?: boolean | usuariosEstudiantesDefaultArgs<ExtArgs>
  }
  export type suscripcionesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuariosEstudiantes?: boolean | usuariosEstudiantesDefaultArgs<ExtArgs>
  }

  export type $suscripcionesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "suscripciones"
    objects: {
      usuariosEstudiantes: Prisma.$usuariosEstudiantesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usuarioEstudianteId: string
      montoUsd: number
      fechaInicio: Date
      fechaFin: Date
      estado: $Enums.EstadoSuscripcion
      creadoEn: Date
      actualizadoEn: Date
    }, ExtArgs["result"]["suscripciones"]>
    composites: {}
  }

  type suscripcionesGetPayload<S extends boolean | null | undefined | suscripcionesDefaultArgs> = $Result.GetResult<Prisma.$suscripcionesPayload, S>

  type suscripcionesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<suscripcionesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SuscripcionesCountAggregateInputType | true
    }

  export interface suscripcionesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['suscripciones'], meta: { name: 'suscripciones' } }
    /**
     * Find zero or one Suscripciones that matches the filter.
     * @param {suscripcionesFindUniqueArgs} args - Arguments to find a Suscripciones
     * @example
     * // Get one Suscripciones
     * const suscripciones = await prisma.suscripciones.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends suscripcionesFindUniqueArgs>(args: SelectSubset<T, suscripcionesFindUniqueArgs<ExtArgs>>): Prisma__suscripcionesClient<$Result.GetResult<Prisma.$suscripcionesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Suscripciones that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {suscripcionesFindUniqueOrThrowArgs} args - Arguments to find a Suscripciones
     * @example
     * // Get one Suscripciones
     * const suscripciones = await prisma.suscripciones.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends suscripcionesFindUniqueOrThrowArgs>(args: SelectSubset<T, suscripcionesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__suscripcionesClient<$Result.GetResult<Prisma.$suscripcionesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Suscripciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suscripcionesFindFirstArgs} args - Arguments to find a Suscripciones
     * @example
     * // Get one Suscripciones
     * const suscripciones = await prisma.suscripciones.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends suscripcionesFindFirstArgs>(args?: SelectSubset<T, suscripcionesFindFirstArgs<ExtArgs>>): Prisma__suscripcionesClient<$Result.GetResult<Prisma.$suscripcionesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Suscripciones that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suscripcionesFindFirstOrThrowArgs} args - Arguments to find a Suscripciones
     * @example
     * // Get one Suscripciones
     * const suscripciones = await prisma.suscripciones.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends suscripcionesFindFirstOrThrowArgs>(args?: SelectSubset<T, suscripcionesFindFirstOrThrowArgs<ExtArgs>>): Prisma__suscripcionesClient<$Result.GetResult<Prisma.$suscripcionesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Suscripciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suscripcionesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suscripciones
     * const suscripciones = await prisma.suscripciones.findMany()
     * 
     * // Get first 10 Suscripciones
     * const suscripciones = await prisma.suscripciones.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const suscripcionesWithIdOnly = await prisma.suscripciones.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends suscripcionesFindManyArgs>(args?: SelectSubset<T, suscripcionesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$suscripcionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Suscripciones.
     * @param {suscripcionesCreateArgs} args - Arguments to create a Suscripciones.
     * @example
     * // Create one Suscripciones
     * const Suscripciones = await prisma.suscripciones.create({
     *   data: {
     *     // ... data to create a Suscripciones
     *   }
     * })
     * 
     */
    create<T extends suscripcionesCreateArgs>(args: SelectSubset<T, suscripcionesCreateArgs<ExtArgs>>): Prisma__suscripcionesClient<$Result.GetResult<Prisma.$suscripcionesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Suscripciones.
     * @param {suscripcionesCreateManyArgs} args - Arguments to create many Suscripciones.
     * @example
     * // Create many Suscripciones
     * const suscripciones = await prisma.suscripciones.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends suscripcionesCreateManyArgs>(args?: SelectSubset<T, suscripcionesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suscripciones and returns the data saved in the database.
     * @param {suscripcionesCreateManyAndReturnArgs} args - Arguments to create many Suscripciones.
     * @example
     * // Create many Suscripciones
     * const suscripciones = await prisma.suscripciones.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suscripciones and only return the `id`
     * const suscripcionesWithIdOnly = await prisma.suscripciones.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends suscripcionesCreateManyAndReturnArgs>(args?: SelectSubset<T, suscripcionesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$suscripcionesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Suscripciones.
     * @param {suscripcionesDeleteArgs} args - Arguments to delete one Suscripciones.
     * @example
     * // Delete one Suscripciones
     * const Suscripciones = await prisma.suscripciones.delete({
     *   where: {
     *     // ... filter to delete one Suscripciones
     *   }
     * })
     * 
     */
    delete<T extends suscripcionesDeleteArgs>(args: SelectSubset<T, suscripcionesDeleteArgs<ExtArgs>>): Prisma__suscripcionesClient<$Result.GetResult<Prisma.$suscripcionesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Suscripciones.
     * @param {suscripcionesUpdateArgs} args - Arguments to update one Suscripciones.
     * @example
     * // Update one Suscripciones
     * const suscripciones = await prisma.suscripciones.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends suscripcionesUpdateArgs>(args: SelectSubset<T, suscripcionesUpdateArgs<ExtArgs>>): Prisma__suscripcionesClient<$Result.GetResult<Prisma.$suscripcionesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Suscripciones.
     * @param {suscripcionesDeleteManyArgs} args - Arguments to filter Suscripciones to delete.
     * @example
     * // Delete a few Suscripciones
     * const { count } = await prisma.suscripciones.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends suscripcionesDeleteManyArgs>(args?: SelectSubset<T, suscripcionesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suscripciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suscripcionesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suscripciones
     * const suscripciones = await prisma.suscripciones.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends suscripcionesUpdateManyArgs>(args: SelectSubset<T, suscripcionesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suscripciones and returns the data updated in the database.
     * @param {suscripcionesUpdateManyAndReturnArgs} args - Arguments to update many Suscripciones.
     * @example
     * // Update many Suscripciones
     * const suscripciones = await prisma.suscripciones.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Suscripciones and only return the `id`
     * const suscripcionesWithIdOnly = await prisma.suscripciones.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends suscripcionesUpdateManyAndReturnArgs>(args: SelectSubset<T, suscripcionesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$suscripcionesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Suscripciones.
     * @param {suscripcionesUpsertArgs} args - Arguments to update or create a Suscripciones.
     * @example
     * // Update or create a Suscripciones
     * const suscripciones = await prisma.suscripciones.upsert({
     *   create: {
     *     // ... data to create a Suscripciones
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Suscripciones we want to update
     *   }
     * })
     */
    upsert<T extends suscripcionesUpsertArgs>(args: SelectSubset<T, suscripcionesUpsertArgs<ExtArgs>>): Prisma__suscripcionesClient<$Result.GetResult<Prisma.$suscripcionesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Suscripciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suscripcionesCountArgs} args - Arguments to filter Suscripciones to count.
     * @example
     * // Count the number of Suscripciones
     * const count = await prisma.suscripciones.count({
     *   where: {
     *     // ... the filter for the Suscripciones we want to count
     *   }
     * })
    **/
    count<T extends suscripcionesCountArgs>(
      args?: Subset<T, suscripcionesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuscripcionesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Suscripciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuscripcionesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuscripcionesAggregateArgs>(args: Subset<T, SuscripcionesAggregateArgs>): Prisma.PrismaPromise<GetSuscripcionesAggregateType<T>>

    /**
     * Group by Suscripciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {suscripcionesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends suscripcionesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: suscripcionesGroupByArgs['orderBy'] }
        : { orderBy?: suscripcionesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, suscripcionesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuscripcionesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the suscripciones model
   */
  readonly fields: suscripcionesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for suscripciones.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__suscripcionesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuariosEstudiantes<T extends usuariosEstudiantesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usuariosEstudiantesDefaultArgs<ExtArgs>>): Prisma__usuariosEstudiantesClient<$Result.GetResult<Prisma.$usuariosEstudiantesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the suscripciones model
   */
  interface suscripcionesFieldRefs {
    readonly id: FieldRef<"suscripciones", 'String'>
    readonly usuarioEstudianteId: FieldRef<"suscripciones", 'String'>
    readonly montoUsd: FieldRef<"suscripciones", 'Float'>
    readonly fechaInicio: FieldRef<"suscripciones", 'DateTime'>
    readonly fechaFin: FieldRef<"suscripciones", 'DateTime'>
    readonly estado: FieldRef<"suscripciones", 'EstadoSuscripcion'>
    readonly creadoEn: FieldRef<"suscripciones", 'DateTime'>
    readonly actualizadoEn: FieldRef<"suscripciones", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * suscripciones findUnique
   */
  export type suscripcionesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suscripciones
     */
    select?: suscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suscripciones
     */
    omit?: suscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suscripcionesInclude<ExtArgs> | null
    /**
     * Filter, which suscripciones to fetch.
     */
    where: suscripcionesWhereUniqueInput
  }

  /**
   * suscripciones findUniqueOrThrow
   */
  export type suscripcionesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suscripciones
     */
    select?: suscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suscripciones
     */
    omit?: suscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suscripcionesInclude<ExtArgs> | null
    /**
     * Filter, which suscripciones to fetch.
     */
    where: suscripcionesWhereUniqueInput
  }

  /**
   * suscripciones findFirst
   */
  export type suscripcionesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suscripciones
     */
    select?: suscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suscripciones
     */
    omit?: suscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suscripcionesInclude<ExtArgs> | null
    /**
     * Filter, which suscripciones to fetch.
     */
    where?: suscripcionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suscripciones to fetch.
     */
    orderBy?: suscripcionesOrderByWithRelationInput | suscripcionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for suscripciones.
     */
    cursor?: suscripcionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suscripciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suscripciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of suscripciones.
     */
    distinct?: SuscripcionesScalarFieldEnum | SuscripcionesScalarFieldEnum[]
  }

  /**
   * suscripciones findFirstOrThrow
   */
  export type suscripcionesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suscripciones
     */
    select?: suscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suscripciones
     */
    omit?: suscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suscripcionesInclude<ExtArgs> | null
    /**
     * Filter, which suscripciones to fetch.
     */
    where?: suscripcionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suscripciones to fetch.
     */
    orderBy?: suscripcionesOrderByWithRelationInput | suscripcionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for suscripciones.
     */
    cursor?: suscripcionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suscripciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suscripciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of suscripciones.
     */
    distinct?: SuscripcionesScalarFieldEnum | SuscripcionesScalarFieldEnum[]
  }

  /**
   * suscripciones findMany
   */
  export type suscripcionesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suscripciones
     */
    select?: suscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suscripciones
     */
    omit?: suscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suscripcionesInclude<ExtArgs> | null
    /**
     * Filter, which suscripciones to fetch.
     */
    where?: suscripcionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of suscripciones to fetch.
     */
    orderBy?: suscripcionesOrderByWithRelationInput | suscripcionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing suscripciones.
     */
    cursor?: suscripcionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` suscripciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` suscripciones.
     */
    skip?: number
    distinct?: SuscripcionesScalarFieldEnum | SuscripcionesScalarFieldEnum[]
  }

  /**
   * suscripciones create
   */
  export type suscripcionesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suscripciones
     */
    select?: suscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suscripciones
     */
    omit?: suscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suscripcionesInclude<ExtArgs> | null
    /**
     * The data needed to create a suscripciones.
     */
    data: XOR<suscripcionesCreateInput, suscripcionesUncheckedCreateInput>
  }

  /**
   * suscripciones createMany
   */
  export type suscripcionesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many suscripciones.
     */
    data: suscripcionesCreateManyInput | suscripcionesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * suscripciones createManyAndReturn
   */
  export type suscripcionesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suscripciones
     */
    select?: suscripcionesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the suscripciones
     */
    omit?: suscripcionesOmit<ExtArgs> | null
    /**
     * The data used to create many suscripciones.
     */
    data: suscripcionesCreateManyInput | suscripcionesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suscripcionesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * suscripciones update
   */
  export type suscripcionesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suscripciones
     */
    select?: suscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suscripciones
     */
    omit?: suscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suscripcionesInclude<ExtArgs> | null
    /**
     * The data needed to update a suscripciones.
     */
    data: XOR<suscripcionesUpdateInput, suscripcionesUncheckedUpdateInput>
    /**
     * Choose, which suscripciones to update.
     */
    where: suscripcionesWhereUniqueInput
  }

  /**
   * suscripciones updateMany
   */
  export type suscripcionesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update suscripciones.
     */
    data: XOR<suscripcionesUpdateManyMutationInput, suscripcionesUncheckedUpdateManyInput>
    /**
     * Filter which suscripciones to update
     */
    where?: suscripcionesWhereInput
    /**
     * Limit how many suscripciones to update.
     */
    limit?: number
  }

  /**
   * suscripciones updateManyAndReturn
   */
  export type suscripcionesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suscripciones
     */
    select?: suscripcionesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the suscripciones
     */
    omit?: suscripcionesOmit<ExtArgs> | null
    /**
     * The data used to update suscripciones.
     */
    data: XOR<suscripcionesUpdateManyMutationInput, suscripcionesUncheckedUpdateManyInput>
    /**
     * Filter which suscripciones to update
     */
    where?: suscripcionesWhereInput
    /**
     * Limit how many suscripciones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suscripcionesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * suscripciones upsert
   */
  export type suscripcionesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suscripciones
     */
    select?: suscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suscripciones
     */
    omit?: suscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suscripcionesInclude<ExtArgs> | null
    /**
     * The filter to search for the suscripciones to update in case it exists.
     */
    where: suscripcionesWhereUniqueInput
    /**
     * In case the suscripciones found by the `where` argument doesn't exist, create a new suscripciones with this data.
     */
    create: XOR<suscripcionesCreateInput, suscripcionesUncheckedCreateInput>
    /**
     * In case the suscripciones was found with the provided `where` argument, update it with this data.
     */
    update: XOR<suscripcionesUpdateInput, suscripcionesUncheckedUpdateInput>
  }

  /**
   * suscripciones delete
   */
  export type suscripcionesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suscripciones
     */
    select?: suscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suscripciones
     */
    omit?: suscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suscripcionesInclude<ExtArgs> | null
    /**
     * Filter which suscripciones to delete.
     */
    where: suscripcionesWhereUniqueInput
  }

  /**
   * suscripciones deleteMany
   */
  export type suscripcionesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which suscripciones to delete
     */
    where?: suscripcionesWhereInput
    /**
     * Limit how many suscripciones to delete.
     */
    limit?: number
  }

  /**
   * suscripciones without action
   */
  export type suscripcionesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the suscripciones
     */
    select?: suscripcionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the suscripciones
     */
    omit?: suscripcionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: suscripcionesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AuditoriaScalarFieldEnum: {
    id: 'id',
    tabla: 'tabla',
    registroId: 'registroId',
    accion: 'accion',
    detalles: 'detalles',
    usuarioId: 'usuarioId',
    creadoEn: 'creadoEn'
  };

  export type AuditoriaScalarFieldEnum = (typeof AuditoriaScalarFieldEnum)[keyof typeof AuditoriaScalarFieldEnum]


  export const BeneficiosCursosScalarFieldEnum: {
    id: 'id',
    cursoId: 'cursoId',
    descripcion: 'descripcion',
    orden: 'orden',
    creadoEn: 'creadoEn'
  };

  export type BeneficiosCursosScalarFieldEnum = (typeof BeneficiosCursosScalarFieldEnum)[keyof typeof BeneficiosCursosScalarFieldEnum]


  export const CalificacionesScalarFieldEnum: {
    id: 'id',
    aprobado: 'aprobado',
    comentarios: 'comentarios',
    estudianteId: 'estudianteId',
    examenId: 'examenId',
    nota: 'nota',
    creadoEn: 'creadoEn'
  };

  export type CalificacionesScalarFieldEnum = (typeof CalificacionesScalarFieldEnum)[keyof typeof CalificacionesScalarFieldEnum]


  export const CategoriasScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn'
  };

  export type CategoriasScalarFieldEnum = (typeof CategoriasScalarFieldEnum)[keyof typeof CategoriasScalarFieldEnum]


  export const CategoriasCursosScalarFieldEnum: {
    id: 'id',
    categoriaId: 'categoriaId',
    cursoId: 'cursoId'
  };

  export type CategoriasCursosScalarFieldEnum = (typeof CategoriasCursosScalarFieldEnum)[keyof typeof CategoriasCursosScalarFieldEnum]


  export const CertificadosScalarFieldEnum: {
    id: 'id',
    codigoUnico: 'codigoUnico',
    edicionId: 'edicionId',
    estudianteId: 'estudianteId',
    fechaEmision: 'fechaEmision',
    tipo: 'tipo',
    notaFinal: 'notaFinal',
    urlCertificado: 'urlCertificado',
    creadoEn: 'creadoEn'
  };

  export type CertificadosScalarFieldEnum = (typeof CertificadosScalarFieldEnum)[keyof typeof CertificadosScalarFieldEnum]


  export const ClasesScalarFieldEnum: {
    id: 'id',
    edicionId: 'edicionId',
    descripcion: 'descripcion',
    duracion: 'duracion',
    fecha: 'fecha',
    orden: 'orden',
    titulo: 'titulo',
    urlYoutube: 'urlYoutube',
    creadoEn: 'creadoEn',
    urlPresentacion: 'urlPresentacion'
  };

  export type ClasesScalarFieldEnum = (typeof ClasesScalarFieldEnum)[keyof typeof ClasesScalarFieldEnum]


  export const ComprasScalarFieldEnum: {
    id: 'id',
    edicionId: 'edicionId',
    monto: 'monto',
    moneda: 'moneda',
    comprobado: 'comprobado',
    providerId: 'providerId',
    fechaCompra: 'fechaCompra',
    metodo: 'metodo',
    deuda: 'deuda',
    usuariosEstudiantesId: 'usuariosEstudiantesId',
    estadoPago: 'estadoPago',
    updatedAt: 'updatedAt',
    conDescuento: 'conDescuento'
  };

  export type ComprasScalarFieldEnum = (typeof ComprasScalarFieldEnum)[keyof typeof ComprasScalarFieldEnum]


  export const CursosScalarFieldEnum: {
    id: 'id',
    descripcion: 'descripcion',
    titulo: 'titulo',
    urlMiniatura: 'urlMiniatura',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn',
    descripcionCorta: 'descripcionCorta',
    enVivo: 'enVivo',
    urlCurso: 'urlCurso',
    cargaHoraria: 'cargaHoraria',
    codigo: 'codigo'
  };

  export type CursosScalarFieldEnum = (typeof CursosScalarFieldEnum)[keyof typeof CursosScalarFieldEnum]


  export const DocenteScalarFieldEnum: {
    id: 'id',
    nombre_completo: 'nombre_completo',
    celular: 'celular',
    especialidad: 'especialidad',
    experiencia: 'experiencia',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn',
    usuarioId: 'usuarioId',
    pais: 'pais'
  };

  export type DocenteScalarFieldEnum = (typeof DocenteScalarFieldEnum)[keyof typeof DocenteScalarFieldEnum]


  export const EdicionesCursosScalarFieldEnum: {
    id: 'id',
    codigo: 'codigo',
    cursoId: 'cursoId',
    descripcion: 'descripcion',
    estado: 'estado',
    fechaFin: 'fechaFin',
    fechaInicio: 'fechaInicio',
    notaMaxima: 'notaMaxima',
    notaMinima: 'notaMinima',
    urlWhatsapp: 'urlWhatsapp',
    vigente: 'vigente',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn',
    docenteId: 'docenteId'
  };

  export type EdicionesCursosScalarFieldEnum = (typeof EdicionesCursosScalarFieldEnum)[keyof typeof EdicionesCursosScalarFieldEnum]


  export const EstudiantesScalarFieldEnum: {
    id: 'id',
    apellido: 'apellido',
    celular: 'celular',
    pais: 'pais',
    genero: 'genero',
    fechaNacimiento: 'fechaNacimiento',
    nombre: 'nombre',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn',
    nroUpdates: 'nroUpdates'
  };

  export type EstudiantesScalarFieldEnum = (typeof EstudiantesScalarFieldEnum)[keyof typeof EstudiantesScalarFieldEnum]


  export const TemasScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    descripcion: 'descripcion',
    capituloId: 'capituloId',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn'
  };

  export type TemasScalarFieldEnum = (typeof TemasScalarFieldEnum)[keyof typeof TemasScalarFieldEnum]


  export const ExamenesScalarFieldEnum: {
    id: 'id',
    edicionId: 'edicionId',
    descripcion: 'descripcion',
    fechaDisponible: 'fechaDisponible',
    fechaLimite: 'fechaLimite',
    notaMaxima: 'notaMaxima',
    notaMinima: 'notaMinima',
    titulo: 'titulo',
    creadoEn: 'creadoEn'
  };

  export type ExamenesScalarFieldEnum = (typeof ExamenesScalarFieldEnum)[keyof typeof ExamenesScalarFieldEnum]


  export const GrabacionesScalarFieldEnum: {
    id: 'id',
    claseId: 'claseId',
    usuarioId: 'usuarioId',
    fechaInicio: 'fechaInicio',
    fechaFin: 'fechaFin',
    duracionSegundos: 'duracionSegundos',
    completada: 'completada'
  };

  export type GrabacionesScalarFieldEnum = (typeof GrabacionesScalarFieldEnum)[keyof typeof GrabacionesScalarFieldEnum]


  export const InscripcionesScalarFieldEnum: {
    id: 'id',
    edicionId: 'edicionId',
    estado: 'estado',
    estudianteId: 'estudianteId',
    inscritoEn: 'inscritoEn',
    compraId: 'compraId'
  };

  export type InscripcionesScalarFieldEnum = (typeof InscripcionesScalarFieldEnum)[keyof typeof InscripcionesScalarFieldEnum]


  export const MaterialesScalarFieldEnum: {
    id: 'id',
    claseId: 'claseId',
    tipo: 'tipo',
    titulo: 'titulo',
    url: 'url',
    creadoEn: 'creadoEn'
  };

  export type MaterialesScalarFieldEnum = (typeof MaterialesScalarFieldEnum)[keyof typeof MaterialesScalarFieldEnum]


  export const ObjetivosCursosScalarFieldEnum: {
    id: 'id',
    cursoId: 'cursoId',
    descripcion: 'descripcion',
    orden: 'orden',
    creadoEn: 'creadoEn'
  };

  export type ObjetivosCursosScalarFieldEnum = (typeof ObjetivosCursosScalarFieldEnum)[keyof typeof ObjetivosCursosScalarFieldEnum]


  export const PagosDocentesScalarFieldEnum: {
    id: 'id',
    docenteId: 'docenteId',
    edicionId: 'edicionId',
    monto: 'monto',
    deuda: 'deuda',
    estadoPago: 'estadoPago',
    fechaPago: 'fechaPago',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn'
  };

  export type PagosDocentesScalarFieldEnum = (typeof PagosDocentesScalarFieldEnum)[keyof typeof PagosDocentesScalarFieldEnum]


  export const PreciosCursosScalarFieldEnum: {
    id: 'id',
    edicionId: 'edicionId',
    fechaInicio: 'fechaInicio',
    fechaFin: 'fechaFin',
    esDescuento: 'esDescuento',
    esPrecioDefault: 'esPrecioDefault',
    moneda: 'moneda',
    nombre: 'nombre',
    porcentajeDescuento: 'porcentajeDescuento',
    precio: 'precio',
    precioOriginal: 'precioOriginal',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn'
  };

  export type PreciosCursosScalarFieldEnum = (typeof PreciosCursosScalarFieldEnum)[keyof typeof PreciosCursosScalarFieldEnum]


  export const PreguntasScalarFieldEnum: {
    id: 'id',
    codigo: 'codigo',
    enunciado: 'enunciado',
    explicacion: 'explicacion',
    referencia: 'referencia',
    opciones: 'opciones',
    solucion: 'solucion',
    estado: 'estado',
    gestion: 'gestion',
    likes: 'likes',
    dislikes: 'dislikes',
    dificultad: 'dificultad',
    dificultadActualizadaEn: 'dificultadActualizadaEn',
    tasaAcierto: 'tasaAcierto',
    totalBien: 'totalBien',
    totalMal: 'totalMal',
    totalRespondidas: 'totalRespondidas',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn'
  };

  export type PreguntasScalarFieldEnum = (typeof PreguntasScalarFieldEnum)[keyof typeof PreguntasScalarFieldEnum]


  export const ReaccionesPreguntasScalarFieldEnum: {
    id: 'id',
    preguntaId: 'preguntaId',
    usuarioEstudianteId: 'usuarioEstudianteId',
    tipo: 'tipo',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn'
  };

  export type ReaccionesPreguntasScalarFieldEnum = (typeof ReaccionesPreguntasScalarFieldEnum)[keyof typeof ReaccionesPreguntasScalarFieldEnum]


  export const RequisitosCursosScalarFieldEnum: {
    id: 'id',
    cursoId: 'cursoId',
    descripcion: 'descripcion',
    orden: 'orden',
    creadoEn: 'creadoEn'
  };

  export type RequisitosCursosScalarFieldEnum = (typeof RequisitosCursosScalarFieldEnum)[keyof typeof RequisitosCursosScalarFieldEnum]


  export const ReviewsCursosScalarFieldEnum: {
    id: 'id',
    cursoId: 'cursoId',
    rating: 'rating',
    comentario: 'comentario',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn',
    usuariosEstudiantesId: 'usuariosEstudiantesId'
  };

  export type ReviewsCursosScalarFieldEnum = (typeof ReviewsCursosScalarFieldEnum)[keyof typeof ReviewsCursosScalarFieldEnum]


  export const UsuariosAdministradoresScalarFieldEnum: {
    id: 'id',
    correo: 'correo',
    contrasena: 'contrasena',
    encargado: 'encargado',
    estado: 'estado',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn',
    tipo: 'tipo'
  };

  export type UsuariosAdministradoresScalarFieldEnum = (typeof UsuariosAdministradoresScalarFieldEnum)[keyof typeof UsuariosAdministradoresScalarFieldEnum]


  export const UsuariosEstudiantesScalarFieldEnum: {
    id: 'id',
    correo: 'correo',
    contrasena: 'contrasena',
    usuario: 'usuario',
    estado: 'estado',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn',
    avatar: 'avatar',
    estudianteId: 'estudianteId',
    registrado: 'registrado'
  };

  export type UsuariosEstudiantesScalarFieldEnum = (typeof UsuariosEstudiantesScalarFieldEnum)[keyof typeof UsuariosEstudiantesScalarFieldEnum]


  export const AreasScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    descripcion: 'descripcion',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn'
  };

  export type AreasScalarFieldEnum = (typeof AreasScalarFieldEnum)[keyof typeof AreasScalarFieldEnum]


  export const BanqueoScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    tipo: 'tipo',
    tipoCreado: 'tipoCreado',
    duracion: 'duracion',
    maxPreguntas: 'maxPreguntas',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn'
  };

  export type BanqueoScalarFieldEnum = (typeof BanqueoScalarFieldEnum)[keyof typeof BanqueoScalarFieldEnum]


  export const CapitulosScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    descripcion: 'descripcion',
    areaId: 'areaId',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn'
  };

  export type CapitulosScalarFieldEnum = (typeof CapitulosScalarFieldEnum)[keyof typeof CapitulosScalarFieldEnum]


  export const IntentosScalarFieldEnum: {
    id: 'id',
    banqueoId: 'banqueoId',
    usuarioEstudianteId: 'usuarioEstudianteId',
    tiempoDuracion: 'tiempoDuracion',
    correctas: 'correctas',
    incorrectas: 'incorrectas',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn',
    estado: 'estado'
  };

  export type IntentosScalarFieldEnum = (typeof IntentosScalarFieldEnum)[keyof typeof IntentosScalarFieldEnum]


  export const RespuestasIntentosScalarFieldEnum: {
    id: 'id',
    intentoId: 'intentoId',
    preguntaId: 'preguntaId',
    respuesta: 'respuesta',
    resultado: 'resultado',
    esCorrecta: 'esCorrecta',
    respondida: 'respondida',
    visitada: 'visitada',
    marcadaRevision: 'marcadaRevision',
    tiempoConsumidoSeg: 'tiempoConsumidoSeg',
    orden: 'orden',
    respondidaEn: 'respondidaEn',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn'
  };

  export type RespuestasIntentosScalarFieldEnum = (typeof RespuestasIntentosScalarFieldEnum)[keyof typeof RespuestasIntentosScalarFieldEnum]


  export const RepasoRegistrosScalarFieldEnum: {
    id: 'id',
    usuarioEstudianteId: 'usuarioEstudianteId',
    banqueoId: 'banqueoId',
    preguntaId: 'preguntaId',
    esCorrecta: 'esCorrecta',
    creadoEn: 'creadoEn'
  };

  export type RepasoRegistrosScalarFieldEnum = (typeof RepasoRegistrosScalarFieldEnum)[keyof typeof RepasoRegistrosScalarFieldEnum]


  export const SuscripcionesScalarFieldEnum: {
    id: 'id',
    usuarioEstudianteId: 'usuarioEstudianteId',
    montoUsd: 'montoUsd',
    fechaInicio: 'fechaInicio',
    fechaFin: 'fechaFin',
    estado: 'estado',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn'
  };

  export type SuscripcionesScalarFieldEnum = (typeof SuscripcionesScalarFieldEnum)[keyof typeof SuscripcionesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Tabla'
   */
  export type EnumTablaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Tabla'>
    


  /**
   * Reference to a field of type 'Tabla[]'
   */
  export type ListEnumTablaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Tabla[]'>
    


  /**
   * Reference to a field of type 'AccionAuditoria'
   */
  export type EnumAccionAuditoriaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccionAuditoria'>
    


  /**
   * Reference to a field of type 'AccionAuditoria[]'
   */
  export type ListEnumAccionAuditoriaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccionAuditoria[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'TipoCertificado'
   */
  export type EnumTipoCertificadoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoCertificado'>
    


  /**
   * Reference to a field of type 'TipoCertificado[]'
   */
  export type ListEnumTipoCertificadoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoCertificado[]'>
    


  /**
   * Reference to a field of type 'MetodoPago'
   */
  export type EnumMetodoPagoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MetodoPago'>
    


  /**
   * Reference to a field of type 'MetodoPago[]'
   */
  export type ListEnumMetodoPagoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MetodoPago[]'>
    


  /**
   * Reference to a field of type 'EstadoPago'
   */
  export type EnumEstadoPagoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoPago'>
    


  /**
   * Reference to a field of type 'EstadoPago[]'
   */
  export type ListEnumEstadoPagoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoPago[]'>
    


  /**
   * Reference to a field of type 'EdicionEstado'
   */
  export type EnumEdicionEstadoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EdicionEstado'>
    


  /**
   * Reference to a field of type 'EdicionEstado[]'
   */
  export type ListEnumEdicionEstadoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EdicionEstado[]'>
    


  /**
   * Reference to a field of type 'TipoGenero'
   */
  export type EnumTipoGeneroFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoGenero'>
    


  /**
   * Reference to a field of type 'TipoGenero[]'
   */
  export type ListEnumTipoGeneroFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoGenero[]'>
    


  /**
   * Reference to a field of type 'TipoMaterial'
   */
  export type EnumTipoMaterialFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoMaterial'>
    


  /**
   * Reference to a field of type 'TipoMaterial[]'
   */
  export type ListEnumTipoMaterialFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoMaterial[]'>
    


  /**
   * Reference to a field of type 'PreguntaEstado'
   */
  export type EnumPreguntaEstadoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PreguntaEstado'>
    


  /**
   * Reference to a field of type 'PreguntaEstado[]'
   */
  export type ListEnumPreguntaEstadoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PreguntaEstado[]'>
    


  /**
   * Reference to a field of type 'PreguntaDificultad'
   */
  export type EnumPreguntaDificultadFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PreguntaDificultad'>
    


  /**
   * Reference to a field of type 'PreguntaDificultad[]'
   */
  export type ListEnumPreguntaDificultadFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PreguntaDificultad[]'>
    


  /**
   * Reference to a field of type 'TipoReaccion'
   */
  export type EnumTipoReaccionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoReaccion'>
    


  /**
   * Reference to a field of type 'TipoReaccion[]'
   */
  export type ListEnumTipoReaccionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoReaccion[]'>
    


  /**
   * Reference to a field of type 'TipoCuenta'
   */
  export type EnumTipoCuentaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoCuenta'>
    


  /**
   * Reference to a field of type 'TipoCuenta[]'
   */
  export type ListEnumTipoCuentaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoCuenta[]'>
    


  /**
   * Reference to a field of type 'BanqueoTipo'
   */
  export type EnumBanqueoTipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BanqueoTipo'>
    


  /**
   * Reference to a field of type 'BanqueoTipo[]'
   */
  export type ListEnumBanqueoTipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BanqueoTipo[]'>
    


  /**
   * Reference to a field of type 'BanqueoTipoCreado'
   */
  export type EnumBanqueoTipoCreadoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BanqueoTipoCreado'>
    


  /**
   * Reference to a field of type 'BanqueoTipoCreado[]'
   */
  export type ListEnumBanqueoTipoCreadoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BanqueoTipoCreado[]'>
    


  /**
   * Reference to a field of type 'EstadoIntento'
   */
  export type EnumEstadoIntentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoIntento'>
    


  /**
   * Reference to a field of type 'EstadoIntento[]'
   */
  export type ListEnumEstadoIntentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoIntento[]'>
    


  /**
   * Reference to a field of type 'ResultadoRespuesta'
   */
  export type EnumResultadoRespuestaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResultadoRespuesta'>
    


  /**
   * Reference to a field of type 'ResultadoRespuesta[]'
   */
  export type ListEnumResultadoRespuestaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResultadoRespuesta[]'>
    


  /**
   * Reference to a field of type 'EstadoSuscripcion'
   */
  export type EnumEstadoSuscripcionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoSuscripcion'>
    


  /**
   * Reference to a field of type 'EstadoSuscripcion[]'
   */
  export type ListEnumEstadoSuscripcionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoSuscripcion[]'>
    
  /**
   * Deep Input Types
   */


  export type auditoriaWhereInput = {
    AND?: auditoriaWhereInput | auditoriaWhereInput[]
    OR?: auditoriaWhereInput[]
    NOT?: auditoriaWhereInput | auditoriaWhereInput[]
    id?: StringFilter<"auditoria"> | string
    tabla?: EnumTablaFilter<"auditoria"> | $Enums.Tabla
    registroId?: StringNullableFilter<"auditoria"> | string | null
    accion?: EnumAccionAuditoriaFilter<"auditoria"> | $Enums.AccionAuditoria
    detalles?: JsonNullableFilter<"auditoria">
    usuarioId?: StringFilter<"auditoria"> | string
    creadoEn?: DateTimeFilter<"auditoria"> | Date | string
    usuariosAdministradores?: XOR<UsuariosAdministradoresScalarRelationFilter, usuariosAdministradoresWhereInput>
  }

  export type auditoriaOrderByWithRelationInput = {
    id?: SortOrder
    tabla?: SortOrder
    registroId?: SortOrderInput | SortOrder
    accion?: SortOrder
    detalles?: SortOrderInput | SortOrder
    usuarioId?: SortOrder
    creadoEn?: SortOrder
    usuariosAdministradores?: usuariosAdministradoresOrderByWithRelationInput
  }

  export type auditoriaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: auditoriaWhereInput | auditoriaWhereInput[]
    OR?: auditoriaWhereInput[]
    NOT?: auditoriaWhereInput | auditoriaWhereInput[]
    tabla?: EnumTablaFilter<"auditoria"> | $Enums.Tabla
    registroId?: StringNullableFilter<"auditoria"> | string | null
    accion?: EnumAccionAuditoriaFilter<"auditoria"> | $Enums.AccionAuditoria
    detalles?: JsonNullableFilter<"auditoria">
    usuarioId?: StringFilter<"auditoria"> | string
    creadoEn?: DateTimeFilter<"auditoria"> | Date | string
    usuariosAdministradores?: XOR<UsuariosAdministradoresScalarRelationFilter, usuariosAdministradoresWhereInput>
  }, "id">

  export type auditoriaOrderByWithAggregationInput = {
    id?: SortOrder
    tabla?: SortOrder
    registroId?: SortOrderInput | SortOrder
    accion?: SortOrder
    detalles?: SortOrderInput | SortOrder
    usuarioId?: SortOrder
    creadoEn?: SortOrder
    _count?: auditoriaCountOrderByAggregateInput
    _max?: auditoriaMaxOrderByAggregateInput
    _min?: auditoriaMinOrderByAggregateInput
  }

  export type auditoriaScalarWhereWithAggregatesInput = {
    AND?: auditoriaScalarWhereWithAggregatesInput | auditoriaScalarWhereWithAggregatesInput[]
    OR?: auditoriaScalarWhereWithAggregatesInput[]
    NOT?: auditoriaScalarWhereWithAggregatesInput | auditoriaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"auditoria"> | string
    tabla?: EnumTablaWithAggregatesFilter<"auditoria"> | $Enums.Tabla
    registroId?: StringNullableWithAggregatesFilter<"auditoria"> | string | null
    accion?: EnumAccionAuditoriaWithAggregatesFilter<"auditoria"> | $Enums.AccionAuditoria
    detalles?: JsonNullableWithAggregatesFilter<"auditoria">
    usuarioId?: StringWithAggregatesFilter<"auditoria"> | string
    creadoEn?: DateTimeWithAggregatesFilter<"auditoria"> | Date | string
  }

  export type beneficiosCursosWhereInput = {
    AND?: beneficiosCursosWhereInput | beneficiosCursosWhereInput[]
    OR?: beneficiosCursosWhereInput[]
    NOT?: beneficiosCursosWhereInput | beneficiosCursosWhereInput[]
    id?: StringFilter<"beneficiosCursos"> | string
    cursoId?: StringFilter<"beneficiosCursos"> | string
    descripcion?: StringFilter<"beneficiosCursos"> | string
    orden?: IntFilter<"beneficiosCursos"> | number
    creadoEn?: DateTimeFilter<"beneficiosCursos"> | Date | string
    cursos?: XOR<CursosScalarRelationFilter, cursosWhereInput>
  }

  export type beneficiosCursosOrderByWithRelationInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
    cursos?: cursosOrderByWithRelationInput
  }

  export type beneficiosCursosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: beneficiosCursosWhereInput | beneficiosCursosWhereInput[]
    OR?: beneficiosCursosWhereInput[]
    NOT?: beneficiosCursosWhereInput | beneficiosCursosWhereInput[]
    cursoId?: StringFilter<"beneficiosCursos"> | string
    descripcion?: StringFilter<"beneficiosCursos"> | string
    orden?: IntFilter<"beneficiosCursos"> | number
    creadoEn?: DateTimeFilter<"beneficiosCursos"> | Date | string
    cursos?: XOR<CursosScalarRelationFilter, cursosWhereInput>
  }, "id">

  export type beneficiosCursosOrderByWithAggregationInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
    _count?: beneficiosCursosCountOrderByAggregateInput
    _avg?: beneficiosCursosAvgOrderByAggregateInput
    _max?: beneficiosCursosMaxOrderByAggregateInput
    _min?: beneficiosCursosMinOrderByAggregateInput
    _sum?: beneficiosCursosSumOrderByAggregateInput
  }

  export type beneficiosCursosScalarWhereWithAggregatesInput = {
    AND?: beneficiosCursosScalarWhereWithAggregatesInput | beneficiosCursosScalarWhereWithAggregatesInput[]
    OR?: beneficiosCursosScalarWhereWithAggregatesInput[]
    NOT?: beneficiosCursosScalarWhereWithAggregatesInput | beneficiosCursosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"beneficiosCursos"> | string
    cursoId?: StringWithAggregatesFilter<"beneficiosCursos"> | string
    descripcion?: StringWithAggregatesFilter<"beneficiosCursos"> | string
    orden?: IntWithAggregatesFilter<"beneficiosCursos"> | number
    creadoEn?: DateTimeWithAggregatesFilter<"beneficiosCursos"> | Date | string
  }

  export type calificacionesWhereInput = {
    AND?: calificacionesWhereInput | calificacionesWhereInput[]
    OR?: calificacionesWhereInput[]
    NOT?: calificacionesWhereInput | calificacionesWhereInput[]
    id?: StringFilter<"calificaciones"> | string
    aprobado?: BoolFilter<"calificaciones"> | boolean
    comentarios?: StringNullableFilter<"calificaciones"> | string | null
    estudianteId?: StringFilter<"calificaciones"> | string
    examenId?: StringFilter<"calificaciones"> | string
    nota?: FloatFilter<"calificaciones"> | number
    creadoEn?: DateTimeFilter<"calificaciones"> | Date | string
    estudiantes?: XOR<EstudiantesScalarRelationFilter, estudiantesWhereInput>
    examenes?: XOR<ExamenesScalarRelationFilter, examenesWhereInput>
  }

  export type calificacionesOrderByWithRelationInput = {
    id?: SortOrder
    aprobado?: SortOrder
    comentarios?: SortOrderInput | SortOrder
    estudianteId?: SortOrder
    examenId?: SortOrder
    nota?: SortOrder
    creadoEn?: SortOrder
    estudiantes?: estudiantesOrderByWithRelationInput
    examenes?: examenesOrderByWithRelationInput
  }

  export type calificacionesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    estudianteId_examenId?: calificacionesEstudianteIdExamenIdCompoundUniqueInput
    AND?: calificacionesWhereInput | calificacionesWhereInput[]
    OR?: calificacionesWhereInput[]
    NOT?: calificacionesWhereInput | calificacionesWhereInput[]
    aprobado?: BoolFilter<"calificaciones"> | boolean
    comentarios?: StringNullableFilter<"calificaciones"> | string | null
    estudianteId?: StringFilter<"calificaciones"> | string
    examenId?: StringFilter<"calificaciones"> | string
    nota?: FloatFilter<"calificaciones"> | number
    creadoEn?: DateTimeFilter<"calificaciones"> | Date | string
    estudiantes?: XOR<EstudiantesScalarRelationFilter, estudiantesWhereInput>
    examenes?: XOR<ExamenesScalarRelationFilter, examenesWhereInput>
  }, "id" | "estudianteId_examenId">

  export type calificacionesOrderByWithAggregationInput = {
    id?: SortOrder
    aprobado?: SortOrder
    comentarios?: SortOrderInput | SortOrder
    estudianteId?: SortOrder
    examenId?: SortOrder
    nota?: SortOrder
    creadoEn?: SortOrder
    _count?: calificacionesCountOrderByAggregateInput
    _avg?: calificacionesAvgOrderByAggregateInput
    _max?: calificacionesMaxOrderByAggregateInput
    _min?: calificacionesMinOrderByAggregateInput
    _sum?: calificacionesSumOrderByAggregateInput
  }

  export type calificacionesScalarWhereWithAggregatesInput = {
    AND?: calificacionesScalarWhereWithAggregatesInput | calificacionesScalarWhereWithAggregatesInput[]
    OR?: calificacionesScalarWhereWithAggregatesInput[]
    NOT?: calificacionesScalarWhereWithAggregatesInput | calificacionesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"calificaciones"> | string
    aprobado?: BoolWithAggregatesFilter<"calificaciones"> | boolean
    comentarios?: StringNullableWithAggregatesFilter<"calificaciones"> | string | null
    estudianteId?: StringWithAggregatesFilter<"calificaciones"> | string
    examenId?: StringWithAggregatesFilter<"calificaciones"> | string
    nota?: FloatWithAggregatesFilter<"calificaciones"> | number
    creadoEn?: DateTimeWithAggregatesFilter<"calificaciones"> | Date | string
  }

  export type categoriasWhereInput = {
    AND?: categoriasWhereInput | categoriasWhereInput[]
    OR?: categoriasWhereInput[]
    NOT?: categoriasWhereInput | categoriasWhereInput[]
    id?: StringFilter<"categorias"> | string
    nombre?: StringFilter<"categorias"> | string
    descripcion?: StringNullableFilter<"categorias"> | string | null
    creadoEn?: DateTimeFilter<"categorias"> | Date | string
    actualizadoEn?: DateTimeFilter<"categorias"> | Date | string
    categoriasCursos?: CategoriasCursosListRelationFilter
  }

  export type categoriasOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    categoriasCursos?: categoriasCursosOrderByRelationAggregateInput
  }

  export type categoriasWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    nombre?: string
    AND?: categoriasWhereInput | categoriasWhereInput[]
    OR?: categoriasWhereInput[]
    NOT?: categoriasWhereInput | categoriasWhereInput[]
    descripcion?: StringNullableFilter<"categorias"> | string | null
    creadoEn?: DateTimeFilter<"categorias"> | Date | string
    actualizadoEn?: DateTimeFilter<"categorias"> | Date | string
    categoriasCursos?: CategoriasCursosListRelationFilter
  }, "id" | "nombre">

  export type categoriasOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    _count?: categoriasCountOrderByAggregateInput
    _max?: categoriasMaxOrderByAggregateInput
    _min?: categoriasMinOrderByAggregateInput
  }

  export type categoriasScalarWhereWithAggregatesInput = {
    AND?: categoriasScalarWhereWithAggregatesInput | categoriasScalarWhereWithAggregatesInput[]
    OR?: categoriasScalarWhereWithAggregatesInput[]
    NOT?: categoriasScalarWhereWithAggregatesInput | categoriasScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"categorias"> | string
    nombre?: StringWithAggregatesFilter<"categorias"> | string
    descripcion?: StringNullableWithAggregatesFilter<"categorias"> | string | null
    creadoEn?: DateTimeWithAggregatesFilter<"categorias"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"categorias"> | Date | string
  }

  export type categoriasCursosWhereInput = {
    AND?: categoriasCursosWhereInput | categoriasCursosWhereInput[]
    OR?: categoriasCursosWhereInput[]
    NOT?: categoriasCursosWhereInput | categoriasCursosWhereInput[]
    id?: StringFilter<"categoriasCursos"> | string
    categoriaId?: StringFilter<"categoriasCursos"> | string
    cursoId?: StringFilter<"categoriasCursos"> | string
    categorias?: XOR<CategoriasScalarRelationFilter, categoriasWhereInput>
    cursos?: XOR<CursosScalarRelationFilter, cursosWhereInput>
  }

  export type categoriasCursosOrderByWithRelationInput = {
    id?: SortOrder
    categoriaId?: SortOrder
    cursoId?: SortOrder
    categorias?: categoriasOrderByWithRelationInput
    cursos?: cursosOrderByWithRelationInput
  }

  export type categoriasCursosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cursoId_categoriaId?: categoriasCursosCursoIdCategoriaIdCompoundUniqueInput
    AND?: categoriasCursosWhereInput | categoriasCursosWhereInput[]
    OR?: categoriasCursosWhereInput[]
    NOT?: categoriasCursosWhereInput | categoriasCursosWhereInput[]
    categoriaId?: StringFilter<"categoriasCursos"> | string
    cursoId?: StringFilter<"categoriasCursos"> | string
    categorias?: XOR<CategoriasScalarRelationFilter, categoriasWhereInput>
    cursos?: XOR<CursosScalarRelationFilter, cursosWhereInput>
  }, "id" | "cursoId_categoriaId">

  export type categoriasCursosOrderByWithAggregationInput = {
    id?: SortOrder
    categoriaId?: SortOrder
    cursoId?: SortOrder
    _count?: categoriasCursosCountOrderByAggregateInput
    _max?: categoriasCursosMaxOrderByAggregateInput
    _min?: categoriasCursosMinOrderByAggregateInput
  }

  export type categoriasCursosScalarWhereWithAggregatesInput = {
    AND?: categoriasCursosScalarWhereWithAggregatesInput | categoriasCursosScalarWhereWithAggregatesInput[]
    OR?: categoriasCursosScalarWhereWithAggregatesInput[]
    NOT?: categoriasCursosScalarWhereWithAggregatesInput | categoriasCursosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"categoriasCursos"> | string
    categoriaId?: StringWithAggregatesFilter<"categoriasCursos"> | string
    cursoId?: StringWithAggregatesFilter<"categoriasCursos"> | string
  }

  export type certificadosWhereInput = {
    AND?: certificadosWhereInput | certificadosWhereInput[]
    OR?: certificadosWhereInput[]
    NOT?: certificadosWhereInput | certificadosWhereInput[]
    id?: StringFilter<"certificados"> | string
    codigoUnico?: StringFilter<"certificados"> | string
    edicionId?: StringFilter<"certificados"> | string
    estudianteId?: StringFilter<"certificados"> | string
    fechaEmision?: DateTimeFilter<"certificados"> | Date | string
    tipo?: EnumTipoCertificadoFilter<"certificados"> | $Enums.TipoCertificado
    notaFinal?: FloatNullableFilter<"certificados"> | number | null
    urlCertificado?: StringNullableFilter<"certificados"> | string | null
    creadoEn?: DateTimeFilter<"certificados"> | Date | string
    edicionesCursos?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
    estudiantes?: XOR<EstudiantesScalarRelationFilter, estudiantesWhereInput>
  }

  export type certificadosOrderByWithRelationInput = {
    id?: SortOrder
    codigoUnico?: SortOrder
    edicionId?: SortOrder
    estudianteId?: SortOrder
    fechaEmision?: SortOrder
    tipo?: SortOrder
    notaFinal?: SortOrderInput | SortOrder
    urlCertificado?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    edicionesCursos?: edicionesCursosOrderByWithRelationInput
    estudiantes?: estudiantesOrderByWithRelationInput
  }

  export type certificadosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    codigoUnico?: string
    AND?: certificadosWhereInput | certificadosWhereInput[]
    OR?: certificadosWhereInput[]
    NOT?: certificadosWhereInput | certificadosWhereInput[]
    edicionId?: StringFilter<"certificados"> | string
    estudianteId?: StringFilter<"certificados"> | string
    fechaEmision?: DateTimeFilter<"certificados"> | Date | string
    tipo?: EnumTipoCertificadoFilter<"certificados"> | $Enums.TipoCertificado
    notaFinal?: FloatNullableFilter<"certificados"> | number | null
    urlCertificado?: StringNullableFilter<"certificados"> | string | null
    creadoEn?: DateTimeFilter<"certificados"> | Date | string
    edicionesCursos?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
    estudiantes?: XOR<EstudiantesScalarRelationFilter, estudiantesWhereInput>
  }, "id" | "codigoUnico">

  export type certificadosOrderByWithAggregationInput = {
    id?: SortOrder
    codigoUnico?: SortOrder
    edicionId?: SortOrder
    estudianteId?: SortOrder
    fechaEmision?: SortOrder
    tipo?: SortOrder
    notaFinal?: SortOrderInput | SortOrder
    urlCertificado?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    _count?: certificadosCountOrderByAggregateInput
    _avg?: certificadosAvgOrderByAggregateInput
    _max?: certificadosMaxOrderByAggregateInput
    _min?: certificadosMinOrderByAggregateInput
    _sum?: certificadosSumOrderByAggregateInput
  }

  export type certificadosScalarWhereWithAggregatesInput = {
    AND?: certificadosScalarWhereWithAggregatesInput | certificadosScalarWhereWithAggregatesInput[]
    OR?: certificadosScalarWhereWithAggregatesInput[]
    NOT?: certificadosScalarWhereWithAggregatesInput | certificadosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"certificados"> | string
    codigoUnico?: StringWithAggregatesFilter<"certificados"> | string
    edicionId?: StringWithAggregatesFilter<"certificados"> | string
    estudianteId?: StringWithAggregatesFilter<"certificados"> | string
    fechaEmision?: DateTimeWithAggregatesFilter<"certificados"> | Date | string
    tipo?: EnumTipoCertificadoWithAggregatesFilter<"certificados"> | $Enums.TipoCertificado
    notaFinal?: FloatNullableWithAggregatesFilter<"certificados"> | number | null
    urlCertificado?: StringNullableWithAggregatesFilter<"certificados"> | string | null
    creadoEn?: DateTimeWithAggregatesFilter<"certificados"> | Date | string
  }

  export type clasesWhereInput = {
    AND?: clasesWhereInput | clasesWhereInput[]
    OR?: clasesWhereInput[]
    NOT?: clasesWhereInput | clasesWhereInput[]
    id?: StringFilter<"clases"> | string
    edicionId?: StringFilter<"clases"> | string
    descripcion?: StringFilter<"clases"> | string
    duracion?: IntNullableFilter<"clases"> | number | null
    fecha?: DateTimeFilter<"clases"> | Date | string
    orden?: IntFilter<"clases"> | number
    titulo?: StringFilter<"clases"> | string
    urlYoutube?: StringNullableFilter<"clases"> | string | null
    creadoEn?: DateTimeFilter<"clases"> | Date | string
    urlPresentacion?: StringNullableFilter<"clases"> | string | null
    edicionesCursos?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
    grabaciones?: GrabacionesListRelationFilter
    materiales?: MaterialesListRelationFilter
  }

  export type clasesOrderByWithRelationInput = {
    id?: SortOrder
    edicionId?: SortOrder
    descripcion?: SortOrder
    duracion?: SortOrderInput | SortOrder
    fecha?: SortOrder
    orden?: SortOrder
    titulo?: SortOrder
    urlYoutube?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    urlPresentacion?: SortOrderInput | SortOrder
    edicionesCursos?: edicionesCursosOrderByWithRelationInput
    grabaciones?: grabacionesOrderByRelationAggregateInput
    materiales?: materialesOrderByRelationAggregateInput
  }

  export type clasesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: clasesWhereInput | clasesWhereInput[]
    OR?: clasesWhereInput[]
    NOT?: clasesWhereInput | clasesWhereInput[]
    edicionId?: StringFilter<"clases"> | string
    descripcion?: StringFilter<"clases"> | string
    duracion?: IntNullableFilter<"clases"> | number | null
    fecha?: DateTimeFilter<"clases"> | Date | string
    orden?: IntFilter<"clases"> | number
    titulo?: StringFilter<"clases"> | string
    urlYoutube?: StringNullableFilter<"clases"> | string | null
    creadoEn?: DateTimeFilter<"clases"> | Date | string
    urlPresentacion?: StringNullableFilter<"clases"> | string | null
    edicionesCursos?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
    grabaciones?: GrabacionesListRelationFilter
    materiales?: MaterialesListRelationFilter
  }, "id">

  export type clasesOrderByWithAggregationInput = {
    id?: SortOrder
    edicionId?: SortOrder
    descripcion?: SortOrder
    duracion?: SortOrderInput | SortOrder
    fecha?: SortOrder
    orden?: SortOrder
    titulo?: SortOrder
    urlYoutube?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    urlPresentacion?: SortOrderInput | SortOrder
    _count?: clasesCountOrderByAggregateInput
    _avg?: clasesAvgOrderByAggregateInput
    _max?: clasesMaxOrderByAggregateInput
    _min?: clasesMinOrderByAggregateInput
    _sum?: clasesSumOrderByAggregateInput
  }

  export type clasesScalarWhereWithAggregatesInput = {
    AND?: clasesScalarWhereWithAggregatesInput | clasesScalarWhereWithAggregatesInput[]
    OR?: clasesScalarWhereWithAggregatesInput[]
    NOT?: clasesScalarWhereWithAggregatesInput | clasesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"clases"> | string
    edicionId?: StringWithAggregatesFilter<"clases"> | string
    descripcion?: StringWithAggregatesFilter<"clases"> | string
    duracion?: IntNullableWithAggregatesFilter<"clases"> | number | null
    fecha?: DateTimeWithAggregatesFilter<"clases"> | Date | string
    orden?: IntWithAggregatesFilter<"clases"> | number
    titulo?: StringWithAggregatesFilter<"clases"> | string
    urlYoutube?: StringNullableWithAggregatesFilter<"clases"> | string | null
    creadoEn?: DateTimeWithAggregatesFilter<"clases"> | Date | string
    urlPresentacion?: StringNullableWithAggregatesFilter<"clases"> | string | null
  }

  export type comprasWhereInput = {
    AND?: comprasWhereInput | comprasWhereInput[]
    OR?: comprasWhereInput[]
    NOT?: comprasWhereInput | comprasWhereInput[]
    id?: StringFilter<"compras"> | string
    edicionId?: StringFilter<"compras"> | string
    monto?: FloatFilter<"compras"> | number
    moneda?: StringFilter<"compras"> | string
    comprobado?: BoolFilter<"compras"> | boolean
    providerId?: StringFilter<"compras"> | string
    fechaCompra?: DateTimeFilter<"compras"> | Date | string
    metodo?: EnumMetodoPagoFilter<"compras"> | $Enums.MetodoPago
    deuda?: FloatFilter<"compras"> | number
    usuariosEstudiantesId?: StringNullableFilter<"compras"> | string | null
    estadoPago?: EnumEstadoPagoFilter<"compras"> | $Enums.EstadoPago
    updatedAt?: DateTimeFilter<"compras"> | Date | string
    conDescuento?: BoolFilter<"compras"> | boolean
    edicionesCursos?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
    usuariosEstudiantes?: XOR<UsuariosEstudiantesNullableScalarRelationFilter, usuariosEstudiantesWhereInput> | null
    inscripciones?: XOR<InscripcionesNullableScalarRelationFilter, inscripcionesWhereInput> | null
  }

  export type comprasOrderByWithRelationInput = {
    id?: SortOrder
    edicionId?: SortOrder
    monto?: SortOrder
    moneda?: SortOrder
    comprobado?: SortOrder
    providerId?: SortOrder
    fechaCompra?: SortOrder
    metodo?: SortOrder
    deuda?: SortOrder
    usuariosEstudiantesId?: SortOrderInput | SortOrder
    estadoPago?: SortOrder
    updatedAt?: SortOrder
    conDescuento?: SortOrder
    edicionesCursos?: edicionesCursosOrderByWithRelationInput
    usuariosEstudiantes?: usuariosEstudiantesOrderByWithRelationInput
    inscripciones?: inscripcionesOrderByWithRelationInput
  }

  export type comprasWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: comprasWhereInput | comprasWhereInput[]
    OR?: comprasWhereInput[]
    NOT?: comprasWhereInput | comprasWhereInput[]
    edicionId?: StringFilter<"compras"> | string
    monto?: FloatFilter<"compras"> | number
    moneda?: StringFilter<"compras"> | string
    comprobado?: BoolFilter<"compras"> | boolean
    providerId?: StringFilter<"compras"> | string
    fechaCompra?: DateTimeFilter<"compras"> | Date | string
    metodo?: EnumMetodoPagoFilter<"compras"> | $Enums.MetodoPago
    deuda?: FloatFilter<"compras"> | number
    usuariosEstudiantesId?: StringNullableFilter<"compras"> | string | null
    estadoPago?: EnumEstadoPagoFilter<"compras"> | $Enums.EstadoPago
    updatedAt?: DateTimeFilter<"compras"> | Date | string
    conDescuento?: BoolFilter<"compras"> | boolean
    edicionesCursos?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
    usuariosEstudiantes?: XOR<UsuariosEstudiantesNullableScalarRelationFilter, usuariosEstudiantesWhereInput> | null
    inscripciones?: XOR<InscripcionesNullableScalarRelationFilter, inscripcionesWhereInput> | null
  }, "id">

  export type comprasOrderByWithAggregationInput = {
    id?: SortOrder
    edicionId?: SortOrder
    monto?: SortOrder
    moneda?: SortOrder
    comprobado?: SortOrder
    providerId?: SortOrder
    fechaCompra?: SortOrder
    metodo?: SortOrder
    deuda?: SortOrder
    usuariosEstudiantesId?: SortOrderInput | SortOrder
    estadoPago?: SortOrder
    updatedAt?: SortOrder
    conDescuento?: SortOrder
    _count?: comprasCountOrderByAggregateInput
    _avg?: comprasAvgOrderByAggregateInput
    _max?: comprasMaxOrderByAggregateInput
    _min?: comprasMinOrderByAggregateInput
    _sum?: comprasSumOrderByAggregateInput
  }

  export type comprasScalarWhereWithAggregatesInput = {
    AND?: comprasScalarWhereWithAggregatesInput | comprasScalarWhereWithAggregatesInput[]
    OR?: comprasScalarWhereWithAggregatesInput[]
    NOT?: comprasScalarWhereWithAggregatesInput | comprasScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"compras"> | string
    edicionId?: StringWithAggregatesFilter<"compras"> | string
    monto?: FloatWithAggregatesFilter<"compras"> | number
    moneda?: StringWithAggregatesFilter<"compras"> | string
    comprobado?: BoolWithAggregatesFilter<"compras"> | boolean
    providerId?: StringWithAggregatesFilter<"compras"> | string
    fechaCompra?: DateTimeWithAggregatesFilter<"compras"> | Date | string
    metodo?: EnumMetodoPagoWithAggregatesFilter<"compras"> | $Enums.MetodoPago
    deuda?: FloatWithAggregatesFilter<"compras"> | number
    usuariosEstudiantesId?: StringNullableWithAggregatesFilter<"compras"> | string | null
    estadoPago?: EnumEstadoPagoWithAggregatesFilter<"compras"> | $Enums.EstadoPago
    updatedAt?: DateTimeWithAggregatesFilter<"compras"> | Date | string
    conDescuento?: BoolWithAggregatesFilter<"compras"> | boolean
  }

  export type cursosWhereInput = {
    AND?: cursosWhereInput | cursosWhereInput[]
    OR?: cursosWhereInput[]
    NOT?: cursosWhereInput | cursosWhereInput[]
    id?: StringFilter<"cursos"> | string
    descripcion?: StringFilter<"cursos"> | string
    titulo?: StringFilter<"cursos"> | string
    urlMiniatura?: StringNullableFilter<"cursos"> | string | null
    creadoEn?: DateTimeFilter<"cursos"> | Date | string
    actualizadoEn?: DateTimeFilter<"cursos"> | Date | string
    descripcionCorta?: StringNullableFilter<"cursos"> | string | null
    enVivo?: BoolFilter<"cursos"> | boolean
    urlCurso?: StringNullableFilter<"cursos"> | string | null
    cargaHoraria?: IntFilter<"cursos"> | number
    codigo?: StringFilter<"cursos"> | string
    beneficiosCursos?: BeneficiosCursosListRelationFilter
    categoriasCursos?: CategoriasCursosListRelationFilter
    edicionesCursos?: EdicionesCursosListRelationFilter
    objetivosCursos?: ObjetivosCursosListRelationFilter
    requisitosCursos?: RequisitosCursosListRelationFilter
    reviewsCursos?: ReviewsCursosListRelationFilter
  }

  export type cursosOrderByWithRelationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    titulo?: SortOrder
    urlMiniatura?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    descripcionCorta?: SortOrderInput | SortOrder
    enVivo?: SortOrder
    urlCurso?: SortOrderInput | SortOrder
    cargaHoraria?: SortOrder
    codigo?: SortOrder
    beneficiosCursos?: beneficiosCursosOrderByRelationAggregateInput
    categoriasCursos?: categoriasCursosOrderByRelationAggregateInput
    edicionesCursos?: edicionesCursosOrderByRelationAggregateInput
    objetivosCursos?: objetivosCursosOrderByRelationAggregateInput
    requisitosCursos?: requisitosCursosOrderByRelationAggregateInput
    reviewsCursos?: reviewsCursosOrderByRelationAggregateInput
  }

  export type cursosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    codigo?: string
    AND?: cursosWhereInput | cursosWhereInput[]
    OR?: cursosWhereInput[]
    NOT?: cursosWhereInput | cursosWhereInput[]
    descripcion?: StringFilter<"cursos"> | string
    titulo?: StringFilter<"cursos"> | string
    urlMiniatura?: StringNullableFilter<"cursos"> | string | null
    creadoEn?: DateTimeFilter<"cursos"> | Date | string
    actualizadoEn?: DateTimeFilter<"cursos"> | Date | string
    descripcionCorta?: StringNullableFilter<"cursos"> | string | null
    enVivo?: BoolFilter<"cursos"> | boolean
    urlCurso?: StringNullableFilter<"cursos"> | string | null
    cargaHoraria?: IntFilter<"cursos"> | number
    beneficiosCursos?: BeneficiosCursosListRelationFilter
    categoriasCursos?: CategoriasCursosListRelationFilter
    edicionesCursos?: EdicionesCursosListRelationFilter
    objetivosCursos?: ObjetivosCursosListRelationFilter
    requisitosCursos?: RequisitosCursosListRelationFilter
    reviewsCursos?: ReviewsCursosListRelationFilter
  }, "id" | "codigo">

  export type cursosOrderByWithAggregationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    titulo?: SortOrder
    urlMiniatura?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    descripcionCorta?: SortOrderInput | SortOrder
    enVivo?: SortOrder
    urlCurso?: SortOrderInput | SortOrder
    cargaHoraria?: SortOrder
    codigo?: SortOrder
    _count?: cursosCountOrderByAggregateInput
    _avg?: cursosAvgOrderByAggregateInput
    _max?: cursosMaxOrderByAggregateInput
    _min?: cursosMinOrderByAggregateInput
    _sum?: cursosSumOrderByAggregateInput
  }

  export type cursosScalarWhereWithAggregatesInput = {
    AND?: cursosScalarWhereWithAggregatesInput | cursosScalarWhereWithAggregatesInput[]
    OR?: cursosScalarWhereWithAggregatesInput[]
    NOT?: cursosScalarWhereWithAggregatesInput | cursosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"cursos"> | string
    descripcion?: StringWithAggregatesFilter<"cursos"> | string
    titulo?: StringWithAggregatesFilter<"cursos"> | string
    urlMiniatura?: StringNullableWithAggregatesFilter<"cursos"> | string | null
    creadoEn?: DateTimeWithAggregatesFilter<"cursos"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"cursos"> | Date | string
    descripcionCorta?: StringNullableWithAggregatesFilter<"cursos"> | string | null
    enVivo?: BoolWithAggregatesFilter<"cursos"> | boolean
    urlCurso?: StringNullableWithAggregatesFilter<"cursos"> | string | null
    cargaHoraria?: IntWithAggregatesFilter<"cursos"> | number
    codigo?: StringWithAggregatesFilter<"cursos"> | string
  }

  export type docenteWhereInput = {
    AND?: docenteWhereInput | docenteWhereInput[]
    OR?: docenteWhereInput[]
    NOT?: docenteWhereInput | docenteWhereInput[]
    id?: StringFilter<"docente"> | string
    nombre_completo?: StringFilter<"docente"> | string
    celular?: StringNullableFilter<"docente"> | string | null
    especialidad?: StringFilter<"docente"> | string
    experiencia?: IntFilter<"docente"> | number
    creadoEn?: DateTimeFilter<"docente"> | Date | string
    actualizadoEn?: DateTimeFilter<"docente"> | Date | string
    usuarioId?: StringFilter<"docente"> | string
    pais?: StringFilter<"docente"> | string
    usuariosAdministradores?: XOR<UsuariosAdministradoresScalarRelationFilter, usuariosAdministradoresWhereInput>
    edicionesCursos?: EdicionesCursosListRelationFilter
    pagosDocentes?: PagosDocentesListRelationFilter
  }

  export type docenteOrderByWithRelationInput = {
    id?: SortOrder
    nombre_completo?: SortOrder
    celular?: SortOrderInput | SortOrder
    especialidad?: SortOrder
    experiencia?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    usuarioId?: SortOrder
    pais?: SortOrder
    usuariosAdministradores?: usuariosAdministradoresOrderByWithRelationInput
    edicionesCursos?: edicionesCursosOrderByRelationAggregateInput
    pagosDocentes?: pagosDocentesOrderByRelationAggregateInput
  }

  export type docenteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    usuarioId?: string
    AND?: docenteWhereInput | docenteWhereInput[]
    OR?: docenteWhereInput[]
    NOT?: docenteWhereInput | docenteWhereInput[]
    nombre_completo?: StringFilter<"docente"> | string
    celular?: StringNullableFilter<"docente"> | string | null
    especialidad?: StringFilter<"docente"> | string
    experiencia?: IntFilter<"docente"> | number
    creadoEn?: DateTimeFilter<"docente"> | Date | string
    actualizadoEn?: DateTimeFilter<"docente"> | Date | string
    pais?: StringFilter<"docente"> | string
    usuariosAdministradores?: XOR<UsuariosAdministradoresScalarRelationFilter, usuariosAdministradoresWhereInput>
    edicionesCursos?: EdicionesCursosListRelationFilter
    pagosDocentes?: PagosDocentesListRelationFilter
  }, "id" | "usuarioId">

  export type docenteOrderByWithAggregationInput = {
    id?: SortOrder
    nombre_completo?: SortOrder
    celular?: SortOrderInput | SortOrder
    especialidad?: SortOrder
    experiencia?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    usuarioId?: SortOrder
    pais?: SortOrder
    _count?: docenteCountOrderByAggregateInput
    _avg?: docenteAvgOrderByAggregateInput
    _max?: docenteMaxOrderByAggregateInput
    _min?: docenteMinOrderByAggregateInput
    _sum?: docenteSumOrderByAggregateInput
  }

  export type docenteScalarWhereWithAggregatesInput = {
    AND?: docenteScalarWhereWithAggregatesInput | docenteScalarWhereWithAggregatesInput[]
    OR?: docenteScalarWhereWithAggregatesInput[]
    NOT?: docenteScalarWhereWithAggregatesInput | docenteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"docente"> | string
    nombre_completo?: StringWithAggregatesFilter<"docente"> | string
    celular?: StringNullableWithAggregatesFilter<"docente"> | string | null
    especialidad?: StringWithAggregatesFilter<"docente"> | string
    experiencia?: IntWithAggregatesFilter<"docente"> | number
    creadoEn?: DateTimeWithAggregatesFilter<"docente"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"docente"> | Date | string
    usuarioId?: StringWithAggregatesFilter<"docente"> | string
    pais?: StringWithAggregatesFilter<"docente"> | string
  }

  export type edicionesCursosWhereInput = {
    AND?: edicionesCursosWhereInput | edicionesCursosWhereInput[]
    OR?: edicionesCursosWhereInput[]
    NOT?: edicionesCursosWhereInput | edicionesCursosWhereInput[]
    id?: StringFilter<"edicionesCursos"> | string
    codigo?: StringFilter<"edicionesCursos"> | string
    cursoId?: StringFilter<"edicionesCursos"> | string
    descripcion?: StringNullableFilter<"edicionesCursos"> | string | null
    estado?: EnumEdicionEstadoFilter<"edicionesCursos"> | $Enums.EdicionEstado
    fechaFin?: DateTimeFilter<"edicionesCursos"> | Date | string
    fechaInicio?: DateTimeFilter<"edicionesCursos"> | Date | string
    notaMaxima?: FloatFilter<"edicionesCursos"> | number
    notaMinima?: FloatFilter<"edicionesCursos"> | number
    urlWhatsapp?: StringNullableFilter<"edicionesCursos"> | string | null
    vigente?: BoolFilter<"edicionesCursos"> | boolean
    creadoEn?: DateTimeFilter<"edicionesCursos"> | Date | string
    actualizadoEn?: DateTimeFilter<"edicionesCursos"> | Date | string
    docenteId?: StringNullableFilter<"edicionesCursos"> | string | null
    certificados?: CertificadosListRelationFilter
    clases?: ClasesListRelationFilter
    compras?: ComprasListRelationFilter
    cursos?: XOR<CursosScalarRelationFilter, cursosWhereInput>
    docente?: XOR<DocenteNullableScalarRelationFilter, docenteWhereInput> | null
    examenes?: ExamenesListRelationFilter
    inscripciones?: InscripcionesListRelationFilter
    pagosDocentes?: XOR<PagosDocentesNullableScalarRelationFilter, pagosDocentesWhereInput> | null
    preciosCursos?: PreciosCursosListRelationFilter
  }

  export type edicionesCursosOrderByWithRelationInput = {
    id?: SortOrder
    codigo?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    estado?: SortOrder
    fechaFin?: SortOrder
    fechaInicio?: SortOrder
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
    urlWhatsapp?: SortOrderInput | SortOrder
    vigente?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    docenteId?: SortOrderInput | SortOrder
    certificados?: certificadosOrderByRelationAggregateInput
    clases?: clasesOrderByRelationAggregateInput
    compras?: comprasOrderByRelationAggregateInput
    cursos?: cursosOrderByWithRelationInput
    docente?: docenteOrderByWithRelationInput
    examenes?: examenesOrderByRelationAggregateInput
    inscripciones?: inscripcionesOrderByRelationAggregateInput
    pagosDocentes?: pagosDocentesOrderByWithRelationInput
    preciosCursos?: preciosCursosOrderByRelationAggregateInput
  }

  export type edicionesCursosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cursoId_codigo_docenteId?: edicionesCursosCursoIdCodigoDocenteIdCompoundUniqueInput
    AND?: edicionesCursosWhereInput | edicionesCursosWhereInput[]
    OR?: edicionesCursosWhereInput[]
    NOT?: edicionesCursosWhereInput | edicionesCursosWhereInput[]
    codigo?: StringFilter<"edicionesCursos"> | string
    cursoId?: StringFilter<"edicionesCursos"> | string
    descripcion?: StringNullableFilter<"edicionesCursos"> | string | null
    estado?: EnumEdicionEstadoFilter<"edicionesCursos"> | $Enums.EdicionEstado
    fechaFin?: DateTimeFilter<"edicionesCursos"> | Date | string
    fechaInicio?: DateTimeFilter<"edicionesCursos"> | Date | string
    notaMaxima?: FloatFilter<"edicionesCursos"> | number
    notaMinima?: FloatFilter<"edicionesCursos"> | number
    urlWhatsapp?: StringNullableFilter<"edicionesCursos"> | string | null
    vigente?: BoolFilter<"edicionesCursos"> | boolean
    creadoEn?: DateTimeFilter<"edicionesCursos"> | Date | string
    actualizadoEn?: DateTimeFilter<"edicionesCursos"> | Date | string
    docenteId?: StringNullableFilter<"edicionesCursos"> | string | null
    certificados?: CertificadosListRelationFilter
    clases?: ClasesListRelationFilter
    compras?: ComprasListRelationFilter
    cursos?: XOR<CursosScalarRelationFilter, cursosWhereInput>
    docente?: XOR<DocenteNullableScalarRelationFilter, docenteWhereInput> | null
    examenes?: ExamenesListRelationFilter
    inscripciones?: InscripcionesListRelationFilter
    pagosDocentes?: XOR<PagosDocentesNullableScalarRelationFilter, pagosDocentesWhereInput> | null
    preciosCursos?: PreciosCursosListRelationFilter
  }, "id" | "cursoId_codigo_docenteId">

  export type edicionesCursosOrderByWithAggregationInput = {
    id?: SortOrder
    codigo?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    estado?: SortOrder
    fechaFin?: SortOrder
    fechaInicio?: SortOrder
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
    urlWhatsapp?: SortOrderInput | SortOrder
    vigente?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    docenteId?: SortOrderInput | SortOrder
    _count?: edicionesCursosCountOrderByAggregateInput
    _avg?: edicionesCursosAvgOrderByAggregateInput
    _max?: edicionesCursosMaxOrderByAggregateInput
    _min?: edicionesCursosMinOrderByAggregateInput
    _sum?: edicionesCursosSumOrderByAggregateInput
  }

  export type edicionesCursosScalarWhereWithAggregatesInput = {
    AND?: edicionesCursosScalarWhereWithAggregatesInput | edicionesCursosScalarWhereWithAggregatesInput[]
    OR?: edicionesCursosScalarWhereWithAggregatesInput[]
    NOT?: edicionesCursosScalarWhereWithAggregatesInput | edicionesCursosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"edicionesCursos"> | string
    codigo?: StringWithAggregatesFilter<"edicionesCursos"> | string
    cursoId?: StringWithAggregatesFilter<"edicionesCursos"> | string
    descripcion?: StringNullableWithAggregatesFilter<"edicionesCursos"> | string | null
    estado?: EnumEdicionEstadoWithAggregatesFilter<"edicionesCursos"> | $Enums.EdicionEstado
    fechaFin?: DateTimeWithAggregatesFilter<"edicionesCursos"> | Date | string
    fechaInicio?: DateTimeWithAggregatesFilter<"edicionesCursos"> | Date | string
    notaMaxima?: FloatWithAggregatesFilter<"edicionesCursos"> | number
    notaMinima?: FloatWithAggregatesFilter<"edicionesCursos"> | number
    urlWhatsapp?: StringNullableWithAggregatesFilter<"edicionesCursos"> | string | null
    vigente?: BoolWithAggregatesFilter<"edicionesCursos"> | boolean
    creadoEn?: DateTimeWithAggregatesFilter<"edicionesCursos"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"edicionesCursos"> | Date | string
    docenteId?: StringNullableWithAggregatesFilter<"edicionesCursos"> | string | null
  }

  export type estudiantesWhereInput = {
    AND?: estudiantesWhereInput | estudiantesWhereInput[]
    OR?: estudiantesWhereInput[]
    NOT?: estudiantesWhereInput | estudiantesWhereInput[]
    id?: StringFilter<"estudiantes"> | string
    apellido?: StringNullableFilter<"estudiantes"> | string | null
    celular?: StringNullableFilter<"estudiantes"> | string | null
    pais?: StringFilter<"estudiantes"> | string
    genero?: EnumTipoGeneroFilter<"estudiantes"> | $Enums.TipoGenero
    fechaNacimiento?: DateTimeNullableFilter<"estudiantes"> | Date | string | null
    nombre?: StringFilter<"estudiantes"> | string
    creadoEn?: DateTimeFilter<"estudiantes"> | Date | string
    actualizadoEn?: DateTimeFilter<"estudiantes"> | Date | string
    nroUpdates?: IntFilter<"estudiantes"> | number
    calificaciones?: CalificacionesListRelationFilter
    certificados?: CertificadosListRelationFilter
    inscripciones?: InscripcionesListRelationFilter
    usuariosEstudiantes?: XOR<UsuariosEstudiantesNullableScalarRelationFilter, usuariosEstudiantesWhereInput> | null
  }

  export type estudiantesOrderByWithRelationInput = {
    id?: SortOrder
    apellido?: SortOrderInput | SortOrder
    celular?: SortOrderInput | SortOrder
    pais?: SortOrder
    genero?: SortOrder
    fechaNacimiento?: SortOrderInput | SortOrder
    nombre?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    nroUpdates?: SortOrder
    calificaciones?: calificacionesOrderByRelationAggregateInput
    certificados?: certificadosOrderByRelationAggregateInput
    inscripciones?: inscripcionesOrderByRelationAggregateInput
    usuariosEstudiantes?: usuariosEstudiantesOrderByWithRelationInput
  }

  export type estudiantesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: estudiantesWhereInput | estudiantesWhereInput[]
    OR?: estudiantesWhereInput[]
    NOT?: estudiantesWhereInput | estudiantesWhereInput[]
    apellido?: StringNullableFilter<"estudiantes"> | string | null
    celular?: StringNullableFilter<"estudiantes"> | string | null
    pais?: StringFilter<"estudiantes"> | string
    genero?: EnumTipoGeneroFilter<"estudiantes"> | $Enums.TipoGenero
    fechaNacimiento?: DateTimeNullableFilter<"estudiantes"> | Date | string | null
    nombre?: StringFilter<"estudiantes"> | string
    creadoEn?: DateTimeFilter<"estudiantes"> | Date | string
    actualizadoEn?: DateTimeFilter<"estudiantes"> | Date | string
    nroUpdates?: IntFilter<"estudiantes"> | number
    calificaciones?: CalificacionesListRelationFilter
    certificados?: CertificadosListRelationFilter
    inscripciones?: InscripcionesListRelationFilter
    usuariosEstudiantes?: XOR<UsuariosEstudiantesNullableScalarRelationFilter, usuariosEstudiantesWhereInput> | null
  }, "id">

  export type estudiantesOrderByWithAggregationInput = {
    id?: SortOrder
    apellido?: SortOrderInput | SortOrder
    celular?: SortOrderInput | SortOrder
    pais?: SortOrder
    genero?: SortOrder
    fechaNacimiento?: SortOrderInput | SortOrder
    nombre?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    nroUpdates?: SortOrder
    _count?: estudiantesCountOrderByAggregateInput
    _avg?: estudiantesAvgOrderByAggregateInput
    _max?: estudiantesMaxOrderByAggregateInput
    _min?: estudiantesMinOrderByAggregateInput
    _sum?: estudiantesSumOrderByAggregateInput
  }

  export type estudiantesScalarWhereWithAggregatesInput = {
    AND?: estudiantesScalarWhereWithAggregatesInput | estudiantesScalarWhereWithAggregatesInput[]
    OR?: estudiantesScalarWhereWithAggregatesInput[]
    NOT?: estudiantesScalarWhereWithAggregatesInput | estudiantesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"estudiantes"> | string
    apellido?: StringNullableWithAggregatesFilter<"estudiantes"> | string | null
    celular?: StringNullableWithAggregatesFilter<"estudiantes"> | string | null
    pais?: StringWithAggregatesFilter<"estudiantes"> | string
    genero?: EnumTipoGeneroWithAggregatesFilter<"estudiantes"> | $Enums.TipoGenero
    fechaNacimiento?: DateTimeNullableWithAggregatesFilter<"estudiantes"> | Date | string | null
    nombre?: StringWithAggregatesFilter<"estudiantes"> | string
    creadoEn?: DateTimeWithAggregatesFilter<"estudiantes"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"estudiantes"> | Date | string
    nroUpdates?: IntWithAggregatesFilter<"estudiantes"> | number
  }

  export type temasWhereInput = {
    AND?: temasWhereInput | temasWhereInput[]
    OR?: temasWhereInput[]
    NOT?: temasWhereInput | temasWhereInput[]
    id?: StringFilter<"temas"> | string
    titulo?: StringFilter<"temas"> | string
    descripcion?: StringNullableFilter<"temas"> | string | null
    capituloId?: StringNullableFilter<"temas"> | string | null
    creadoEn?: DateTimeFilter<"temas"> | Date | string
    actualizadoEn?: DateTimeFilter<"temas"> | Date | string
    capitulos?: XOR<CapitulosNullableScalarRelationFilter, capitulosWhereInput> | null
    preguntas?: PreguntasListRelationFilter
  }

  export type temasOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    capituloId?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    capitulos?: capitulosOrderByWithRelationInput
    preguntas?: preguntasOrderByRelationAggregateInput
  }

  export type temasWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: temasWhereInput | temasWhereInput[]
    OR?: temasWhereInput[]
    NOT?: temasWhereInput | temasWhereInput[]
    titulo?: StringFilter<"temas"> | string
    descripcion?: StringNullableFilter<"temas"> | string | null
    capituloId?: StringNullableFilter<"temas"> | string | null
    creadoEn?: DateTimeFilter<"temas"> | Date | string
    actualizadoEn?: DateTimeFilter<"temas"> | Date | string
    capitulos?: XOR<CapitulosNullableScalarRelationFilter, capitulosWhereInput> | null
    preguntas?: PreguntasListRelationFilter
  }, "id">

  export type temasOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    capituloId?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    _count?: temasCountOrderByAggregateInput
    _max?: temasMaxOrderByAggregateInput
    _min?: temasMinOrderByAggregateInput
  }

  export type temasScalarWhereWithAggregatesInput = {
    AND?: temasScalarWhereWithAggregatesInput | temasScalarWhereWithAggregatesInput[]
    OR?: temasScalarWhereWithAggregatesInput[]
    NOT?: temasScalarWhereWithAggregatesInput | temasScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"temas"> | string
    titulo?: StringWithAggregatesFilter<"temas"> | string
    descripcion?: StringNullableWithAggregatesFilter<"temas"> | string | null
    capituloId?: StringNullableWithAggregatesFilter<"temas"> | string | null
    creadoEn?: DateTimeWithAggregatesFilter<"temas"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"temas"> | Date | string
  }

  export type examenesWhereInput = {
    AND?: examenesWhereInput | examenesWhereInput[]
    OR?: examenesWhereInput[]
    NOT?: examenesWhereInput | examenesWhereInput[]
    id?: StringFilter<"examenes"> | string
    edicionId?: StringFilter<"examenes"> | string
    descripcion?: StringNullableFilter<"examenes"> | string | null
    fechaDisponible?: DateTimeFilter<"examenes"> | Date | string
    fechaLimite?: DateTimeFilter<"examenes"> | Date | string
    notaMaxima?: FloatFilter<"examenes"> | number
    notaMinima?: FloatFilter<"examenes"> | number
    titulo?: StringFilter<"examenes"> | string
    creadoEn?: DateTimeFilter<"examenes"> | Date | string
    calificaciones?: CalificacionesListRelationFilter
    edicionesCursos?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
  }

  export type examenesOrderByWithRelationInput = {
    id?: SortOrder
    edicionId?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    fechaDisponible?: SortOrder
    fechaLimite?: SortOrder
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
    titulo?: SortOrder
    creadoEn?: SortOrder
    calificaciones?: calificacionesOrderByRelationAggregateInput
    edicionesCursos?: edicionesCursosOrderByWithRelationInput
  }

  export type examenesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: examenesWhereInput | examenesWhereInput[]
    OR?: examenesWhereInput[]
    NOT?: examenesWhereInput | examenesWhereInput[]
    edicionId?: StringFilter<"examenes"> | string
    descripcion?: StringNullableFilter<"examenes"> | string | null
    fechaDisponible?: DateTimeFilter<"examenes"> | Date | string
    fechaLimite?: DateTimeFilter<"examenes"> | Date | string
    notaMaxima?: FloatFilter<"examenes"> | number
    notaMinima?: FloatFilter<"examenes"> | number
    titulo?: StringFilter<"examenes"> | string
    creadoEn?: DateTimeFilter<"examenes"> | Date | string
    calificaciones?: CalificacionesListRelationFilter
    edicionesCursos?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
  }, "id">

  export type examenesOrderByWithAggregationInput = {
    id?: SortOrder
    edicionId?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    fechaDisponible?: SortOrder
    fechaLimite?: SortOrder
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
    titulo?: SortOrder
    creadoEn?: SortOrder
    _count?: examenesCountOrderByAggregateInput
    _avg?: examenesAvgOrderByAggregateInput
    _max?: examenesMaxOrderByAggregateInput
    _min?: examenesMinOrderByAggregateInput
    _sum?: examenesSumOrderByAggregateInput
  }

  export type examenesScalarWhereWithAggregatesInput = {
    AND?: examenesScalarWhereWithAggregatesInput | examenesScalarWhereWithAggregatesInput[]
    OR?: examenesScalarWhereWithAggregatesInput[]
    NOT?: examenesScalarWhereWithAggregatesInput | examenesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"examenes"> | string
    edicionId?: StringWithAggregatesFilter<"examenes"> | string
    descripcion?: StringNullableWithAggregatesFilter<"examenes"> | string | null
    fechaDisponible?: DateTimeWithAggregatesFilter<"examenes"> | Date | string
    fechaLimite?: DateTimeWithAggregatesFilter<"examenes"> | Date | string
    notaMaxima?: FloatWithAggregatesFilter<"examenes"> | number
    notaMinima?: FloatWithAggregatesFilter<"examenes"> | number
    titulo?: StringWithAggregatesFilter<"examenes"> | string
    creadoEn?: DateTimeWithAggregatesFilter<"examenes"> | Date | string
  }

  export type grabacionesWhereInput = {
    AND?: grabacionesWhereInput | grabacionesWhereInput[]
    OR?: grabacionesWhereInput[]
    NOT?: grabacionesWhereInput | grabacionesWhereInput[]
    id?: StringFilter<"grabaciones"> | string
    claseId?: StringFilter<"grabaciones"> | string
    usuarioId?: StringFilter<"grabaciones"> | string
    fechaInicio?: DateTimeFilter<"grabaciones"> | Date | string
    fechaFin?: DateTimeNullableFilter<"grabaciones"> | Date | string | null
    duracionSegundos?: IntNullableFilter<"grabaciones"> | number | null
    completada?: BoolFilter<"grabaciones"> | boolean
    clases?: XOR<ClasesScalarRelationFilter, clasesWhereInput>
    usuariosAdministradores?: XOR<UsuariosAdministradoresScalarRelationFilter, usuariosAdministradoresWhereInput>
  }

  export type grabacionesOrderByWithRelationInput = {
    id?: SortOrder
    claseId?: SortOrder
    usuarioId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrderInput | SortOrder
    duracionSegundos?: SortOrderInput | SortOrder
    completada?: SortOrder
    clases?: clasesOrderByWithRelationInput
    usuariosAdministradores?: usuariosAdministradoresOrderByWithRelationInput
  }

  export type grabacionesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: grabacionesWhereInput | grabacionesWhereInput[]
    OR?: grabacionesWhereInput[]
    NOT?: grabacionesWhereInput | grabacionesWhereInput[]
    claseId?: StringFilter<"grabaciones"> | string
    usuarioId?: StringFilter<"grabaciones"> | string
    fechaInicio?: DateTimeFilter<"grabaciones"> | Date | string
    fechaFin?: DateTimeNullableFilter<"grabaciones"> | Date | string | null
    duracionSegundos?: IntNullableFilter<"grabaciones"> | number | null
    completada?: BoolFilter<"grabaciones"> | boolean
    clases?: XOR<ClasesScalarRelationFilter, clasesWhereInput>
    usuariosAdministradores?: XOR<UsuariosAdministradoresScalarRelationFilter, usuariosAdministradoresWhereInput>
  }, "id">

  export type grabacionesOrderByWithAggregationInput = {
    id?: SortOrder
    claseId?: SortOrder
    usuarioId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrderInput | SortOrder
    duracionSegundos?: SortOrderInput | SortOrder
    completada?: SortOrder
    _count?: grabacionesCountOrderByAggregateInput
    _avg?: grabacionesAvgOrderByAggregateInput
    _max?: grabacionesMaxOrderByAggregateInput
    _min?: grabacionesMinOrderByAggregateInput
    _sum?: grabacionesSumOrderByAggregateInput
  }

  export type grabacionesScalarWhereWithAggregatesInput = {
    AND?: grabacionesScalarWhereWithAggregatesInput | grabacionesScalarWhereWithAggregatesInput[]
    OR?: grabacionesScalarWhereWithAggregatesInput[]
    NOT?: grabacionesScalarWhereWithAggregatesInput | grabacionesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"grabaciones"> | string
    claseId?: StringWithAggregatesFilter<"grabaciones"> | string
    usuarioId?: StringWithAggregatesFilter<"grabaciones"> | string
    fechaInicio?: DateTimeWithAggregatesFilter<"grabaciones"> | Date | string
    fechaFin?: DateTimeNullableWithAggregatesFilter<"grabaciones"> | Date | string | null
    duracionSegundos?: IntNullableWithAggregatesFilter<"grabaciones"> | number | null
    completada?: BoolWithAggregatesFilter<"grabaciones"> | boolean
  }

  export type inscripcionesWhereInput = {
    AND?: inscripcionesWhereInput | inscripcionesWhereInput[]
    OR?: inscripcionesWhereInput[]
    NOT?: inscripcionesWhereInput | inscripcionesWhereInput[]
    id?: StringFilter<"inscripciones"> | string
    edicionId?: StringFilter<"inscripciones"> | string
    estado?: BoolFilter<"inscripciones"> | boolean
    estudianteId?: StringFilter<"inscripciones"> | string
    inscritoEn?: DateTimeFilter<"inscripciones"> | Date | string
    compraId?: StringFilter<"inscripciones"> | string
    compras?: XOR<ComprasScalarRelationFilter, comprasWhereInput>
    edicionesCursos?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
    estudiantes?: XOR<EstudiantesScalarRelationFilter, estudiantesWhereInput>
  }

  export type inscripcionesOrderByWithRelationInput = {
    id?: SortOrder
    edicionId?: SortOrder
    estado?: SortOrder
    estudianteId?: SortOrder
    inscritoEn?: SortOrder
    compraId?: SortOrder
    compras?: comprasOrderByWithRelationInput
    edicionesCursos?: edicionesCursosOrderByWithRelationInput
    estudiantes?: estudiantesOrderByWithRelationInput
  }

  export type inscripcionesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    compraId?: string
    estudianteId_edicionId?: inscripcionesEstudianteIdEdicionIdCompoundUniqueInput
    AND?: inscripcionesWhereInput | inscripcionesWhereInput[]
    OR?: inscripcionesWhereInput[]
    NOT?: inscripcionesWhereInput | inscripcionesWhereInput[]
    edicionId?: StringFilter<"inscripciones"> | string
    estado?: BoolFilter<"inscripciones"> | boolean
    estudianteId?: StringFilter<"inscripciones"> | string
    inscritoEn?: DateTimeFilter<"inscripciones"> | Date | string
    compras?: XOR<ComprasScalarRelationFilter, comprasWhereInput>
    edicionesCursos?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
    estudiantes?: XOR<EstudiantesScalarRelationFilter, estudiantesWhereInput>
  }, "id" | "compraId" | "estudianteId_edicionId">

  export type inscripcionesOrderByWithAggregationInput = {
    id?: SortOrder
    edicionId?: SortOrder
    estado?: SortOrder
    estudianteId?: SortOrder
    inscritoEn?: SortOrder
    compraId?: SortOrder
    _count?: inscripcionesCountOrderByAggregateInput
    _max?: inscripcionesMaxOrderByAggregateInput
    _min?: inscripcionesMinOrderByAggregateInput
  }

  export type inscripcionesScalarWhereWithAggregatesInput = {
    AND?: inscripcionesScalarWhereWithAggregatesInput | inscripcionesScalarWhereWithAggregatesInput[]
    OR?: inscripcionesScalarWhereWithAggregatesInput[]
    NOT?: inscripcionesScalarWhereWithAggregatesInput | inscripcionesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"inscripciones"> | string
    edicionId?: StringWithAggregatesFilter<"inscripciones"> | string
    estado?: BoolWithAggregatesFilter<"inscripciones"> | boolean
    estudianteId?: StringWithAggregatesFilter<"inscripciones"> | string
    inscritoEn?: DateTimeWithAggregatesFilter<"inscripciones"> | Date | string
    compraId?: StringWithAggregatesFilter<"inscripciones"> | string
  }

  export type materialesWhereInput = {
    AND?: materialesWhereInput | materialesWhereInput[]
    OR?: materialesWhereInput[]
    NOT?: materialesWhereInput | materialesWhereInput[]
    id?: StringFilter<"materiales"> | string
    claseId?: StringFilter<"materiales"> | string
    tipo?: EnumTipoMaterialFilter<"materiales"> | $Enums.TipoMaterial
    titulo?: StringFilter<"materiales"> | string
    url?: StringFilter<"materiales"> | string
    creadoEn?: DateTimeFilter<"materiales"> | Date | string
    clases?: XOR<ClasesScalarRelationFilter, clasesWhereInput>
  }

  export type materialesOrderByWithRelationInput = {
    id?: SortOrder
    claseId?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    url?: SortOrder
    creadoEn?: SortOrder
    clases?: clasesOrderByWithRelationInput
  }

  export type materialesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: materialesWhereInput | materialesWhereInput[]
    OR?: materialesWhereInput[]
    NOT?: materialesWhereInput | materialesWhereInput[]
    claseId?: StringFilter<"materiales"> | string
    tipo?: EnumTipoMaterialFilter<"materiales"> | $Enums.TipoMaterial
    titulo?: StringFilter<"materiales"> | string
    url?: StringFilter<"materiales"> | string
    creadoEn?: DateTimeFilter<"materiales"> | Date | string
    clases?: XOR<ClasesScalarRelationFilter, clasesWhereInput>
  }, "id">

  export type materialesOrderByWithAggregationInput = {
    id?: SortOrder
    claseId?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    url?: SortOrder
    creadoEn?: SortOrder
    _count?: materialesCountOrderByAggregateInput
    _max?: materialesMaxOrderByAggregateInput
    _min?: materialesMinOrderByAggregateInput
  }

  export type materialesScalarWhereWithAggregatesInput = {
    AND?: materialesScalarWhereWithAggregatesInput | materialesScalarWhereWithAggregatesInput[]
    OR?: materialesScalarWhereWithAggregatesInput[]
    NOT?: materialesScalarWhereWithAggregatesInput | materialesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"materiales"> | string
    claseId?: StringWithAggregatesFilter<"materiales"> | string
    tipo?: EnumTipoMaterialWithAggregatesFilter<"materiales"> | $Enums.TipoMaterial
    titulo?: StringWithAggregatesFilter<"materiales"> | string
    url?: StringWithAggregatesFilter<"materiales"> | string
    creadoEn?: DateTimeWithAggregatesFilter<"materiales"> | Date | string
  }

  export type objetivosCursosWhereInput = {
    AND?: objetivosCursosWhereInput | objetivosCursosWhereInput[]
    OR?: objetivosCursosWhereInput[]
    NOT?: objetivosCursosWhereInput | objetivosCursosWhereInput[]
    id?: StringFilter<"objetivosCursos"> | string
    cursoId?: StringFilter<"objetivosCursos"> | string
    descripcion?: StringFilter<"objetivosCursos"> | string
    orden?: IntFilter<"objetivosCursos"> | number
    creadoEn?: DateTimeFilter<"objetivosCursos"> | Date | string
    cursos?: XOR<CursosScalarRelationFilter, cursosWhereInput>
  }

  export type objetivosCursosOrderByWithRelationInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
    cursos?: cursosOrderByWithRelationInput
  }

  export type objetivosCursosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: objetivosCursosWhereInput | objetivosCursosWhereInput[]
    OR?: objetivosCursosWhereInput[]
    NOT?: objetivosCursosWhereInput | objetivosCursosWhereInput[]
    cursoId?: StringFilter<"objetivosCursos"> | string
    descripcion?: StringFilter<"objetivosCursos"> | string
    orden?: IntFilter<"objetivosCursos"> | number
    creadoEn?: DateTimeFilter<"objetivosCursos"> | Date | string
    cursos?: XOR<CursosScalarRelationFilter, cursosWhereInput>
  }, "id">

  export type objetivosCursosOrderByWithAggregationInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
    _count?: objetivosCursosCountOrderByAggregateInput
    _avg?: objetivosCursosAvgOrderByAggregateInput
    _max?: objetivosCursosMaxOrderByAggregateInput
    _min?: objetivosCursosMinOrderByAggregateInput
    _sum?: objetivosCursosSumOrderByAggregateInput
  }

  export type objetivosCursosScalarWhereWithAggregatesInput = {
    AND?: objetivosCursosScalarWhereWithAggregatesInput | objetivosCursosScalarWhereWithAggregatesInput[]
    OR?: objetivosCursosScalarWhereWithAggregatesInput[]
    NOT?: objetivosCursosScalarWhereWithAggregatesInput | objetivosCursosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"objetivosCursos"> | string
    cursoId?: StringWithAggregatesFilter<"objetivosCursos"> | string
    descripcion?: StringWithAggregatesFilter<"objetivosCursos"> | string
    orden?: IntWithAggregatesFilter<"objetivosCursos"> | number
    creadoEn?: DateTimeWithAggregatesFilter<"objetivosCursos"> | Date | string
  }

  export type pagosDocentesWhereInput = {
    AND?: pagosDocentesWhereInput | pagosDocentesWhereInput[]
    OR?: pagosDocentesWhereInput[]
    NOT?: pagosDocentesWhereInput | pagosDocentesWhereInput[]
    id?: StringFilter<"pagosDocentes"> | string
    docenteId?: StringFilter<"pagosDocentes"> | string
    edicionId?: StringFilter<"pagosDocentes"> | string
    monto?: FloatFilter<"pagosDocentes"> | number
    deuda?: FloatFilter<"pagosDocentes"> | number
    estadoPago?: EnumEstadoPagoFilter<"pagosDocentes"> | $Enums.EstadoPago
    fechaPago?: DateTimeNullableFilter<"pagosDocentes"> | Date | string | null
    creadoEn?: DateTimeFilter<"pagosDocentes"> | Date | string
    actualizadoEn?: DateTimeFilter<"pagosDocentes"> | Date | string
    docente?: XOR<DocenteScalarRelationFilter, docenteWhereInput>
    edicionesCursos?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
  }

  export type pagosDocentesOrderByWithRelationInput = {
    id?: SortOrder
    docenteId?: SortOrder
    edicionId?: SortOrder
    monto?: SortOrder
    deuda?: SortOrder
    estadoPago?: SortOrder
    fechaPago?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    docente?: docenteOrderByWithRelationInput
    edicionesCursos?: edicionesCursosOrderByWithRelationInput
  }

  export type pagosDocentesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    edicionId?: string
    AND?: pagosDocentesWhereInput | pagosDocentesWhereInput[]
    OR?: pagosDocentesWhereInput[]
    NOT?: pagosDocentesWhereInput | pagosDocentesWhereInput[]
    docenteId?: StringFilter<"pagosDocentes"> | string
    monto?: FloatFilter<"pagosDocentes"> | number
    deuda?: FloatFilter<"pagosDocentes"> | number
    estadoPago?: EnumEstadoPagoFilter<"pagosDocentes"> | $Enums.EstadoPago
    fechaPago?: DateTimeNullableFilter<"pagosDocentes"> | Date | string | null
    creadoEn?: DateTimeFilter<"pagosDocentes"> | Date | string
    actualizadoEn?: DateTimeFilter<"pagosDocentes"> | Date | string
    docente?: XOR<DocenteScalarRelationFilter, docenteWhereInput>
    edicionesCursos?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
  }, "id" | "edicionId">

  export type pagosDocentesOrderByWithAggregationInput = {
    id?: SortOrder
    docenteId?: SortOrder
    edicionId?: SortOrder
    monto?: SortOrder
    deuda?: SortOrder
    estadoPago?: SortOrder
    fechaPago?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    _count?: pagosDocentesCountOrderByAggregateInput
    _avg?: pagosDocentesAvgOrderByAggregateInput
    _max?: pagosDocentesMaxOrderByAggregateInput
    _min?: pagosDocentesMinOrderByAggregateInput
    _sum?: pagosDocentesSumOrderByAggregateInput
  }

  export type pagosDocentesScalarWhereWithAggregatesInput = {
    AND?: pagosDocentesScalarWhereWithAggregatesInput | pagosDocentesScalarWhereWithAggregatesInput[]
    OR?: pagosDocentesScalarWhereWithAggregatesInput[]
    NOT?: pagosDocentesScalarWhereWithAggregatesInput | pagosDocentesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"pagosDocentes"> | string
    docenteId?: StringWithAggregatesFilter<"pagosDocentes"> | string
    edicionId?: StringWithAggregatesFilter<"pagosDocentes"> | string
    monto?: FloatWithAggregatesFilter<"pagosDocentes"> | number
    deuda?: FloatWithAggregatesFilter<"pagosDocentes"> | number
    estadoPago?: EnumEstadoPagoWithAggregatesFilter<"pagosDocentes"> | $Enums.EstadoPago
    fechaPago?: DateTimeNullableWithAggregatesFilter<"pagosDocentes"> | Date | string | null
    creadoEn?: DateTimeWithAggregatesFilter<"pagosDocentes"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"pagosDocentes"> | Date | string
  }

  export type preciosCursosWhereInput = {
    AND?: preciosCursosWhereInput | preciosCursosWhereInput[]
    OR?: preciosCursosWhereInput[]
    NOT?: preciosCursosWhereInput | preciosCursosWhereInput[]
    id?: StringFilter<"preciosCursos"> | string
    edicionId?: StringFilter<"preciosCursos"> | string
    fechaInicio?: DateTimeNullableFilter<"preciosCursos"> | Date | string | null
    fechaFin?: DateTimeNullableFilter<"preciosCursos"> | Date | string | null
    esDescuento?: BoolFilter<"preciosCursos"> | boolean
    esPrecioDefault?: BoolFilter<"preciosCursos"> | boolean
    moneda?: StringFilter<"preciosCursos"> | string
    nombre?: StringFilter<"preciosCursos"> | string
    porcentajeDescuento?: FloatNullableFilter<"preciosCursos"> | number | null
    precio?: FloatFilter<"preciosCursos"> | number
    precioOriginal?: FloatNullableFilter<"preciosCursos"> | number | null
    creadoEn?: DateTimeFilter<"preciosCursos"> | Date | string
    actualizadoEn?: DateTimeFilter<"preciosCursos"> | Date | string
    edicionesCursos?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
  }

  export type preciosCursosOrderByWithRelationInput = {
    id?: SortOrder
    edicionId?: SortOrder
    fechaInicio?: SortOrderInput | SortOrder
    fechaFin?: SortOrderInput | SortOrder
    esDescuento?: SortOrder
    esPrecioDefault?: SortOrder
    moneda?: SortOrder
    nombre?: SortOrder
    porcentajeDescuento?: SortOrderInput | SortOrder
    precio?: SortOrder
    precioOriginal?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    edicionesCursos?: edicionesCursosOrderByWithRelationInput
  }

  export type preciosCursosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: preciosCursosWhereInput | preciosCursosWhereInput[]
    OR?: preciosCursosWhereInput[]
    NOT?: preciosCursosWhereInput | preciosCursosWhereInput[]
    edicionId?: StringFilter<"preciosCursos"> | string
    fechaInicio?: DateTimeNullableFilter<"preciosCursos"> | Date | string | null
    fechaFin?: DateTimeNullableFilter<"preciosCursos"> | Date | string | null
    esDescuento?: BoolFilter<"preciosCursos"> | boolean
    esPrecioDefault?: BoolFilter<"preciosCursos"> | boolean
    moneda?: StringFilter<"preciosCursos"> | string
    nombre?: StringFilter<"preciosCursos"> | string
    porcentajeDescuento?: FloatNullableFilter<"preciosCursos"> | number | null
    precio?: FloatFilter<"preciosCursos"> | number
    precioOriginal?: FloatNullableFilter<"preciosCursos"> | number | null
    creadoEn?: DateTimeFilter<"preciosCursos"> | Date | string
    actualizadoEn?: DateTimeFilter<"preciosCursos"> | Date | string
    edicionesCursos?: XOR<EdicionesCursosScalarRelationFilter, edicionesCursosWhereInput>
  }, "id">

  export type preciosCursosOrderByWithAggregationInput = {
    id?: SortOrder
    edicionId?: SortOrder
    fechaInicio?: SortOrderInput | SortOrder
    fechaFin?: SortOrderInput | SortOrder
    esDescuento?: SortOrder
    esPrecioDefault?: SortOrder
    moneda?: SortOrder
    nombre?: SortOrder
    porcentajeDescuento?: SortOrderInput | SortOrder
    precio?: SortOrder
    precioOriginal?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    _count?: preciosCursosCountOrderByAggregateInput
    _avg?: preciosCursosAvgOrderByAggregateInput
    _max?: preciosCursosMaxOrderByAggregateInput
    _min?: preciosCursosMinOrderByAggregateInput
    _sum?: preciosCursosSumOrderByAggregateInput
  }

  export type preciosCursosScalarWhereWithAggregatesInput = {
    AND?: preciosCursosScalarWhereWithAggregatesInput | preciosCursosScalarWhereWithAggregatesInput[]
    OR?: preciosCursosScalarWhereWithAggregatesInput[]
    NOT?: preciosCursosScalarWhereWithAggregatesInput | preciosCursosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"preciosCursos"> | string
    edicionId?: StringWithAggregatesFilter<"preciosCursos"> | string
    fechaInicio?: DateTimeNullableWithAggregatesFilter<"preciosCursos"> | Date | string | null
    fechaFin?: DateTimeNullableWithAggregatesFilter<"preciosCursos"> | Date | string | null
    esDescuento?: BoolWithAggregatesFilter<"preciosCursos"> | boolean
    esPrecioDefault?: BoolWithAggregatesFilter<"preciosCursos"> | boolean
    moneda?: StringWithAggregatesFilter<"preciosCursos"> | string
    nombre?: StringWithAggregatesFilter<"preciosCursos"> | string
    porcentajeDescuento?: FloatNullableWithAggregatesFilter<"preciosCursos"> | number | null
    precio?: FloatWithAggregatesFilter<"preciosCursos"> | number
    precioOriginal?: FloatNullableWithAggregatesFilter<"preciosCursos"> | number | null
    creadoEn?: DateTimeWithAggregatesFilter<"preciosCursos"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"preciosCursos"> | Date | string
  }

  export type preguntasWhereInput = {
    AND?: preguntasWhereInput | preguntasWhereInput[]
    OR?: preguntasWhereInput[]
    NOT?: preguntasWhereInput | preguntasWhereInput[]
    id?: StringFilter<"preguntas"> | string
    codigo?: StringFilter<"preguntas"> | string
    enunciado?: StringFilter<"preguntas"> | string
    explicacion?: StringNullableFilter<"preguntas"> | string | null
    referencia?: StringNullableFilter<"preguntas"> | string | null
    opciones?: JsonFilter<"preguntas">
    solucion?: JsonFilter<"preguntas">
    estado?: EnumPreguntaEstadoFilter<"preguntas"> | $Enums.PreguntaEstado
    gestion?: IntFilter<"preguntas"> | number
    likes?: IntFilter<"preguntas"> | number
    dislikes?: IntFilter<"preguntas"> | number
    dificultad?: EnumPreguntaDificultadFilter<"preguntas"> | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: DateTimeNullableFilter<"preguntas"> | Date | string | null
    tasaAcierto?: IntFilter<"preguntas"> | number
    totalBien?: IntFilter<"preguntas"> | number
    totalMal?: IntFilter<"preguntas"> | number
    totalRespondidas?: IntFilter<"preguntas"> | number
    creadoEn?: DateTimeFilter<"preguntas"> | Date | string
    actualizadoEn?: DateTimeFilter<"preguntas"> | Date | string
    reaccionesPreguntas?: ReaccionesPreguntasListRelationFilter
    repasoRegistros?: RepasoRegistrosListRelationFilter
    respuestasIntentos?: RespuestasIntentosListRelationFilter
    areas?: AreasListRelationFilter
    banqueo?: BanqueoListRelationFilter
    capitulos?: CapitulosListRelationFilter
    temas?: TemasListRelationFilter
  }

  export type preguntasOrderByWithRelationInput = {
    id?: SortOrder
    codigo?: SortOrder
    enunciado?: SortOrder
    explicacion?: SortOrderInput | SortOrder
    referencia?: SortOrderInput | SortOrder
    opciones?: SortOrder
    solucion?: SortOrder
    estado?: SortOrder
    gestion?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    dificultad?: SortOrder
    dificultadActualizadaEn?: SortOrderInput | SortOrder
    tasaAcierto?: SortOrder
    totalBien?: SortOrder
    totalMal?: SortOrder
    totalRespondidas?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    reaccionesPreguntas?: reaccionesPreguntasOrderByRelationAggregateInput
    repasoRegistros?: repasoRegistrosOrderByRelationAggregateInput
    respuestasIntentos?: respuestasIntentosOrderByRelationAggregateInput
    areas?: areasOrderByRelationAggregateInput
    banqueo?: banqueoOrderByRelationAggregateInput
    capitulos?: capitulosOrderByRelationAggregateInput
    temas?: temasOrderByRelationAggregateInput
  }

  export type preguntasWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    codigo?: string
    AND?: preguntasWhereInput | preguntasWhereInput[]
    OR?: preguntasWhereInput[]
    NOT?: preguntasWhereInput | preguntasWhereInput[]
    enunciado?: StringFilter<"preguntas"> | string
    explicacion?: StringNullableFilter<"preguntas"> | string | null
    referencia?: StringNullableFilter<"preguntas"> | string | null
    opciones?: JsonFilter<"preguntas">
    solucion?: JsonFilter<"preguntas">
    estado?: EnumPreguntaEstadoFilter<"preguntas"> | $Enums.PreguntaEstado
    gestion?: IntFilter<"preguntas"> | number
    likes?: IntFilter<"preguntas"> | number
    dislikes?: IntFilter<"preguntas"> | number
    dificultad?: EnumPreguntaDificultadFilter<"preguntas"> | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: DateTimeNullableFilter<"preguntas"> | Date | string | null
    tasaAcierto?: IntFilter<"preguntas"> | number
    totalBien?: IntFilter<"preguntas"> | number
    totalMal?: IntFilter<"preguntas"> | number
    totalRespondidas?: IntFilter<"preguntas"> | number
    creadoEn?: DateTimeFilter<"preguntas"> | Date | string
    actualizadoEn?: DateTimeFilter<"preguntas"> | Date | string
    reaccionesPreguntas?: ReaccionesPreguntasListRelationFilter
    repasoRegistros?: RepasoRegistrosListRelationFilter
    respuestasIntentos?: RespuestasIntentosListRelationFilter
    areas?: AreasListRelationFilter
    banqueo?: BanqueoListRelationFilter
    capitulos?: CapitulosListRelationFilter
    temas?: TemasListRelationFilter
  }, "id" | "codigo">

  export type preguntasOrderByWithAggregationInput = {
    id?: SortOrder
    codigo?: SortOrder
    enunciado?: SortOrder
    explicacion?: SortOrderInput | SortOrder
    referencia?: SortOrderInput | SortOrder
    opciones?: SortOrder
    solucion?: SortOrder
    estado?: SortOrder
    gestion?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    dificultad?: SortOrder
    dificultadActualizadaEn?: SortOrderInput | SortOrder
    tasaAcierto?: SortOrder
    totalBien?: SortOrder
    totalMal?: SortOrder
    totalRespondidas?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    _count?: preguntasCountOrderByAggregateInput
    _avg?: preguntasAvgOrderByAggregateInput
    _max?: preguntasMaxOrderByAggregateInput
    _min?: preguntasMinOrderByAggregateInput
    _sum?: preguntasSumOrderByAggregateInput
  }

  export type preguntasScalarWhereWithAggregatesInput = {
    AND?: preguntasScalarWhereWithAggregatesInput | preguntasScalarWhereWithAggregatesInput[]
    OR?: preguntasScalarWhereWithAggregatesInput[]
    NOT?: preguntasScalarWhereWithAggregatesInput | preguntasScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"preguntas"> | string
    codigo?: StringWithAggregatesFilter<"preguntas"> | string
    enunciado?: StringWithAggregatesFilter<"preguntas"> | string
    explicacion?: StringNullableWithAggregatesFilter<"preguntas"> | string | null
    referencia?: StringNullableWithAggregatesFilter<"preguntas"> | string | null
    opciones?: JsonWithAggregatesFilter<"preguntas">
    solucion?: JsonWithAggregatesFilter<"preguntas">
    estado?: EnumPreguntaEstadoWithAggregatesFilter<"preguntas"> | $Enums.PreguntaEstado
    gestion?: IntWithAggregatesFilter<"preguntas"> | number
    likes?: IntWithAggregatesFilter<"preguntas"> | number
    dislikes?: IntWithAggregatesFilter<"preguntas"> | number
    dificultad?: EnumPreguntaDificultadWithAggregatesFilter<"preguntas"> | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: DateTimeNullableWithAggregatesFilter<"preguntas"> | Date | string | null
    tasaAcierto?: IntWithAggregatesFilter<"preguntas"> | number
    totalBien?: IntWithAggregatesFilter<"preguntas"> | number
    totalMal?: IntWithAggregatesFilter<"preguntas"> | number
    totalRespondidas?: IntWithAggregatesFilter<"preguntas"> | number
    creadoEn?: DateTimeWithAggregatesFilter<"preguntas"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"preguntas"> | Date | string
  }

  export type reaccionesPreguntasWhereInput = {
    AND?: reaccionesPreguntasWhereInput | reaccionesPreguntasWhereInput[]
    OR?: reaccionesPreguntasWhereInput[]
    NOT?: reaccionesPreguntasWhereInput | reaccionesPreguntasWhereInput[]
    id?: StringFilter<"reaccionesPreguntas"> | string
    preguntaId?: StringFilter<"reaccionesPreguntas"> | string
    usuarioEstudianteId?: StringFilter<"reaccionesPreguntas"> | string
    tipo?: EnumTipoReaccionFilter<"reaccionesPreguntas"> | $Enums.TipoReaccion
    creadoEn?: DateTimeFilter<"reaccionesPreguntas"> | Date | string
    actualizadoEn?: DateTimeFilter<"reaccionesPreguntas"> | Date | string
    pregunta?: XOR<PreguntasScalarRelationFilter, preguntasWhereInput>
    usuariosEstudiantes?: XOR<UsuariosEstudiantesScalarRelationFilter, usuariosEstudiantesWhereInput>
  }

  export type reaccionesPreguntasOrderByWithRelationInput = {
    id?: SortOrder
    preguntaId?: SortOrder
    usuarioEstudianteId?: SortOrder
    tipo?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    pregunta?: preguntasOrderByWithRelationInput
    usuariosEstudiantes?: usuariosEstudiantesOrderByWithRelationInput
  }

  export type reaccionesPreguntasWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    preguntaId_usuarioEstudianteId?: reaccionesPreguntasPreguntaIdUsuarioEstudianteIdCompoundUniqueInput
    AND?: reaccionesPreguntasWhereInput | reaccionesPreguntasWhereInput[]
    OR?: reaccionesPreguntasWhereInput[]
    NOT?: reaccionesPreguntasWhereInput | reaccionesPreguntasWhereInput[]
    preguntaId?: StringFilter<"reaccionesPreguntas"> | string
    usuarioEstudianteId?: StringFilter<"reaccionesPreguntas"> | string
    tipo?: EnumTipoReaccionFilter<"reaccionesPreguntas"> | $Enums.TipoReaccion
    creadoEn?: DateTimeFilter<"reaccionesPreguntas"> | Date | string
    actualizadoEn?: DateTimeFilter<"reaccionesPreguntas"> | Date | string
    pregunta?: XOR<PreguntasScalarRelationFilter, preguntasWhereInput>
    usuariosEstudiantes?: XOR<UsuariosEstudiantesScalarRelationFilter, usuariosEstudiantesWhereInput>
  }, "id" | "preguntaId_usuarioEstudianteId">

  export type reaccionesPreguntasOrderByWithAggregationInput = {
    id?: SortOrder
    preguntaId?: SortOrder
    usuarioEstudianteId?: SortOrder
    tipo?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    _count?: reaccionesPreguntasCountOrderByAggregateInput
    _max?: reaccionesPreguntasMaxOrderByAggregateInput
    _min?: reaccionesPreguntasMinOrderByAggregateInput
  }

  export type reaccionesPreguntasScalarWhereWithAggregatesInput = {
    AND?: reaccionesPreguntasScalarWhereWithAggregatesInput | reaccionesPreguntasScalarWhereWithAggregatesInput[]
    OR?: reaccionesPreguntasScalarWhereWithAggregatesInput[]
    NOT?: reaccionesPreguntasScalarWhereWithAggregatesInput | reaccionesPreguntasScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"reaccionesPreguntas"> | string
    preguntaId?: StringWithAggregatesFilter<"reaccionesPreguntas"> | string
    usuarioEstudianteId?: StringWithAggregatesFilter<"reaccionesPreguntas"> | string
    tipo?: EnumTipoReaccionWithAggregatesFilter<"reaccionesPreguntas"> | $Enums.TipoReaccion
    creadoEn?: DateTimeWithAggregatesFilter<"reaccionesPreguntas"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"reaccionesPreguntas"> | Date | string
  }

  export type requisitosCursosWhereInput = {
    AND?: requisitosCursosWhereInput | requisitosCursosWhereInput[]
    OR?: requisitosCursosWhereInput[]
    NOT?: requisitosCursosWhereInput | requisitosCursosWhereInput[]
    id?: StringFilter<"requisitosCursos"> | string
    cursoId?: StringFilter<"requisitosCursos"> | string
    descripcion?: StringFilter<"requisitosCursos"> | string
    orden?: IntFilter<"requisitosCursos"> | number
    creadoEn?: DateTimeFilter<"requisitosCursos"> | Date | string
    cursos?: XOR<CursosScalarRelationFilter, cursosWhereInput>
  }

  export type requisitosCursosOrderByWithRelationInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
    cursos?: cursosOrderByWithRelationInput
  }

  export type requisitosCursosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: requisitosCursosWhereInput | requisitosCursosWhereInput[]
    OR?: requisitosCursosWhereInput[]
    NOT?: requisitosCursosWhereInput | requisitosCursosWhereInput[]
    cursoId?: StringFilter<"requisitosCursos"> | string
    descripcion?: StringFilter<"requisitosCursos"> | string
    orden?: IntFilter<"requisitosCursos"> | number
    creadoEn?: DateTimeFilter<"requisitosCursos"> | Date | string
    cursos?: XOR<CursosScalarRelationFilter, cursosWhereInput>
  }, "id">

  export type requisitosCursosOrderByWithAggregationInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
    _count?: requisitosCursosCountOrderByAggregateInput
    _avg?: requisitosCursosAvgOrderByAggregateInput
    _max?: requisitosCursosMaxOrderByAggregateInput
    _min?: requisitosCursosMinOrderByAggregateInput
    _sum?: requisitosCursosSumOrderByAggregateInput
  }

  export type requisitosCursosScalarWhereWithAggregatesInput = {
    AND?: requisitosCursosScalarWhereWithAggregatesInput | requisitosCursosScalarWhereWithAggregatesInput[]
    OR?: requisitosCursosScalarWhereWithAggregatesInput[]
    NOT?: requisitosCursosScalarWhereWithAggregatesInput | requisitosCursosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"requisitosCursos"> | string
    cursoId?: StringWithAggregatesFilter<"requisitosCursos"> | string
    descripcion?: StringWithAggregatesFilter<"requisitosCursos"> | string
    orden?: IntWithAggregatesFilter<"requisitosCursos"> | number
    creadoEn?: DateTimeWithAggregatesFilter<"requisitosCursos"> | Date | string
  }

  export type reviewsCursosWhereInput = {
    AND?: reviewsCursosWhereInput | reviewsCursosWhereInput[]
    OR?: reviewsCursosWhereInput[]
    NOT?: reviewsCursosWhereInput | reviewsCursosWhereInput[]
    id?: StringFilter<"reviewsCursos"> | string
    cursoId?: StringFilter<"reviewsCursos"> | string
    rating?: IntFilter<"reviewsCursos"> | number
    comentario?: StringNullableFilter<"reviewsCursos"> | string | null
    creadoEn?: DateTimeFilter<"reviewsCursos"> | Date | string
    actualizadoEn?: DateTimeFilter<"reviewsCursos"> | Date | string
    usuariosEstudiantesId?: StringNullableFilter<"reviewsCursos"> | string | null
    cursos?: XOR<CursosScalarRelationFilter, cursosWhereInput>
    usuariosEstudiantes?: XOR<UsuariosEstudiantesNullableScalarRelationFilter, usuariosEstudiantesWhereInput> | null
  }

  export type reviewsCursosOrderByWithRelationInput = {
    id?: SortOrder
    cursoId?: SortOrder
    rating?: SortOrder
    comentario?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    usuariosEstudiantesId?: SortOrderInput | SortOrder
    cursos?: cursosOrderByWithRelationInput
    usuariosEstudiantes?: usuariosEstudiantesOrderByWithRelationInput
  }

  export type reviewsCursosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: reviewsCursosWhereInput | reviewsCursosWhereInput[]
    OR?: reviewsCursosWhereInput[]
    NOT?: reviewsCursosWhereInput | reviewsCursosWhereInput[]
    cursoId?: StringFilter<"reviewsCursos"> | string
    rating?: IntFilter<"reviewsCursos"> | number
    comentario?: StringNullableFilter<"reviewsCursos"> | string | null
    creadoEn?: DateTimeFilter<"reviewsCursos"> | Date | string
    actualizadoEn?: DateTimeFilter<"reviewsCursos"> | Date | string
    usuariosEstudiantesId?: StringNullableFilter<"reviewsCursos"> | string | null
    cursos?: XOR<CursosScalarRelationFilter, cursosWhereInput>
    usuariosEstudiantes?: XOR<UsuariosEstudiantesNullableScalarRelationFilter, usuariosEstudiantesWhereInput> | null
  }, "id">

  export type reviewsCursosOrderByWithAggregationInput = {
    id?: SortOrder
    cursoId?: SortOrder
    rating?: SortOrder
    comentario?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    usuariosEstudiantesId?: SortOrderInput | SortOrder
    _count?: reviewsCursosCountOrderByAggregateInput
    _avg?: reviewsCursosAvgOrderByAggregateInput
    _max?: reviewsCursosMaxOrderByAggregateInput
    _min?: reviewsCursosMinOrderByAggregateInput
    _sum?: reviewsCursosSumOrderByAggregateInput
  }

  export type reviewsCursosScalarWhereWithAggregatesInput = {
    AND?: reviewsCursosScalarWhereWithAggregatesInput | reviewsCursosScalarWhereWithAggregatesInput[]
    OR?: reviewsCursosScalarWhereWithAggregatesInput[]
    NOT?: reviewsCursosScalarWhereWithAggregatesInput | reviewsCursosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"reviewsCursos"> | string
    cursoId?: StringWithAggregatesFilter<"reviewsCursos"> | string
    rating?: IntWithAggregatesFilter<"reviewsCursos"> | number
    comentario?: StringNullableWithAggregatesFilter<"reviewsCursos"> | string | null
    creadoEn?: DateTimeWithAggregatesFilter<"reviewsCursos"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"reviewsCursos"> | Date | string
    usuariosEstudiantesId?: StringNullableWithAggregatesFilter<"reviewsCursos"> | string | null
  }

  export type usuariosAdministradoresWhereInput = {
    AND?: usuariosAdministradoresWhereInput | usuariosAdministradoresWhereInput[]
    OR?: usuariosAdministradoresWhereInput[]
    NOT?: usuariosAdministradoresWhereInput | usuariosAdministradoresWhereInput[]
    id?: StringFilter<"usuariosAdministradores"> | string
    correo?: StringFilter<"usuariosAdministradores"> | string
    contrasena?: StringFilter<"usuariosAdministradores"> | string
    encargado?: StringNullableFilter<"usuariosAdministradores"> | string | null
    estado?: BoolFilter<"usuariosAdministradores"> | boolean
    creadoEn?: DateTimeFilter<"usuariosAdministradores"> | Date | string
    actualizadoEn?: DateTimeFilter<"usuariosAdministradores"> | Date | string
    tipo?: EnumTipoCuentaFilter<"usuariosAdministradores"> | $Enums.TipoCuenta
    auditoria?: AuditoriaListRelationFilter
    docente?: XOR<DocenteNullableScalarRelationFilter, docenteWhereInput> | null
    grabaciones?: GrabacionesListRelationFilter
  }

  export type usuariosAdministradoresOrderByWithRelationInput = {
    id?: SortOrder
    correo?: SortOrder
    contrasena?: SortOrder
    encargado?: SortOrderInput | SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    tipo?: SortOrder
    auditoria?: auditoriaOrderByRelationAggregateInput
    docente?: docenteOrderByWithRelationInput
    grabaciones?: grabacionesOrderByRelationAggregateInput
  }

  export type usuariosAdministradoresWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    correo?: string
    AND?: usuariosAdministradoresWhereInput | usuariosAdministradoresWhereInput[]
    OR?: usuariosAdministradoresWhereInput[]
    NOT?: usuariosAdministradoresWhereInput | usuariosAdministradoresWhereInput[]
    contrasena?: StringFilter<"usuariosAdministradores"> | string
    encargado?: StringNullableFilter<"usuariosAdministradores"> | string | null
    estado?: BoolFilter<"usuariosAdministradores"> | boolean
    creadoEn?: DateTimeFilter<"usuariosAdministradores"> | Date | string
    actualizadoEn?: DateTimeFilter<"usuariosAdministradores"> | Date | string
    tipo?: EnumTipoCuentaFilter<"usuariosAdministradores"> | $Enums.TipoCuenta
    auditoria?: AuditoriaListRelationFilter
    docente?: XOR<DocenteNullableScalarRelationFilter, docenteWhereInput> | null
    grabaciones?: GrabacionesListRelationFilter
  }, "id" | "correo">

  export type usuariosAdministradoresOrderByWithAggregationInput = {
    id?: SortOrder
    correo?: SortOrder
    contrasena?: SortOrder
    encargado?: SortOrderInput | SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    tipo?: SortOrder
    _count?: usuariosAdministradoresCountOrderByAggregateInput
    _max?: usuariosAdministradoresMaxOrderByAggregateInput
    _min?: usuariosAdministradoresMinOrderByAggregateInput
  }

  export type usuariosAdministradoresScalarWhereWithAggregatesInput = {
    AND?: usuariosAdministradoresScalarWhereWithAggregatesInput | usuariosAdministradoresScalarWhereWithAggregatesInput[]
    OR?: usuariosAdministradoresScalarWhereWithAggregatesInput[]
    NOT?: usuariosAdministradoresScalarWhereWithAggregatesInput | usuariosAdministradoresScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"usuariosAdministradores"> | string
    correo?: StringWithAggregatesFilter<"usuariosAdministradores"> | string
    contrasena?: StringWithAggregatesFilter<"usuariosAdministradores"> | string
    encargado?: StringNullableWithAggregatesFilter<"usuariosAdministradores"> | string | null
    estado?: BoolWithAggregatesFilter<"usuariosAdministradores"> | boolean
    creadoEn?: DateTimeWithAggregatesFilter<"usuariosAdministradores"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"usuariosAdministradores"> | Date | string
    tipo?: EnumTipoCuentaWithAggregatesFilter<"usuariosAdministradores"> | $Enums.TipoCuenta
  }

  export type usuariosEstudiantesWhereInput = {
    AND?: usuariosEstudiantesWhereInput | usuariosEstudiantesWhereInput[]
    OR?: usuariosEstudiantesWhereInput[]
    NOT?: usuariosEstudiantesWhereInput | usuariosEstudiantesWhereInput[]
    id?: StringFilter<"usuariosEstudiantes"> | string
    correo?: StringFilter<"usuariosEstudiantes"> | string
    contrasena?: StringFilter<"usuariosEstudiantes"> | string
    usuario?: StringFilter<"usuariosEstudiantes"> | string
    estado?: BoolFilter<"usuariosEstudiantes"> | boolean
    creadoEn?: DateTimeFilter<"usuariosEstudiantes"> | Date | string
    actualizadoEn?: DateTimeFilter<"usuariosEstudiantes"> | Date | string
    avatar?: StringNullableFilter<"usuariosEstudiantes"> | string | null
    estudianteId?: StringNullableFilter<"usuariosEstudiantes"> | string | null
    registrado?: BoolFilter<"usuariosEstudiantes"> | boolean
    compras?: ComprasListRelationFilter
    intentos?: IntentosListRelationFilter
    reaccionesPreguntas?: ReaccionesPreguntasListRelationFilter
    repasoRegistros?: RepasoRegistrosListRelationFilter
    reviewsCursos?: ReviewsCursosListRelationFilter
    suscripciones?: SuscripcionesListRelationFilter
    estudiantes?: XOR<EstudiantesNullableScalarRelationFilter, estudiantesWhereInput> | null
  }

  export type usuariosEstudiantesOrderByWithRelationInput = {
    id?: SortOrder
    correo?: SortOrder
    contrasena?: SortOrder
    usuario?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    avatar?: SortOrderInput | SortOrder
    estudianteId?: SortOrderInput | SortOrder
    registrado?: SortOrder
    compras?: comprasOrderByRelationAggregateInput
    intentos?: intentosOrderByRelationAggregateInput
    reaccionesPreguntas?: reaccionesPreguntasOrderByRelationAggregateInput
    repasoRegistros?: repasoRegistrosOrderByRelationAggregateInput
    reviewsCursos?: reviewsCursosOrderByRelationAggregateInput
    suscripciones?: suscripcionesOrderByRelationAggregateInput
    estudiantes?: estudiantesOrderByWithRelationInput
  }

  export type usuariosEstudiantesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    correo?: string
    usuario?: string
    estudianteId?: string
    AND?: usuariosEstudiantesWhereInput | usuariosEstudiantesWhereInput[]
    OR?: usuariosEstudiantesWhereInput[]
    NOT?: usuariosEstudiantesWhereInput | usuariosEstudiantesWhereInput[]
    contrasena?: StringFilter<"usuariosEstudiantes"> | string
    estado?: BoolFilter<"usuariosEstudiantes"> | boolean
    creadoEn?: DateTimeFilter<"usuariosEstudiantes"> | Date | string
    actualizadoEn?: DateTimeFilter<"usuariosEstudiantes"> | Date | string
    avatar?: StringNullableFilter<"usuariosEstudiantes"> | string | null
    registrado?: BoolFilter<"usuariosEstudiantes"> | boolean
    compras?: ComprasListRelationFilter
    intentos?: IntentosListRelationFilter
    reaccionesPreguntas?: ReaccionesPreguntasListRelationFilter
    repasoRegistros?: RepasoRegistrosListRelationFilter
    reviewsCursos?: ReviewsCursosListRelationFilter
    suscripciones?: SuscripcionesListRelationFilter
    estudiantes?: XOR<EstudiantesNullableScalarRelationFilter, estudiantesWhereInput> | null
  }, "id" | "correo" | "usuario" | "estudianteId">

  export type usuariosEstudiantesOrderByWithAggregationInput = {
    id?: SortOrder
    correo?: SortOrder
    contrasena?: SortOrder
    usuario?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    avatar?: SortOrderInput | SortOrder
    estudianteId?: SortOrderInput | SortOrder
    registrado?: SortOrder
    _count?: usuariosEstudiantesCountOrderByAggregateInput
    _max?: usuariosEstudiantesMaxOrderByAggregateInput
    _min?: usuariosEstudiantesMinOrderByAggregateInput
  }

  export type usuariosEstudiantesScalarWhereWithAggregatesInput = {
    AND?: usuariosEstudiantesScalarWhereWithAggregatesInput | usuariosEstudiantesScalarWhereWithAggregatesInput[]
    OR?: usuariosEstudiantesScalarWhereWithAggregatesInput[]
    NOT?: usuariosEstudiantesScalarWhereWithAggregatesInput | usuariosEstudiantesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"usuariosEstudiantes"> | string
    correo?: StringWithAggregatesFilter<"usuariosEstudiantes"> | string
    contrasena?: StringWithAggregatesFilter<"usuariosEstudiantes"> | string
    usuario?: StringWithAggregatesFilter<"usuariosEstudiantes"> | string
    estado?: BoolWithAggregatesFilter<"usuariosEstudiantes"> | boolean
    creadoEn?: DateTimeWithAggregatesFilter<"usuariosEstudiantes"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"usuariosEstudiantes"> | Date | string
    avatar?: StringNullableWithAggregatesFilter<"usuariosEstudiantes"> | string | null
    estudianteId?: StringNullableWithAggregatesFilter<"usuariosEstudiantes"> | string | null
    registrado?: BoolWithAggregatesFilter<"usuariosEstudiantes"> | boolean
  }

  export type areasWhereInput = {
    AND?: areasWhereInput | areasWhereInput[]
    OR?: areasWhereInput[]
    NOT?: areasWhereInput | areasWhereInput[]
    id?: StringFilter<"areas"> | string
    titulo?: StringFilter<"areas"> | string
    descripcion?: StringNullableFilter<"areas"> | string | null
    creadoEn?: DateTimeFilter<"areas"> | Date | string
    actualizadoEn?: DateTimeFilter<"areas"> | Date | string
    capitulos?: CapitulosListRelationFilter
    preguntas?: PreguntasListRelationFilter
  }

  export type areasOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    capitulos?: capitulosOrderByRelationAggregateInput
    preguntas?: preguntasOrderByRelationAggregateInput
  }

  export type areasWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: areasWhereInput | areasWhereInput[]
    OR?: areasWhereInput[]
    NOT?: areasWhereInput | areasWhereInput[]
    titulo?: StringFilter<"areas"> | string
    descripcion?: StringNullableFilter<"areas"> | string | null
    creadoEn?: DateTimeFilter<"areas"> | Date | string
    actualizadoEn?: DateTimeFilter<"areas"> | Date | string
    capitulos?: CapitulosListRelationFilter
    preguntas?: PreguntasListRelationFilter
  }, "id">

  export type areasOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    _count?: areasCountOrderByAggregateInput
    _max?: areasMaxOrderByAggregateInput
    _min?: areasMinOrderByAggregateInput
  }

  export type areasScalarWhereWithAggregatesInput = {
    AND?: areasScalarWhereWithAggregatesInput | areasScalarWhereWithAggregatesInput[]
    OR?: areasScalarWhereWithAggregatesInput[]
    NOT?: areasScalarWhereWithAggregatesInput | areasScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"areas"> | string
    titulo?: StringWithAggregatesFilter<"areas"> | string
    descripcion?: StringNullableWithAggregatesFilter<"areas"> | string | null
    creadoEn?: DateTimeWithAggregatesFilter<"areas"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"areas"> | Date | string
  }

  export type banqueoWhereInput = {
    AND?: banqueoWhereInput | banqueoWhereInput[]
    OR?: banqueoWhereInput[]
    NOT?: banqueoWhereInput | banqueoWhereInput[]
    id?: StringFilter<"banqueo"> | string
    titulo?: StringFilter<"banqueo"> | string
    tipo?: EnumBanqueoTipoFilter<"banqueo"> | $Enums.BanqueoTipo
    tipoCreado?: EnumBanqueoTipoCreadoFilter<"banqueo"> | $Enums.BanqueoTipoCreado
    duracion?: IntFilter<"banqueo"> | number
    maxPreguntas?: IntFilter<"banqueo"> | number
    creadoEn?: DateTimeFilter<"banqueo"> | Date | string
    actualizadoEn?: DateTimeFilter<"banqueo"> | Date | string
    intentos?: IntentosListRelationFilter
    repasoRegistros?: RepasoRegistrosListRelationFilter
    preguntas?: PreguntasListRelationFilter
  }

  export type banqueoOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    tipo?: SortOrder
    tipoCreado?: SortOrder
    duracion?: SortOrder
    maxPreguntas?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    intentos?: intentosOrderByRelationAggregateInput
    repasoRegistros?: repasoRegistrosOrderByRelationAggregateInput
    preguntas?: preguntasOrderByRelationAggregateInput
  }

  export type banqueoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: banqueoWhereInput | banqueoWhereInput[]
    OR?: banqueoWhereInput[]
    NOT?: banqueoWhereInput | banqueoWhereInput[]
    titulo?: StringFilter<"banqueo"> | string
    tipo?: EnumBanqueoTipoFilter<"banqueo"> | $Enums.BanqueoTipo
    tipoCreado?: EnumBanqueoTipoCreadoFilter<"banqueo"> | $Enums.BanqueoTipoCreado
    duracion?: IntFilter<"banqueo"> | number
    maxPreguntas?: IntFilter<"banqueo"> | number
    creadoEn?: DateTimeFilter<"banqueo"> | Date | string
    actualizadoEn?: DateTimeFilter<"banqueo"> | Date | string
    intentos?: IntentosListRelationFilter
    repasoRegistros?: RepasoRegistrosListRelationFilter
    preguntas?: PreguntasListRelationFilter
  }, "id">

  export type banqueoOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    tipo?: SortOrder
    tipoCreado?: SortOrder
    duracion?: SortOrder
    maxPreguntas?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    _count?: banqueoCountOrderByAggregateInput
    _avg?: banqueoAvgOrderByAggregateInput
    _max?: banqueoMaxOrderByAggregateInput
    _min?: banqueoMinOrderByAggregateInput
    _sum?: banqueoSumOrderByAggregateInput
  }

  export type banqueoScalarWhereWithAggregatesInput = {
    AND?: banqueoScalarWhereWithAggregatesInput | banqueoScalarWhereWithAggregatesInput[]
    OR?: banqueoScalarWhereWithAggregatesInput[]
    NOT?: banqueoScalarWhereWithAggregatesInput | banqueoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"banqueo"> | string
    titulo?: StringWithAggregatesFilter<"banqueo"> | string
    tipo?: EnumBanqueoTipoWithAggregatesFilter<"banqueo"> | $Enums.BanqueoTipo
    tipoCreado?: EnumBanqueoTipoCreadoWithAggregatesFilter<"banqueo"> | $Enums.BanqueoTipoCreado
    duracion?: IntWithAggregatesFilter<"banqueo"> | number
    maxPreguntas?: IntWithAggregatesFilter<"banqueo"> | number
    creadoEn?: DateTimeWithAggregatesFilter<"banqueo"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"banqueo"> | Date | string
  }

  export type capitulosWhereInput = {
    AND?: capitulosWhereInput | capitulosWhereInput[]
    OR?: capitulosWhereInput[]
    NOT?: capitulosWhereInput | capitulosWhereInput[]
    id?: StringFilter<"capitulos"> | string
    titulo?: StringFilter<"capitulos"> | string
    descripcion?: StringNullableFilter<"capitulos"> | string | null
    areaId?: StringNullableFilter<"capitulos"> | string | null
    creadoEn?: DateTimeFilter<"capitulos"> | Date | string
    actualizadoEn?: DateTimeFilter<"capitulos"> | Date | string
    areas?: XOR<AreasNullableScalarRelationFilter, areasWhereInput> | null
    temas?: TemasListRelationFilter
    preguntas?: PreguntasListRelationFilter
  }

  export type capitulosOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    areaId?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    areas?: areasOrderByWithRelationInput
    temas?: temasOrderByRelationAggregateInput
    preguntas?: preguntasOrderByRelationAggregateInput
  }

  export type capitulosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: capitulosWhereInput | capitulosWhereInput[]
    OR?: capitulosWhereInput[]
    NOT?: capitulosWhereInput | capitulosWhereInput[]
    titulo?: StringFilter<"capitulos"> | string
    descripcion?: StringNullableFilter<"capitulos"> | string | null
    areaId?: StringNullableFilter<"capitulos"> | string | null
    creadoEn?: DateTimeFilter<"capitulos"> | Date | string
    actualizadoEn?: DateTimeFilter<"capitulos"> | Date | string
    areas?: XOR<AreasNullableScalarRelationFilter, areasWhereInput> | null
    temas?: TemasListRelationFilter
    preguntas?: PreguntasListRelationFilter
  }, "id">

  export type capitulosOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    areaId?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    _count?: capitulosCountOrderByAggregateInput
    _max?: capitulosMaxOrderByAggregateInput
    _min?: capitulosMinOrderByAggregateInput
  }

  export type capitulosScalarWhereWithAggregatesInput = {
    AND?: capitulosScalarWhereWithAggregatesInput | capitulosScalarWhereWithAggregatesInput[]
    OR?: capitulosScalarWhereWithAggregatesInput[]
    NOT?: capitulosScalarWhereWithAggregatesInput | capitulosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"capitulos"> | string
    titulo?: StringWithAggregatesFilter<"capitulos"> | string
    descripcion?: StringNullableWithAggregatesFilter<"capitulos"> | string | null
    areaId?: StringNullableWithAggregatesFilter<"capitulos"> | string | null
    creadoEn?: DateTimeWithAggregatesFilter<"capitulos"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"capitulos"> | Date | string
  }

  export type intentosWhereInput = {
    AND?: intentosWhereInput | intentosWhereInput[]
    OR?: intentosWhereInput[]
    NOT?: intentosWhereInput | intentosWhereInput[]
    id?: StringFilter<"intentos"> | string
    banqueoId?: StringFilter<"intentos"> | string
    usuarioEstudianteId?: StringNullableFilter<"intentos"> | string | null
    tiempoDuracion?: IntFilter<"intentos"> | number
    correctas?: IntFilter<"intentos"> | number
    incorrectas?: IntFilter<"intentos"> | number
    creadoEn?: DateTimeFilter<"intentos"> | Date | string
    actualizadoEn?: DateTimeFilter<"intentos"> | Date | string
    estado?: EnumEstadoIntentoFilter<"intentos"> | $Enums.EstadoIntento
    banqueo?: XOR<BanqueoScalarRelationFilter, banqueoWhereInput>
    usuariosEstudiantes?: XOR<UsuariosEstudiantesNullableScalarRelationFilter, usuariosEstudiantesWhereInput> | null
    respuestasIntentos?: RespuestasIntentosListRelationFilter
  }

  export type intentosOrderByWithRelationInput = {
    id?: SortOrder
    banqueoId?: SortOrder
    usuarioEstudianteId?: SortOrderInput | SortOrder
    tiempoDuracion?: SortOrder
    correctas?: SortOrder
    incorrectas?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    estado?: SortOrder
    banqueo?: banqueoOrderByWithRelationInput
    usuariosEstudiantes?: usuariosEstudiantesOrderByWithRelationInput
    respuestasIntentos?: respuestasIntentosOrderByRelationAggregateInput
  }

  export type intentosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: intentosWhereInput | intentosWhereInput[]
    OR?: intentosWhereInput[]
    NOT?: intentosWhereInput | intentosWhereInput[]
    banqueoId?: StringFilter<"intentos"> | string
    usuarioEstudianteId?: StringNullableFilter<"intentos"> | string | null
    tiempoDuracion?: IntFilter<"intentos"> | number
    correctas?: IntFilter<"intentos"> | number
    incorrectas?: IntFilter<"intentos"> | number
    creadoEn?: DateTimeFilter<"intentos"> | Date | string
    actualizadoEn?: DateTimeFilter<"intentos"> | Date | string
    estado?: EnumEstadoIntentoFilter<"intentos"> | $Enums.EstadoIntento
    banqueo?: XOR<BanqueoScalarRelationFilter, banqueoWhereInput>
    usuariosEstudiantes?: XOR<UsuariosEstudiantesNullableScalarRelationFilter, usuariosEstudiantesWhereInput> | null
    respuestasIntentos?: RespuestasIntentosListRelationFilter
  }, "id">

  export type intentosOrderByWithAggregationInput = {
    id?: SortOrder
    banqueoId?: SortOrder
    usuarioEstudianteId?: SortOrderInput | SortOrder
    tiempoDuracion?: SortOrder
    correctas?: SortOrder
    incorrectas?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    estado?: SortOrder
    _count?: intentosCountOrderByAggregateInput
    _avg?: intentosAvgOrderByAggregateInput
    _max?: intentosMaxOrderByAggregateInput
    _min?: intentosMinOrderByAggregateInput
    _sum?: intentosSumOrderByAggregateInput
  }

  export type intentosScalarWhereWithAggregatesInput = {
    AND?: intentosScalarWhereWithAggregatesInput | intentosScalarWhereWithAggregatesInput[]
    OR?: intentosScalarWhereWithAggregatesInput[]
    NOT?: intentosScalarWhereWithAggregatesInput | intentosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"intentos"> | string
    banqueoId?: StringWithAggregatesFilter<"intentos"> | string
    usuarioEstudianteId?: StringNullableWithAggregatesFilter<"intentos"> | string | null
    tiempoDuracion?: IntWithAggregatesFilter<"intentos"> | number
    correctas?: IntWithAggregatesFilter<"intentos"> | number
    incorrectas?: IntWithAggregatesFilter<"intentos"> | number
    creadoEn?: DateTimeWithAggregatesFilter<"intentos"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"intentos"> | Date | string
    estado?: EnumEstadoIntentoWithAggregatesFilter<"intentos"> | $Enums.EstadoIntento
  }

  export type respuestasIntentosWhereInput = {
    AND?: respuestasIntentosWhereInput | respuestasIntentosWhereInput[]
    OR?: respuestasIntentosWhereInput[]
    NOT?: respuestasIntentosWhereInput | respuestasIntentosWhereInput[]
    id?: StringFilter<"respuestasIntentos"> | string
    intentoId?: StringFilter<"respuestasIntentos"> | string
    preguntaId?: StringFilter<"respuestasIntentos"> | string
    respuesta?: JsonNullableFilter<"respuestasIntentos">
    resultado?: EnumResultadoRespuestaFilter<"respuestasIntentos"> | $Enums.ResultadoRespuesta
    esCorrecta?: BoolNullableFilter<"respuestasIntentos"> | boolean | null
    respondida?: BoolFilter<"respuestasIntentos"> | boolean
    visitada?: BoolFilter<"respuestasIntentos"> | boolean
    marcadaRevision?: BoolFilter<"respuestasIntentos"> | boolean
    tiempoConsumidoSeg?: IntFilter<"respuestasIntentos"> | number
    orden?: IntNullableFilter<"respuestasIntentos"> | number | null
    respondidaEn?: DateTimeNullableFilter<"respuestasIntentos"> | Date | string | null
    creadoEn?: DateTimeFilter<"respuestasIntentos"> | Date | string
    actualizadoEn?: DateTimeFilter<"respuestasIntentos"> | Date | string
    intentos?: XOR<IntentosScalarRelationFilter, intentosWhereInput>
    preguntas?: XOR<PreguntasScalarRelationFilter, preguntasWhereInput>
  }

  export type respuestasIntentosOrderByWithRelationInput = {
    id?: SortOrder
    intentoId?: SortOrder
    preguntaId?: SortOrder
    respuesta?: SortOrderInput | SortOrder
    resultado?: SortOrder
    esCorrecta?: SortOrderInput | SortOrder
    respondida?: SortOrder
    visitada?: SortOrder
    marcadaRevision?: SortOrder
    tiempoConsumidoSeg?: SortOrder
    orden?: SortOrderInput | SortOrder
    respondidaEn?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    intentos?: intentosOrderByWithRelationInput
    preguntas?: preguntasOrderByWithRelationInput
  }

  export type respuestasIntentosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    intentoId_preguntaId?: respuestasIntentosIntentoIdPreguntaIdCompoundUniqueInput
    AND?: respuestasIntentosWhereInput | respuestasIntentosWhereInput[]
    OR?: respuestasIntentosWhereInput[]
    NOT?: respuestasIntentosWhereInput | respuestasIntentosWhereInput[]
    intentoId?: StringFilter<"respuestasIntentos"> | string
    preguntaId?: StringFilter<"respuestasIntentos"> | string
    respuesta?: JsonNullableFilter<"respuestasIntentos">
    resultado?: EnumResultadoRespuestaFilter<"respuestasIntentos"> | $Enums.ResultadoRespuesta
    esCorrecta?: BoolNullableFilter<"respuestasIntentos"> | boolean | null
    respondida?: BoolFilter<"respuestasIntentos"> | boolean
    visitada?: BoolFilter<"respuestasIntentos"> | boolean
    marcadaRevision?: BoolFilter<"respuestasIntentos"> | boolean
    tiempoConsumidoSeg?: IntFilter<"respuestasIntentos"> | number
    orden?: IntNullableFilter<"respuestasIntentos"> | number | null
    respondidaEn?: DateTimeNullableFilter<"respuestasIntentos"> | Date | string | null
    creadoEn?: DateTimeFilter<"respuestasIntentos"> | Date | string
    actualizadoEn?: DateTimeFilter<"respuestasIntentos"> | Date | string
    intentos?: XOR<IntentosScalarRelationFilter, intentosWhereInput>
    preguntas?: XOR<PreguntasScalarRelationFilter, preguntasWhereInput>
  }, "id" | "intentoId_preguntaId">

  export type respuestasIntentosOrderByWithAggregationInput = {
    id?: SortOrder
    intentoId?: SortOrder
    preguntaId?: SortOrder
    respuesta?: SortOrderInput | SortOrder
    resultado?: SortOrder
    esCorrecta?: SortOrderInput | SortOrder
    respondida?: SortOrder
    visitada?: SortOrder
    marcadaRevision?: SortOrder
    tiempoConsumidoSeg?: SortOrder
    orden?: SortOrderInput | SortOrder
    respondidaEn?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    _count?: respuestasIntentosCountOrderByAggregateInput
    _avg?: respuestasIntentosAvgOrderByAggregateInput
    _max?: respuestasIntentosMaxOrderByAggregateInput
    _min?: respuestasIntentosMinOrderByAggregateInput
    _sum?: respuestasIntentosSumOrderByAggregateInput
  }

  export type respuestasIntentosScalarWhereWithAggregatesInput = {
    AND?: respuestasIntentosScalarWhereWithAggregatesInput | respuestasIntentosScalarWhereWithAggregatesInput[]
    OR?: respuestasIntentosScalarWhereWithAggregatesInput[]
    NOT?: respuestasIntentosScalarWhereWithAggregatesInput | respuestasIntentosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"respuestasIntentos"> | string
    intentoId?: StringWithAggregatesFilter<"respuestasIntentos"> | string
    preguntaId?: StringWithAggregatesFilter<"respuestasIntentos"> | string
    respuesta?: JsonNullableWithAggregatesFilter<"respuestasIntentos">
    resultado?: EnumResultadoRespuestaWithAggregatesFilter<"respuestasIntentos"> | $Enums.ResultadoRespuesta
    esCorrecta?: BoolNullableWithAggregatesFilter<"respuestasIntentos"> | boolean | null
    respondida?: BoolWithAggregatesFilter<"respuestasIntentos"> | boolean
    visitada?: BoolWithAggregatesFilter<"respuestasIntentos"> | boolean
    marcadaRevision?: BoolWithAggregatesFilter<"respuestasIntentos"> | boolean
    tiempoConsumidoSeg?: IntWithAggregatesFilter<"respuestasIntentos"> | number
    orden?: IntNullableWithAggregatesFilter<"respuestasIntentos"> | number | null
    respondidaEn?: DateTimeNullableWithAggregatesFilter<"respuestasIntentos"> | Date | string | null
    creadoEn?: DateTimeWithAggregatesFilter<"respuestasIntentos"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"respuestasIntentos"> | Date | string
  }

  export type repasoRegistrosWhereInput = {
    AND?: repasoRegistrosWhereInput | repasoRegistrosWhereInput[]
    OR?: repasoRegistrosWhereInput[]
    NOT?: repasoRegistrosWhereInput | repasoRegistrosWhereInput[]
    id?: StringFilter<"repasoRegistros"> | string
    usuarioEstudianteId?: StringFilter<"repasoRegistros"> | string
    banqueoId?: StringFilter<"repasoRegistros"> | string
    preguntaId?: StringFilter<"repasoRegistros"> | string
    esCorrecta?: BoolFilter<"repasoRegistros"> | boolean
    creadoEn?: DateTimeFilter<"repasoRegistros"> | Date | string
    banqueo?: XOR<BanqueoScalarRelationFilter, banqueoWhereInput>
    preguntas?: XOR<PreguntasScalarRelationFilter, preguntasWhereInput>
    usuariosEstudiantes?: XOR<UsuariosEstudiantesScalarRelationFilter, usuariosEstudiantesWhereInput>
  }

  export type repasoRegistrosOrderByWithRelationInput = {
    id?: SortOrder
    usuarioEstudianteId?: SortOrder
    banqueoId?: SortOrder
    preguntaId?: SortOrder
    esCorrecta?: SortOrder
    creadoEn?: SortOrder
    banqueo?: banqueoOrderByWithRelationInput
    preguntas?: preguntasOrderByWithRelationInput
    usuariosEstudiantes?: usuariosEstudiantesOrderByWithRelationInput
  }

  export type repasoRegistrosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: repasoRegistrosWhereInput | repasoRegistrosWhereInput[]
    OR?: repasoRegistrosWhereInput[]
    NOT?: repasoRegistrosWhereInput | repasoRegistrosWhereInput[]
    usuarioEstudianteId?: StringFilter<"repasoRegistros"> | string
    banqueoId?: StringFilter<"repasoRegistros"> | string
    preguntaId?: StringFilter<"repasoRegistros"> | string
    esCorrecta?: BoolFilter<"repasoRegistros"> | boolean
    creadoEn?: DateTimeFilter<"repasoRegistros"> | Date | string
    banqueo?: XOR<BanqueoScalarRelationFilter, banqueoWhereInput>
    preguntas?: XOR<PreguntasScalarRelationFilter, preguntasWhereInput>
    usuariosEstudiantes?: XOR<UsuariosEstudiantesScalarRelationFilter, usuariosEstudiantesWhereInput>
  }, "id">

  export type repasoRegistrosOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioEstudianteId?: SortOrder
    banqueoId?: SortOrder
    preguntaId?: SortOrder
    esCorrecta?: SortOrder
    creadoEn?: SortOrder
    _count?: repasoRegistrosCountOrderByAggregateInput
    _max?: repasoRegistrosMaxOrderByAggregateInput
    _min?: repasoRegistrosMinOrderByAggregateInput
  }

  export type repasoRegistrosScalarWhereWithAggregatesInput = {
    AND?: repasoRegistrosScalarWhereWithAggregatesInput | repasoRegistrosScalarWhereWithAggregatesInput[]
    OR?: repasoRegistrosScalarWhereWithAggregatesInput[]
    NOT?: repasoRegistrosScalarWhereWithAggregatesInput | repasoRegistrosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"repasoRegistros"> | string
    usuarioEstudianteId?: StringWithAggregatesFilter<"repasoRegistros"> | string
    banqueoId?: StringWithAggregatesFilter<"repasoRegistros"> | string
    preguntaId?: StringWithAggregatesFilter<"repasoRegistros"> | string
    esCorrecta?: BoolWithAggregatesFilter<"repasoRegistros"> | boolean
    creadoEn?: DateTimeWithAggregatesFilter<"repasoRegistros"> | Date | string
  }

  export type suscripcionesWhereInput = {
    AND?: suscripcionesWhereInput | suscripcionesWhereInput[]
    OR?: suscripcionesWhereInput[]
    NOT?: suscripcionesWhereInput | suscripcionesWhereInput[]
    id?: StringFilter<"suscripciones"> | string
    usuarioEstudianteId?: StringFilter<"suscripciones"> | string
    montoUsd?: FloatFilter<"suscripciones"> | number
    fechaInicio?: DateTimeFilter<"suscripciones"> | Date | string
    fechaFin?: DateTimeFilter<"suscripciones"> | Date | string
    estado?: EnumEstadoSuscripcionFilter<"suscripciones"> | $Enums.EstadoSuscripcion
    creadoEn?: DateTimeFilter<"suscripciones"> | Date | string
    actualizadoEn?: DateTimeFilter<"suscripciones"> | Date | string
    usuariosEstudiantes?: XOR<UsuariosEstudiantesScalarRelationFilter, usuariosEstudiantesWhereInput>
  }

  export type suscripcionesOrderByWithRelationInput = {
    id?: SortOrder
    usuarioEstudianteId?: SortOrder
    montoUsd?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    usuariosEstudiantes?: usuariosEstudiantesOrderByWithRelationInput
  }

  export type suscripcionesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: suscripcionesWhereInput | suscripcionesWhereInput[]
    OR?: suscripcionesWhereInput[]
    NOT?: suscripcionesWhereInput | suscripcionesWhereInput[]
    usuarioEstudianteId?: StringFilter<"suscripciones"> | string
    montoUsd?: FloatFilter<"suscripciones"> | number
    fechaInicio?: DateTimeFilter<"suscripciones"> | Date | string
    fechaFin?: DateTimeFilter<"suscripciones"> | Date | string
    estado?: EnumEstadoSuscripcionFilter<"suscripciones"> | $Enums.EstadoSuscripcion
    creadoEn?: DateTimeFilter<"suscripciones"> | Date | string
    actualizadoEn?: DateTimeFilter<"suscripciones"> | Date | string
    usuariosEstudiantes?: XOR<UsuariosEstudiantesScalarRelationFilter, usuariosEstudiantesWhereInput>
  }, "id">

  export type suscripcionesOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioEstudianteId?: SortOrder
    montoUsd?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    _count?: suscripcionesCountOrderByAggregateInput
    _avg?: suscripcionesAvgOrderByAggregateInput
    _max?: suscripcionesMaxOrderByAggregateInput
    _min?: suscripcionesMinOrderByAggregateInput
    _sum?: suscripcionesSumOrderByAggregateInput
  }

  export type suscripcionesScalarWhereWithAggregatesInput = {
    AND?: suscripcionesScalarWhereWithAggregatesInput | suscripcionesScalarWhereWithAggregatesInput[]
    OR?: suscripcionesScalarWhereWithAggregatesInput[]
    NOT?: suscripcionesScalarWhereWithAggregatesInput | suscripcionesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"suscripciones"> | string
    usuarioEstudianteId?: StringWithAggregatesFilter<"suscripciones"> | string
    montoUsd?: FloatWithAggregatesFilter<"suscripciones"> | number
    fechaInicio?: DateTimeWithAggregatesFilter<"suscripciones"> | Date | string
    fechaFin?: DateTimeWithAggregatesFilter<"suscripciones"> | Date | string
    estado?: EnumEstadoSuscripcionWithAggregatesFilter<"suscripciones"> | $Enums.EstadoSuscripcion
    creadoEn?: DateTimeWithAggregatesFilter<"suscripciones"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"suscripciones"> | Date | string
  }

  export type auditoriaCreateInput = {
    id?: string
    tabla: $Enums.Tabla
    registroId?: string | null
    accion: $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    creadoEn?: Date | string
    usuariosAdministradores: usuariosAdministradoresCreateNestedOneWithoutAuditoriaInput
  }

  export type auditoriaUncheckedCreateInput = {
    id?: string
    tabla: $Enums.Tabla
    registroId?: string | null
    accion: $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    usuarioId: string
    creadoEn?: Date | string
  }

  export type auditoriaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tabla?: EnumTablaFieldUpdateOperationsInput | $Enums.Tabla
    registroId?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: EnumAccionAuditoriaFieldUpdateOperationsInput | $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosAdministradores?: usuariosAdministradoresUpdateOneRequiredWithoutAuditoriaNestedInput
  }

  export type auditoriaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tabla?: EnumTablaFieldUpdateOperationsInput | $Enums.Tabla
    registroId?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: EnumAccionAuditoriaFieldUpdateOperationsInput | $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    usuarioId?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auditoriaCreateManyInput = {
    id?: string
    tabla: $Enums.Tabla
    registroId?: string | null
    accion: $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    usuarioId: string
    creadoEn?: Date | string
  }

  export type auditoriaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tabla?: EnumTablaFieldUpdateOperationsInput | $Enums.Tabla
    registroId?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: EnumAccionAuditoriaFieldUpdateOperationsInput | $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auditoriaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tabla?: EnumTablaFieldUpdateOperationsInput | $Enums.Tabla
    registroId?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: EnumAccionAuditoriaFieldUpdateOperationsInput | $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    usuarioId?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type beneficiosCursosCreateInput = {
    id?: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
    cursos: cursosCreateNestedOneWithoutBeneficiosCursosInput
  }

  export type beneficiosCursosUncheckedCreateInput = {
    id?: string
    cursoId: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type beneficiosCursosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    cursos?: cursosUpdateOneRequiredWithoutBeneficiosCursosNestedInput
  }

  export type beneficiosCursosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type beneficiosCursosCreateManyInput = {
    id?: string
    cursoId: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type beneficiosCursosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type beneficiosCursosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type calificacionesCreateInput = {
    id?: string
    aprobado?: boolean
    comentarios?: string | null
    nota: number
    creadoEn?: Date | string
    estudiantes: estudiantesCreateNestedOneWithoutCalificacionesInput
    examenes: examenesCreateNestedOneWithoutCalificacionesInput
  }

  export type calificacionesUncheckedCreateInput = {
    id?: string
    aprobado?: boolean
    comentarios?: string | null
    estudianteId: string
    examenId: string
    nota: number
    creadoEn?: Date | string
  }

  export type calificacionesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    nota?: FloatFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiantes?: estudiantesUpdateOneRequiredWithoutCalificacionesNestedInput
    examenes?: examenesUpdateOneRequiredWithoutCalificacionesNestedInput
  }

  export type calificacionesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: StringFieldUpdateOperationsInput | string
    examenId?: StringFieldUpdateOperationsInput | string
    nota?: FloatFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type calificacionesCreateManyInput = {
    id?: string
    aprobado?: boolean
    comentarios?: string | null
    estudianteId: string
    examenId: string
    nota: number
    creadoEn?: Date | string
  }

  export type calificacionesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    nota?: FloatFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type calificacionesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: StringFieldUpdateOperationsInput | string
    examenId?: StringFieldUpdateOperationsInput | string
    nota?: FloatFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type categoriasCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    categoriasCursos?: categoriasCursosCreateNestedManyWithoutCategoriasInput
  }

  export type categoriasUncheckedCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    categoriasCursos?: categoriasCursosUncheckedCreateNestedManyWithoutCategoriasInput
  }

  export type categoriasUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    categoriasCursos?: categoriasCursosUpdateManyWithoutCategoriasNestedInput
  }

  export type categoriasUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    categoriasCursos?: categoriasCursosUncheckedUpdateManyWithoutCategoriasNestedInput
  }

  export type categoriasCreateManyInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type categoriasUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type categoriasUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type categoriasCursosCreateInput = {
    id?: string
    categorias: categoriasCreateNestedOneWithoutCategoriasCursosInput
    cursos: cursosCreateNestedOneWithoutCategoriasCursosInput
  }

  export type categoriasCursosUncheckedCreateInput = {
    id?: string
    categoriaId: string
    cursoId: string
  }

  export type categoriasCursosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categorias?: categoriasUpdateOneRequiredWithoutCategoriasCursosNestedInput
    cursos?: cursosUpdateOneRequiredWithoutCategoriasCursosNestedInput
  }

  export type categoriasCursosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoriaId?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
  }

  export type categoriasCursosCreateManyInput = {
    id?: string
    categoriaId: string
    cursoId: string
  }

  export type categoriasCursosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type categoriasCursosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoriaId?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
  }

  export type certificadosCreateInput = {
    id?: string
    codigoUnico: string
    fechaEmision: Date | string
    tipo?: $Enums.TipoCertificado
    notaFinal?: number | null
    urlCertificado?: string | null
    creadoEn?: Date | string
    edicionesCursos: edicionesCursosCreateNestedOneWithoutCertificadosInput
    estudiantes: estudiantesCreateNestedOneWithoutCertificadosInput
  }

  export type certificadosUncheckedCreateInput = {
    id?: string
    codigoUnico: string
    edicionId: string
    estudianteId: string
    fechaEmision: Date | string
    tipo?: $Enums.TipoCertificado
    notaFinal?: number | null
    urlCertificado?: string | null
    creadoEn?: Date | string
  }

  export type certificadosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigoUnico?: StringFieldUpdateOperationsInput | string
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCertificadoFieldUpdateOperationsInput | $Enums.TipoCertificado
    notaFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    urlCertificado?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    edicionesCursos?: edicionesCursosUpdateOneRequiredWithoutCertificadosNestedInput
    estudiantes?: estudiantesUpdateOneRequiredWithoutCertificadosNestedInput
  }

  export type certificadosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigoUnico?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    estudianteId?: StringFieldUpdateOperationsInput | string
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCertificadoFieldUpdateOperationsInput | $Enums.TipoCertificado
    notaFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    urlCertificado?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type certificadosCreateManyInput = {
    id?: string
    codigoUnico: string
    edicionId: string
    estudianteId: string
    fechaEmision: Date | string
    tipo?: $Enums.TipoCertificado
    notaFinal?: number | null
    urlCertificado?: string | null
    creadoEn?: Date | string
  }

  export type certificadosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigoUnico?: StringFieldUpdateOperationsInput | string
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCertificadoFieldUpdateOperationsInput | $Enums.TipoCertificado
    notaFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    urlCertificado?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type certificadosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigoUnico?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    estudianteId?: StringFieldUpdateOperationsInput | string
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCertificadoFieldUpdateOperationsInput | $Enums.TipoCertificado
    notaFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    urlCertificado?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clasesCreateInput = {
    id?: string
    descripcion: string
    duracion?: number | null
    fecha: Date | string
    orden: number
    titulo: string
    urlYoutube?: string | null
    creadoEn?: Date | string
    urlPresentacion?: string | null
    edicionesCursos: edicionesCursosCreateNestedOneWithoutClasesInput
    grabaciones?: grabacionesCreateNestedManyWithoutClasesInput
    materiales?: materialesCreateNestedManyWithoutClasesInput
  }

  export type clasesUncheckedCreateInput = {
    id?: string
    edicionId: string
    descripcion: string
    duracion?: number | null
    fecha: Date | string
    orden: number
    titulo: string
    urlYoutube?: string | null
    creadoEn?: Date | string
    urlPresentacion?: string | null
    grabaciones?: grabacionesUncheckedCreateNestedManyWithoutClasesInput
    materiales?: materialesUncheckedCreateNestedManyWithoutClasesInput
  }

  export type clasesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    orden?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    urlYoutube?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    urlPresentacion?: NullableStringFieldUpdateOperationsInput | string | null
    edicionesCursos?: edicionesCursosUpdateOneRequiredWithoutClasesNestedInput
    grabaciones?: grabacionesUpdateManyWithoutClasesNestedInput
    materiales?: materialesUpdateManyWithoutClasesNestedInput
  }

  export type clasesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    orden?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    urlYoutube?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    urlPresentacion?: NullableStringFieldUpdateOperationsInput | string | null
    grabaciones?: grabacionesUncheckedUpdateManyWithoutClasesNestedInput
    materiales?: materialesUncheckedUpdateManyWithoutClasesNestedInput
  }

  export type clasesCreateManyInput = {
    id?: string
    edicionId: string
    descripcion: string
    duracion?: number | null
    fecha: Date | string
    orden: number
    titulo: string
    urlYoutube?: string | null
    creadoEn?: Date | string
    urlPresentacion?: string | null
  }

  export type clasesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    orden?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    urlYoutube?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    urlPresentacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clasesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    orden?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    urlYoutube?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    urlPresentacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type comprasCreateInput = {
    id?: string
    monto: number
    moneda?: string
    comprobado?: boolean
    providerId: string
    fechaCompra?: Date | string
    metodo?: $Enums.MetodoPago
    deuda?: number
    estadoPago?: $Enums.EstadoPago
    updatedAt: Date | string
    conDescuento?: boolean
    edicionesCursos: edicionesCursosCreateNestedOneWithoutComprasInput
    usuariosEstudiantes?: usuariosEstudiantesCreateNestedOneWithoutComprasInput
    inscripciones?: inscripcionesCreateNestedOneWithoutComprasInput
  }

  export type comprasUncheckedCreateInput = {
    id?: string
    edicionId: string
    monto: number
    moneda?: string
    comprobado?: boolean
    providerId: string
    fechaCompra?: Date | string
    metodo?: $Enums.MetodoPago
    deuda?: number
    usuariosEstudiantesId?: string | null
    estadoPago?: $Enums.EstadoPago
    updatedAt: Date | string
    conDescuento?: boolean
    inscripciones?: inscripcionesUncheckedCreateNestedOneWithoutComprasInput
  }

  export type comprasUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: StringFieldUpdateOperationsInput | string
    comprobado?: BoolFieldUpdateOperationsInput | boolean
    providerId?: StringFieldUpdateOperationsInput | string
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    deuda?: FloatFieldUpdateOperationsInput | number
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conDescuento?: BoolFieldUpdateOperationsInput | boolean
    edicionesCursos?: edicionesCursosUpdateOneRequiredWithoutComprasNestedInput
    usuariosEstudiantes?: usuariosEstudiantesUpdateOneWithoutComprasNestedInput
    inscripciones?: inscripcionesUpdateOneWithoutComprasNestedInput
  }

  export type comprasUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: StringFieldUpdateOperationsInput | string
    comprobado?: BoolFieldUpdateOperationsInput | boolean
    providerId?: StringFieldUpdateOperationsInput | string
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    deuda?: FloatFieldUpdateOperationsInput | number
    usuariosEstudiantesId?: NullableStringFieldUpdateOperationsInput | string | null
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conDescuento?: BoolFieldUpdateOperationsInput | boolean
    inscripciones?: inscripcionesUncheckedUpdateOneWithoutComprasNestedInput
  }

  export type comprasCreateManyInput = {
    id?: string
    edicionId: string
    monto: number
    moneda?: string
    comprobado?: boolean
    providerId: string
    fechaCompra?: Date | string
    metodo?: $Enums.MetodoPago
    deuda?: number
    usuariosEstudiantesId?: string | null
    estadoPago?: $Enums.EstadoPago
    updatedAt: Date | string
    conDescuento?: boolean
  }

  export type comprasUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: StringFieldUpdateOperationsInput | string
    comprobado?: BoolFieldUpdateOperationsInput | boolean
    providerId?: StringFieldUpdateOperationsInput | string
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    deuda?: FloatFieldUpdateOperationsInput | number
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conDescuento?: BoolFieldUpdateOperationsInput | boolean
  }

  export type comprasUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: StringFieldUpdateOperationsInput | string
    comprobado?: BoolFieldUpdateOperationsInput | boolean
    providerId?: StringFieldUpdateOperationsInput | string
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    deuda?: FloatFieldUpdateOperationsInput | number
    usuariosEstudiantesId?: NullableStringFieldUpdateOperationsInput | string | null
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conDescuento?: BoolFieldUpdateOperationsInput | boolean
  }

  export type cursosCreateInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    cargaHoraria?: number
    codigo: string
    beneficiosCursos?: beneficiosCursosCreateNestedManyWithoutCursosInput
    categoriasCursos?: categoriasCursosCreateNestedManyWithoutCursosInput
    edicionesCursos?: edicionesCursosCreateNestedManyWithoutCursosInput
    objetivosCursos?: objetivosCursosCreateNestedManyWithoutCursosInput
    requisitosCursos?: requisitosCursosCreateNestedManyWithoutCursosInput
    reviewsCursos?: reviewsCursosCreateNestedManyWithoutCursosInput
  }

  export type cursosUncheckedCreateInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    cargaHoraria?: number
    codigo: string
    beneficiosCursos?: beneficiosCursosUncheckedCreateNestedManyWithoutCursosInput
    categoriasCursos?: categoriasCursosUncheckedCreateNestedManyWithoutCursosInput
    edicionesCursos?: edicionesCursosUncheckedCreateNestedManyWithoutCursosInput
    objetivosCursos?: objetivosCursosUncheckedCreateNestedManyWithoutCursosInput
    requisitosCursos?: requisitosCursosUncheckedCreateNestedManyWithoutCursosInput
    reviewsCursos?: reviewsCursosUncheckedCreateNestedManyWithoutCursosInput
  }

  export type cursosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    cargaHoraria?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    beneficiosCursos?: beneficiosCursosUpdateManyWithoutCursosNestedInput
    categoriasCursos?: categoriasCursosUpdateManyWithoutCursosNestedInput
    edicionesCursos?: edicionesCursosUpdateManyWithoutCursosNestedInput
    objetivosCursos?: objetivosCursosUpdateManyWithoutCursosNestedInput
    requisitosCursos?: requisitosCursosUpdateManyWithoutCursosNestedInput
    reviewsCursos?: reviewsCursosUpdateManyWithoutCursosNestedInput
  }

  export type cursosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    cargaHoraria?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    beneficiosCursos?: beneficiosCursosUncheckedUpdateManyWithoutCursosNestedInput
    categoriasCursos?: categoriasCursosUncheckedUpdateManyWithoutCursosNestedInput
    edicionesCursos?: edicionesCursosUncheckedUpdateManyWithoutCursosNestedInput
    objetivosCursos?: objetivosCursosUncheckedUpdateManyWithoutCursosNestedInput
    requisitosCursos?: requisitosCursosUncheckedUpdateManyWithoutCursosNestedInput
    reviewsCursos?: reviewsCursosUncheckedUpdateManyWithoutCursosNestedInput
  }

  export type cursosCreateManyInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    cargaHoraria?: number
    codigo: string
  }

  export type cursosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    cargaHoraria?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
  }

  export type cursosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    cargaHoraria?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
  }

  export type docenteCreateInput = {
    id?: string
    nombre_completo: string
    celular?: string | null
    especialidad: string
    experiencia?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    pais?: string
    usuariosAdministradores: usuariosAdministradoresCreateNestedOneWithoutDocenteInput
    edicionesCursos?: edicionesCursosCreateNestedManyWithoutDocenteInput
    pagosDocentes?: pagosDocentesCreateNestedManyWithoutDocenteInput
  }

  export type docenteUncheckedCreateInput = {
    id?: string
    nombre_completo: string
    celular?: string | null
    especialidad: string
    experiencia?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    usuarioId: string
    pais?: string
    edicionesCursos?: edicionesCursosUncheckedCreateNestedManyWithoutDocenteInput
    pagosDocentes?: pagosDocentesUncheckedCreateNestedManyWithoutDocenteInput
  }

  export type docenteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre_completo?: StringFieldUpdateOperationsInput | string
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    experiencia?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    pais?: StringFieldUpdateOperationsInput | string
    usuariosAdministradores?: usuariosAdministradoresUpdateOneRequiredWithoutDocenteNestedInput
    edicionesCursos?: edicionesCursosUpdateManyWithoutDocenteNestedInput
    pagosDocentes?: pagosDocentesUpdateManyWithoutDocenteNestedInput
  }

  export type docenteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre_completo?: StringFieldUpdateOperationsInput | string
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    experiencia?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    edicionesCursos?: edicionesCursosUncheckedUpdateManyWithoutDocenteNestedInput
    pagosDocentes?: pagosDocentesUncheckedUpdateManyWithoutDocenteNestedInput
  }

  export type docenteCreateManyInput = {
    id?: string
    nombre_completo: string
    celular?: string | null
    especialidad: string
    experiencia?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    usuarioId: string
    pais?: string
  }

  export type docenteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre_completo?: StringFieldUpdateOperationsInput | string
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    experiencia?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    pais?: StringFieldUpdateOperationsInput | string
  }

  export type docenteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre_completo?: StringFieldUpdateOperationsInput | string
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    experiencia?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
  }

  export type edicionesCursosCreateInput = {
    id?: string
    codigo: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    certificados?: certificadosCreateNestedManyWithoutEdicionesCursosInput
    clases?: clasesCreateNestedManyWithoutEdicionesCursosInput
    compras?: comprasCreateNestedManyWithoutEdicionesCursosInput
    cursos: cursosCreateNestedOneWithoutEdicionesCursosInput
    docente?: docenteCreateNestedOneWithoutEdicionesCursosInput
    examenes?: examenesCreateNestedManyWithoutEdicionesCursosInput
    inscripciones?: inscripcionesCreateNestedManyWithoutEdicionesCursosInput
    pagosDocentes?: pagosDocentesCreateNestedOneWithoutEdicionesCursosInput
    preciosCursos?: preciosCursosCreateNestedManyWithoutEdicionesCursosInput
  }

  export type edicionesCursosUncheckedCreateInput = {
    id?: string
    codigo: string
    cursoId: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    docenteId?: string | null
    certificados?: certificadosUncheckedCreateNestedManyWithoutEdicionesCursosInput
    clases?: clasesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    compras?: comprasUncheckedCreateNestedManyWithoutEdicionesCursosInput
    examenes?: examenesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    pagosDocentes?: pagosDocentesUncheckedCreateNestedOneWithoutEdicionesCursosInput
    preciosCursos?: preciosCursosUncheckedCreateNestedManyWithoutEdicionesCursosInput
  }

  export type edicionesCursosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    certificados?: certificadosUpdateManyWithoutEdicionesCursosNestedInput
    clases?: clasesUpdateManyWithoutEdicionesCursosNestedInput
    compras?: comprasUpdateManyWithoutEdicionesCursosNestedInput
    cursos?: cursosUpdateOneRequiredWithoutEdicionesCursosNestedInput
    docente?: docenteUpdateOneWithoutEdicionesCursosNestedInput
    examenes?: examenesUpdateManyWithoutEdicionesCursosNestedInput
    inscripciones?: inscripcionesUpdateManyWithoutEdicionesCursosNestedInput
    pagosDocentes?: pagosDocentesUpdateOneWithoutEdicionesCursosNestedInput
    preciosCursos?: preciosCursosUpdateManyWithoutEdicionesCursosNestedInput
  }

  export type edicionesCursosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docenteId?: NullableStringFieldUpdateOperationsInput | string | null
    certificados?: certificadosUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    clases?: clasesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    compras?: comprasUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    examenes?: examenesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    pagosDocentes?: pagosDocentesUncheckedUpdateOneWithoutEdicionesCursosNestedInput
    preciosCursos?: preciosCursosUncheckedUpdateManyWithoutEdicionesCursosNestedInput
  }

  export type edicionesCursosCreateManyInput = {
    id?: string
    codigo: string
    cursoId: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    docenteId?: string | null
  }

  export type edicionesCursosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type edicionesCursosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docenteId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type estudiantesCreateInput = {
    id?: string
    apellido?: string | null
    celular?: string | null
    pais?: string
    genero?: $Enums.TipoGenero
    fechaNacimiento?: Date | string | null
    nombre: string
    creadoEn?: Date | string
    actualizadoEn: Date | string
    nroUpdates?: number
    calificaciones?: calificacionesCreateNestedManyWithoutEstudiantesInput
    certificados?: certificadosCreateNestedManyWithoutEstudiantesInput
    inscripciones?: inscripcionesCreateNestedManyWithoutEstudiantesInput
    usuariosEstudiantes?: usuariosEstudiantesCreateNestedOneWithoutEstudiantesInput
  }

  export type estudiantesUncheckedCreateInput = {
    id?: string
    apellido?: string | null
    celular?: string | null
    pais?: string
    genero?: $Enums.TipoGenero
    fechaNacimiento?: Date | string | null
    nombre: string
    creadoEn?: Date | string
    actualizadoEn: Date | string
    nroUpdates?: number
    calificaciones?: calificacionesUncheckedCreateNestedManyWithoutEstudiantesInput
    certificados?: certificadosUncheckedCreateNestedManyWithoutEstudiantesInput
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEstudiantesInput
    usuariosEstudiantes?: usuariosEstudiantesUncheckedCreateNestedOneWithoutEstudiantesInput
  }

  export type estudiantesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: StringFieldUpdateOperationsInput | string
    genero?: EnumTipoGeneroFieldUpdateOperationsInput | $Enums.TipoGenero
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    nroUpdates?: IntFieldUpdateOperationsInput | number
    calificaciones?: calificacionesUpdateManyWithoutEstudiantesNestedInput
    certificados?: certificadosUpdateManyWithoutEstudiantesNestedInput
    inscripciones?: inscripcionesUpdateManyWithoutEstudiantesNestedInput
    usuariosEstudiantes?: usuariosEstudiantesUpdateOneWithoutEstudiantesNestedInput
  }

  export type estudiantesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: StringFieldUpdateOperationsInput | string
    genero?: EnumTipoGeneroFieldUpdateOperationsInput | $Enums.TipoGenero
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    nroUpdates?: IntFieldUpdateOperationsInput | number
    calificaciones?: calificacionesUncheckedUpdateManyWithoutEstudiantesNestedInput
    certificados?: certificadosUncheckedUpdateManyWithoutEstudiantesNestedInput
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEstudiantesNestedInput
    usuariosEstudiantes?: usuariosEstudiantesUncheckedUpdateOneWithoutEstudiantesNestedInput
  }

  export type estudiantesCreateManyInput = {
    id?: string
    apellido?: string | null
    celular?: string | null
    pais?: string
    genero?: $Enums.TipoGenero
    fechaNacimiento?: Date | string | null
    nombre: string
    creadoEn?: Date | string
    actualizadoEn: Date | string
    nroUpdates?: number
  }

  export type estudiantesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: StringFieldUpdateOperationsInput | string
    genero?: EnumTipoGeneroFieldUpdateOperationsInput | $Enums.TipoGenero
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    nroUpdates?: IntFieldUpdateOperationsInput | number
  }

  export type estudiantesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: StringFieldUpdateOperationsInput | string
    genero?: EnumTipoGeneroFieldUpdateOperationsInput | $Enums.TipoGenero
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    nroUpdates?: IntFieldUpdateOperationsInput | number
  }

  export type temasCreateInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    capitulos?: capitulosCreateNestedOneWithoutTemasInput
    preguntas?: preguntasCreateNestedManyWithoutTemasInput
  }

  export type temasUncheckedCreateInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    capituloId?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    preguntas?: preguntasUncheckedCreateNestedManyWithoutTemasInput
  }

  export type temasUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    capitulos?: capitulosUpdateOneWithoutTemasNestedInput
    preguntas?: preguntasUpdateManyWithoutTemasNestedInput
  }

  export type temasUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    capituloId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    preguntas?: preguntasUncheckedUpdateManyWithoutTemasNestedInput
  }

  export type temasCreateManyInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    capituloId?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type temasUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type temasUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    capituloId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type examenesCreateInput = {
    id?: string
    descripcion?: string | null
    fechaDisponible: Date | string
    fechaLimite: Date | string
    notaMaxima: number
    notaMinima: number
    titulo: string
    creadoEn?: Date | string
    calificaciones?: calificacionesCreateNestedManyWithoutExamenesInput
    edicionesCursos: edicionesCursosCreateNestedOneWithoutExamenesInput
  }

  export type examenesUncheckedCreateInput = {
    id?: string
    edicionId: string
    descripcion?: string | null
    fechaDisponible: Date | string
    fechaLimite: Date | string
    notaMaxima: number
    notaMinima: number
    titulo: string
    creadoEn?: Date | string
    calificaciones?: calificacionesUncheckedCreateNestedManyWithoutExamenesInput
  }

  export type examenesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaDisponible?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    calificaciones?: calificacionesUpdateManyWithoutExamenesNestedInput
    edicionesCursos?: edicionesCursosUpdateOneRequiredWithoutExamenesNestedInput
  }

  export type examenesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaDisponible?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    calificaciones?: calificacionesUncheckedUpdateManyWithoutExamenesNestedInput
  }

  export type examenesCreateManyInput = {
    id?: string
    edicionId: string
    descripcion?: string | null
    fechaDisponible: Date | string
    fechaLimite: Date | string
    notaMaxima: number
    notaMinima: number
    titulo: string
    creadoEn?: Date | string
  }

  export type examenesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaDisponible?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type examenesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaDisponible?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type grabacionesCreateInput = {
    id?: string
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    duracionSegundos?: number | null
    completada?: boolean
    clases: clasesCreateNestedOneWithoutGrabacionesInput
    usuariosAdministradores: usuariosAdministradoresCreateNestedOneWithoutGrabacionesInput
  }

  export type grabacionesUncheckedCreateInput = {
    id?: string
    claseId: string
    usuarioId: string
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    duracionSegundos?: number | null
    completada?: boolean
  }

  export type grabacionesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duracionSegundos?: NullableIntFieldUpdateOperationsInput | number | null
    completada?: BoolFieldUpdateOperationsInput | boolean
    clases?: clasesUpdateOneRequiredWithoutGrabacionesNestedInput
    usuariosAdministradores?: usuariosAdministradoresUpdateOneRequiredWithoutGrabacionesNestedInput
  }

  export type grabacionesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    claseId?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duracionSegundos?: NullableIntFieldUpdateOperationsInput | number | null
    completada?: BoolFieldUpdateOperationsInput | boolean
  }

  export type grabacionesCreateManyInput = {
    id?: string
    claseId: string
    usuarioId: string
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    duracionSegundos?: number | null
    completada?: boolean
  }

  export type grabacionesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duracionSegundos?: NullableIntFieldUpdateOperationsInput | number | null
    completada?: BoolFieldUpdateOperationsInput | boolean
  }

  export type grabacionesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    claseId?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duracionSegundos?: NullableIntFieldUpdateOperationsInput | number | null
    completada?: BoolFieldUpdateOperationsInput | boolean
  }

  export type inscripcionesCreateInput = {
    id?: string
    estado?: boolean
    inscritoEn?: Date | string
    compras: comprasCreateNestedOneWithoutInscripcionesInput
    edicionesCursos: edicionesCursosCreateNestedOneWithoutInscripcionesInput
    estudiantes: estudiantesCreateNestedOneWithoutInscripcionesInput
  }

  export type inscripcionesUncheckedCreateInput = {
    id?: string
    edicionId: string
    estado?: boolean
    estudianteId: string
    inscritoEn?: Date | string
    compraId: string
  }

  export type inscripcionesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    inscritoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    compras?: comprasUpdateOneRequiredWithoutInscripcionesNestedInput
    edicionesCursos?: edicionesCursosUpdateOneRequiredWithoutInscripcionesNestedInput
    estudiantes?: estudiantesUpdateOneRequiredWithoutInscripcionesNestedInput
  }

  export type inscripcionesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    estudianteId?: StringFieldUpdateOperationsInput | string
    inscritoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    compraId?: StringFieldUpdateOperationsInput | string
  }

  export type inscripcionesCreateManyInput = {
    id?: string
    edicionId: string
    estado?: boolean
    estudianteId: string
    inscritoEn?: Date | string
    compraId: string
  }

  export type inscripcionesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    inscritoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inscripcionesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    estudianteId?: StringFieldUpdateOperationsInput | string
    inscritoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    compraId?: StringFieldUpdateOperationsInput | string
  }

  export type materialesCreateInput = {
    id?: string
    tipo?: $Enums.TipoMaterial
    titulo: string
    url: string
    creadoEn?: Date | string
    clases: clasesCreateNestedOneWithoutMaterialesInput
  }

  export type materialesUncheckedCreateInput = {
    id?: string
    claseId: string
    tipo?: $Enums.TipoMaterial
    titulo: string
    url: string
    creadoEn?: Date | string
  }

  export type materialesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoMaterialFieldUpdateOperationsInput | $Enums.TipoMaterial
    titulo?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    clases?: clasesUpdateOneRequiredWithoutMaterialesNestedInput
  }

  export type materialesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    claseId?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoMaterialFieldUpdateOperationsInput | $Enums.TipoMaterial
    titulo?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type materialesCreateManyInput = {
    id?: string
    claseId: string
    tipo?: $Enums.TipoMaterial
    titulo: string
    url: string
    creadoEn?: Date | string
  }

  export type materialesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoMaterialFieldUpdateOperationsInput | $Enums.TipoMaterial
    titulo?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type materialesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    claseId?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoMaterialFieldUpdateOperationsInput | $Enums.TipoMaterial
    titulo?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type objetivosCursosCreateInput = {
    id?: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
    cursos: cursosCreateNestedOneWithoutObjetivosCursosInput
  }

  export type objetivosCursosUncheckedCreateInput = {
    id?: string
    cursoId: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type objetivosCursosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    cursos?: cursosUpdateOneRequiredWithoutObjetivosCursosNestedInput
  }

  export type objetivosCursosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type objetivosCursosCreateManyInput = {
    id?: string
    cursoId: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type objetivosCursosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type objetivosCursosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pagosDocentesCreateInput = {
    id?: string
    monto: number
    deuda?: number
    estadoPago?: $Enums.EstadoPago
    fechaPago?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    docente: docenteCreateNestedOneWithoutPagosDocentesInput
    edicionesCursos: edicionesCursosCreateNestedOneWithoutPagosDocentesInput
  }

  export type pagosDocentesUncheckedCreateInput = {
    id?: string
    docenteId: string
    edicionId: string
    monto: number
    deuda?: number
    estadoPago?: $Enums.EstadoPago
    fechaPago?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type pagosDocentesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    deuda?: FloatFieldUpdateOperationsInput | number
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docente?: docenteUpdateOneRequiredWithoutPagosDocentesNestedInput
    edicionesCursos?: edicionesCursosUpdateOneRequiredWithoutPagosDocentesNestedInput
  }

  export type pagosDocentesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    docenteId?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    deuda?: FloatFieldUpdateOperationsInput | number
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pagosDocentesCreateManyInput = {
    id?: string
    docenteId: string
    edicionId: string
    monto: number
    deuda?: number
    estadoPago?: $Enums.EstadoPago
    fechaPago?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type pagosDocentesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    deuda?: FloatFieldUpdateOperationsInput | number
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pagosDocentesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    docenteId?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    deuda?: FloatFieldUpdateOperationsInput | number
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type preciosCursosCreateInput = {
    id?: string
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    esDescuento?: boolean
    esPrecioDefault?: boolean
    moneda?: string
    nombre: string
    porcentajeDescuento?: number | null
    precio: number
    precioOriginal?: number | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    edicionesCursos: edicionesCursosCreateNestedOneWithoutPreciosCursosInput
  }

  export type preciosCursosUncheckedCreateInput = {
    id?: string
    edicionId: string
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    esDescuento?: boolean
    esPrecioDefault?: boolean
    moneda?: string
    nombre: string
    porcentajeDescuento?: number | null
    precio: number
    precioOriginal?: number | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type preciosCursosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    esDescuento?: BoolFieldUpdateOperationsInput | boolean
    esPrecioDefault?: BoolFieldUpdateOperationsInput | boolean
    moneda?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    porcentajeDescuento?: NullableFloatFieldUpdateOperationsInput | number | null
    precio?: FloatFieldUpdateOperationsInput | number
    precioOriginal?: NullableFloatFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    edicionesCursos?: edicionesCursosUpdateOneRequiredWithoutPreciosCursosNestedInput
  }

  export type preciosCursosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    esDescuento?: BoolFieldUpdateOperationsInput | boolean
    esPrecioDefault?: BoolFieldUpdateOperationsInput | boolean
    moneda?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    porcentajeDescuento?: NullableFloatFieldUpdateOperationsInput | number | null
    precio?: FloatFieldUpdateOperationsInput | number
    precioOriginal?: NullableFloatFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type preciosCursosCreateManyInput = {
    id?: string
    edicionId: string
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    esDescuento?: boolean
    esPrecioDefault?: boolean
    moneda?: string
    nombre: string
    porcentajeDescuento?: number | null
    precio: number
    precioOriginal?: number | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type preciosCursosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    esDescuento?: BoolFieldUpdateOperationsInput | boolean
    esPrecioDefault?: BoolFieldUpdateOperationsInput | boolean
    moneda?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    porcentajeDescuento?: NullableFloatFieldUpdateOperationsInput | number | null
    precio?: FloatFieldUpdateOperationsInput | number
    precioOriginal?: NullableFloatFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type preciosCursosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    esDescuento?: BoolFieldUpdateOperationsInput | boolean
    esPrecioDefault?: BoolFieldUpdateOperationsInput | boolean
    moneda?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    porcentajeDescuento?: NullableFloatFieldUpdateOperationsInput | number | null
    precio?: FloatFieldUpdateOperationsInput | number
    precioOriginal?: NullableFloatFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type preguntasCreateInput = {
    id?: string
    codigo: string
    enunciado: string
    explicacion?: string | null
    referencia?: string | null
    opciones: JsonNullValueInput | InputJsonValue
    solucion: JsonNullValueInput | InputJsonValue
    estado?: $Enums.PreguntaEstado
    gestion: number
    likes?: number
    dislikes?: number
    dificultad?: $Enums.PreguntaDificultad
    dificultadActualizadaEn?: Date | string | null
    tasaAcierto?: number
    totalBien?: number
    totalMal?: number
    totalRespondidas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    reaccionesPreguntas?: reaccionesPreguntasCreateNestedManyWithoutPreguntaInput
    repasoRegistros?: repasoRegistrosCreateNestedManyWithoutPreguntasInput
    respuestasIntentos?: respuestasIntentosCreateNestedManyWithoutPreguntasInput
    areas?: areasCreateNestedManyWithoutPreguntasInput
    banqueo?: banqueoCreateNestedManyWithoutPreguntasInput
    capitulos?: capitulosCreateNestedManyWithoutPreguntasInput
    temas?: temasCreateNestedManyWithoutPreguntasInput
  }

  export type preguntasUncheckedCreateInput = {
    id?: string
    codigo: string
    enunciado: string
    explicacion?: string | null
    referencia?: string | null
    opciones: JsonNullValueInput | InputJsonValue
    solucion: JsonNullValueInput | InputJsonValue
    estado?: $Enums.PreguntaEstado
    gestion: number
    likes?: number
    dislikes?: number
    dificultad?: $Enums.PreguntaDificultad
    dificultadActualizadaEn?: Date | string | null
    tasaAcierto?: number
    totalBien?: number
    totalMal?: number
    totalRespondidas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    reaccionesPreguntas?: reaccionesPreguntasUncheckedCreateNestedManyWithoutPreguntaInput
    repasoRegistros?: repasoRegistrosUncheckedCreateNestedManyWithoutPreguntasInput
    respuestasIntentos?: respuestasIntentosUncheckedCreateNestedManyWithoutPreguntasInput
    areas?: areasUncheckedCreateNestedManyWithoutPreguntasInput
    banqueo?: banqueoUncheckedCreateNestedManyWithoutPreguntasInput
    capitulos?: capitulosUncheckedCreateNestedManyWithoutPreguntasInput
    temas?: temasUncheckedCreateNestedManyWithoutPreguntasInput
  }

  export type preguntasUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    enunciado?: StringFieldUpdateOperationsInput | string
    explicacion?: NullableStringFieldUpdateOperationsInput | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    opciones?: JsonNullValueInput | InputJsonValue
    solucion?: JsonNullValueInput | InputJsonValue
    estado?: EnumPreguntaEstadoFieldUpdateOperationsInput | $Enums.PreguntaEstado
    gestion?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumPreguntaDificultadFieldUpdateOperationsInput | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasaAcierto?: IntFieldUpdateOperationsInput | number
    totalBien?: IntFieldUpdateOperationsInput | number
    totalMal?: IntFieldUpdateOperationsInput | number
    totalRespondidas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    reaccionesPreguntas?: reaccionesPreguntasUpdateManyWithoutPreguntaNestedInput
    repasoRegistros?: repasoRegistrosUpdateManyWithoutPreguntasNestedInput
    respuestasIntentos?: respuestasIntentosUpdateManyWithoutPreguntasNestedInput
    areas?: areasUpdateManyWithoutPreguntasNestedInput
    banqueo?: banqueoUpdateManyWithoutPreguntasNestedInput
    capitulos?: capitulosUpdateManyWithoutPreguntasNestedInput
    temas?: temasUpdateManyWithoutPreguntasNestedInput
  }

  export type preguntasUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    enunciado?: StringFieldUpdateOperationsInput | string
    explicacion?: NullableStringFieldUpdateOperationsInput | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    opciones?: JsonNullValueInput | InputJsonValue
    solucion?: JsonNullValueInput | InputJsonValue
    estado?: EnumPreguntaEstadoFieldUpdateOperationsInput | $Enums.PreguntaEstado
    gestion?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumPreguntaDificultadFieldUpdateOperationsInput | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasaAcierto?: IntFieldUpdateOperationsInput | number
    totalBien?: IntFieldUpdateOperationsInput | number
    totalMal?: IntFieldUpdateOperationsInput | number
    totalRespondidas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    reaccionesPreguntas?: reaccionesPreguntasUncheckedUpdateManyWithoutPreguntaNestedInput
    repasoRegistros?: repasoRegistrosUncheckedUpdateManyWithoutPreguntasNestedInput
    respuestasIntentos?: respuestasIntentosUncheckedUpdateManyWithoutPreguntasNestedInput
    areas?: areasUncheckedUpdateManyWithoutPreguntasNestedInput
    banqueo?: banqueoUncheckedUpdateManyWithoutPreguntasNestedInput
    capitulos?: capitulosUncheckedUpdateManyWithoutPreguntasNestedInput
    temas?: temasUncheckedUpdateManyWithoutPreguntasNestedInput
  }

  export type preguntasCreateManyInput = {
    id?: string
    codigo: string
    enunciado: string
    explicacion?: string | null
    referencia?: string | null
    opciones: JsonNullValueInput | InputJsonValue
    solucion: JsonNullValueInput | InputJsonValue
    estado?: $Enums.PreguntaEstado
    gestion: number
    likes?: number
    dislikes?: number
    dificultad?: $Enums.PreguntaDificultad
    dificultadActualizadaEn?: Date | string | null
    tasaAcierto?: number
    totalBien?: number
    totalMal?: number
    totalRespondidas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type preguntasUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    enunciado?: StringFieldUpdateOperationsInput | string
    explicacion?: NullableStringFieldUpdateOperationsInput | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    opciones?: JsonNullValueInput | InputJsonValue
    solucion?: JsonNullValueInput | InputJsonValue
    estado?: EnumPreguntaEstadoFieldUpdateOperationsInput | $Enums.PreguntaEstado
    gestion?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumPreguntaDificultadFieldUpdateOperationsInput | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasaAcierto?: IntFieldUpdateOperationsInput | number
    totalBien?: IntFieldUpdateOperationsInput | number
    totalMal?: IntFieldUpdateOperationsInput | number
    totalRespondidas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type preguntasUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    enunciado?: StringFieldUpdateOperationsInput | string
    explicacion?: NullableStringFieldUpdateOperationsInput | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    opciones?: JsonNullValueInput | InputJsonValue
    solucion?: JsonNullValueInput | InputJsonValue
    estado?: EnumPreguntaEstadoFieldUpdateOperationsInput | $Enums.PreguntaEstado
    gestion?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumPreguntaDificultadFieldUpdateOperationsInput | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasaAcierto?: IntFieldUpdateOperationsInput | number
    totalBien?: IntFieldUpdateOperationsInput | number
    totalMal?: IntFieldUpdateOperationsInput | number
    totalRespondidas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reaccionesPreguntasCreateInput = {
    id?: string
    tipo: $Enums.TipoReaccion
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    pregunta: preguntasCreateNestedOneWithoutReaccionesPreguntasInput
    usuariosEstudiantes: usuariosEstudiantesCreateNestedOneWithoutReaccionesPreguntasInput
  }

  export type reaccionesPreguntasUncheckedCreateInput = {
    id?: string
    preguntaId: string
    usuarioEstudianteId: string
    tipo: $Enums.TipoReaccion
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type reaccionesPreguntasUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoReaccionFieldUpdateOperationsInput | $Enums.TipoReaccion
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    pregunta?: preguntasUpdateOneRequiredWithoutReaccionesPreguntasNestedInput
    usuariosEstudiantes?: usuariosEstudiantesUpdateOneRequiredWithoutReaccionesPreguntasNestedInput
  }

  export type reaccionesPreguntasUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    preguntaId?: StringFieldUpdateOperationsInput | string
    usuarioEstudianteId?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoReaccionFieldUpdateOperationsInput | $Enums.TipoReaccion
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reaccionesPreguntasCreateManyInput = {
    id?: string
    preguntaId: string
    usuarioEstudianteId: string
    tipo: $Enums.TipoReaccion
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type reaccionesPreguntasUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoReaccionFieldUpdateOperationsInput | $Enums.TipoReaccion
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reaccionesPreguntasUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    preguntaId?: StringFieldUpdateOperationsInput | string
    usuarioEstudianteId?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoReaccionFieldUpdateOperationsInput | $Enums.TipoReaccion
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requisitosCursosCreateInput = {
    id?: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
    cursos: cursosCreateNestedOneWithoutRequisitosCursosInput
  }

  export type requisitosCursosUncheckedCreateInput = {
    id?: string
    cursoId: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type requisitosCursosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    cursos?: cursosUpdateOneRequiredWithoutRequisitosCursosNestedInput
  }

  export type requisitosCursosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requisitosCursosCreateManyInput = {
    id?: string
    cursoId: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type requisitosCursosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requisitosCursosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewsCursosCreateInput = {
    id?: string
    rating: number
    comentario?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    cursos: cursosCreateNestedOneWithoutReviewsCursosInput
    usuariosEstudiantes?: usuariosEstudiantesCreateNestedOneWithoutReviewsCursosInput
  }

  export type reviewsCursosUncheckedCreateInput = {
    id?: string
    cursoId: string
    rating: number
    comentario?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    usuariosEstudiantesId?: string | null
  }

  export type reviewsCursosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    cursos?: cursosUpdateOneRequiredWithoutReviewsCursosNestedInput
    usuariosEstudiantes?: usuariosEstudiantesUpdateOneWithoutReviewsCursosNestedInput
  }

  export type reviewsCursosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosEstudiantesId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reviewsCursosCreateManyInput = {
    id?: string
    cursoId: string
    rating: number
    comentario?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    usuariosEstudiantesId?: string | null
  }

  export type reviewsCursosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewsCursosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosEstudiantesId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usuariosAdministradoresCreateInput = {
    id?: string
    correo: string
    contrasena: string
    encargado?: string | null
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    tipo: $Enums.TipoCuenta
    auditoria?: auditoriaCreateNestedManyWithoutUsuariosAdministradoresInput
    docente?: docenteCreateNestedOneWithoutUsuariosAdministradoresInput
    grabaciones?: grabacionesCreateNestedManyWithoutUsuariosAdministradoresInput
  }

  export type usuariosAdministradoresUncheckedCreateInput = {
    id?: string
    correo: string
    contrasena: string
    encargado?: string | null
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    tipo: $Enums.TipoCuenta
    auditoria?: auditoriaUncheckedCreateNestedManyWithoutUsuariosAdministradoresInput
    docente?: docenteUncheckedCreateNestedOneWithoutUsuariosAdministradoresInput
    grabaciones?: grabacionesUncheckedCreateNestedManyWithoutUsuariosAdministradoresInput
  }

  export type usuariosAdministradoresUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    encargado?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCuentaFieldUpdateOperationsInput | $Enums.TipoCuenta
    auditoria?: auditoriaUpdateManyWithoutUsuariosAdministradoresNestedInput
    docente?: docenteUpdateOneWithoutUsuariosAdministradoresNestedInput
    grabaciones?: grabacionesUpdateManyWithoutUsuariosAdministradoresNestedInput
  }

  export type usuariosAdministradoresUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    encargado?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCuentaFieldUpdateOperationsInput | $Enums.TipoCuenta
    auditoria?: auditoriaUncheckedUpdateManyWithoutUsuariosAdministradoresNestedInput
    docente?: docenteUncheckedUpdateOneWithoutUsuariosAdministradoresNestedInput
    grabaciones?: grabacionesUncheckedUpdateManyWithoutUsuariosAdministradoresNestedInput
  }

  export type usuariosAdministradoresCreateManyInput = {
    id?: string
    correo: string
    contrasena: string
    encargado?: string | null
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    tipo: $Enums.TipoCuenta
  }

  export type usuariosAdministradoresUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    encargado?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCuentaFieldUpdateOperationsInput | $Enums.TipoCuenta
  }

  export type usuariosAdministradoresUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    encargado?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCuentaFieldUpdateOperationsInput | $Enums.TipoCuenta
  }

  export type usuariosEstudiantesCreateInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    avatar?: string | null
    registrado?: boolean
    compras?: comprasCreateNestedManyWithoutUsuariosEstudiantesInput
    intentos?: intentosCreateNestedManyWithoutUsuariosEstudiantesInput
    reaccionesPreguntas?: reaccionesPreguntasCreateNestedManyWithoutUsuariosEstudiantesInput
    repasoRegistros?: repasoRegistrosCreateNestedManyWithoutUsuariosEstudiantesInput
    reviewsCursos?: reviewsCursosCreateNestedManyWithoutUsuariosEstudiantesInput
    suscripciones?: suscripcionesCreateNestedManyWithoutUsuariosEstudiantesInput
    estudiantes?: estudiantesCreateNestedOneWithoutUsuariosEstudiantesInput
  }

  export type usuariosEstudiantesUncheckedCreateInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    avatar?: string | null
    estudianteId?: string | null
    registrado?: boolean
    compras?: comprasUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    intentos?: intentosUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    reaccionesPreguntas?: reaccionesPreguntasUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    repasoRegistros?: repasoRegistrosUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    reviewsCursos?: reviewsCursosUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    suscripciones?: suscripcionesUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
  }

  export type usuariosEstudiantesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
    compras?: comprasUpdateManyWithoutUsuariosEstudiantesNestedInput
    intentos?: intentosUpdateManyWithoutUsuariosEstudiantesNestedInput
    reaccionesPreguntas?: reaccionesPreguntasUpdateManyWithoutUsuariosEstudiantesNestedInput
    repasoRegistros?: repasoRegistrosUpdateManyWithoutUsuariosEstudiantesNestedInput
    reviewsCursos?: reviewsCursosUpdateManyWithoutUsuariosEstudiantesNestedInput
    suscripciones?: suscripcionesUpdateManyWithoutUsuariosEstudiantesNestedInput
    estudiantes?: estudiantesUpdateOneWithoutUsuariosEstudiantesNestedInput
  }

  export type usuariosEstudiantesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
    compras?: comprasUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    intentos?: intentosUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    reaccionesPreguntas?: reaccionesPreguntasUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    repasoRegistros?: repasoRegistrosUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    reviewsCursos?: reviewsCursosUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    suscripciones?: suscripcionesUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
  }

  export type usuariosEstudiantesCreateManyInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    avatar?: string | null
    estudianteId?: string | null
    registrado?: boolean
  }

  export type usuariosEstudiantesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type usuariosEstudiantesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type areasCreateInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    capitulos?: capitulosCreateNestedManyWithoutAreasInput
    preguntas?: preguntasCreateNestedManyWithoutAreasInput
  }

  export type areasUncheckedCreateInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    capitulos?: capitulosUncheckedCreateNestedManyWithoutAreasInput
    preguntas?: preguntasUncheckedCreateNestedManyWithoutAreasInput
  }

  export type areasUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    capitulos?: capitulosUpdateManyWithoutAreasNestedInput
    preguntas?: preguntasUpdateManyWithoutAreasNestedInput
  }

  export type areasUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    capitulos?: capitulosUncheckedUpdateManyWithoutAreasNestedInput
    preguntas?: preguntasUncheckedUpdateManyWithoutAreasNestedInput
  }

  export type areasCreateManyInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type areasUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type areasUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type banqueoCreateInput = {
    id?: string
    titulo: string
    tipo: $Enums.BanqueoTipo
    tipoCreado: $Enums.BanqueoTipoCreado
    duracion: number
    maxPreguntas: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    intentos?: intentosCreateNestedManyWithoutBanqueoInput
    repasoRegistros?: repasoRegistrosCreateNestedManyWithoutBanqueoInput
    preguntas?: preguntasCreateNestedManyWithoutBanqueoInput
  }

  export type banqueoUncheckedCreateInput = {
    id?: string
    titulo: string
    tipo: $Enums.BanqueoTipo
    tipoCreado: $Enums.BanqueoTipoCreado
    duracion: number
    maxPreguntas: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    intentos?: intentosUncheckedCreateNestedManyWithoutBanqueoInput
    repasoRegistros?: repasoRegistrosUncheckedCreateNestedManyWithoutBanqueoInput
    preguntas?: preguntasUncheckedCreateNestedManyWithoutBanqueoInput
  }

  export type banqueoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    tipo?: EnumBanqueoTipoFieldUpdateOperationsInput | $Enums.BanqueoTipo
    tipoCreado?: EnumBanqueoTipoCreadoFieldUpdateOperationsInput | $Enums.BanqueoTipoCreado
    duracion?: IntFieldUpdateOperationsInput | number
    maxPreguntas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    intentos?: intentosUpdateManyWithoutBanqueoNestedInput
    repasoRegistros?: repasoRegistrosUpdateManyWithoutBanqueoNestedInput
    preguntas?: preguntasUpdateManyWithoutBanqueoNestedInput
  }

  export type banqueoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    tipo?: EnumBanqueoTipoFieldUpdateOperationsInput | $Enums.BanqueoTipo
    tipoCreado?: EnumBanqueoTipoCreadoFieldUpdateOperationsInput | $Enums.BanqueoTipoCreado
    duracion?: IntFieldUpdateOperationsInput | number
    maxPreguntas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    intentos?: intentosUncheckedUpdateManyWithoutBanqueoNestedInput
    repasoRegistros?: repasoRegistrosUncheckedUpdateManyWithoutBanqueoNestedInput
    preguntas?: preguntasUncheckedUpdateManyWithoutBanqueoNestedInput
  }

  export type banqueoCreateManyInput = {
    id?: string
    titulo: string
    tipo: $Enums.BanqueoTipo
    tipoCreado: $Enums.BanqueoTipoCreado
    duracion: number
    maxPreguntas: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type banqueoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    tipo?: EnumBanqueoTipoFieldUpdateOperationsInput | $Enums.BanqueoTipo
    tipoCreado?: EnumBanqueoTipoCreadoFieldUpdateOperationsInput | $Enums.BanqueoTipoCreado
    duracion?: IntFieldUpdateOperationsInput | number
    maxPreguntas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type banqueoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    tipo?: EnumBanqueoTipoFieldUpdateOperationsInput | $Enums.BanqueoTipo
    tipoCreado?: EnumBanqueoTipoCreadoFieldUpdateOperationsInput | $Enums.BanqueoTipoCreado
    duracion?: IntFieldUpdateOperationsInput | number
    maxPreguntas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type capitulosCreateInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    areas?: areasCreateNestedOneWithoutCapitulosInput
    temas?: temasCreateNestedManyWithoutCapitulosInput
    preguntas?: preguntasCreateNestedManyWithoutCapitulosInput
  }

  export type capitulosUncheckedCreateInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    areaId?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    temas?: temasUncheckedCreateNestedManyWithoutCapitulosInput
    preguntas?: preguntasUncheckedCreateNestedManyWithoutCapitulosInput
  }

  export type capitulosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    areas?: areasUpdateOneWithoutCapitulosNestedInput
    temas?: temasUpdateManyWithoutCapitulosNestedInput
    preguntas?: preguntasUpdateManyWithoutCapitulosNestedInput
  }

  export type capitulosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    temas?: temasUncheckedUpdateManyWithoutCapitulosNestedInput
    preguntas?: preguntasUncheckedUpdateManyWithoutCapitulosNestedInput
  }

  export type capitulosCreateManyInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    areaId?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type capitulosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type capitulosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type intentosCreateInput = {
    id?: string
    tiempoDuracion: number
    correctas?: number
    incorrectas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    estado?: $Enums.EstadoIntento
    banqueo: banqueoCreateNestedOneWithoutIntentosInput
    usuariosEstudiantes?: usuariosEstudiantesCreateNestedOneWithoutIntentosInput
    respuestasIntentos?: respuestasIntentosCreateNestedManyWithoutIntentosInput
  }

  export type intentosUncheckedCreateInput = {
    id?: string
    banqueoId: string
    usuarioEstudianteId?: string | null
    tiempoDuracion: number
    correctas?: number
    incorrectas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    estado?: $Enums.EstadoIntento
    respuestasIntentos?: respuestasIntentosUncheckedCreateNestedManyWithoutIntentosInput
  }

  export type intentosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tiempoDuracion?: IntFieldUpdateOperationsInput | number
    correctas?: IntFieldUpdateOperationsInput | number
    incorrectas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoIntentoFieldUpdateOperationsInput | $Enums.EstadoIntento
    banqueo?: banqueoUpdateOneRequiredWithoutIntentosNestedInput
    usuariosEstudiantes?: usuariosEstudiantesUpdateOneWithoutIntentosNestedInput
    respuestasIntentos?: respuestasIntentosUpdateManyWithoutIntentosNestedInput
  }

  export type intentosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    banqueoId?: StringFieldUpdateOperationsInput | string
    usuarioEstudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    tiempoDuracion?: IntFieldUpdateOperationsInput | number
    correctas?: IntFieldUpdateOperationsInput | number
    incorrectas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoIntentoFieldUpdateOperationsInput | $Enums.EstadoIntento
    respuestasIntentos?: respuestasIntentosUncheckedUpdateManyWithoutIntentosNestedInput
  }

  export type intentosCreateManyInput = {
    id?: string
    banqueoId: string
    usuarioEstudianteId?: string | null
    tiempoDuracion: number
    correctas?: number
    incorrectas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    estado?: $Enums.EstadoIntento
  }

  export type intentosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tiempoDuracion?: IntFieldUpdateOperationsInput | number
    correctas?: IntFieldUpdateOperationsInput | number
    incorrectas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoIntentoFieldUpdateOperationsInput | $Enums.EstadoIntento
  }

  export type intentosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    banqueoId?: StringFieldUpdateOperationsInput | string
    usuarioEstudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    tiempoDuracion?: IntFieldUpdateOperationsInput | number
    correctas?: IntFieldUpdateOperationsInput | number
    incorrectas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoIntentoFieldUpdateOperationsInput | $Enums.EstadoIntento
  }

  export type respuestasIntentosCreateInput = {
    id?: string
    respuesta?: NullableJsonNullValueInput | InputJsonValue
    resultado?: $Enums.ResultadoRespuesta
    esCorrecta?: boolean | null
    respondida?: boolean
    visitada?: boolean
    marcadaRevision?: boolean
    tiempoConsumidoSeg?: number
    orden?: number | null
    respondidaEn?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    intentos: intentosCreateNestedOneWithoutRespuestasIntentosInput
    preguntas: preguntasCreateNestedOneWithoutRespuestasIntentosInput
  }

  export type respuestasIntentosUncheckedCreateInput = {
    id?: string
    intentoId: string
    preguntaId: string
    respuesta?: NullableJsonNullValueInput | InputJsonValue
    resultado?: $Enums.ResultadoRespuesta
    esCorrecta?: boolean | null
    respondida?: boolean
    visitada?: boolean
    marcadaRevision?: boolean
    tiempoConsumidoSeg?: number
    orden?: number | null
    respondidaEn?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type respuestasIntentosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    respuesta?: NullableJsonNullValueInput | InputJsonValue
    resultado?: EnumResultadoRespuestaFieldUpdateOperationsInput | $Enums.ResultadoRespuesta
    esCorrecta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    respondida?: BoolFieldUpdateOperationsInput | boolean
    visitada?: BoolFieldUpdateOperationsInput | boolean
    marcadaRevision?: BoolFieldUpdateOperationsInput | boolean
    tiempoConsumidoSeg?: IntFieldUpdateOperationsInput | number
    orden?: NullableIntFieldUpdateOperationsInput | number | null
    respondidaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    intentos?: intentosUpdateOneRequiredWithoutRespuestasIntentosNestedInput
    preguntas?: preguntasUpdateOneRequiredWithoutRespuestasIntentosNestedInput
  }

  export type respuestasIntentosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    intentoId?: StringFieldUpdateOperationsInput | string
    preguntaId?: StringFieldUpdateOperationsInput | string
    respuesta?: NullableJsonNullValueInput | InputJsonValue
    resultado?: EnumResultadoRespuestaFieldUpdateOperationsInput | $Enums.ResultadoRespuesta
    esCorrecta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    respondida?: BoolFieldUpdateOperationsInput | boolean
    visitada?: BoolFieldUpdateOperationsInput | boolean
    marcadaRevision?: BoolFieldUpdateOperationsInput | boolean
    tiempoConsumidoSeg?: IntFieldUpdateOperationsInput | number
    orden?: NullableIntFieldUpdateOperationsInput | number | null
    respondidaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type respuestasIntentosCreateManyInput = {
    id?: string
    intentoId: string
    preguntaId: string
    respuesta?: NullableJsonNullValueInput | InputJsonValue
    resultado?: $Enums.ResultadoRespuesta
    esCorrecta?: boolean | null
    respondida?: boolean
    visitada?: boolean
    marcadaRevision?: boolean
    tiempoConsumidoSeg?: number
    orden?: number | null
    respondidaEn?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type respuestasIntentosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    respuesta?: NullableJsonNullValueInput | InputJsonValue
    resultado?: EnumResultadoRespuestaFieldUpdateOperationsInput | $Enums.ResultadoRespuesta
    esCorrecta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    respondida?: BoolFieldUpdateOperationsInput | boolean
    visitada?: BoolFieldUpdateOperationsInput | boolean
    marcadaRevision?: BoolFieldUpdateOperationsInput | boolean
    tiempoConsumidoSeg?: IntFieldUpdateOperationsInput | number
    orden?: NullableIntFieldUpdateOperationsInput | number | null
    respondidaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type respuestasIntentosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    intentoId?: StringFieldUpdateOperationsInput | string
    preguntaId?: StringFieldUpdateOperationsInput | string
    respuesta?: NullableJsonNullValueInput | InputJsonValue
    resultado?: EnumResultadoRespuestaFieldUpdateOperationsInput | $Enums.ResultadoRespuesta
    esCorrecta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    respondida?: BoolFieldUpdateOperationsInput | boolean
    visitada?: BoolFieldUpdateOperationsInput | boolean
    marcadaRevision?: BoolFieldUpdateOperationsInput | boolean
    tiempoConsumidoSeg?: IntFieldUpdateOperationsInput | number
    orden?: NullableIntFieldUpdateOperationsInput | number | null
    respondidaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type repasoRegistrosCreateInput = {
    id?: string
    esCorrecta: boolean
    creadoEn?: Date | string
    banqueo: banqueoCreateNestedOneWithoutRepasoRegistrosInput
    preguntas: preguntasCreateNestedOneWithoutRepasoRegistrosInput
    usuariosEstudiantes: usuariosEstudiantesCreateNestedOneWithoutRepasoRegistrosInput
  }

  export type repasoRegistrosUncheckedCreateInput = {
    id?: string
    usuarioEstudianteId: string
    banqueoId: string
    preguntaId: string
    esCorrecta: boolean
    creadoEn?: Date | string
  }

  export type repasoRegistrosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    esCorrecta?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    banqueo?: banqueoUpdateOneRequiredWithoutRepasoRegistrosNestedInput
    preguntas?: preguntasUpdateOneRequiredWithoutRepasoRegistrosNestedInput
    usuariosEstudiantes?: usuariosEstudiantesUpdateOneRequiredWithoutRepasoRegistrosNestedInput
  }

  export type repasoRegistrosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioEstudianteId?: StringFieldUpdateOperationsInput | string
    banqueoId?: StringFieldUpdateOperationsInput | string
    preguntaId?: StringFieldUpdateOperationsInput | string
    esCorrecta?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type repasoRegistrosCreateManyInput = {
    id?: string
    usuarioEstudianteId: string
    banqueoId: string
    preguntaId: string
    esCorrecta: boolean
    creadoEn?: Date | string
  }

  export type repasoRegistrosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    esCorrecta?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type repasoRegistrosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioEstudianteId?: StringFieldUpdateOperationsInput | string
    banqueoId?: StringFieldUpdateOperationsInput | string
    preguntaId?: StringFieldUpdateOperationsInput | string
    esCorrecta?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type suscripcionesCreateInput = {
    id?: string
    montoUsd: number
    fechaInicio?: Date | string
    fechaFin: Date | string
    estado?: $Enums.EstadoSuscripcion
    creadoEn?: Date | string
    actualizadoEn: Date | string
    usuariosEstudiantes: usuariosEstudiantesCreateNestedOneWithoutSuscripcionesInput
  }

  export type suscripcionesUncheckedCreateInput = {
    id?: string
    usuarioEstudianteId: string
    montoUsd: number
    fechaInicio?: Date | string
    fechaFin: Date | string
    estado?: $Enums.EstadoSuscripcion
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type suscripcionesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    montoUsd?: FloatFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoSuscripcionFieldUpdateOperationsInput | $Enums.EstadoSuscripcion
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosEstudiantes?: usuariosEstudiantesUpdateOneRequiredWithoutSuscripcionesNestedInput
  }

  export type suscripcionesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioEstudianteId?: StringFieldUpdateOperationsInput | string
    montoUsd?: FloatFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoSuscripcionFieldUpdateOperationsInput | $Enums.EstadoSuscripcion
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type suscripcionesCreateManyInput = {
    id?: string
    usuarioEstudianteId: string
    montoUsd: number
    fechaInicio?: Date | string
    fechaFin: Date | string
    estado?: $Enums.EstadoSuscripcion
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type suscripcionesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    montoUsd?: FloatFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoSuscripcionFieldUpdateOperationsInput | $Enums.EstadoSuscripcion
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type suscripcionesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioEstudianteId?: StringFieldUpdateOperationsInput | string
    montoUsd?: FloatFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoSuscripcionFieldUpdateOperationsInput | $Enums.EstadoSuscripcion
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumTablaFilter<$PrismaModel = never> = {
    equals?: $Enums.Tabla | EnumTablaFieldRefInput<$PrismaModel>
    in?: $Enums.Tabla[] | ListEnumTablaFieldRefInput<$PrismaModel>
    notIn?: $Enums.Tabla[] | ListEnumTablaFieldRefInput<$PrismaModel>
    not?: NestedEnumTablaFilter<$PrismaModel> | $Enums.Tabla
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumAccionAuditoriaFilter<$PrismaModel = never> = {
    equals?: $Enums.AccionAuditoria | EnumAccionAuditoriaFieldRefInput<$PrismaModel>
    in?: $Enums.AccionAuditoria[] | ListEnumAccionAuditoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccionAuditoria[] | ListEnumAccionAuditoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumAccionAuditoriaFilter<$PrismaModel> | $Enums.AccionAuditoria
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UsuariosAdministradoresScalarRelationFilter = {
    is?: usuariosAdministradoresWhereInput
    isNot?: usuariosAdministradoresWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type auditoriaCountOrderByAggregateInput = {
    id?: SortOrder
    tabla?: SortOrder
    registroId?: SortOrder
    accion?: SortOrder
    detalles?: SortOrder
    usuarioId?: SortOrder
    creadoEn?: SortOrder
  }

  export type auditoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    tabla?: SortOrder
    registroId?: SortOrder
    accion?: SortOrder
    usuarioId?: SortOrder
    creadoEn?: SortOrder
  }

  export type auditoriaMinOrderByAggregateInput = {
    id?: SortOrder
    tabla?: SortOrder
    registroId?: SortOrder
    accion?: SortOrder
    usuarioId?: SortOrder
    creadoEn?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumTablaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tabla | EnumTablaFieldRefInput<$PrismaModel>
    in?: $Enums.Tabla[] | ListEnumTablaFieldRefInput<$PrismaModel>
    notIn?: $Enums.Tabla[] | ListEnumTablaFieldRefInput<$PrismaModel>
    not?: NestedEnumTablaWithAggregatesFilter<$PrismaModel> | $Enums.Tabla
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTablaFilter<$PrismaModel>
    _max?: NestedEnumTablaFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumAccionAuditoriaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccionAuditoria | EnumAccionAuditoriaFieldRefInput<$PrismaModel>
    in?: $Enums.AccionAuditoria[] | ListEnumAccionAuditoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccionAuditoria[] | ListEnumAccionAuditoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumAccionAuditoriaWithAggregatesFilter<$PrismaModel> | $Enums.AccionAuditoria
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccionAuditoriaFilter<$PrismaModel>
    _max?: NestedEnumAccionAuditoriaFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type CursosScalarRelationFilter = {
    is?: cursosWhereInput
    isNot?: cursosWhereInput
  }

  export type beneficiosCursosCountOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
  }

  export type beneficiosCursosAvgOrderByAggregateInput = {
    orden?: SortOrder
  }

  export type beneficiosCursosMaxOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
  }

  export type beneficiosCursosMinOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
  }

  export type beneficiosCursosSumOrderByAggregateInput = {
    orden?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EstudiantesScalarRelationFilter = {
    is?: estudiantesWhereInput
    isNot?: estudiantesWhereInput
  }

  export type ExamenesScalarRelationFilter = {
    is?: examenesWhereInput
    isNot?: examenesWhereInput
  }

  export type calificacionesEstudianteIdExamenIdCompoundUniqueInput = {
    estudianteId: string
    examenId: string
  }

  export type calificacionesCountOrderByAggregateInput = {
    id?: SortOrder
    aprobado?: SortOrder
    comentarios?: SortOrder
    estudianteId?: SortOrder
    examenId?: SortOrder
    nota?: SortOrder
    creadoEn?: SortOrder
  }

  export type calificacionesAvgOrderByAggregateInput = {
    nota?: SortOrder
  }

  export type calificacionesMaxOrderByAggregateInput = {
    id?: SortOrder
    aprobado?: SortOrder
    comentarios?: SortOrder
    estudianteId?: SortOrder
    examenId?: SortOrder
    nota?: SortOrder
    creadoEn?: SortOrder
  }

  export type calificacionesMinOrderByAggregateInput = {
    id?: SortOrder
    aprobado?: SortOrder
    comentarios?: SortOrder
    estudianteId?: SortOrder
    examenId?: SortOrder
    nota?: SortOrder
    creadoEn?: SortOrder
  }

  export type calificacionesSumOrderByAggregateInput = {
    nota?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type CategoriasCursosListRelationFilter = {
    every?: categoriasCursosWhereInput
    some?: categoriasCursosWhereInput
    none?: categoriasCursosWhereInput
  }

  export type categoriasCursosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categoriasCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type categoriasMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type categoriasMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type CategoriasScalarRelationFilter = {
    is?: categoriasWhereInput
    isNot?: categoriasWhereInput
  }

  export type categoriasCursosCursoIdCategoriaIdCompoundUniqueInput = {
    cursoId: string
    categoriaId: string
  }

  export type categoriasCursosCountOrderByAggregateInput = {
    id?: SortOrder
    categoriaId?: SortOrder
    cursoId?: SortOrder
  }

  export type categoriasCursosMaxOrderByAggregateInput = {
    id?: SortOrder
    categoriaId?: SortOrder
    cursoId?: SortOrder
  }

  export type categoriasCursosMinOrderByAggregateInput = {
    id?: SortOrder
    categoriaId?: SortOrder
    cursoId?: SortOrder
  }

  export type EnumTipoCertificadoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoCertificado | EnumTipoCertificadoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoCertificado[] | ListEnumTipoCertificadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoCertificado[] | ListEnumTipoCertificadoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoCertificadoFilter<$PrismaModel> | $Enums.TipoCertificado
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EdicionesCursosScalarRelationFilter = {
    is?: edicionesCursosWhereInput
    isNot?: edicionesCursosWhereInput
  }

  export type certificadosCountOrderByAggregateInput = {
    id?: SortOrder
    codigoUnico?: SortOrder
    edicionId?: SortOrder
    estudianteId?: SortOrder
    fechaEmision?: SortOrder
    tipo?: SortOrder
    notaFinal?: SortOrder
    urlCertificado?: SortOrder
    creadoEn?: SortOrder
  }

  export type certificadosAvgOrderByAggregateInput = {
    notaFinal?: SortOrder
  }

  export type certificadosMaxOrderByAggregateInput = {
    id?: SortOrder
    codigoUnico?: SortOrder
    edicionId?: SortOrder
    estudianteId?: SortOrder
    fechaEmision?: SortOrder
    tipo?: SortOrder
    notaFinal?: SortOrder
    urlCertificado?: SortOrder
    creadoEn?: SortOrder
  }

  export type certificadosMinOrderByAggregateInput = {
    id?: SortOrder
    codigoUnico?: SortOrder
    edicionId?: SortOrder
    estudianteId?: SortOrder
    fechaEmision?: SortOrder
    tipo?: SortOrder
    notaFinal?: SortOrder
    urlCertificado?: SortOrder
    creadoEn?: SortOrder
  }

  export type certificadosSumOrderByAggregateInput = {
    notaFinal?: SortOrder
  }

  export type EnumTipoCertificadoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoCertificado | EnumTipoCertificadoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoCertificado[] | ListEnumTipoCertificadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoCertificado[] | ListEnumTipoCertificadoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoCertificadoWithAggregatesFilter<$PrismaModel> | $Enums.TipoCertificado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoCertificadoFilter<$PrismaModel>
    _max?: NestedEnumTipoCertificadoFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type GrabacionesListRelationFilter = {
    every?: grabacionesWhereInput
    some?: grabacionesWhereInput
    none?: grabacionesWhereInput
  }

  export type MaterialesListRelationFilter = {
    every?: materialesWhereInput
    some?: materialesWhereInput
    none?: materialesWhereInput
  }

  export type grabacionesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type materialesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clasesCountOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    descripcion?: SortOrder
    duracion?: SortOrder
    fecha?: SortOrder
    orden?: SortOrder
    titulo?: SortOrder
    urlYoutube?: SortOrder
    creadoEn?: SortOrder
    urlPresentacion?: SortOrder
  }

  export type clasesAvgOrderByAggregateInput = {
    duracion?: SortOrder
    orden?: SortOrder
  }

  export type clasesMaxOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    descripcion?: SortOrder
    duracion?: SortOrder
    fecha?: SortOrder
    orden?: SortOrder
    titulo?: SortOrder
    urlYoutube?: SortOrder
    creadoEn?: SortOrder
    urlPresentacion?: SortOrder
  }

  export type clasesMinOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    descripcion?: SortOrder
    duracion?: SortOrder
    fecha?: SortOrder
    orden?: SortOrder
    titulo?: SortOrder
    urlYoutube?: SortOrder
    creadoEn?: SortOrder
    urlPresentacion?: SortOrder
  }

  export type clasesSumOrderByAggregateInput = {
    duracion?: SortOrder
    orden?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumMetodoPagoFilter<$PrismaModel = never> = {
    equals?: $Enums.MetodoPago | EnumMetodoPagoFieldRefInput<$PrismaModel>
    in?: $Enums.MetodoPago[] | ListEnumMetodoPagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetodoPago[] | ListEnumMetodoPagoFieldRefInput<$PrismaModel>
    not?: NestedEnumMetodoPagoFilter<$PrismaModel> | $Enums.MetodoPago
  }

  export type EnumEstadoPagoFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPago | EnumEstadoPagoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPago[] | ListEnumEstadoPagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoPago[] | ListEnumEstadoPagoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoPagoFilter<$PrismaModel> | $Enums.EstadoPago
  }

  export type UsuariosEstudiantesNullableScalarRelationFilter = {
    is?: usuariosEstudiantesWhereInput | null
    isNot?: usuariosEstudiantesWhereInput | null
  }

  export type InscripcionesNullableScalarRelationFilter = {
    is?: inscripcionesWhereInput | null
    isNot?: inscripcionesWhereInput | null
  }

  export type comprasCountOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    monto?: SortOrder
    moneda?: SortOrder
    comprobado?: SortOrder
    providerId?: SortOrder
    fechaCompra?: SortOrder
    metodo?: SortOrder
    deuda?: SortOrder
    usuariosEstudiantesId?: SortOrder
    estadoPago?: SortOrder
    updatedAt?: SortOrder
    conDescuento?: SortOrder
  }

  export type comprasAvgOrderByAggregateInput = {
    monto?: SortOrder
    deuda?: SortOrder
  }

  export type comprasMaxOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    monto?: SortOrder
    moneda?: SortOrder
    comprobado?: SortOrder
    providerId?: SortOrder
    fechaCompra?: SortOrder
    metodo?: SortOrder
    deuda?: SortOrder
    usuariosEstudiantesId?: SortOrder
    estadoPago?: SortOrder
    updatedAt?: SortOrder
    conDescuento?: SortOrder
  }

  export type comprasMinOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    monto?: SortOrder
    moneda?: SortOrder
    comprobado?: SortOrder
    providerId?: SortOrder
    fechaCompra?: SortOrder
    metodo?: SortOrder
    deuda?: SortOrder
    usuariosEstudiantesId?: SortOrder
    estadoPago?: SortOrder
    updatedAt?: SortOrder
    conDescuento?: SortOrder
  }

  export type comprasSumOrderByAggregateInput = {
    monto?: SortOrder
    deuda?: SortOrder
  }

  export type EnumMetodoPagoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MetodoPago | EnumMetodoPagoFieldRefInput<$PrismaModel>
    in?: $Enums.MetodoPago[] | ListEnumMetodoPagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetodoPago[] | ListEnumMetodoPagoFieldRefInput<$PrismaModel>
    not?: NestedEnumMetodoPagoWithAggregatesFilter<$PrismaModel> | $Enums.MetodoPago
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMetodoPagoFilter<$PrismaModel>
    _max?: NestedEnumMetodoPagoFilter<$PrismaModel>
  }

  export type EnumEstadoPagoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPago | EnumEstadoPagoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPago[] | ListEnumEstadoPagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoPago[] | ListEnumEstadoPagoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoPagoWithAggregatesFilter<$PrismaModel> | $Enums.EstadoPago
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoPagoFilter<$PrismaModel>
    _max?: NestedEnumEstadoPagoFilter<$PrismaModel>
  }

  export type BeneficiosCursosListRelationFilter = {
    every?: beneficiosCursosWhereInput
    some?: beneficiosCursosWhereInput
    none?: beneficiosCursosWhereInput
  }

  export type EdicionesCursosListRelationFilter = {
    every?: edicionesCursosWhereInput
    some?: edicionesCursosWhereInput
    none?: edicionesCursosWhereInput
  }

  export type ObjetivosCursosListRelationFilter = {
    every?: objetivosCursosWhereInput
    some?: objetivosCursosWhereInput
    none?: objetivosCursosWhereInput
  }

  export type RequisitosCursosListRelationFilter = {
    every?: requisitosCursosWhereInput
    some?: requisitosCursosWhereInput
    none?: requisitosCursosWhereInput
  }

  export type ReviewsCursosListRelationFilter = {
    every?: reviewsCursosWhereInput
    some?: reviewsCursosWhereInput
    none?: reviewsCursosWhereInput
  }

  export type beneficiosCursosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type edicionesCursosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type objetivosCursosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type requisitosCursosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reviewsCursosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type cursosCountOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    titulo?: SortOrder
    urlMiniatura?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    descripcionCorta?: SortOrder
    enVivo?: SortOrder
    urlCurso?: SortOrder
    cargaHoraria?: SortOrder
    codigo?: SortOrder
  }

  export type cursosAvgOrderByAggregateInput = {
    cargaHoraria?: SortOrder
  }

  export type cursosMaxOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    titulo?: SortOrder
    urlMiniatura?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    descripcionCorta?: SortOrder
    enVivo?: SortOrder
    urlCurso?: SortOrder
    cargaHoraria?: SortOrder
    codigo?: SortOrder
  }

  export type cursosMinOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    titulo?: SortOrder
    urlMiniatura?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    descripcionCorta?: SortOrder
    enVivo?: SortOrder
    urlCurso?: SortOrder
    cargaHoraria?: SortOrder
    codigo?: SortOrder
  }

  export type cursosSumOrderByAggregateInput = {
    cargaHoraria?: SortOrder
  }

  export type PagosDocentesListRelationFilter = {
    every?: pagosDocentesWhereInput
    some?: pagosDocentesWhereInput
    none?: pagosDocentesWhereInput
  }

  export type pagosDocentesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type docenteCountOrderByAggregateInput = {
    id?: SortOrder
    nombre_completo?: SortOrder
    celular?: SortOrder
    especialidad?: SortOrder
    experiencia?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    usuarioId?: SortOrder
    pais?: SortOrder
  }

  export type docenteAvgOrderByAggregateInput = {
    experiencia?: SortOrder
  }

  export type docenteMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre_completo?: SortOrder
    celular?: SortOrder
    especialidad?: SortOrder
    experiencia?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    usuarioId?: SortOrder
    pais?: SortOrder
  }

  export type docenteMinOrderByAggregateInput = {
    id?: SortOrder
    nombre_completo?: SortOrder
    celular?: SortOrder
    especialidad?: SortOrder
    experiencia?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    usuarioId?: SortOrder
    pais?: SortOrder
  }

  export type docenteSumOrderByAggregateInput = {
    experiencia?: SortOrder
  }

  export type EnumEdicionEstadoFilter<$PrismaModel = never> = {
    equals?: $Enums.EdicionEstado | EnumEdicionEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.EdicionEstado[] | ListEnumEdicionEstadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EdicionEstado[] | ListEnumEdicionEstadoFieldRefInput<$PrismaModel>
    not?: NestedEnumEdicionEstadoFilter<$PrismaModel> | $Enums.EdicionEstado
  }

  export type CertificadosListRelationFilter = {
    every?: certificadosWhereInput
    some?: certificadosWhereInput
    none?: certificadosWhereInput
  }

  export type ClasesListRelationFilter = {
    every?: clasesWhereInput
    some?: clasesWhereInput
    none?: clasesWhereInput
  }

  export type ComprasListRelationFilter = {
    every?: comprasWhereInput
    some?: comprasWhereInput
    none?: comprasWhereInput
  }

  export type DocenteNullableScalarRelationFilter = {
    is?: docenteWhereInput | null
    isNot?: docenteWhereInput | null
  }

  export type ExamenesListRelationFilter = {
    every?: examenesWhereInput
    some?: examenesWhereInput
    none?: examenesWhereInput
  }

  export type InscripcionesListRelationFilter = {
    every?: inscripcionesWhereInput
    some?: inscripcionesWhereInput
    none?: inscripcionesWhereInput
  }

  export type PagosDocentesNullableScalarRelationFilter = {
    is?: pagosDocentesWhereInput | null
    isNot?: pagosDocentesWhereInput | null
  }

  export type PreciosCursosListRelationFilter = {
    every?: preciosCursosWhereInput
    some?: preciosCursosWhereInput
    none?: preciosCursosWhereInput
  }

  export type certificadosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clasesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type comprasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type examenesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type inscripcionesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type preciosCursosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type edicionesCursosCursoIdCodigoDocenteIdCompoundUniqueInput = {
    cursoId: string
    codigo: string
    docenteId: string
  }

  export type edicionesCursosCountOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    estado?: SortOrder
    fechaFin?: SortOrder
    fechaInicio?: SortOrder
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
    urlWhatsapp?: SortOrder
    vigente?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    docenteId?: SortOrder
  }

  export type edicionesCursosAvgOrderByAggregateInput = {
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
  }

  export type edicionesCursosMaxOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    estado?: SortOrder
    fechaFin?: SortOrder
    fechaInicio?: SortOrder
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
    urlWhatsapp?: SortOrder
    vigente?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    docenteId?: SortOrder
  }

  export type edicionesCursosMinOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    estado?: SortOrder
    fechaFin?: SortOrder
    fechaInicio?: SortOrder
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
    urlWhatsapp?: SortOrder
    vigente?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    docenteId?: SortOrder
  }

  export type edicionesCursosSumOrderByAggregateInput = {
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
  }

  export type EnumEdicionEstadoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EdicionEstado | EnumEdicionEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.EdicionEstado[] | ListEnumEdicionEstadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EdicionEstado[] | ListEnumEdicionEstadoFieldRefInput<$PrismaModel>
    not?: NestedEnumEdicionEstadoWithAggregatesFilter<$PrismaModel> | $Enums.EdicionEstado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEdicionEstadoFilter<$PrismaModel>
    _max?: NestedEnumEdicionEstadoFilter<$PrismaModel>
  }

  export type EnumTipoGeneroFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoGenero | EnumTipoGeneroFieldRefInput<$PrismaModel>
    in?: $Enums.TipoGenero[] | ListEnumTipoGeneroFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoGenero[] | ListEnumTipoGeneroFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoGeneroFilter<$PrismaModel> | $Enums.TipoGenero
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CalificacionesListRelationFilter = {
    every?: calificacionesWhereInput
    some?: calificacionesWhereInput
    none?: calificacionesWhereInput
  }

  export type calificacionesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type estudiantesCountOrderByAggregateInput = {
    id?: SortOrder
    apellido?: SortOrder
    celular?: SortOrder
    pais?: SortOrder
    genero?: SortOrder
    fechaNacimiento?: SortOrder
    nombre?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    nroUpdates?: SortOrder
  }

  export type estudiantesAvgOrderByAggregateInput = {
    nroUpdates?: SortOrder
  }

  export type estudiantesMaxOrderByAggregateInput = {
    id?: SortOrder
    apellido?: SortOrder
    celular?: SortOrder
    pais?: SortOrder
    genero?: SortOrder
    fechaNacimiento?: SortOrder
    nombre?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    nroUpdates?: SortOrder
  }

  export type estudiantesMinOrderByAggregateInput = {
    id?: SortOrder
    apellido?: SortOrder
    celular?: SortOrder
    pais?: SortOrder
    genero?: SortOrder
    fechaNacimiento?: SortOrder
    nombre?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    nroUpdates?: SortOrder
  }

  export type estudiantesSumOrderByAggregateInput = {
    nroUpdates?: SortOrder
  }

  export type EnumTipoGeneroWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoGenero | EnumTipoGeneroFieldRefInput<$PrismaModel>
    in?: $Enums.TipoGenero[] | ListEnumTipoGeneroFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoGenero[] | ListEnumTipoGeneroFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoGeneroWithAggregatesFilter<$PrismaModel> | $Enums.TipoGenero
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoGeneroFilter<$PrismaModel>
    _max?: NestedEnumTipoGeneroFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type CapitulosNullableScalarRelationFilter = {
    is?: capitulosWhereInput | null
    isNot?: capitulosWhereInput | null
  }

  export type PreguntasListRelationFilter = {
    every?: preguntasWhereInput
    some?: preguntasWhereInput
    none?: preguntasWhereInput
  }

  export type preguntasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type temasCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    capituloId?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type temasMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    capituloId?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type temasMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    capituloId?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type examenesCountOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    descripcion?: SortOrder
    fechaDisponible?: SortOrder
    fechaLimite?: SortOrder
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
    titulo?: SortOrder
    creadoEn?: SortOrder
  }

  export type examenesAvgOrderByAggregateInput = {
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
  }

  export type examenesMaxOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    descripcion?: SortOrder
    fechaDisponible?: SortOrder
    fechaLimite?: SortOrder
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
    titulo?: SortOrder
    creadoEn?: SortOrder
  }

  export type examenesMinOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    descripcion?: SortOrder
    fechaDisponible?: SortOrder
    fechaLimite?: SortOrder
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
    titulo?: SortOrder
    creadoEn?: SortOrder
  }

  export type examenesSumOrderByAggregateInput = {
    notaMaxima?: SortOrder
    notaMinima?: SortOrder
  }

  export type ClasesScalarRelationFilter = {
    is?: clasesWhereInput
    isNot?: clasesWhereInput
  }

  export type grabacionesCountOrderByAggregateInput = {
    id?: SortOrder
    claseId?: SortOrder
    usuarioId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    duracionSegundos?: SortOrder
    completada?: SortOrder
  }

  export type grabacionesAvgOrderByAggregateInput = {
    duracionSegundos?: SortOrder
  }

  export type grabacionesMaxOrderByAggregateInput = {
    id?: SortOrder
    claseId?: SortOrder
    usuarioId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    duracionSegundos?: SortOrder
    completada?: SortOrder
  }

  export type grabacionesMinOrderByAggregateInput = {
    id?: SortOrder
    claseId?: SortOrder
    usuarioId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    duracionSegundos?: SortOrder
    completada?: SortOrder
  }

  export type grabacionesSumOrderByAggregateInput = {
    duracionSegundos?: SortOrder
  }

  export type ComprasScalarRelationFilter = {
    is?: comprasWhereInput
    isNot?: comprasWhereInput
  }

  export type inscripcionesEstudianteIdEdicionIdCompoundUniqueInput = {
    estudianteId: string
    edicionId: string
  }

  export type inscripcionesCountOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    estado?: SortOrder
    estudianteId?: SortOrder
    inscritoEn?: SortOrder
    compraId?: SortOrder
  }

  export type inscripcionesMaxOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    estado?: SortOrder
    estudianteId?: SortOrder
    inscritoEn?: SortOrder
    compraId?: SortOrder
  }

  export type inscripcionesMinOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    estado?: SortOrder
    estudianteId?: SortOrder
    inscritoEn?: SortOrder
    compraId?: SortOrder
  }

  export type EnumTipoMaterialFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoMaterial | EnumTipoMaterialFieldRefInput<$PrismaModel>
    in?: $Enums.TipoMaterial[] | ListEnumTipoMaterialFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoMaterial[] | ListEnumTipoMaterialFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoMaterialFilter<$PrismaModel> | $Enums.TipoMaterial
  }

  export type materialesCountOrderByAggregateInput = {
    id?: SortOrder
    claseId?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    url?: SortOrder
    creadoEn?: SortOrder
  }

  export type materialesMaxOrderByAggregateInput = {
    id?: SortOrder
    claseId?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    url?: SortOrder
    creadoEn?: SortOrder
  }

  export type materialesMinOrderByAggregateInput = {
    id?: SortOrder
    claseId?: SortOrder
    tipo?: SortOrder
    titulo?: SortOrder
    url?: SortOrder
    creadoEn?: SortOrder
  }

  export type EnumTipoMaterialWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoMaterial | EnumTipoMaterialFieldRefInput<$PrismaModel>
    in?: $Enums.TipoMaterial[] | ListEnumTipoMaterialFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoMaterial[] | ListEnumTipoMaterialFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoMaterialWithAggregatesFilter<$PrismaModel> | $Enums.TipoMaterial
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoMaterialFilter<$PrismaModel>
    _max?: NestedEnumTipoMaterialFilter<$PrismaModel>
  }

  export type objetivosCursosCountOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
  }

  export type objetivosCursosAvgOrderByAggregateInput = {
    orden?: SortOrder
  }

  export type objetivosCursosMaxOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
  }

  export type objetivosCursosMinOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
  }

  export type objetivosCursosSumOrderByAggregateInput = {
    orden?: SortOrder
  }

  export type DocenteScalarRelationFilter = {
    is?: docenteWhereInput
    isNot?: docenteWhereInput
  }

  export type pagosDocentesCountOrderByAggregateInput = {
    id?: SortOrder
    docenteId?: SortOrder
    edicionId?: SortOrder
    monto?: SortOrder
    deuda?: SortOrder
    estadoPago?: SortOrder
    fechaPago?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type pagosDocentesAvgOrderByAggregateInput = {
    monto?: SortOrder
    deuda?: SortOrder
  }

  export type pagosDocentesMaxOrderByAggregateInput = {
    id?: SortOrder
    docenteId?: SortOrder
    edicionId?: SortOrder
    monto?: SortOrder
    deuda?: SortOrder
    estadoPago?: SortOrder
    fechaPago?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type pagosDocentesMinOrderByAggregateInput = {
    id?: SortOrder
    docenteId?: SortOrder
    edicionId?: SortOrder
    monto?: SortOrder
    deuda?: SortOrder
    estadoPago?: SortOrder
    fechaPago?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type pagosDocentesSumOrderByAggregateInput = {
    monto?: SortOrder
    deuda?: SortOrder
  }

  export type preciosCursosCountOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    esDescuento?: SortOrder
    esPrecioDefault?: SortOrder
    moneda?: SortOrder
    nombre?: SortOrder
    porcentajeDescuento?: SortOrder
    precio?: SortOrder
    precioOriginal?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type preciosCursosAvgOrderByAggregateInput = {
    porcentajeDescuento?: SortOrder
    precio?: SortOrder
    precioOriginal?: SortOrder
  }

  export type preciosCursosMaxOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    esDescuento?: SortOrder
    esPrecioDefault?: SortOrder
    moneda?: SortOrder
    nombre?: SortOrder
    porcentajeDescuento?: SortOrder
    precio?: SortOrder
    precioOriginal?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type preciosCursosMinOrderByAggregateInput = {
    id?: SortOrder
    edicionId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    esDescuento?: SortOrder
    esPrecioDefault?: SortOrder
    moneda?: SortOrder
    nombre?: SortOrder
    porcentajeDescuento?: SortOrder
    precio?: SortOrder
    precioOriginal?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type preciosCursosSumOrderByAggregateInput = {
    porcentajeDescuento?: SortOrder
    precio?: SortOrder
    precioOriginal?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumPreguntaEstadoFilter<$PrismaModel = never> = {
    equals?: $Enums.PreguntaEstado | EnumPreguntaEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.PreguntaEstado[] | ListEnumPreguntaEstadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.PreguntaEstado[] | ListEnumPreguntaEstadoFieldRefInput<$PrismaModel>
    not?: NestedEnumPreguntaEstadoFilter<$PrismaModel> | $Enums.PreguntaEstado
  }

  export type EnumPreguntaDificultadFilter<$PrismaModel = never> = {
    equals?: $Enums.PreguntaDificultad | EnumPreguntaDificultadFieldRefInput<$PrismaModel>
    in?: $Enums.PreguntaDificultad[] | ListEnumPreguntaDificultadFieldRefInput<$PrismaModel>
    notIn?: $Enums.PreguntaDificultad[] | ListEnumPreguntaDificultadFieldRefInput<$PrismaModel>
    not?: NestedEnumPreguntaDificultadFilter<$PrismaModel> | $Enums.PreguntaDificultad
  }

  export type ReaccionesPreguntasListRelationFilter = {
    every?: reaccionesPreguntasWhereInput
    some?: reaccionesPreguntasWhereInput
    none?: reaccionesPreguntasWhereInput
  }

  export type RepasoRegistrosListRelationFilter = {
    every?: repasoRegistrosWhereInput
    some?: repasoRegistrosWhereInput
    none?: repasoRegistrosWhereInput
  }

  export type RespuestasIntentosListRelationFilter = {
    every?: respuestasIntentosWhereInput
    some?: respuestasIntentosWhereInput
    none?: respuestasIntentosWhereInput
  }

  export type AreasListRelationFilter = {
    every?: areasWhereInput
    some?: areasWhereInput
    none?: areasWhereInput
  }

  export type BanqueoListRelationFilter = {
    every?: banqueoWhereInput
    some?: banqueoWhereInput
    none?: banqueoWhereInput
  }

  export type CapitulosListRelationFilter = {
    every?: capitulosWhereInput
    some?: capitulosWhereInput
    none?: capitulosWhereInput
  }

  export type TemasListRelationFilter = {
    every?: temasWhereInput
    some?: temasWhereInput
    none?: temasWhereInput
  }

  export type reaccionesPreguntasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type repasoRegistrosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type respuestasIntentosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type areasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type banqueoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type capitulosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type temasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type preguntasCountOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    enunciado?: SortOrder
    explicacion?: SortOrder
    referencia?: SortOrder
    opciones?: SortOrder
    solucion?: SortOrder
    estado?: SortOrder
    gestion?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    dificultad?: SortOrder
    dificultadActualizadaEn?: SortOrder
    tasaAcierto?: SortOrder
    totalBien?: SortOrder
    totalMal?: SortOrder
    totalRespondidas?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type preguntasAvgOrderByAggregateInput = {
    gestion?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    tasaAcierto?: SortOrder
    totalBien?: SortOrder
    totalMal?: SortOrder
    totalRespondidas?: SortOrder
  }

  export type preguntasMaxOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    enunciado?: SortOrder
    explicacion?: SortOrder
    referencia?: SortOrder
    estado?: SortOrder
    gestion?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    dificultad?: SortOrder
    dificultadActualizadaEn?: SortOrder
    tasaAcierto?: SortOrder
    totalBien?: SortOrder
    totalMal?: SortOrder
    totalRespondidas?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type preguntasMinOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    enunciado?: SortOrder
    explicacion?: SortOrder
    referencia?: SortOrder
    estado?: SortOrder
    gestion?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    dificultad?: SortOrder
    dificultadActualizadaEn?: SortOrder
    tasaAcierto?: SortOrder
    totalBien?: SortOrder
    totalMal?: SortOrder
    totalRespondidas?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type preguntasSumOrderByAggregateInput = {
    gestion?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    tasaAcierto?: SortOrder
    totalBien?: SortOrder
    totalMal?: SortOrder
    totalRespondidas?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumPreguntaEstadoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PreguntaEstado | EnumPreguntaEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.PreguntaEstado[] | ListEnumPreguntaEstadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.PreguntaEstado[] | ListEnumPreguntaEstadoFieldRefInput<$PrismaModel>
    not?: NestedEnumPreguntaEstadoWithAggregatesFilter<$PrismaModel> | $Enums.PreguntaEstado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPreguntaEstadoFilter<$PrismaModel>
    _max?: NestedEnumPreguntaEstadoFilter<$PrismaModel>
  }

  export type EnumPreguntaDificultadWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PreguntaDificultad | EnumPreguntaDificultadFieldRefInput<$PrismaModel>
    in?: $Enums.PreguntaDificultad[] | ListEnumPreguntaDificultadFieldRefInput<$PrismaModel>
    notIn?: $Enums.PreguntaDificultad[] | ListEnumPreguntaDificultadFieldRefInput<$PrismaModel>
    not?: NestedEnumPreguntaDificultadWithAggregatesFilter<$PrismaModel> | $Enums.PreguntaDificultad
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPreguntaDificultadFilter<$PrismaModel>
    _max?: NestedEnumPreguntaDificultadFilter<$PrismaModel>
  }

  export type EnumTipoReaccionFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoReaccion | EnumTipoReaccionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoReaccion[] | ListEnumTipoReaccionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoReaccion[] | ListEnumTipoReaccionFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoReaccionFilter<$PrismaModel> | $Enums.TipoReaccion
  }

  export type PreguntasScalarRelationFilter = {
    is?: preguntasWhereInput
    isNot?: preguntasWhereInput
  }

  export type UsuariosEstudiantesScalarRelationFilter = {
    is?: usuariosEstudiantesWhereInput
    isNot?: usuariosEstudiantesWhereInput
  }

  export type reaccionesPreguntasPreguntaIdUsuarioEstudianteIdCompoundUniqueInput = {
    preguntaId: string
    usuarioEstudianteId: string
  }

  export type reaccionesPreguntasCountOrderByAggregateInput = {
    id?: SortOrder
    preguntaId?: SortOrder
    usuarioEstudianteId?: SortOrder
    tipo?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type reaccionesPreguntasMaxOrderByAggregateInput = {
    id?: SortOrder
    preguntaId?: SortOrder
    usuarioEstudianteId?: SortOrder
    tipo?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type reaccionesPreguntasMinOrderByAggregateInput = {
    id?: SortOrder
    preguntaId?: SortOrder
    usuarioEstudianteId?: SortOrder
    tipo?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type EnumTipoReaccionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoReaccion | EnumTipoReaccionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoReaccion[] | ListEnumTipoReaccionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoReaccion[] | ListEnumTipoReaccionFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoReaccionWithAggregatesFilter<$PrismaModel> | $Enums.TipoReaccion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoReaccionFilter<$PrismaModel>
    _max?: NestedEnumTipoReaccionFilter<$PrismaModel>
  }

  export type requisitosCursosCountOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
  }

  export type requisitosCursosAvgOrderByAggregateInput = {
    orden?: SortOrder
  }

  export type requisitosCursosMaxOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
  }

  export type requisitosCursosMinOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    descripcion?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
  }

  export type requisitosCursosSumOrderByAggregateInput = {
    orden?: SortOrder
  }

  export type reviewsCursosCountOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    rating?: SortOrder
    comentario?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    usuariosEstudiantesId?: SortOrder
  }

  export type reviewsCursosAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type reviewsCursosMaxOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    rating?: SortOrder
    comentario?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    usuariosEstudiantesId?: SortOrder
  }

  export type reviewsCursosMinOrderByAggregateInput = {
    id?: SortOrder
    cursoId?: SortOrder
    rating?: SortOrder
    comentario?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    usuariosEstudiantesId?: SortOrder
  }

  export type reviewsCursosSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type EnumTipoCuentaFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoCuenta | EnumTipoCuentaFieldRefInput<$PrismaModel>
    in?: $Enums.TipoCuenta[] | ListEnumTipoCuentaFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoCuenta[] | ListEnumTipoCuentaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoCuentaFilter<$PrismaModel> | $Enums.TipoCuenta
  }

  export type AuditoriaListRelationFilter = {
    every?: auditoriaWhereInput
    some?: auditoriaWhereInput
    none?: auditoriaWhereInput
  }

  export type auditoriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usuariosAdministradoresCountOrderByAggregateInput = {
    id?: SortOrder
    correo?: SortOrder
    contrasena?: SortOrder
    encargado?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    tipo?: SortOrder
  }

  export type usuariosAdministradoresMaxOrderByAggregateInput = {
    id?: SortOrder
    correo?: SortOrder
    contrasena?: SortOrder
    encargado?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    tipo?: SortOrder
  }

  export type usuariosAdministradoresMinOrderByAggregateInput = {
    id?: SortOrder
    correo?: SortOrder
    contrasena?: SortOrder
    encargado?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    tipo?: SortOrder
  }

  export type EnumTipoCuentaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoCuenta | EnumTipoCuentaFieldRefInput<$PrismaModel>
    in?: $Enums.TipoCuenta[] | ListEnumTipoCuentaFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoCuenta[] | ListEnumTipoCuentaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoCuentaWithAggregatesFilter<$PrismaModel> | $Enums.TipoCuenta
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoCuentaFilter<$PrismaModel>
    _max?: NestedEnumTipoCuentaFilter<$PrismaModel>
  }

  export type IntentosListRelationFilter = {
    every?: intentosWhereInput
    some?: intentosWhereInput
    none?: intentosWhereInput
  }

  export type SuscripcionesListRelationFilter = {
    every?: suscripcionesWhereInput
    some?: suscripcionesWhereInput
    none?: suscripcionesWhereInput
  }

  export type EstudiantesNullableScalarRelationFilter = {
    is?: estudiantesWhereInput | null
    isNot?: estudiantesWhereInput | null
  }

  export type intentosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type suscripcionesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usuariosEstudiantesCountOrderByAggregateInput = {
    id?: SortOrder
    correo?: SortOrder
    contrasena?: SortOrder
    usuario?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    avatar?: SortOrder
    estudianteId?: SortOrder
    registrado?: SortOrder
  }

  export type usuariosEstudiantesMaxOrderByAggregateInput = {
    id?: SortOrder
    correo?: SortOrder
    contrasena?: SortOrder
    usuario?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    avatar?: SortOrder
    estudianteId?: SortOrder
    registrado?: SortOrder
  }

  export type usuariosEstudiantesMinOrderByAggregateInput = {
    id?: SortOrder
    correo?: SortOrder
    contrasena?: SortOrder
    usuario?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    avatar?: SortOrder
    estudianteId?: SortOrder
    registrado?: SortOrder
  }

  export type areasCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type areasMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type areasMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type EnumBanqueoTipoFilter<$PrismaModel = never> = {
    equals?: $Enums.BanqueoTipo | EnumBanqueoTipoFieldRefInput<$PrismaModel>
    in?: $Enums.BanqueoTipo[] | ListEnumBanqueoTipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.BanqueoTipo[] | ListEnumBanqueoTipoFieldRefInput<$PrismaModel>
    not?: NestedEnumBanqueoTipoFilter<$PrismaModel> | $Enums.BanqueoTipo
  }

  export type EnumBanqueoTipoCreadoFilter<$PrismaModel = never> = {
    equals?: $Enums.BanqueoTipoCreado | EnumBanqueoTipoCreadoFieldRefInput<$PrismaModel>
    in?: $Enums.BanqueoTipoCreado[] | ListEnumBanqueoTipoCreadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.BanqueoTipoCreado[] | ListEnumBanqueoTipoCreadoFieldRefInput<$PrismaModel>
    not?: NestedEnumBanqueoTipoCreadoFilter<$PrismaModel> | $Enums.BanqueoTipoCreado
  }

  export type banqueoCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    tipo?: SortOrder
    tipoCreado?: SortOrder
    duracion?: SortOrder
    maxPreguntas?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type banqueoAvgOrderByAggregateInput = {
    duracion?: SortOrder
    maxPreguntas?: SortOrder
  }

  export type banqueoMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    tipo?: SortOrder
    tipoCreado?: SortOrder
    duracion?: SortOrder
    maxPreguntas?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type banqueoMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    tipo?: SortOrder
    tipoCreado?: SortOrder
    duracion?: SortOrder
    maxPreguntas?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type banqueoSumOrderByAggregateInput = {
    duracion?: SortOrder
    maxPreguntas?: SortOrder
  }

  export type EnumBanqueoTipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BanqueoTipo | EnumBanqueoTipoFieldRefInput<$PrismaModel>
    in?: $Enums.BanqueoTipo[] | ListEnumBanqueoTipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.BanqueoTipo[] | ListEnumBanqueoTipoFieldRefInput<$PrismaModel>
    not?: NestedEnumBanqueoTipoWithAggregatesFilter<$PrismaModel> | $Enums.BanqueoTipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBanqueoTipoFilter<$PrismaModel>
    _max?: NestedEnumBanqueoTipoFilter<$PrismaModel>
  }

  export type EnumBanqueoTipoCreadoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BanqueoTipoCreado | EnumBanqueoTipoCreadoFieldRefInput<$PrismaModel>
    in?: $Enums.BanqueoTipoCreado[] | ListEnumBanqueoTipoCreadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.BanqueoTipoCreado[] | ListEnumBanqueoTipoCreadoFieldRefInput<$PrismaModel>
    not?: NestedEnumBanqueoTipoCreadoWithAggregatesFilter<$PrismaModel> | $Enums.BanqueoTipoCreado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBanqueoTipoCreadoFilter<$PrismaModel>
    _max?: NestedEnumBanqueoTipoCreadoFilter<$PrismaModel>
  }

  export type AreasNullableScalarRelationFilter = {
    is?: areasWhereInput | null
    isNot?: areasWhereInput | null
  }

  export type capitulosCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    areaId?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type capitulosMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    areaId?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type capitulosMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    areaId?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type EnumEstadoIntentoFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoIntento | EnumEstadoIntentoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoIntento[] | ListEnumEstadoIntentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoIntento[] | ListEnumEstadoIntentoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoIntentoFilter<$PrismaModel> | $Enums.EstadoIntento
  }

  export type BanqueoScalarRelationFilter = {
    is?: banqueoWhereInput
    isNot?: banqueoWhereInput
  }

  export type intentosCountOrderByAggregateInput = {
    id?: SortOrder
    banqueoId?: SortOrder
    usuarioEstudianteId?: SortOrder
    tiempoDuracion?: SortOrder
    correctas?: SortOrder
    incorrectas?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    estado?: SortOrder
  }

  export type intentosAvgOrderByAggregateInput = {
    tiempoDuracion?: SortOrder
    correctas?: SortOrder
    incorrectas?: SortOrder
  }

  export type intentosMaxOrderByAggregateInput = {
    id?: SortOrder
    banqueoId?: SortOrder
    usuarioEstudianteId?: SortOrder
    tiempoDuracion?: SortOrder
    correctas?: SortOrder
    incorrectas?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    estado?: SortOrder
  }

  export type intentosMinOrderByAggregateInput = {
    id?: SortOrder
    banqueoId?: SortOrder
    usuarioEstudianteId?: SortOrder
    tiempoDuracion?: SortOrder
    correctas?: SortOrder
    incorrectas?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    estado?: SortOrder
  }

  export type intentosSumOrderByAggregateInput = {
    tiempoDuracion?: SortOrder
    correctas?: SortOrder
    incorrectas?: SortOrder
  }

  export type EnumEstadoIntentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoIntento | EnumEstadoIntentoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoIntento[] | ListEnumEstadoIntentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoIntento[] | ListEnumEstadoIntentoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoIntentoWithAggregatesFilter<$PrismaModel> | $Enums.EstadoIntento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoIntentoFilter<$PrismaModel>
    _max?: NestedEnumEstadoIntentoFilter<$PrismaModel>
  }

  export type EnumResultadoRespuestaFilter<$PrismaModel = never> = {
    equals?: $Enums.ResultadoRespuesta | EnumResultadoRespuestaFieldRefInput<$PrismaModel>
    in?: $Enums.ResultadoRespuesta[] | ListEnumResultadoRespuestaFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResultadoRespuesta[] | ListEnumResultadoRespuestaFieldRefInput<$PrismaModel>
    not?: NestedEnumResultadoRespuestaFilter<$PrismaModel> | $Enums.ResultadoRespuesta
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type IntentosScalarRelationFilter = {
    is?: intentosWhereInput
    isNot?: intentosWhereInput
  }

  export type respuestasIntentosIntentoIdPreguntaIdCompoundUniqueInput = {
    intentoId: string
    preguntaId: string
  }

  export type respuestasIntentosCountOrderByAggregateInput = {
    id?: SortOrder
    intentoId?: SortOrder
    preguntaId?: SortOrder
    respuesta?: SortOrder
    resultado?: SortOrder
    esCorrecta?: SortOrder
    respondida?: SortOrder
    visitada?: SortOrder
    marcadaRevision?: SortOrder
    tiempoConsumidoSeg?: SortOrder
    orden?: SortOrder
    respondidaEn?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type respuestasIntentosAvgOrderByAggregateInput = {
    tiempoConsumidoSeg?: SortOrder
    orden?: SortOrder
  }

  export type respuestasIntentosMaxOrderByAggregateInput = {
    id?: SortOrder
    intentoId?: SortOrder
    preguntaId?: SortOrder
    resultado?: SortOrder
    esCorrecta?: SortOrder
    respondida?: SortOrder
    visitada?: SortOrder
    marcadaRevision?: SortOrder
    tiempoConsumidoSeg?: SortOrder
    orden?: SortOrder
    respondidaEn?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type respuestasIntentosMinOrderByAggregateInput = {
    id?: SortOrder
    intentoId?: SortOrder
    preguntaId?: SortOrder
    resultado?: SortOrder
    esCorrecta?: SortOrder
    respondida?: SortOrder
    visitada?: SortOrder
    marcadaRevision?: SortOrder
    tiempoConsumidoSeg?: SortOrder
    orden?: SortOrder
    respondidaEn?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type respuestasIntentosSumOrderByAggregateInput = {
    tiempoConsumidoSeg?: SortOrder
    orden?: SortOrder
  }

  export type EnumResultadoRespuestaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResultadoRespuesta | EnumResultadoRespuestaFieldRefInput<$PrismaModel>
    in?: $Enums.ResultadoRespuesta[] | ListEnumResultadoRespuestaFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResultadoRespuesta[] | ListEnumResultadoRespuestaFieldRefInput<$PrismaModel>
    not?: NestedEnumResultadoRespuestaWithAggregatesFilter<$PrismaModel> | $Enums.ResultadoRespuesta
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResultadoRespuestaFilter<$PrismaModel>
    _max?: NestedEnumResultadoRespuestaFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type repasoRegistrosCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioEstudianteId?: SortOrder
    banqueoId?: SortOrder
    preguntaId?: SortOrder
    esCorrecta?: SortOrder
    creadoEn?: SortOrder
  }

  export type repasoRegistrosMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioEstudianteId?: SortOrder
    banqueoId?: SortOrder
    preguntaId?: SortOrder
    esCorrecta?: SortOrder
    creadoEn?: SortOrder
  }

  export type repasoRegistrosMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioEstudianteId?: SortOrder
    banqueoId?: SortOrder
    preguntaId?: SortOrder
    esCorrecta?: SortOrder
    creadoEn?: SortOrder
  }

  export type EnumEstadoSuscripcionFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoSuscripcion | EnumEstadoSuscripcionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoSuscripcion[] | ListEnumEstadoSuscripcionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoSuscripcion[] | ListEnumEstadoSuscripcionFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoSuscripcionFilter<$PrismaModel> | $Enums.EstadoSuscripcion
  }

  export type suscripcionesCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioEstudianteId?: SortOrder
    montoUsd?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type suscripcionesAvgOrderByAggregateInput = {
    montoUsd?: SortOrder
  }

  export type suscripcionesMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioEstudianteId?: SortOrder
    montoUsd?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type suscripcionesMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioEstudianteId?: SortOrder
    montoUsd?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    estado?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type suscripcionesSumOrderByAggregateInput = {
    montoUsd?: SortOrder
  }

  export type EnumEstadoSuscripcionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoSuscripcion | EnumEstadoSuscripcionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoSuscripcion[] | ListEnumEstadoSuscripcionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoSuscripcion[] | ListEnumEstadoSuscripcionFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoSuscripcionWithAggregatesFilter<$PrismaModel> | $Enums.EstadoSuscripcion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoSuscripcionFilter<$PrismaModel>
    _max?: NestedEnumEstadoSuscripcionFilter<$PrismaModel>
  }

  export type usuariosAdministradoresCreateNestedOneWithoutAuditoriaInput = {
    create?: XOR<usuariosAdministradoresCreateWithoutAuditoriaInput, usuariosAdministradoresUncheckedCreateWithoutAuditoriaInput>
    connectOrCreate?: usuariosAdministradoresCreateOrConnectWithoutAuditoriaInput
    connect?: usuariosAdministradoresWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumTablaFieldUpdateOperationsInput = {
    set?: $Enums.Tabla
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumAccionAuditoriaFieldUpdateOperationsInput = {
    set?: $Enums.AccionAuditoria
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type usuariosAdministradoresUpdateOneRequiredWithoutAuditoriaNestedInput = {
    create?: XOR<usuariosAdministradoresCreateWithoutAuditoriaInput, usuariosAdministradoresUncheckedCreateWithoutAuditoriaInput>
    connectOrCreate?: usuariosAdministradoresCreateOrConnectWithoutAuditoriaInput
    upsert?: usuariosAdministradoresUpsertWithoutAuditoriaInput
    connect?: usuariosAdministradoresWhereUniqueInput
    update?: XOR<XOR<usuariosAdministradoresUpdateToOneWithWhereWithoutAuditoriaInput, usuariosAdministradoresUpdateWithoutAuditoriaInput>, usuariosAdministradoresUncheckedUpdateWithoutAuditoriaInput>
  }

  export type cursosCreateNestedOneWithoutBeneficiosCursosInput = {
    create?: XOR<cursosCreateWithoutBeneficiosCursosInput, cursosUncheckedCreateWithoutBeneficiosCursosInput>
    connectOrCreate?: cursosCreateOrConnectWithoutBeneficiosCursosInput
    connect?: cursosWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type cursosUpdateOneRequiredWithoutBeneficiosCursosNestedInput = {
    create?: XOR<cursosCreateWithoutBeneficiosCursosInput, cursosUncheckedCreateWithoutBeneficiosCursosInput>
    connectOrCreate?: cursosCreateOrConnectWithoutBeneficiosCursosInput
    upsert?: cursosUpsertWithoutBeneficiosCursosInput
    connect?: cursosWhereUniqueInput
    update?: XOR<XOR<cursosUpdateToOneWithWhereWithoutBeneficiosCursosInput, cursosUpdateWithoutBeneficiosCursosInput>, cursosUncheckedUpdateWithoutBeneficiosCursosInput>
  }

  export type estudiantesCreateNestedOneWithoutCalificacionesInput = {
    create?: XOR<estudiantesCreateWithoutCalificacionesInput, estudiantesUncheckedCreateWithoutCalificacionesInput>
    connectOrCreate?: estudiantesCreateOrConnectWithoutCalificacionesInput
    connect?: estudiantesWhereUniqueInput
  }

  export type examenesCreateNestedOneWithoutCalificacionesInput = {
    create?: XOR<examenesCreateWithoutCalificacionesInput, examenesUncheckedCreateWithoutCalificacionesInput>
    connectOrCreate?: examenesCreateOrConnectWithoutCalificacionesInput
    connect?: examenesWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type estudiantesUpdateOneRequiredWithoutCalificacionesNestedInput = {
    create?: XOR<estudiantesCreateWithoutCalificacionesInput, estudiantesUncheckedCreateWithoutCalificacionesInput>
    connectOrCreate?: estudiantesCreateOrConnectWithoutCalificacionesInput
    upsert?: estudiantesUpsertWithoutCalificacionesInput
    connect?: estudiantesWhereUniqueInput
    update?: XOR<XOR<estudiantesUpdateToOneWithWhereWithoutCalificacionesInput, estudiantesUpdateWithoutCalificacionesInput>, estudiantesUncheckedUpdateWithoutCalificacionesInput>
  }

  export type examenesUpdateOneRequiredWithoutCalificacionesNestedInput = {
    create?: XOR<examenesCreateWithoutCalificacionesInput, examenesUncheckedCreateWithoutCalificacionesInput>
    connectOrCreate?: examenesCreateOrConnectWithoutCalificacionesInput
    upsert?: examenesUpsertWithoutCalificacionesInput
    connect?: examenesWhereUniqueInput
    update?: XOR<XOR<examenesUpdateToOneWithWhereWithoutCalificacionesInput, examenesUpdateWithoutCalificacionesInput>, examenesUncheckedUpdateWithoutCalificacionesInput>
  }

  export type categoriasCursosCreateNestedManyWithoutCategoriasInput = {
    create?: XOR<categoriasCursosCreateWithoutCategoriasInput, categoriasCursosUncheckedCreateWithoutCategoriasInput> | categoriasCursosCreateWithoutCategoriasInput[] | categoriasCursosUncheckedCreateWithoutCategoriasInput[]
    connectOrCreate?: categoriasCursosCreateOrConnectWithoutCategoriasInput | categoriasCursosCreateOrConnectWithoutCategoriasInput[]
    createMany?: categoriasCursosCreateManyCategoriasInputEnvelope
    connect?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
  }

  export type categoriasCursosUncheckedCreateNestedManyWithoutCategoriasInput = {
    create?: XOR<categoriasCursosCreateWithoutCategoriasInput, categoriasCursosUncheckedCreateWithoutCategoriasInput> | categoriasCursosCreateWithoutCategoriasInput[] | categoriasCursosUncheckedCreateWithoutCategoriasInput[]
    connectOrCreate?: categoriasCursosCreateOrConnectWithoutCategoriasInput | categoriasCursosCreateOrConnectWithoutCategoriasInput[]
    createMany?: categoriasCursosCreateManyCategoriasInputEnvelope
    connect?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
  }

  export type categoriasCursosUpdateManyWithoutCategoriasNestedInput = {
    create?: XOR<categoriasCursosCreateWithoutCategoriasInput, categoriasCursosUncheckedCreateWithoutCategoriasInput> | categoriasCursosCreateWithoutCategoriasInput[] | categoriasCursosUncheckedCreateWithoutCategoriasInput[]
    connectOrCreate?: categoriasCursosCreateOrConnectWithoutCategoriasInput | categoriasCursosCreateOrConnectWithoutCategoriasInput[]
    upsert?: categoriasCursosUpsertWithWhereUniqueWithoutCategoriasInput | categoriasCursosUpsertWithWhereUniqueWithoutCategoriasInput[]
    createMany?: categoriasCursosCreateManyCategoriasInputEnvelope
    set?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    disconnect?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    delete?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    connect?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    update?: categoriasCursosUpdateWithWhereUniqueWithoutCategoriasInput | categoriasCursosUpdateWithWhereUniqueWithoutCategoriasInput[]
    updateMany?: categoriasCursosUpdateManyWithWhereWithoutCategoriasInput | categoriasCursosUpdateManyWithWhereWithoutCategoriasInput[]
    deleteMany?: categoriasCursosScalarWhereInput | categoriasCursosScalarWhereInput[]
  }

  export type categoriasCursosUncheckedUpdateManyWithoutCategoriasNestedInput = {
    create?: XOR<categoriasCursosCreateWithoutCategoriasInput, categoriasCursosUncheckedCreateWithoutCategoriasInput> | categoriasCursosCreateWithoutCategoriasInput[] | categoriasCursosUncheckedCreateWithoutCategoriasInput[]
    connectOrCreate?: categoriasCursosCreateOrConnectWithoutCategoriasInput | categoriasCursosCreateOrConnectWithoutCategoriasInput[]
    upsert?: categoriasCursosUpsertWithWhereUniqueWithoutCategoriasInput | categoriasCursosUpsertWithWhereUniqueWithoutCategoriasInput[]
    createMany?: categoriasCursosCreateManyCategoriasInputEnvelope
    set?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    disconnect?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    delete?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    connect?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    update?: categoriasCursosUpdateWithWhereUniqueWithoutCategoriasInput | categoriasCursosUpdateWithWhereUniqueWithoutCategoriasInput[]
    updateMany?: categoriasCursosUpdateManyWithWhereWithoutCategoriasInput | categoriasCursosUpdateManyWithWhereWithoutCategoriasInput[]
    deleteMany?: categoriasCursosScalarWhereInput | categoriasCursosScalarWhereInput[]
  }

  export type categoriasCreateNestedOneWithoutCategoriasCursosInput = {
    create?: XOR<categoriasCreateWithoutCategoriasCursosInput, categoriasUncheckedCreateWithoutCategoriasCursosInput>
    connectOrCreate?: categoriasCreateOrConnectWithoutCategoriasCursosInput
    connect?: categoriasWhereUniqueInput
  }

  export type cursosCreateNestedOneWithoutCategoriasCursosInput = {
    create?: XOR<cursosCreateWithoutCategoriasCursosInput, cursosUncheckedCreateWithoutCategoriasCursosInput>
    connectOrCreate?: cursosCreateOrConnectWithoutCategoriasCursosInput
    connect?: cursosWhereUniqueInput
  }

  export type categoriasUpdateOneRequiredWithoutCategoriasCursosNestedInput = {
    create?: XOR<categoriasCreateWithoutCategoriasCursosInput, categoriasUncheckedCreateWithoutCategoriasCursosInput>
    connectOrCreate?: categoriasCreateOrConnectWithoutCategoriasCursosInput
    upsert?: categoriasUpsertWithoutCategoriasCursosInput
    connect?: categoriasWhereUniqueInput
    update?: XOR<XOR<categoriasUpdateToOneWithWhereWithoutCategoriasCursosInput, categoriasUpdateWithoutCategoriasCursosInput>, categoriasUncheckedUpdateWithoutCategoriasCursosInput>
  }

  export type cursosUpdateOneRequiredWithoutCategoriasCursosNestedInput = {
    create?: XOR<cursosCreateWithoutCategoriasCursosInput, cursosUncheckedCreateWithoutCategoriasCursosInput>
    connectOrCreate?: cursosCreateOrConnectWithoutCategoriasCursosInput
    upsert?: cursosUpsertWithoutCategoriasCursosInput
    connect?: cursosWhereUniqueInput
    update?: XOR<XOR<cursosUpdateToOneWithWhereWithoutCategoriasCursosInput, cursosUpdateWithoutCategoriasCursosInput>, cursosUncheckedUpdateWithoutCategoriasCursosInput>
  }

  export type edicionesCursosCreateNestedOneWithoutCertificadosInput = {
    create?: XOR<edicionesCursosCreateWithoutCertificadosInput, edicionesCursosUncheckedCreateWithoutCertificadosInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutCertificadosInput
    connect?: edicionesCursosWhereUniqueInput
  }

  export type estudiantesCreateNestedOneWithoutCertificadosInput = {
    create?: XOR<estudiantesCreateWithoutCertificadosInput, estudiantesUncheckedCreateWithoutCertificadosInput>
    connectOrCreate?: estudiantesCreateOrConnectWithoutCertificadosInput
    connect?: estudiantesWhereUniqueInput
  }

  export type EnumTipoCertificadoFieldUpdateOperationsInput = {
    set?: $Enums.TipoCertificado
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type edicionesCursosUpdateOneRequiredWithoutCertificadosNestedInput = {
    create?: XOR<edicionesCursosCreateWithoutCertificadosInput, edicionesCursosUncheckedCreateWithoutCertificadosInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutCertificadosInput
    upsert?: edicionesCursosUpsertWithoutCertificadosInput
    connect?: edicionesCursosWhereUniqueInput
    update?: XOR<XOR<edicionesCursosUpdateToOneWithWhereWithoutCertificadosInput, edicionesCursosUpdateWithoutCertificadosInput>, edicionesCursosUncheckedUpdateWithoutCertificadosInput>
  }

  export type estudiantesUpdateOneRequiredWithoutCertificadosNestedInput = {
    create?: XOR<estudiantesCreateWithoutCertificadosInput, estudiantesUncheckedCreateWithoutCertificadosInput>
    connectOrCreate?: estudiantesCreateOrConnectWithoutCertificadosInput
    upsert?: estudiantesUpsertWithoutCertificadosInput
    connect?: estudiantesWhereUniqueInput
    update?: XOR<XOR<estudiantesUpdateToOneWithWhereWithoutCertificadosInput, estudiantesUpdateWithoutCertificadosInput>, estudiantesUncheckedUpdateWithoutCertificadosInput>
  }

  export type edicionesCursosCreateNestedOneWithoutClasesInput = {
    create?: XOR<edicionesCursosCreateWithoutClasesInput, edicionesCursosUncheckedCreateWithoutClasesInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutClasesInput
    connect?: edicionesCursosWhereUniqueInput
  }

  export type grabacionesCreateNestedManyWithoutClasesInput = {
    create?: XOR<grabacionesCreateWithoutClasesInput, grabacionesUncheckedCreateWithoutClasesInput> | grabacionesCreateWithoutClasesInput[] | grabacionesUncheckedCreateWithoutClasesInput[]
    connectOrCreate?: grabacionesCreateOrConnectWithoutClasesInput | grabacionesCreateOrConnectWithoutClasesInput[]
    createMany?: grabacionesCreateManyClasesInputEnvelope
    connect?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
  }

  export type materialesCreateNestedManyWithoutClasesInput = {
    create?: XOR<materialesCreateWithoutClasesInput, materialesUncheckedCreateWithoutClasesInput> | materialesCreateWithoutClasesInput[] | materialesUncheckedCreateWithoutClasesInput[]
    connectOrCreate?: materialesCreateOrConnectWithoutClasesInput | materialesCreateOrConnectWithoutClasesInput[]
    createMany?: materialesCreateManyClasesInputEnvelope
    connect?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
  }

  export type grabacionesUncheckedCreateNestedManyWithoutClasesInput = {
    create?: XOR<grabacionesCreateWithoutClasesInput, grabacionesUncheckedCreateWithoutClasesInput> | grabacionesCreateWithoutClasesInput[] | grabacionesUncheckedCreateWithoutClasesInput[]
    connectOrCreate?: grabacionesCreateOrConnectWithoutClasesInput | grabacionesCreateOrConnectWithoutClasesInput[]
    createMany?: grabacionesCreateManyClasesInputEnvelope
    connect?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
  }

  export type materialesUncheckedCreateNestedManyWithoutClasesInput = {
    create?: XOR<materialesCreateWithoutClasesInput, materialesUncheckedCreateWithoutClasesInput> | materialesCreateWithoutClasesInput[] | materialesUncheckedCreateWithoutClasesInput[]
    connectOrCreate?: materialesCreateOrConnectWithoutClasesInput | materialesCreateOrConnectWithoutClasesInput[]
    createMany?: materialesCreateManyClasesInputEnvelope
    connect?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type edicionesCursosUpdateOneRequiredWithoutClasesNestedInput = {
    create?: XOR<edicionesCursosCreateWithoutClasesInput, edicionesCursosUncheckedCreateWithoutClasesInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutClasesInput
    upsert?: edicionesCursosUpsertWithoutClasesInput
    connect?: edicionesCursosWhereUniqueInput
    update?: XOR<XOR<edicionesCursosUpdateToOneWithWhereWithoutClasesInput, edicionesCursosUpdateWithoutClasesInput>, edicionesCursosUncheckedUpdateWithoutClasesInput>
  }

  export type grabacionesUpdateManyWithoutClasesNestedInput = {
    create?: XOR<grabacionesCreateWithoutClasesInput, grabacionesUncheckedCreateWithoutClasesInput> | grabacionesCreateWithoutClasesInput[] | grabacionesUncheckedCreateWithoutClasesInput[]
    connectOrCreate?: grabacionesCreateOrConnectWithoutClasesInput | grabacionesCreateOrConnectWithoutClasesInput[]
    upsert?: grabacionesUpsertWithWhereUniqueWithoutClasesInput | grabacionesUpsertWithWhereUniqueWithoutClasesInput[]
    createMany?: grabacionesCreateManyClasesInputEnvelope
    set?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    disconnect?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    delete?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    connect?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    update?: grabacionesUpdateWithWhereUniqueWithoutClasesInput | grabacionesUpdateWithWhereUniqueWithoutClasesInput[]
    updateMany?: grabacionesUpdateManyWithWhereWithoutClasesInput | grabacionesUpdateManyWithWhereWithoutClasesInput[]
    deleteMany?: grabacionesScalarWhereInput | grabacionesScalarWhereInput[]
  }

  export type materialesUpdateManyWithoutClasesNestedInput = {
    create?: XOR<materialesCreateWithoutClasesInput, materialesUncheckedCreateWithoutClasesInput> | materialesCreateWithoutClasesInput[] | materialesUncheckedCreateWithoutClasesInput[]
    connectOrCreate?: materialesCreateOrConnectWithoutClasesInput | materialesCreateOrConnectWithoutClasesInput[]
    upsert?: materialesUpsertWithWhereUniqueWithoutClasesInput | materialesUpsertWithWhereUniqueWithoutClasesInput[]
    createMany?: materialesCreateManyClasesInputEnvelope
    set?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
    disconnect?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
    delete?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
    connect?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
    update?: materialesUpdateWithWhereUniqueWithoutClasesInput | materialesUpdateWithWhereUniqueWithoutClasesInput[]
    updateMany?: materialesUpdateManyWithWhereWithoutClasesInput | materialesUpdateManyWithWhereWithoutClasesInput[]
    deleteMany?: materialesScalarWhereInput | materialesScalarWhereInput[]
  }

  export type grabacionesUncheckedUpdateManyWithoutClasesNestedInput = {
    create?: XOR<grabacionesCreateWithoutClasesInput, grabacionesUncheckedCreateWithoutClasesInput> | grabacionesCreateWithoutClasesInput[] | grabacionesUncheckedCreateWithoutClasesInput[]
    connectOrCreate?: grabacionesCreateOrConnectWithoutClasesInput | grabacionesCreateOrConnectWithoutClasesInput[]
    upsert?: grabacionesUpsertWithWhereUniqueWithoutClasesInput | grabacionesUpsertWithWhereUniqueWithoutClasesInput[]
    createMany?: grabacionesCreateManyClasesInputEnvelope
    set?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    disconnect?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    delete?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    connect?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    update?: grabacionesUpdateWithWhereUniqueWithoutClasesInput | grabacionesUpdateWithWhereUniqueWithoutClasesInput[]
    updateMany?: grabacionesUpdateManyWithWhereWithoutClasesInput | grabacionesUpdateManyWithWhereWithoutClasesInput[]
    deleteMany?: grabacionesScalarWhereInput | grabacionesScalarWhereInput[]
  }

  export type materialesUncheckedUpdateManyWithoutClasesNestedInput = {
    create?: XOR<materialesCreateWithoutClasesInput, materialesUncheckedCreateWithoutClasesInput> | materialesCreateWithoutClasesInput[] | materialesUncheckedCreateWithoutClasesInput[]
    connectOrCreate?: materialesCreateOrConnectWithoutClasesInput | materialesCreateOrConnectWithoutClasesInput[]
    upsert?: materialesUpsertWithWhereUniqueWithoutClasesInput | materialesUpsertWithWhereUniqueWithoutClasesInput[]
    createMany?: materialesCreateManyClasesInputEnvelope
    set?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
    disconnect?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
    delete?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
    connect?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
    update?: materialesUpdateWithWhereUniqueWithoutClasesInput | materialesUpdateWithWhereUniqueWithoutClasesInput[]
    updateMany?: materialesUpdateManyWithWhereWithoutClasesInput | materialesUpdateManyWithWhereWithoutClasesInput[]
    deleteMany?: materialesScalarWhereInput | materialesScalarWhereInput[]
  }

  export type edicionesCursosCreateNestedOneWithoutComprasInput = {
    create?: XOR<edicionesCursosCreateWithoutComprasInput, edicionesCursosUncheckedCreateWithoutComprasInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutComprasInput
    connect?: edicionesCursosWhereUniqueInput
  }

  export type usuariosEstudiantesCreateNestedOneWithoutComprasInput = {
    create?: XOR<usuariosEstudiantesCreateWithoutComprasInput, usuariosEstudiantesUncheckedCreateWithoutComprasInput>
    connectOrCreate?: usuariosEstudiantesCreateOrConnectWithoutComprasInput
    connect?: usuariosEstudiantesWhereUniqueInput
  }

  export type inscripcionesCreateNestedOneWithoutComprasInput = {
    create?: XOR<inscripcionesCreateWithoutComprasInput, inscripcionesUncheckedCreateWithoutComprasInput>
    connectOrCreate?: inscripcionesCreateOrConnectWithoutComprasInput
    connect?: inscripcionesWhereUniqueInput
  }

  export type inscripcionesUncheckedCreateNestedOneWithoutComprasInput = {
    create?: XOR<inscripcionesCreateWithoutComprasInput, inscripcionesUncheckedCreateWithoutComprasInput>
    connectOrCreate?: inscripcionesCreateOrConnectWithoutComprasInput
    connect?: inscripcionesWhereUniqueInput
  }

  export type EnumMetodoPagoFieldUpdateOperationsInput = {
    set?: $Enums.MetodoPago
  }

  export type EnumEstadoPagoFieldUpdateOperationsInput = {
    set?: $Enums.EstadoPago
  }

  export type edicionesCursosUpdateOneRequiredWithoutComprasNestedInput = {
    create?: XOR<edicionesCursosCreateWithoutComprasInput, edicionesCursosUncheckedCreateWithoutComprasInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutComprasInput
    upsert?: edicionesCursosUpsertWithoutComprasInput
    connect?: edicionesCursosWhereUniqueInput
    update?: XOR<XOR<edicionesCursosUpdateToOneWithWhereWithoutComprasInput, edicionesCursosUpdateWithoutComprasInput>, edicionesCursosUncheckedUpdateWithoutComprasInput>
  }

  export type usuariosEstudiantesUpdateOneWithoutComprasNestedInput = {
    create?: XOR<usuariosEstudiantesCreateWithoutComprasInput, usuariosEstudiantesUncheckedCreateWithoutComprasInput>
    connectOrCreate?: usuariosEstudiantesCreateOrConnectWithoutComprasInput
    upsert?: usuariosEstudiantesUpsertWithoutComprasInput
    disconnect?: usuariosEstudiantesWhereInput | boolean
    delete?: usuariosEstudiantesWhereInput | boolean
    connect?: usuariosEstudiantesWhereUniqueInput
    update?: XOR<XOR<usuariosEstudiantesUpdateToOneWithWhereWithoutComprasInput, usuariosEstudiantesUpdateWithoutComprasInput>, usuariosEstudiantesUncheckedUpdateWithoutComprasInput>
  }

  export type inscripcionesUpdateOneWithoutComprasNestedInput = {
    create?: XOR<inscripcionesCreateWithoutComprasInput, inscripcionesUncheckedCreateWithoutComprasInput>
    connectOrCreate?: inscripcionesCreateOrConnectWithoutComprasInput
    upsert?: inscripcionesUpsertWithoutComprasInput
    disconnect?: inscripcionesWhereInput | boolean
    delete?: inscripcionesWhereInput | boolean
    connect?: inscripcionesWhereUniqueInput
    update?: XOR<XOR<inscripcionesUpdateToOneWithWhereWithoutComprasInput, inscripcionesUpdateWithoutComprasInput>, inscripcionesUncheckedUpdateWithoutComprasInput>
  }

  export type inscripcionesUncheckedUpdateOneWithoutComprasNestedInput = {
    create?: XOR<inscripcionesCreateWithoutComprasInput, inscripcionesUncheckedCreateWithoutComprasInput>
    connectOrCreate?: inscripcionesCreateOrConnectWithoutComprasInput
    upsert?: inscripcionesUpsertWithoutComprasInput
    disconnect?: inscripcionesWhereInput | boolean
    delete?: inscripcionesWhereInput | boolean
    connect?: inscripcionesWhereUniqueInput
    update?: XOR<XOR<inscripcionesUpdateToOneWithWhereWithoutComprasInput, inscripcionesUpdateWithoutComprasInput>, inscripcionesUncheckedUpdateWithoutComprasInput>
  }

  export type beneficiosCursosCreateNestedManyWithoutCursosInput = {
    create?: XOR<beneficiosCursosCreateWithoutCursosInput, beneficiosCursosUncheckedCreateWithoutCursosInput> | beneficiosCursosCreateWithoutCursosInput[] | beneficiosCursosUncheckedCreateWithoutCursosInput[]
    connectOrCreate?: beneficiosCursosCreateOrConnectWithoutCursosInput | beneficiosCursosCreateOrConnectWithoutCursosInput[]
    createMany?: beneficiosCursosCreateManyCursosInputEnvelope
    connect?: beneficiosCursosWhereUniqueInput | beneficiosCursosWhereUniqueInput[]
  }

  export type categoriasCursosCreateNestedManyWithoutCursosInput = {
    create?: XOR<categoriasCursosCreateWithoutCursosInput, categoriasCursosUncheckedCreateWithoutCursosInput> | categoriasCursosCreateWithoutCursosInput[] | categoriasCursosUncheckedCreateWithoutCursosInput[]
    connectOrCreate?: categoriasCursosCreateOrConnectWithoutCursosInput | categoriasCursosCreateOrConnectWithoutCursosInput[]
    createMany?: categoriasCursosCreateManyCursosInputEnvelope
    connect?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
  }

  export type edicionesCursosCreateNestedManyWithoutCursosInput = {
    create?: XOR<edicionesCursosCreateWithoutCursosInput, edicionesCursosUncheckedCreateWithoutCursosInput> | edicionesCursosCreateWithoutCursosInput[] | edicionesCursosUncheckedCreateWithoutCursosInput[]
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutCursosInput | edicionesCursosCreateOrConnectWithoutCursosInput[]
    createMany?: edicionesCursosCreateManyCursosInputEnvelope
    connect?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
  }

  export type objetivosCursosCreateNestedManyWithoutCursosInput = {
    create?: XOR<objetivosCursosCreateWithoutCursosInput, objetivosCursosUncheckedCreateWithoutCursosInput> | objetivosCursosCreateWithoutCursosInput[] | objetivosCursosUncheckedCreateWithoutCursosInput[]
    connectOrCreate?: objetivosCursosCreateOrConnectWithoutCursosInput | objetivosCursosCreateOrConnectWithoutCursosInput[]
    createMany?: objetivosCursosCreateManyCursosInputEnvelope
    connect?: objetivosCursosWhereUniqueInput | objetivosCursosWhereUniqueInput[]
  }

  export type requisitosCursosCreateNestedManyWithoutCursosInput = {
    create?: XOR<requisitosCursosCreateWithoutCursosInput, requisitosCursosUncheckedCreateWithoutCursosInput> | requisitosCursosCreateWithoutCursosInput[] | requisitosCursosUncheckedCreateWithoutCursosInput[]
    connectOrCreate?: requisitosCursosCreateOrConnectWithoutCursosInput | requisitosCursosCreateOrConnectWithoutCursosInput[]
    createMany?: requisitosCursosCreateManyCursosInputEnvelope
    connect?: requisitosCursosWhereUniqueInput | requisitosCursosWhereUniqueInput[]
  }

  export type reviewsCursosCreateNestedManyWithoutCursosInput = {
    create?: XOR<reviewsCursosCreateWithoutCursosInput, reviewsCursosUncheckedCreateWithoutCursosInput> | reviewsCursosCreateWithoutCursosInput[] | reviewsCursosUncheckedCreateWithoutCursosInput[]
    connectOrCreate?: reviewsCursosCreateOrConnectWithoutCursosInput | reviewsCursosCreateOrConnectWithoutCursosInput[]
    createMany?: reviewsCursosCreateManyCursosInputEnvelope
    connect?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
  }

  export type beneficiosCursosUncheckedCreateNestedManyWithoutCursosInput = {
    create?: XOR<beneficiosCursosCreateWithoutCursosInput, beneficiosCursosUncheckedCreateWithoutCursosInput> | beneficiosCursosCreateWithoutCursosInput[] | beneficiosCursosUncheckedCreateWithoutCursosInput[]
    connectOrCreate?: beneficiosCursosCreateOrConnectWithoutCursosInput | beneficiosCursosCreateOrConnectWithoutCursosInput[]
    createMany?: beneficiosCursosCreateManyCursosInputEnvelope
    connect?: beneficiosCursosWhereUniqueInput | beneficiosCursosWhereUniqueInput[]
  }

  export type categoriasCursosUncheckedCreateNestedManyWithoutCursosInput = {
    create?: XOR<categoriasCursosCreateWithoutCursosInput, categoriasCursosUncheckedCreateWithoutCursosInput> | categoriasCursosCreateWithoutCursosInput[] | categoriasCursosUncheckedCreateWithoutCursosInput[]
    connectOrCreate?: categoriasCursosCreateOrConnectWithoutCursosInput | categoriasCursosCreateOrConnectWithoutCursosInput[]
    createMany?: categoriasCursosCreateManyCursosInputEnvelope
    connect?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
  }

  export type edicionesCursosUncheckedCreateNestedManyWithoutCursosInput = {
    create?: XOR<edicionesCursosCreateWithoutCursosInput, edicionesCursosUncheckedCreateWithoutCursosInput> | edicionesCursosCreateWithoutCursosInput[] | edicionesCursosUncheckedCreateWithoutCursosInput[]
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutCursosInput | edicionesCursosCreateOrConnectWithoutCursosInput[]
    createMany?: edicionesCursosCreateManyCursosInputEnvelope
    connect?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
  }

  export type objetivosCursosUncheckedCreateNestedManyWithoutCursosInput = {
    create?: XOR<objetivosCursosCreateWithoutCursosInput, objetivosCursosUncheckedCreateWithoutCursosInput> | objetivosCursosCreateWithoutCursosInput[] | objetivosCursosUncheckedCreateWithoutCursosInput[]
    connectOrCreate?: objetivosCursosCreateOrConnectWithoutCursosInput | objetivosCursosCreateOrConnectWithoutCursosInput[]
    createMany?: objetivosCursosCreateManyCursosInputEnvelope
    connect?: objetivosCursosWhereUniqueInput | objetivosCursosWhereUniqueInput[]
  }

  export type requisitosCursosUncheckedCreateNestedManyWithoutCursosInput = {
    create?: XOR<requisitosCursosCreateWithoutCursosInput, requisitosCursosUncheckedCreateWithoutCursosInput> | requisitosCursosCreateWithoutCursosInput[] | requisitosCursosUncheckedCreateWithoutCursosInput[]
    connectOrCreate?: requisitosCursosCreateOrConnectWithoutCursosInput | requisitosCursosCreateOrConnectWithoutCursosInput[]
    createMany?: requisitosCursosCreateManyCursosInputEnvelope
    connect?: requisitosCursosWhereUniqueInput | requisitosCursosWhereUniqueInput[]
  }

  export type reviewsCursosUncheckedCreateNestedManyWithoutCursosInput = {
    create?: XOR<reviewsCursosCreateWithoutCursosInput, reviewsCursosUncheckedCreateWithoutCursosInput> | reviewsCursosCreateWithoutCursosInput[] | reviewsCursosUncheckedCreateWithoutCursosInput[]
    connectOrCreate?: reviewsCursosCreateOrConnectWithoutCursosInput | reviewsCursosCreateOrConnectWithoutCursosInput[]
    createMany?: reviewsCursosCreateManyCursosInputEnvelope
    connect?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
  }

  export type beneficiosCursosUpdateManyWithoutCursosNestedInput = {
    create?: XOR<beneficiosCursosCreateWithoutCursosInput, beneficiosCursosUncheckedCreateWithoutCursosInput> | beneficiosCursosCreateWithoutCursosInput[] | beneficiosCursosUncheckedCreateWithoutCursosInput[]
    connectOrCreate?: beneficiosCursosCreateOrConnectWithoutCursosInput | beneficiosCursosCreateOrConnectWithoutCursosInput[]
    upsert?: beneficiosCursosUpsertWithWhereUniqueWithoutCursosInput | beneficiosCursosUpsertWithWhereUniqueWithoutCursosInput[]
    createMany?: beneficiosCursosCreateManyCursosInputEnvelope
    set?: beneficiosCursosWhereUniqueInput | beneficiosCursosWhereUniqueInput[]
    disconnect?: beneficiosCursosWhereUniqueInput | beneficiosCursosWhereUniqueInput[]
    delete?: beneficiosCursosWhereUniqueInput | beneficiosCursosWhereUniqueInput[]
    connect?: beneficiosCursosWhereUniqueInput | beneficiosCursosWhereUniqueInput[]
    update?: beneficiosCursosUpdateWithWhereUniqueWithoutCursosInput | beneficiosCursosUpdateWithWhereUniqueWithoutCursosInput[]
    updateMany?: beneficiosCursosUpdateManyWithWhereWithoutCursosInput | beneficiosCursosUpdateManyWithWhereWithoutCursosInput[]
    deleteMany?: beneficiosCursosScalarWhereInput | beneficiosCursosScalarWhereInput[]
  }

  export type categoriasCursosUpdateManyWithoutCursosNestedInput = {
    create?: XOR<categoriasCursosCreateWithoutCursosInput, categoriasCursosUncheckedCreateWithoutCursosInput> | categoriasCursosCreateWithoutCursosInput[] | categoriasCursosUncheckedCreateWithoutCursosInput[]
    connectOrCreate?: categoriasCursosCreateOrConnectWithoutCursosInput | categoriasCursosCreateOrConnectWithoutCursosInput[]
    upsert?: categoriasCursosUpsertWithWhereUniqueWithoutCursosInput | categoriasCursosUpsertWithWhereUniqueWithoutCursosInput[]
    createMany?: categoriasCursosCreateManyCursosInputEnvelope
    set?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    disconnect?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    delete?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    connect?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    update?: categoriasCursosUpdateWithWhereUniqueWithoutCursosInput | categoriasCursosUpdateWithWhereUniqueWithoutCursosInput[]
    updateMany?: categoriasCursosUpdateManyWithWhereWithoutCursosInput | categoriasCursosUpdateManyWithWhereWithoutCursosInput[]
    deleteMany?: categoriasCursosScalarWhereInput | categoriasCursosScalarWhereInput[]
  }

  export type edicionesCursosUpdateManyWithoutCursosNestedInput = {
    create?: XOR<edicionesCursosCreateWithoutCursosInput, edicionesCursosUncheckedCreateWithoutCursosInput> | edicionesCursosCreateWithoutCursosInput[] | edicionesCursosUncheckedCreateWithoutCursosInput[]
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutCursosInput | edicionesCursosCreateOrConnectWithoutCursosInput[]
    upsert?: edicionesCursosUpsertWithWhereUniqueWithoutCursosInput | edicionesCursosUpsertWithWhereUniqueWithoutCursosInput[]
    createMany?: edicionesCursosCreateManyCursosInputEnvelope
    set?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    disconnect?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    delete?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    connect?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    update?: edicionesCursosUpdateWithWhereUniqueWithoutCursosInput | edicionesCursosUpdateWithWhereUniqueWithoutCursosInput[]
    updateMany?: edicionesCursosUpdateManyWithWhereWithoutCursosInput | edicionesCursosUpdateManyWithWhereWithoutCursosInput[]
    deleteMany?: edicionesCursosScalarWhereInput | edicionesCursosScalarWhereInput[]
  }

  export type objetivosCursosUpdateManyWithoutCursosNestedInput = {
    create?: XOR<objetivosCursosCreateWithoutCursosInput, objetivosCursosUncheckedCreateWithoutCursosInput> | objetivosCursosCreateWithoutCursosInput[] | objetivosCursosUncheckedCreateWithoutCursosInput[]
    connectOrCreate?: objetivosCursosCreateOrConnectWithoutCursosInput | objetivosCursosCreateOrConnectWithoutCursosInput[]
    upsert?: objetivosCursosUpsertWithWhereUniqueWithoutCursosInput | objetivosCursosUpsertWithWhereUniqueWithoutCursosInput[]
    createMany?: objetivosCursosCreateManyCursosInputEnvelope
    set?: objetivosCursosWhereUniqueInput | objetivosCursosWhereUniqueInput[]
    disconnect?: objetivosCursosWhereUniqueInput | objetivosCursosWhereUniqueInput[]
    delete?: objetivosCursosWhereUniqueInput | objetivosCursosWhereUniqueInput[]
    connect?: objetivosCursosWhereUniqueInput | objetivosCursosWhereUniqueInput[]
    update?: objetivosCursosUpdateWithWhereUniqueWithoutCursosInput | objetivosCursosUpdateWithWhereUniqueWithoutCursosInput[]
    updateMany?: objetivosCursosUpdateManyWithWhereWithoutCursosInput | objetivosCursosUpdateManyWithWhereWithoutCursosInput[]
    deleteMany?: objetivosCursosScalarWhereInput | objetivosCursosScalarWhereInput[]
  }

  export type requisitosCursosUpdateManyWithoutCursosNestedInput = {
    create?: XOR<requisitosCursosCreateWithoutCursosInput, requisitosCursosUncheckedCreateWithoutCursosInput> | requisitosCursosCreateWithoutCursosInput[] | requisitosCursosUncheckedCreateWithoutCursosInput[]
    connectOrCreate?: requisitosCursosCreateOrConnectWithoutCursosInput | requisitosCursosCreateOrConnectWithoutCursosInput[]
    upsert?: requisitosCursosUpsertWithWhereUniqueWithoutCursosInput | requisitosCursosUpsertWithWhereUniqueWithoutCursosInput[]
    createMany?: requisitosCursosCreateManyCursosInputEnvelope
    set?: requisitosCursosWhereUniqueInput | requisitosCursosWhereUniqueInput[]
    disconnect?: requisitosCursosWhereUniqueInput | requisitosCursosWhereUniqueInput[]
    delete?: requisitosCursosWhereUniqueInput | requisitosCursosWhereUniqueInput[]
    connect?: requisitosCursosWhereUniqueInput | requisitosCursosWhereUniqueInput[]
    update?: requisitosCursosUpdateWithWhereUniqueWithoutCursosInput | requisitosCursosUpdateWithWhereUniqueWithoutCursosInput[]
    updateMany?: requisitosCursosUpdateManyWithWhereWithoutCursosInput | requisitosCursosUpdateManyWithWhereWithoutCursosInput[]
    deleteMany?: requisitosCursosScalarWhereInput | requisitosCursosScalarWhereInput[]
  }

  export type reviewsCursosUpdateManyWithoutCursosNestedInput = {
    create?: XOR<reviewsCursosCreateWithoutCursosInput, reviewsCursosUncheckedCreateWithoutCursosInput> | reviewsCursosCreateWithoutCursosInput[] | reviewsCursosUncheckedCreateWithoutCursosInput[]
    connectOrCreate?: reviewsCursosCreateOrConnectWithoutCursosInput | reviewsCursosCreateOrConnectWithoutCursosInput[]
    upsert?: reviewsCursosUpsertWithWhereUniqueWithoutCursosInput | reviewsCursosUpsertWithWhereUniqueWithoutCursosInput[]
    createMany?: reviewsCursosCreateManyCursosInputEnvelope
    set?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    disconnect?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    delete?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    connect?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    update?: reviewsCursosUpdateWithWhereUniqueWithoutCursosInput | reviewsCursosUpdateWithWhereUniqueWithoutCursosInput[]
    updateMany?: reviewsCursosUpdateManyWithWhereWithoutCursosInput | reviewsCursosUpdateManyWithWhereWithoutCursosInput[]
    deleteMany?: reviewsCursosScalarWhereInput | reviewsCursosScalarWhereInput[]
  }

  export type beneficiosCursosUncheckedUpdateManyWithoutCursosNestedInput = {
    create?: XOR<beneficiosCursosCreateWithoutCursosInput, beneficiosCursosUncheckedCreateWithoutCursosInput> | beneficiosCursosCreateWithoutCursosInput[] | beneficiosCursosUncheckedCreateWithoutCursosInput[]
    connectOrCreate?: beneficiosCursosCreateOrConnectWithoutCursosInput | beneficiosCursosCreateOrConnectWithoutCursosInput[]
    upsert?: beneficiosCursosUpsertWithWhereUniqueWithoutCursosInput | beneficiosCursosUpsertWithWhereUniqueWithoutCursosInput[]
    createMany?: beneficiosCursosCreateManyCursosInputEnvelope
    set?: beneficiosCursosWhereUniqueInput | beneficiosCursosWhereUniqueInput[]
    disconnect?: beneficiosCursosWhereUniqueInput | beneficiosCursosWhereUniqueInput[]
    delete?: beneficiosCursosWhereUniqueInput | beneficiosCursosWhereUniqueInput[]
    connect?: beneficiosCursosWhereUniqueInput | beneficiosCursosWhereUniqueInput[]
    update?: beneficiosCursosUpdateWithWhereUniqueWithoutCursosInput | beneficiosCursosUpdateWithWhereUniqueWithoutCursosInput[]
    updateMany?: beneficiosCursosUpdateManyWithWhereWithoutCursosInput | beneficiosCursosUpdateManyWithWhereWithoutCursosInput[]
    deleteMany?: beneficiosCursosScalarWhereInput | beneficiosCursosScalarWhereInput[]
  }

  export type categoriasCursosUncheckedUpdateManyWithoutCursosNestedInput = {
    create?: XOR<categoriasCursosCreateWithoutCursosInput, categoriasCursosUncheckedCreateWithoutCursosInput> | categoriasCursosCreateWithoutCursosInput[] | categoriasCursosUncheckedCreateWithoutCursosInput[]
    connectOrCreate?: categoriasCursosCreateOrConnectWithoutCursosInput | categoriasCursosCreateOrConnectWithoutCursosInput[]
    upsert?: categoriasCursosUpsertWithWhereUniqueWithoutCursosInput | categoriasCursosUpsertWithWhereUniqueWithoutCursosInput[]
    createMany?: categoriasCursosCreateManyCursosInputEnvelope
    set?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    disconnect?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    delete?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    connect?: categoriasCursosWhereUniqueInput | categoriasCursosWhereUniqueInput[]
    update?: categoriasCursosUpdateWithWhereUniqueWithoutCursosInput | categoriasCursosUpdateWithWhereUniqueWithoutCursosInput[]
    updateMany?: categoriasCursosUpdateManyWithWhereWithoutCursosInput | categoriasCursosUpdateManyWithWhereWithoutCursosInput[]
    deleteMany?: categoriasCursosScalarWhereInput | categoriasCursosScalarWhereInput[]
  }

  export type edicionesCursosUncheckedUpdateManyWithoutCursosNestedInput = {
    create?: XOR<edicionesCursosCreateWithoutCursosInput, edicionesCursosUncheckedCreateWithoutCursosInput> | edicionesCursosCreateWithoutCursosInput[] | edicionesCursosUncheckedCreateWithoutCursosInput[]
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutCursosInput | edicionesCursosCreateOrConnectWithoutCursosInput[]
    upsert?: edicionesCursosUpsertWithWhereUniqueWithoutCursosInput | edicionesCursosUpsertWithWhereUniqueWithoutCursosInput[]
    createMany?: edicionesCursosCreateManyCursosInputEnvelope
    set?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    disconnect?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    delete?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    connect?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    update?: edicionesCursosUpdateWithWhereUniqueWithoutCursosInput | edicionesCursosUpdateWithWhereUniqueWithoutCursosInput[]
    updateMany?: edicionesCursosUpdateManyWithWhereWithoutCursosInput | edicionesCursosUpdateManyWithWhereWithoutCursosInput[]
    deleteMany?: edicionesCursosScalarWhereInput | edicionesCursosScalarWhereInput[]
  }

  export type objetivosCursosUncheckedUpdateManyWithoutCursosNestedInput = {
    create?: XOR<objetivosCursosCreateWithoutCursosInput, objetivosCursosUncheckedCreateWithoutCursosInput> | objetivosCursosCreateWithoutCursosInput[] | objetivosCursosUncheckedCreateWithoutCursosInput[]
    connectOrCreate?: objetivosCursosCreateOrConnectWithoutCursosInput | objetivosCursosCreateOrConnectWithoutCursosInput[]
    upsert?: objetivosCursosUpsertWithWhereUniqueWithoutCursosInput | objetivosCursosUpsertWithWhereUniqueWithoutCursosInput[]
    createMany?: objetivosCursosCreateManyCursosInputEnvelope
    set?: objetivosCursosWhereUniqueInput | objetivosCursosWhereUniqueInput[]
    disconnect?: objetivosCursosWhereUniqueInput | objetivosCursosWhereUniqueInput[]
    delete?: objetivosCursosWhereUniqueInput | objetivosCursosWhereUniqueInput[]
    connect?: objetivosCursosWhereUniqueInput | objetivosCursosWhereUniqueInput[]
    update?: objetivosCursosUpdateWithWhereUniqueWithoutCursosInput | objetivosCursosUpdateWithWhereUniqueWithoutCursosInput[]
    updateMany?: objetivosCursosUpdateManyWithWhereWithoutCursosInput | objetivosCursosUpdateManyWithWhereWithoutCursosInput[]
    deleteMany?: objetivosCursosScalarWhereInput | objetivosCursosScalarWhereInput[]
  }

  export type requisitosCursosUncheckedUpdateManyWithoutCursosNestedInput = {
    create?: XOR<requisitosCursosCreateWithoutCursosInput, requisitosCursosUncheckedCreateWithoutCursosInput> | requisitosCursosCreateWithoutCursosInput[] | requisitosCursosUncheckedCreateWithoutCursosInput[]
    connectOrCreate?: requisitosCursosCreateOrConnectWithoutCursosInput | requisitosCursosCreateOrConnectWithoutCursosInput[]
    upsert?: requisitosCursosUpsertWithWhereUniqueWithoutCursosInput | requisitosCursosUpsertWithWhereUniqueWithoutCursosInput[]
    createMany?: requisitosCursosCreateManyCursosInputEnvelope
    set?: requisitosCursosWhereUniqueInput | requisitosCursosWhereUniqueInput[]
    disconnect?: requisitosCursosWhereUniqueInput | requisitosCursosWhereUniqueInput[]
    delete?: requisitosCursosWhereUniqueInput | requisitosCursosWhereUniqueInput[]
    connect?: requisitosCursosWhereUniqueInput | requisitosCursosWhereUniqueInput[]
    update?: requisitosCursosUpdateWithWhereUniqueWithoutCursosInput | requisitosCursosUpdateWithWhereUniqueWithoutCursosInput[]
    updateMany?: requisitosCursosUpdateManyWithWhereWithoutCursosInput | requisitosCursosUpdateManyWithWhereWithoutCursosInput[]
    deleteMany?: requisitosCursosScalarWhereInput | requisitosCursosScalarWhereInput[]
  }

  export type reviewsCursosUncheckedUpdateManyWithoutCursosNestedInput = {
    create?: XOR<reviewsCursosCreateWithoutCursosInput, reviewsCursosUncheckedCreateWithoutCursosInput> | reviewsCursosCreateWithoutCursosInput[] | reviewsCursosUncheckedCreateWithoutCursosInput[]
    connectOrCreate?: reviewsCursosCreateOrConnectWithoutCursosInput | reviewsCursosCreateOrConnectWithoutCursosInput[]
    upsert?: reviewsCursosUpsertWithWhereUniqueWithoutCursosInput | reviewsCursosUpsertWithWhereUniqueWithoutCursosInput[]
    createMany?: reviewsCursosCreateManyCursosInputEnvelope
    set?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    disconnect?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    delete?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    connect?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    update?: reviewsCursosUpdateWithWhereUniqueWithoutCursosInput | reviewsCursosUpdateWithWhereUniqueWithoutCursosInput[]
    updateMany?: reviewsCursosUpdateManyWithWhereWithoutCursosInput | reviewsCursosUpdateManyWithWhereWithoutCursosInput[]
    deleteMany?: reviewsCursosScalarWhereInput | reviewsCursosScalarWhereInput[]
  }

  export type usuariosAdministradoresCreateNestedOneWithoutDocenteInput = {
    create?: XOR<usuariosAdministradoresCreateWithoutDocenteInput, usuariosAdministradoresUncheckedCreateWithoutDocenteInput>
    connectOrCreate?: usuariosAdministradoresCreateOrConnectWithoutDocenteInput
    connect?: usuariosAdministradoresWhereUniqueInput
  }

  export type edicionesCursosCreateNestedManyWithoutDocenteInput = {
    create?: XOR<edicionesCursosCreateWithoutDocenteInput, edicionesCursosUncheckedCreateWithoutDocenteInput> | edicionesCursosCreateWithoutDocenteInput[] | edicionesCursosUncheckedCreateWithoutDocenteInput[]
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutDocenteInput | edicionesCursosCreateOrConnectWithoutDocenteInput[]
    createMany?: edicionesCursosCreateManyDocenteInputEnvelope
    connect?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
  }

  export type pagosDocentesCreateNestedManyWithoutDocenteInput = {
    create?: XOR<pagosDocentesCreateWithoutDocenteInput, pagosDocentesUncheckedCreateWithoutDocenteInput> | pagosDocentesCreateWithoutDocenteInput[] | pagosDocentesUncheckedCreateWithoutDocenteInput[]
    connectOrCreate?: pagosDocentesCreateOrConnectWithoutDocenteInput | pagosDocentesCreateOrConnectWithoutDocenteInput[]
    createMany?: pagosDocentesCreateManyDocenteInputEnvelope
    connect?: pagosDocentesWhereUniqueInput | pagosDocentesWhereUniqueInput[]
  }

  export type edicionesCursosUncheckedCreateNestedManyWithoutDocenteInput = {
    create?: XOR<edicionesCursosCreateWithoutDocenteInput, edicionesCursosUncheckedCreateWithoutDocenteInput> | edicionesCursosCreateWithoutDocenteInput[] | edicionesCursosUncheckedCreateWithoutDocenteInput[]
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutDocenteInput | edicionesCursosCreateOrConnectWithoutDocenteInput[]
    createMany?: edicionesCursosCreateManyDocenteInputEnvelope
    connect?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
  }

  export type pagosDocentesUncheckedCreateNestedManyWithoutDocenteInput = {
    create?: XOR<pagosDocentesCreateWithoutDocenteInput, pagosDocentesUncheckedCreateWithoutDocenteInput> | pagosDocentesCreateWithoutDocenteInput[] | pagosDocentesUncheckedCreateWithoutDocenteInput[]
    connectOrCreate?: pagosDocentesCreateOrConnectWithoutDocenteInput | pagosDocentesCreateOrConnectWithoutDocenteInput[]
    createMany?: pagosDocentesCreateManyDocenteInputEnvelope
    connect?: pagosDocentesWhereUniqueInput | pagosDocentesWhereUniqueInput[]
  }

  export type usuariosAdministradoresUpdateOneRequiredWithoutDocenteNestedInput = {
    create?: XOR<usuariosAdministradoresCreateWithoutDocenteInput, usuariosAdministradoresUncheckedCreateWithoutDocenteInput>
    connectOrCreate?: usuariosAdministradoresCreateOrConnectWithoutDocenteInput
    upsert?: usuariosAdministradoresUpsertWithoutDocenteInput
    connect?: usuariosAdministradoresWhereUniqueInput
    update?: XOR<XOR<usuariosAdministradoresUpdateToOneWithWhereWithoutDocenteInput, usuariosAdministradoresUpdateWithoutDocenteInput>, usuariosAdministradoresUncheckedUpdateWithoutDocenteInput>
  }

  export type edicionesCursosUpdateManyWithoutDocenteNestedInput = {
    create?: XOR<edicionesCursosCreateWithoutDocenteInput, edicionesCursosUncheckedCreateWithoutDocenteInput> | edicionesCursosCreateWithoutDocenteInput[] | edicionesCursosUncheckedCreateWithoutDocenteInput[]
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutDocenteInput | edicionesCursosCreateOrConnectWithoutDocenteInput[]
    upsert?: edicionesCursosUpsertWithWhereUniqueWithoutDocenteInput | edicionesCursosUpsertWithWhereUniqueWithoutDocenteInput[]
    createMany?: edicionesCursosCreateManyDocenteInputEnvelope
    set?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    disconnect?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    delete?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    connect?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    update?: edicionesCursosUpdateWithWhereUniqueWithoutDocenteInput | edicionesCursosUpdateWithWhereUniqueWithoutDocenteInput[]
    updateMany?: edicionesCursosUpdateManyWithWhereWithoutDocenteInput | edicionesCursosUpdateManyWithWhereWithoutDocenteInput[]
    deleteMany?: edicionesCursosScalarWhereInput | edicionesCursosScalarWhereInput[]
  }

  export type pagosDocentesUpdateManyWithoutDocenteNestedInput = {
    create?: XOR<pagosDocentesCreateWithoutDocenteInput, pagosDocentesUncheckedCreateWithoutDocenteInput> | pagosDocentesCreateWithoutDocenteInput[] | pagosDocentesUncheckedCreateWithoutDocenteInput[]
    connectOrCreate?: pagosDocentesCreateOrConnectWithoutDocenteInput | pagosDocentesCreateOrConnectWithoutDocenteInput[]
    upsert?: pagosDocentesUpsertWithWhereUniqueWithoutDocenteInput | pagosDocentesUpsertWithWhereUniqueWithoutDocenteInput[]
    createMany?: pagosDocentesCreateManyDocenteInputEnvelope
    set?: pagosDocentesWhereUniqueInput | pagosDocentesWhereUniqueInput[]
    disconnect?: pagosDocentesWhereUniqueInput | pagosDocentesWhereUniqueInput[]
    delete?: pagosDocentesWhereUniqueInput | pagosDocentesWhereUniqueInput[]
    connect?: pagosDocentesWhereUniqueInput | pagosDocentesWhereUniqueInput[]
    update?: pagosDocentesUpdateWithWhereUniqueWithoutDocenteInput | pagosDocentesUpdateWithWhereUniqueWithoutDocenteInput[]
    updateMany?: pagosDocentesUpdateManyWithWhereWithoutDocenteInput | pagosDocentesUpdateManyWithWhereWithoutDocenteInput[]
    deleteMany?: pagosDocentesScalarWhereInput | pagosDocentesScalarWhereInput[]
  }

  export type edicionesCursosUncheckedUpdateManyWithoutDocenteNestedInput = {
    create?: XOR<edicionesCursosCreateWithoutDocenteInput, edicionesCursosUncheckedCreateWithoutDocenteInput> | edicionesCursosCreateWithoutDocenteInput[] | edicionesCursosUncheckedCreateWithoutDocenteInput[]
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutDocenteInput | edicionesCursosCreateOrConnectWithoutDocenteInput[]
    upsert?: edicionesCursosUpsertWithWhereUniqueWithoutDocenteInput | edicionesCursosUpsertWithWhereUniqueWithoutDocenteInput[]
    createMany?: edicionesCursosCreateManyDocenteInputEnvelope
    set?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    disconnect?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    delete?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    connect?: edicionesCursosWhereUniqueInput | edicionesCursosWhereUniqueInput[]
    update?: edicionesCursosUpdateWithWhereUniqueWithoutDocenteInput | edicionesCursosUpdateWithWhereUniqueWithoutDocenteInput[]
    updateMany?: edicionesCursosUpdateManyWithWhereWithoutDocenteInput | edicionesCursosUpdateManyWithWhereWithoutDocenteInput[]
    deleteMany?: edicionesCursosScalarWhereInput | edicionesCursosScalarWhereInput[]
  }

  export type pagosDocentesUncheckedUpdateManyWithoutDocenteNestedInput = {
    create?: XOR<pagosDocentesCreateWithoutDocenteInput, pagosDocentesUncheckedCreateWithoutDocenteInput> | pagosDocentesCreateWithoutDocenteInput[] | pagosDocentesUncheckedCreateWithoutDocenteInput[]
    connectOrCreate?: pagosDocentesCreateOrConnectWithoutDocenteInput | pagosDocentesCreateOrConnectWithoutDocenteInput[]
    upsert?: pagosDocentesUpsertWithWhereUniqueWithoutDocenteInput | pagosDocentesUpsertWithWhereUniqueWithoutDocenteInput[]
    createMany?: pagosDocentesCreateManyDocenteInputEnvelope
    set?: pagosDocentesWhereUniqueInput | pagosDocentesWhereUniqueInput[]
    disconnect?: pagosDocentesWhereUniqueInput | pagosDocentesWhereUniqueInput[]
    delete?: pagosDocentesWhereUniqueInput | pagosDocentesWhereUniqueInput[]
    connect?: pagosDocentesWhereUniqueInput | pagosDocentesWhereUniqueInput[]
    update?: pagosDocentesUpdateWithWhereUniqueWithoutDocenteInput | pagosDocentesUpdateWithWhereUniqueWithoutDocenteInput[]
    updateMany?: pagosDocentesUpdateManyWithWhereWithoutDocenteInput | pagosDocentesUpdateManyWithWhereWithoutDocenteInput[]
    deleteMany?: pagosDocentesScalarWhereInput | pagosDocentesScalarWhereInput[]
  }

  export type certificadosCreateNestedManyWithoutEdicionesCursosInput = {
    create?: XOR<certificadosCreateWithoutEdicionesCursosInput, certificadosUncheckedCreateWithoutEdicionesCursosInput> | certificadosCreateWithoutEdicionesCursosInput[] | certificadosUncheckedCreateWithoutEdicionesCursosInput[]
    connectOrCreate?: certificadosCreateOrConnectWithoutEdicionesCursosInput | certificadosCreateOrConnectWithoutEdicionesCursosInput[]
    createMany?: certificadosCreateManyEdicionesCursosInputEnvelope
    connect?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
  }

  export type clasesCreateNestedManyWithoutEdicionesCursosInput = {
    create?: XOR<clasesCreateWithoutEdicionesCursosInput, clasesUncheckedCreateWithoutEdicionesCursosInput> | clasesCreateWithoutEdicionesCursosInput[] | clasesUncheckedCreateWithoutEdicionesCursosInput[]
    connectOrCreate?: clasesCreateOrConnectWithoutEdicionesCursosInput | clasesCreateOrConnectWithoutEdicionesCursosInput[]
    createMany?: clasesCreateManyEdicionesCursosInputEnvelope
    connect?: clasesWhereUniqueInput | clasesWhereUniqueInput[]
  }

  export type comprasCreateNestedManyWithoutEdicionesCursosInput = {
    create?: XOR<comprasCreateWithoutEdicionesCursosInput, comprasUncheckedCreateWithoutEdicionesCursosInput> | comprasCreateWithoutEdicionesCursosInput[] | comprasUncheckedCreateWithoutEdicionesCursosInput[]
    connectOrCreate?: comprasCreateOrConnectWithoutEdicionesCursosInput | comprasCreateOrConnectWithoutEdicionesCursosInput[]
    createMany?: comprasCreateManyEdicionesCursosInputEnvelope
    connect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
  }

  export type cursosCreateNestedOneWithoutEdicionesCursosInput = {
    create?: XOR<cursosCreateWithoutEdicionesCursosInput, cursosUncheckedCreateWithoutEdicionesCursosInput>
    connectOrCreate?: cursosCreateOrConnectWithoutEdicionesCursosInput
    connect?: cursosWhereUniqueInput
  }

  export type docenteCreateNestedOneWithoutEdicionesCursosInput = {
    create?: XOR<docenteCreateWithoutEdicionesCursosInput, docenteUncheckedCreateWithoutEdicionesCursosInput>
    connectOrCreate?: docenteCreateOrConnectWithoutEdicionesCursosInput
    connect?: docenteWhereUniqueInput
  }

  export type examenesCreateNestedManyWithoutEdicionesCursosInput = {
    create?: XOR<examenesCreateWithoutEdicionesCursosInput, examenesUncheckedCreateWithoutEdicionesCursosInput> | examenesCreateWithoutEdicionesCursosInput[] | examenesUncheckedCreateWithoutEdicionesCursosInput[]
    connectOrCreate?: examenesCreateOrConnectWithoutEdicionesCursosInput | examenesCreateOrConnectWithoutEdicionesCursosInput[]
    createMany?: examenesCreateManyEdicionesCursosInputEnvelope
    connect?: examenesWhereUniqueInput | examenesWhereUniqueInput[]
  }

  export type inscripcionesCreateNestedManyWithoutEdicionesCursosInput = {
    create?: XOR<inscripcionesCreateWithoutEdicionesCursosInput, inscripcionesUncheckedCreateWithoutEdicionesCursosInput> | inscripcionesCreateWithoutEdicionesCursosInput[] | inscripcionesUncheckedCreateWithoutEdicionesCursosInput[]
    connectOrCreate?: inscripcionesCreateOrConnectWithoutEdicionesCursosInput | inscripcionesCreateOrConnectWithoutEdicionesCursosInput[]
    createMany?: inscripcionesCreateManyEdicionesCursosInputEnvelope
    connect?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
  }

  export type pagosDocentesCreateNestedOneWithoutEdicionesCursosInput = {
    create?: XOR<pagosDocentesCreateWithoutEdicionesCursosInput, pagosDocentesUncheckedCreateWithoutEdicionesCursosInput>
    connectOrCreate?: pagosDocentesCreateOrConnectWithoutEdicionesCursosInput
    connect?: pagosDocentesWhereUniqueInput
  }

  export type preciosCursosCreateNestedManyWithoutEdicionesCursosInput = {
    create?: XOR<preciosCursosCreateWithoutEdicionesCursosInput, preciosCursosUncheckedCreateWithoutEdicionesCursosInput> | preciosCursosCreateWithoutEdicionesCursosInput[] | preciosCursosUncheckedCreateWithoutEdicionesCursosInput[]
    connectOrCreate?: preciosCursosCreateOrConnectWithoutEdicionesCursosInput | preciosCursosCreateOrConnectWithoutEdicionesCursosInput[]
    createMany?: preciosCursosCreateManyEdicionesCursosInputEnvelope
    connect?: preciosCursosWhereUniqueInput | preciosCursosWhereUniqueInput[]
  }

  export type certificadosUncheckedCreateNestedManyWithoutEdicionesCursosInput = {
    create?: XOR<certificadosCreateWithoutEdicionesCursosInput, certificadosUncheckedCreateWithoutEdicionesCursosInput> | certificadosCreateWithoutEdicionesCursosInput[] | certificadosUncheckedCreateWithoutEdicionesCursosInput[]
    connectOrCreate?: certificadosCreateOrConnectWithoutEdicionesCursosInput | certificadosCreateOrConnectWithoutEdicionesCursosInput[]
    createMany?: certificadosCreateManyEdicionesCursosInputEnvelope
    connect?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
  }

  export type clasesUncheckedCreateNestedManyWithoutEdicionesCursosInput = {
    create?: XOR<clasesCreateWithoutEdicionesCursosInput, clasesUncheckedCreateWithoutEdicionesCursosInput> | clasesCreateWithoutEdicionesCursosInput[] | clasesUncheckedCreateWithoutEdicionesCursosInput[]
    connectOrCreate?: clasesCreateOrConnectWithoutEdicionesCursosInput | clasesCreateOrConnectWithoutEdicionesCursosInput[]
    createMany?: clasesCreateManyEdicionesCursosInputEnvelope
    connect?: clasesWhereUniqueInput | clasesWhereUniqueInput[]
  }

  export type comprasUncheckedCreateNestedManyWithoutEdicionesCursosInput = {
    create?: XOR<comprasCreateWithoutEdicionesCursosInput, comprasUncheckedCreateWithoutEdicionesCursosInput> | comprasCreateWithoutEdicionesCursosInput[] | comprasUncheckedCreateWithoutEdicionesCursosInput[]
    connectOrCreate?: comprasCreateOrConnectWithoutEdicionesCursosInput | comprasCreateOrConnectWithoutEdicionesCursosInput[]
    createMany?: comprasCreateManyEdicionesCursosInputEnvelope
    connect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
  }

  export type examenesUncheckedCreateNestedManyWithoutEdicionesCursosInput = {
    create?: XOR<examenesCreateWithoutEdicionesCursosInput, examenesUncheckedCreateWithoutEdicionesCursosInput> | examenesCreateWithoutEdicionesCursosInput[] | examenesUncheckedCreateWithoutEdicionesCursosInput[]
    connectOrCreate?: examenesCreateOrConnectWithoutEdicionesCursosInput | examenesCreateOrConnectWithoutEdicionesCursosInput[]
    createMany?: examenesCreateManyEdicionesCursosInputEnvelope
    connect?: examenesWhereUniqueInput | examenesWhereUniqueInput[]
  }

  export type inscripcionesUncheckedCreateNestedManyWithoutEdicionesCursosInput = {
    create?: XOR<inscripcionesCreateWithoutEdicionesCursosInput, inscripcionesUncheckedCreateWithoutEdicionesCursosInput> | inscripcionesCreateWithoutEdicionesCursosInput[] | inscripcionesUncheckedCreateWithoutEdicionesCursosInput[]
    connectOrCreate?: inscripcionesCreateOrConnectWithoutEdicionesCursosInput | inscripcionesCreateOrConnectWithoutEdicionesCursosInput[]
    createMany?: inscripcionesCreateManyEdicionesCursosInputEnvelope
    connect?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
  }

  export type pagosDocentesUncheckedCreateNestedOneWithoutEdicionesCursosInput = {
    create?: XOR<pagosDocentesCreateWithoutEdicionesCursosInput, pagosDocentesUncheckedCreateWithoutEdicionesCursosInput>
    connectOrCreate?: pagosDocentesCreateOrConnectWithoutEdicionesCursosInput
    connect?: pagosDocentesWhereUniqueInput
  }

  export type preciosCursosUncheckedCreateNestedManyWithoutEdicionesCursosInput = {
    create?: XOR<preciosCursosCreateWithoutEdicionesCursosInput, preciosCursosUncheckedCreateWithoutEdicionesCursosInput> | preciosCursosCreateWithoutEdicionesCursosInput[] | preciosCursosUncheckedCreateWithoutEdicionesCursosInput[]
    connectOrCreate?: preciosCursosCreateOrConnectWithoutEdicionesCursosInput | preciosCursosCreateOrConnectWithoutEdicionesCursosInput[]
    createMany?: preciosCursosCreateManyEdicionesCursosInputEnvelope
    connect?: preciosCursosWhereUniqueInput | preciosCursosWhereUniqueInput[]
  }

  export type EnumEdicionEstadoFieldUpdateOperationsInput = {
    set?: $Enums.EdicionEstado
  }

  export type certificadosUpdateManyWithoutEdicionesCursosNestedInput = {
    create?: XOR<certificadosCreateWithoutEdicionesCursosInput, certificadosUncheckedCreateWithoutEdicionesCursosInput> | certificadosCreateWithoutEdicionesCursosInput[] | certificadosUncheckedCreateWithoutEdicionesCursosInput[]
    connectOrCreate?: certificadosCreateOrConnectWithoutEdicionesCursosInput | certificadosCreateOrConnectWithoutEdicionesCursosInput[]
    upsert?: certificadosUpsertWithWhereUniqueWithoutEdicionesCursosInput | certificadosUpsertWithWhereUniqueWithoutEdicionesCursosInput[]
    createMany?: certificadosCreateManyEdicionesCursosInputEnvelope
    set?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    disconnect?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    delete?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    connect?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    update?: certificadosUpdateWithWhereUniqueWithoutEdicionesCursosInput | certificadosUpdateWithWhereUniqueWithoutEdicionesCursosInput[]
    updateMany?: certificadosUpdateManyWithWhereWithoutEdicionesCursosInput | certificadosUpdateManyWithWhereWithoutEdicionesCursosInput[]
    deleteMany?: certificadosScalarWhereInput | certificadosScalarWhereInput[]
  }

  export type clasesUpdateManyWithoutEdicionesCursosNestedInput = {
    create?: XOR<clasesCreateWithoutEdicionesCursosInput, clasesUncheckedCreateWithoutEdicionesCursosInput> | clasesCreateWithoutEdicionesCursosInput[] | clasesUncheckedCreateWithoutEdicionesCursosInput[]
    connectOrCreate?: clasesCreateOrConnectWithoutEdicionesCursosInput | clasesCreateOrConnectWithoutEdicionesCursosInput[]
    upsert?: clasesUpsertWithWhereUniqueWithoutEdicionesCursosInput | clasesUpsertWithWhereUniqueWithoutEdicionesCursosInput[]
    createMany?: clasesCreateManyEdicionesCursosInputEnvelope
    set?: clasesWhereUniqueInput | clasesWhereUniqueInput[]
    disconnect?: clasesWhereUniqueInput | clasesWhereUniqueInput[]
    delete?: clasesWhereUniqueInput | clasesWhereUniqueInput[]
    connect?: clasesWhereUniqueInput | clasesWhereUniqueInput[]
    update?: clasesUpdateWithWhereUniqueWithoutEdicionesCursosInput | clasesUpdateWithWhereUniqueWithoutEdicionesCursosInput[]
    updateMany?: clasesUpdateManyWithWhereWithoutEdicionesCursosInput | clasesUpdateManyWithWhereWithoutEdicionesCursosInput[]
    deleteMany?: clasesScalarWhereInput | clasesScalarWhereInput[]
  }

  export type comprasUpdateManyWithoutEdicionesCursosNestedInput = {
    create?: XOR<comprasCreateWithoutEdicionesCursosInput, comprasUncheckedCreateWithoutEdicionesCursosInput> | comprasCreateWithoutEdicionesCursosInput[] | comprasUncheckedCreateWithoutEdicionesCursosInput[]
    connectOrCreate?: comprasCreateOrConnectWithoutEdicionesCursosInput | comprasCreateOrConnectWithoutEdicionesCursosInput[]
    upsert?: comprasUpsertWithWhereUniqueWithoutEdicionesCursosInput | comprasUpsertWithWhereUniqueWithoutEdicionesCursosInput[]
    createMany?: comprasCreateManyEdicionesCursosInputEnvelope
    set?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    disconnect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    delete?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    connect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    update?: comprasUpdateWithWhereUniqueWithoutEdicionesCursosInput | comprasUpdateWithWhereUniqueWithoutEdicionesCursosInput[]
    updateMany?: comprasUpdateManyWithWhereWithoutEdicionesCursosInput | comprasUpdateManyWithWhereWithoutEdicionesCursosInput[]
    deleteMany?: comprasScalarWhereInput | comprasScalarWhereInput[]
  }

  export type cursosUpdateOneRequiredWithoutEdicionesCursosNestedInput = {
    create?: XOR<cursosCreateWithoutEdicionesCursosInput, cursosUncheckedCreateWithoutEdicionesCursosInput>
    connectOrCreate?: cursosCreateOrConnectWithoutEdicionesCursosInput
    upsert?: cursosUpsertWithoutEdicionesCursosInput
    connect?: cursosWhereUniqueInput
    update?: XOR<XOR<cursosUpdateToOneWithWhereWithoutEdicionesCursosInput, cursosUpdateWithoutEdicionesCursosInput>, cursosUncheckedUpdateWithoutEdicionesCursosInput>
  }

  export type docenteUpdateOneWithoutEdicionesCursosNestedInput = {
    create?: XOR<docenteCreateWithoutEdicionesCursosInput, docenteUncheckedCreateWithoutEdicionesCursosInput>
    connectOrCreate?: docenteCreateOrConnectWithoutEdicionesCursosInput
    upsert?: docenteUpsertWithoutEdicionesCursosInput
    disconnect?: docenteWhereInput | boolean
    delete?: docenteWhereInput | boolean
    connect?: docenteWhereUniqueInput
    update?: XOR<XOR<docenteUpdateToOneWithWhereWithoutEdicionesCursosInput, docenteUpdateWithoutEdicionesCursosInput>, docenteUncheckedUpdateWithoutEdicionesCursosInput>
  }

  export type examenesUpdateManyWithoutEdicionesCursosNestedInput = {
    create?: XOR<examenesCreateWithoutEdicionesCursosInput, examenesUncheckedCreateWithoutEdicionesCursosInput> | examenesCreateWithoutEdicionesCursosInput[] | examenesUncheckedCreateWithoutEdicionesCursosInput[]
    connectOrCreate?: examenesCreateOrConnectWithoutEdicionesCursosInput | examenesCreateOrConnectWithoutEdicionesCursosInput[]
    upsert?: examenesUpsertWithWhereUniqueWithoutEdicionesCursosInput | examenesUpsertWithWhereUniqueWithoutEdicionesCursosInput[]
    createMany?: examenesCreateManyEdicionesCursosInputEnvelope
    set?: examenesWhereUniqueInput | examenesWhereUniqueInput[]
    disconnect?: examenesWhereUniqueInput | examenesWhereUniqueInput[]
    delete?: examenesWhereUniqueInput | examenesWhereUniqueInput[]
    connect?: examenesWhereUniqueInput | examenesWhereUniqueInput[]
    update?: examenesUpdateWithWhereUniqueWithoutEdicionesCursosInput | examenesUpdateWithWhereUniqueWithoutEdicionesCursosInput[]
    updateMany?: examenesUpdateManyWithWhereWithoutEdicionesCursosInput | examenesUpdateManyWithWhereWithoutEdicionesCursosInput[]
    deleteMany?: examenesScalarWhereInput | examenesScalarWhereInput[]
  }

  export type inscripcionesUpdateManyWithoutEdicionesCursosNestedInput = {
    create?: XOR<inscripcionesCreateWithoutEdicionesCursosInput, inscripcionesUncheckedCreateWithoutEdicionesCursosInput> | inscripcionesCreateWithoutEdicionesCursosInput[] | inscripcionesUncheckedCreateWithoutEdicionesCursosInput[]
    connectOrCreate?: inscripcionesCreateOrConnectWithoutEdicionesCursosInput | inscripcionesCreateOrConnectWithoutEdicionesCursosInput[]
    upsert?: inscripcionesUpsertWithWhereUniqueWithoutEdicionesCursosInput | inscripcionesUpsertWithWhereUniqueWithoutEdicionesCursosInput[]
    createMany?: inscripcionesCreateManyEdicionesCursosInputEnvelope
    set?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    disconnect?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    delete?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    connect?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    update?: inscripcionesUpdateWithWhereUniqueWithoutEdicionesCursosInput | inscripcionesUpdateWithWhereUniqueWithoutEdicionesCursosInput[]
    updateMany?: inscripcionesUpdateManyWithWhereWithoutEdicionesCursosInput | inscripcionesUpdateManyWithWhereWithoutEdicionesCursosInput[]
    deleteMany?: inscripcionesScalarWhereInput | inscripcionesScalarWhereInput[]
  }

  export type pagosDocentesUpdateOneWithoutEdicionesCursosNestedInput = {
    create?: XOR<pagosDocentesCreateWithoutEdicionesCursosInput, pagosDocentesUncheckedCreateWithoutEdicionesCursosInput>
    connectOrCreate?: pagosDocentesCreateOrConnectWithoutEdicionesCursosInput
    upsert?: pagosDocentesUpsertWithoutEdicionesCursosInput
    disconnect?: pagosDocentesWhereInput | boolean
    delete?: pagosDocentesWhereInput | boolean
    connect?: pagosDocentesWhereUniqueInput
    update?: XOR<XOR<pagosDocentesUpdateToOneWithWhereWithoutEdicionesCursosInput, pagosDocentesUpdateWithoutEdicionesCursosInput>, pagosDocentesUncheckedUpdateWithoutEdicionesCursosInput>
  }

  export type preciosCursosUpdateManyWithoutEdicionesCursosNestedInput = {
    create?: XOR<preciosCursosCreateWithoutEdicionesCursosInput, preciosCursosUncheckedCreateWithoutEdicionesCursosInput> | preciosCursosCreateWithoutEdicionesCursosInput[] | preciosCursosUncheckedCreateWithoutEdicionesCursosInput[]
    connectOrCreate?: preciosCursosCreateOrConnectWithoutEdicionesCursosInput | preciosCursosCreateOrConnectWithoutEdicionesCursosInput[]
    upsert?: preciosCursosUpsertWithWhereUniqueWithoutEdicionesCursosInput | preciosCursosUpsertWithWhereUniqueWithoutEdicionesCursosInput[]
    createMany?: preciosCursosCreateManyEdicionesCursosInputEnvelope
    set?: preciosCursosWhereUniqueInput | preciosCursosWhereUniqueInput[]
    disconnect?: preciosCursosWhereUniqueInput | preciosCursosWhereUniqueInput[]
    delete?: preciosCursosWhereUniqueInput | preciosCursosWhereUniqueInput[]
    connect?: preciosCursosWhereUniqueInput | preciosCursosWhereUniqueInput[]
    update?: preciosCursosUpdateWithWhereUniqueWithoutEdicionesCursosInput | preciosCursosUpdateWithWhereUniqueWithoutEdicionesCursosInput[]
    updateMany?: preciosCursosUpdateManyWithWhereWithoutEdicionesCursosInput | preciosCursosUpdateManyWithWhereWithoutEdicionesCursosInput[]
    deleteMany?: preciosCursosScalarWhereInput | preciosCursosScalarWhereInput[]
  }

  export type certificadosUncheckedUpdateManyWithoutEdicionesCursosNestedInput = {
    create?: XOR<certificadosCreateWithoutEdicionesCursosInput, certificadosUncheckedCreateWithoutEdicionesCursosInput> | certificadosCreateWithoutEdicionesCursosInput[] | certificadosUncheckedCreateWithoutEdicionesCursosInput[]
    connectOrCreate?: certificadosCreateOrConnectWithoutEdicionesCursosInput | certificadosCreateOrConnectWithoutEdicionesCursosInput[]
    upsert?: certificadosUpsertWithWhereUniqueWithoutEdicionesCursosInput | certificadosUpsertWithWhereUniqueWithoutEdicionesCursosInput[]
    createMany?: certificadosCreateManyEdicionesCursosInputEnvelope
    set?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    disconnect?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    delete?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    connect?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    update?: certificadosUpdateWithWhereUniqueWithoutEdicionesCursosInput | certificadosUpdateWithWhereUniqueWithoutEdicionesCursosInput[]
    updateMany?: certificadosUpdateManyWithWhereWithoutEdicionesCursosInput | certificadosUpdateManyWithWhereWithoutEdicionesCursosInput[]
    deleteMany?: certificadosScalarWhereInput | certificadosScalarWhereInput[]
  }

  export type clasesUncheckedUpdateManyWithoutEdicionesCursosNestedInput = {
    create?: XOR<clasesCreateWithoutEdicionesCursosInput, clasesUncheckedCreateWithoutEdicionesCursosInput> | clasesCreateWithoutEdicionesCursosInput[] | clasesUncheckedCreateWithoutEdicionesCursosInput[]
    connectOrCreate?: clasesCreateOrConnectWithoutEdicionesCursosInput | clasesCreateOrConnectWithoutEdicionesCursosInput[]
    upsert?: clasesUpsertWithWhereUniqueWithoutEdicionesCursosInput | clasesUpsertWithWhereUniqueWithoutEdicionesCursosInput[]
    createMany?: clasesCreateManyEdicionesCursosInputEnvelope
    set?: clasesWhereUniqueInput | clasesWhereUniqueInput[]
    disconnect?: clasesWhereUniqueInput | clasesWhereUniqueInput[]
    delete?: clasesWhereUniqueInput | clasesWhereUniqueInput[]
    connect?: clasesWhereUniqueInput | clasesWhereUniqueInput[]
    update?: clasesUpdateWithWhereUniqueWithoutEdicionesCursosInput | clasesUpdateWithWhereUniqueWithoutEdicionesCursosInput[]
    updateMany?: clasesUpdateManyWithWhereWithoutEdicionesCursosInput | clasesUpdateManyWithWhereWithoutEdicionesCursosInput[]
    deleteMany?: clasesScalarWhereInput | clasesScalarWhereInput[]
  }

  export type comprasUncheckedUpdateManyWithoutEdicionesCursosNestedInput = {
    create?: XOR<comprasCreateWithoutEdicionesCursosInput, comprasUncheckedCreateWithoutEdicionesCursosInput> | comprasCreateWithoutEdicionesCursosInput[] | comprasUncheckedCreateWithoutEdicionesCursosInput[]
    connectOrCreate?: comprasCreateOrConnectWithoutEdicionesCursosInput | comprasCreateOrConnectWithoutEdicionesCursosInput[]
    upsert?: comprasUpsertWithWhereUniqueWithoutEdicionesCursosInput | comprasUpsertWithWhereUniqueWithoutEdicionesCursosInput[]
    createMany?: comprasCreateManyEdicionesCursosInputEnvelope
    set?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    disconnect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    delete?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    connect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    update?: comprasUpdateWithWhereUniqueWithoutEdicionesCursosInput | comprasUpdateWithWhereUniqueWithoutEdicionesCursosInput[]
    updateMany?: comprasUpdateManyWithWhereWithoutEdicionesCursosInput | comprasUpdateManyWithWhereWithoutEdicionesCursosInput[]
    deleteMany?: comprasScalarWhereInput | comprasScalarWhereInput[]
  }

  export type examenesUncheckedUpdateManyWithoutEdicionesCursosNestedInput = {
    create?: XOR<examenesCreateWithoutEdicionesCursosInput, examenesUncheckedCreateWithoutEdicionesCursosInput> | examenesCreateWithoutEdicionesCursosInput[] | examenesUncheckedCreateWithoutEdicionesCursosInput[]
    connectOrCreate?: examenesCreateOrConnectWithoutEdicionesCursosInput | examenesCreateOrConnectWithoutEdicionesCursosInput[]
    upsert?: examenesUpsertWithWhereUniqueWithoutEdicionesCursosInput | examenesUpsertWithWhereUniqueWithoutEdicionesCursosInput[]
    createMany?: examenesCreateManyEdicionesCursosInputEnvelope
    set?: examenesWhereUniqueInput | examenesWhereUniqueInput[]
    disconnect?: examenesWhereUniqueInput | examenesWhereUniqueInput[]
    delete?: examenesWhereUniqueInput | examenesWhereUniqueInput[]
    connect?: examenesWhereUniqueInput | examenesWhereUniqueInput[]
    update?: examenesUpdateWithWhereUniqueWithoutEdicionesCursosInput | examenesUpdateWithWhereUniqueWithoutEdicionesCursosInput[]
    updateMany?: examenesUpdateManyWithWhereWithoutEdicionesCursosInput | examenesUpdateManyWithWhereWithoutEdicionesCursosInput[]
    deleteMany?: examenesScalarWhereInput | examenesScalarWhereInput[]
  }

  export type inscripcionesUncheckedUpdateManyWithoutEdicionesCursosNestedInput = {
    create?: XOR<inscripcionesCreateWithoutEdicionesCursosInput, inscripcionesUncheckedCreateWithoutEdicionesCursosInput> | inscripcionesCreateWithoutEdicionesCursosInput[] | inscripcionesUncheckedCreateWithoutEdicionesCursosInput[]
    connectOrCreate?: inscripcionesCreateOrConnectWithoutEdicionesCursosInput | inscripcionesCreateOrConnectWithoutEdicionesCursosInput[]
    upsert?: inscripcionesUpsertWithWhereUniqueWithoutEdicionesCursosInput | inscripcionesUpsertWithWhereUniqueWithoutEdicionesCursosInput[]
    createMany?: inscripcionesCreateManyEdicionesCursosInputEnvelope
    set?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    disconnect?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    delete?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    connect?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    update?: inscripcionesUpdateWithWhereUniqueWithoutEdicionesCursosInput | inscripcionesUpdateWithWhereUniqueWithoutEdicionesCursosInput[]
    updateMany?: inscripcionesUpdateManyWithWhereWithoutEdicionesCursosInput | inscripcionesUpdateManyWithWhereWithoutEdicionesCursosInput[]
    deleteMany?: inscripcionesScalarWhereInput | inscripcionesScalarWhereInput[]
  }

  export type pagosDocentesUncheckedUpdateOneWithoutEdicionesCursosNestedInput = {
    create?: XOR<pagosDocentesCreateWithoutEdicionesCursosInput, pagosDocentesUncheckedCreateWithoutEdicionesCursosInput>
    connectOrCreate?: pagosDocentesCreateOrConnectWithoutEdicionesCursosInput
    upsert?: pagosDocentesUpsertWithoutEdicionesCursosInput
    disconnect?: pagosDocentesWhereInput | boolean
    delete?: pagosDocentesWhereInput | boolean
    connect?: pagosDocentesWhereUniqueInput
    update?: XOR<XOR<pagosDocentesUpdateToOneWithWhereWithoutEdicionesCursosInput, pagosDocentesUpdateWithoutEdicionesCursosInput>, pagosDocentesUncheckedUpdateWithoutEdicionesCursosInput>
  }

  export type preciosCursosUncheckedUpdateManyWithoutEdicionesCursosNestedInput = {
    create?: XOR<preciosCursosCreateWithoutEdicionesCursosInput, preciosCursosUncheckedCreateWithoutEdicionesCursosInput> | preciosCursosCreateWithoutEdicionesCursosInput[] | preciosCursosUncheckedCreateWithoutEdicionesCursosInput[]
    connectOrCreate?: preciosCursosCreateOrConnectWithoutEdicionesCursosInput | preciosCursosCreateOrConnectWithoutEdicionesCursosInput[]
    upsert?: preciosCursosUpsertWithWhereUniqueWithoutEdicionesCursosInput | preciosCursosUpsertWithWhereUniqueWithoutEdicionesCursosInput[]
    createMany?: preciosCursosCreateManyEdicionesCursosInputEnvelope
    set?: preciosCursosWhereUniqueInput | preciosCursosWhereUniqueInput[]
    disconnect?: preciosCursosWhereUniqueInput | preciosCursosWhereUniqueInput[]
    delete?: preciosCursosWhereUniqueInput | preciosCursosWhereUniqueInput[]
    connect?: preciosCursosWhereUniqueInput | preciosCursosWhereUniqueInput[]
    update?: preciosCursosUpdateWithWhereUniqueWithoutEdicionesCursosInput | preciosCursosUpdateWithWhereUniqueWithoutEdicionesCursosInput[]
    updateMany?: preciosCursosUpdateManyWithWhereWithoutEdicionesCursosInput | preciosCursosUpdateManyWithWhereWithoutEdicionesCursosInput[]
    deleteMany?: preciosCursosScalarWhereInput | preciosCursosScalarWhereInput[]
  }

  export type calificacionesCreateNestedManyWithoutEstudiantesInput = {
    create?: XOR<calificacionesCreateWithoutEstudiantesInput, calificacionesUncheckedCreateWithoutEstudiantesInput> | calificacionesCreateWithoutEstudiantesInput[] | calificacionesUncheckedCreateWithoutEstudiantesInput[]
    connectOrCreate?: calificacionesCreateOrConnectWithoutEstudiantesInput | calificacionesCreateOrConnectWithoutEstudiantesInput[]
    createMany?: calificacionesCreateManyEstudiantesInputEnvelope
    connect?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
  }

  export type certificadosCreateNestedManyWithoutEstudiantesInput = {
    create?: XOR<certificadosCreateWithoutEstudiantesInput, certificadosUncheckedCreateWithoutEstudiantesInput> | certificadosCreateWithoutEstudiantesInput[] | certificadosUncheckedCreateWithoutEstudiantesInput[]
    connectOrCreate?: certificadosCreateOrConnectWithoutEstudiantesInput | certificadosCreateOrConnectWithoutEstudiantesInput[]
    createMany?: certificadosCreateManyEstudiantesInputEnvelope
    connect?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
  }

  export type inscripcionesCreateNestedManyWithoutEstudiantesInput = {
    create?: XOR<inscripcionesCreateWithoutEstudiantesInput, inscripcionesUncheckedCreateWithoutEstudiantesInput> | inscripcionesCreateWithoutEstudiantesInput[] | inscripcionesUncheckedCreateWithoutEstudiantesInput[]
    connectOrCreate?: inscripcionesCreateOrConnectWithoutEstudiantesInput | inscripcionesCreateOrConnectWithoutEstudiantesInput[]
    createMany?: inscripcionesCreateManyEstudiantesInputEnvelope
    connect?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
  }

  export type usuariosEstudiantesCreateNestedOneWithoutEstudiantesInput = {
    create?: XOR<usuariosEstudiantesCreateWithoutEstudiantesInput, usuariosEstudiantesUncheckedCreateWithoutEstudiantesInput>
    connectOrCreate?: usuariosEstudiantesCreateOrConnectWithoutEstudiantesInput
    connect?: usuariosEstudiantesWhereUniqueInput
  }

  export type calificacionesUncheckedCreateNestedManyWithoutEstudiantesInput = {
    create?: XOR<calificacionesCreateWithoutEstudiantesInput, calificacionesUncheckedCreateWithoutEstudiantesInput> | calificacionesCreateWithoutEstudiantesInput[] | calificacionesUncheckedCreateWithoutEstudiantesInput[]
    connectOrCreate?: calificacionesCreateOrConnectWithoutEstudiantesInput | calificacionesCreateOrConnectWithoutEstudiantesInput[]
    createMany?: calificacionesCreateManyEstudiantesInputEnvelope
    connect?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
  }

  export type certificadosUncheckedCreateNestedManyWithoutEstudiantesInput = {
    create?: XOR<certificadosCreateWithoutEstudiantesInput, certificadosUncheckedCreateWithoutEstudiantesInput> | certificadosCreateWithoutEstudiantesInput[] | certificadosUncheckedCreateWithoutEstudiantesInput[]
    connectOrCreate?: certificadosCreateOrConnectWithoutEstudiantesInput | certificadosCreateOrConnectWithoutEstudiantesInput[]
    createMany?: certificadosCreateManyEstudiantesInputEnvelope
    connect?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
  }

  export type inscripcionesUncheckedCreateNestedManyWithoutEstudiantesInput = {
    create?: XOR<inscripcionesCreateWithoutEstudiantesInput, inscripcionesUncheckedCreateWithoutEstudiantesInput> | inscripcionesCreateWithoutEstudiantesInput[] | inscripcionesUncheckedCreateWithoutEstudiantesInput[]
    connectOrCreate?: inscripcionesCreateOrConnectWithoutEstudiantesInput | inscripcionesCreateOrConnectWithoutEstudiantesInput[]
    createMany?: inscripcionesCreateManyEstudiantesInputEnvelope
    connect?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
  }

  export type usuariosEstudiantesUncheckedCreateNestedOneWithoutEstudiantesInput = {
    create?: XOR<usuariosEstudiantesCreateWithoutEstudiantesInput, usuariosEstudiantesUncheckedCreateWithoutEstudiantesInput>
    connectOrCreate?: usuariosEstudiantesCreateOrConnectWithoutEstudiantesInput
    connect?: usuariosEstudiantesWhereUniqueInput
  }

  export type EnumTipoGeneroFieldUpdateOperationsInput = {
    set?: $Enums.TipoGenero
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type calificacionesUpdateManyWithoutEstudiantesNestedInput = {
    create?: XOR<calificacionesCreateWithoutEstudiantesInput, calificacionesUncheckedCreateWithoutEstudiantesInput> | calificacionesCreateWithoutEstudiantesInput[] | calificacionesUncheckedCreateWithoutEstudiantesInput[]
    connectOrCreate?: calificacionesCreateOrConnectWithoutEstudiantesInput | calificacionesCreateOrConnectWithoutEstudiantesInput[]
    upsert?: calificacionesUpsertWithWhereUniqueWithoutEstudiantesInput | calificacionesUpsertWithWhereUniqueWithoutEstudiantesInput[]
    createMany?: calificacionesCreateManyEstudiantesInputEnvelope
    set?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    disconnect?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    delete?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    connect?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    update?: calificacionesUpdateWithWhereUniqueWithoutEstudiantesInput | calificacionesUpdateWithWhereUniqueWithoutEstudiantesInput[]
    updateMany?: calificacionesUpdateManyWithWhereWithoutEstudiantesInput | calificacionesUpdateManyWithWhereWithoutEstudiantesInput[]
    deleteMany?: calificacionesScalarWhereInput | calificacionesScalarWhereInput[]
  }

  export type certificadosUpdateManyWithoutEstudiantesNestedInput = {
    create?: XOR<certificadosCreateWithoutEstudiantesInput, certificadosUncheckedCreateWithoutEstudiantesInput> | certificadosCreateWithoutEstudiantesInput[] | certificadosUncheckedCreateWithoutEstudiantesInput[]
    connectOrCreate?: certificadosCreateOrConnectWithoutEstudiantesInput | certificadosCreateOrConnectWithoutEstudiantesInput[]
    upsert?: certificadosUpsertWithWhereUniqueWithoutEstudiantesInput | certificadosUpsertWithWhereUniqueWithoutEstudiantesInput[]
    createMany?: certificadosCreateManyEstudiantesInputEnvelope
    set?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    disconnect?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    delete?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    connect?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    update?: certificadosUpdateWithWhereUniqueWithoutEstudiantesInput | certificadosUpdateWithWhereUniqueWithoutEstudiantesInput[]
    updateMany?: certificadosUpdateManyWithWhereWithoutEstudiantesInput | certificadosUpdateManyWithWhereWithoutEstudiantesInput[]
    deleteMany?: certificadosScalarWhereInput | certificadosScalarWhereInput[]
  }

  export type inscripcionesUpdateManyWithoutEstudiantesNestedInput = {
    create?: XOR<inscripcionesCreateWithoutEstudiantesInput, inscripcionesUncheckedCreateWithoutEstudiantesInput> | inscripcionesCreateWithoutEstudiantesInput[] | inscripcionesUncheckedCreateWithoutEstudiantesInput[]
    connectOrCreate?: inscripcionesCreateOrConnectWithoutEstudiantesInput | inscripcionesCreateOrConnectWithoutEstudiantesInput[]
    upsert?: inscripcionesUpsertWithWhereUniqueWithoutEstudiantesInput | inscripcionesUpsertWithWhereUniqueWithoutEstudiantesInput[]
    createMany?: inscripcionesCreateManyEstudiantesInputEnvelope
    set?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    disconnect?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    delete?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    connect?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    update?: inscripcionesUpdateWithWhereUniqueWithoutEstudiantesInput | inscripcionesUpdateWithWhereUniqueWithoutEstudiantesInput[]
    updateMany?: inscripcionesUpdateManyWithWhereWithoutEstudiantesInput | inscripcionesUpdateManyWithWhereWithoutEstudiantesInput[]
    deleteMany?: inscripcionesScalarWhereInput | inscripcionesScalarWhereInput[]
  }

  export type usuariosEstudiantesUpdateOneWithoutEstudiantesNestedInput = {
    create?: XOR<usuariosEstudiantesCreateWithoutEstudiantesInput, usuariosEstudiantesUncheckedCreateWithoutEstudiantesInput>
    connectOrCreate?: usuariosEstudiantesCreateOrConnectWithoutEstudiantesInput
    upsert?: usuariosEstudiantesUpsertWithoutEstudiantesInput
    disconnect?: usuariosEstudiantesWhereInput | boolean
    delete?: usuariosEstudiantesWhereInput | boolean
    connect?: usuariosEstudiantesWhereUniqueInput
    update?: XOR<XOR<usuariosEstudiantesUpdateToOneWithWhereWithoutEstudiantesInput, usuariosEstudiantesUpdateWithoutEstudiantesInput>, usuariosEstudiantesUncheckedUpdateWithoutEstudiantesInput>
  }

  export type calificacionesUncheckedUpdateManyWithoutEstudiantesNestedInput = {
    create?: XOR<calificacionesCreateWithoutEstudiantesInput, calificacionesUncheckedCreateWithoutEstudiantesInput> | calificacionesCreateWithoutEstudiantesInput[] | calificacionesUncheckedCreateWithoutEstudiantesInput[]
    connectOrCreate?: calificacionesCreateOrConnectWithoutEstudiantesInput | calificacionesCreateOrConnectWithoutEstudiantesInput[]
    upsert?: calificacionesUpsertWithWhereUniqueWithoutEstudiantesInput | calificacionesUpsertWithWhereUniqueWithoutEstudiantesInput[]
    createMany?: calificacionesCreateManyEstudiantesInputEnvelope
    set?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    disconnect?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    delete?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    connect?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    update?: calificacionesUpdateWithWhereUniqueWithoutEstudiantesInput | calificacionesUpdateWithWhereUniqueWithoutEstudiantesInput[]
    updateMany?: calificacionesUpdateManyWithWhereWithoutEstudiantesInput | calificacionesUpdateManyWithWhereWithoutEstudiantesInput[]
    deleteMany?: calificacionesScalarWhereInput | calificacionesScalarWhereInput[]
  }

  export type certificadosUncheckedUpdateManyWithoutEstudiantesNestedInput = {
    create?: XOR<certificadosCreateWithoutEstudiantesInput, certificadosUncheckedCreateWithoutEstudiantesInput> | certificadosCreateWithoutEstudiantesInput[] | certificadosUncheckedCreateWithoutEstudiantesInput[]
    connectOrCreate?: certificadosCreateOrConnectWithoutEstudiantesInput | certificadosCreateOrConnectWithoutEstudiantesInput[]
    upsert?: certificadosUpsertWithWhereUniqueWithoutEstudiantesInput | certificadosUpsertWithWhereUniqueWithoutEstudiantesInput[]
    createMany?: certificadosCreateManyEstudiantesInputEnvelope
    set?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    disconnect?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    delete?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    connect?: certificadosWhereUniqueInput | certificadosWhereUniqueInput[]
    update?: certificadosUpdateWithWhereUniqueWithoutEstudiantesInput | certificadosUpdateWithWhereUniqueWithoutEstudiantesInput[]
    updateMany?: certificadosUpdateManyWithWhereWithoutEstudiantesInput | certificadosUpdateManyWithWhereWithoutEstudiantesInput[]
    deleteMany?: certificadosScalarWhereInput | certificadosScalarWhereInput[]
  }

  export type inscripcionesUncheckedUpdateManyWithoutEstudiantesNestedInput = {
    create?: XOR<inscripcionesCreateWithoutEstudiantesInput, inscripcionesUncheckedCreateWithoutEstudiantesInput> | inscripcionesCreateWithoutEstudiantesInput[] | inscripcionesUncheckedCreateWithoutEstudiantesInput[]
    connectOrCreate?: inscripcionesCreateOrConnectWithoutEstudiantesInput | inscripcionesCreateOrConnectWithoutEstudiantesInput[]
    upsert?: inscripcionesUpsertWithWhereUniqueWithoutEstudiantesInput | inscripcionesUpsertWithWhereUniqueWithoutEstudiantesInput[]
    createMany?: inscripcionesCreateManyEstudiantesInputEnvelope
    set?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    disconnect?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    delete?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    connect?: inscripcionesWhereUniqueInput | inscripcionesWhereUniqueInput[]
    update?: inscripcionesUpdateWithWhereUniqueWithoutEstudiantesInput | inscripcionesUpdateWithWhereUniqueWithoutEstudiantesInput[]
    updateMany?: inscripcionesUpdateManyWithWhereWithoutEstudiantesInput | inscripcionesUpdateManyWithWhereWithoutEstudiantesInput[]
    deleteMany?: inscripcionesScalarWhereInput | inscripcionesScalarWhereInput[]
  }

  export type usuariosEstudiantesUncheckedUpdateOneWithoutEstudiantesNestedInput = {
    create?: XOR<usuariosEstudiantesCreateWithoutEstudiantesInput, usuariosEstudiantesUncheckedCreateWithoutEstudiantesInput>
    connectOrCreate?: usuariosEstudiantesCreateOrConnectWithoutEstudiantesInput
    upsert?: usuariosEstudiantesUpsertWithoutEstudiantesInput
    disconnect?: usuariosEstudiantesWhereInput | boolean
    delete?: usuariosEstudiantesWhereInput | boolean
    connect?: usuariosEstudiantesWhereUniqueInput
    update?: XOR<XOR<usuariosEstudiantesUpdateToOneWithWhereWithoutEstudiantesInput, usuariosEstudiantesUpdateWithoutEstudiantesInput>, usuariosEstudiantesUncheckedUpdateWithoutEstudiantesInput>
  }

  export type capitulosCreateNestedOneWithoutTemasInput = {
    create?: XOR<capitulosCreateWithoutTemasInput, capitulosUncheckedCreateWithoutTemasInput>
    connectOrCreate?: capitulosCreateOrConnectWithoutTemasInput
    connect?: capitulosWhereUniqueInput
  }

  export type preguntasCreateNestedManyWithoutTemasInput = {
    create?: XOR<preguntasCreateWithoutTemasInput, preguntasUncheckedCreateWithoutTemasInput> | preguntasCreateWithoutTemasInput[] | preguntasUncheckedCreateWithoutTemasInput[]
    connectOrCreate?: preguntasCreateOrConnectWithoutTemasInput | preguntasCreateOrConnectWithoutTemasInput[]
    connect?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
  }

  export type preguntasUncheckedCreateNestedManyWithoutTemasInput = {
    create?: XOR<preguntasCreateWithoutTemasInput, preguntasUncheckedCreateWithoutTemasInput> | preguntasCreateWithoutTemasInput[] | preguntasUncheckedCreateWithoutTemasInput[]
    connectOrCreate?: preguntasCreateOrConnectWithoutTemasInput | preguntasCreateOrConnectWithoutTemasInput[]
    connect?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
  }

  export type capitulosUpdateOneWithoutTemasNestedInput = {
    create?: XOR<capitulosCreateWithoutTemasInput, capitulosUncheckedCreateWithoutTemasInput>
    connectOrCreate?: capitulosCreateOrConnectWithoutTemasInput
    upsert?: capitulosUpsertWithoutTemasInput
    disconnect?: capitulosWhereInput | boolean
    delete?: capitulosWhereInput | boolean
    connect?: capitulosWhereUniqueInput
    update?: XOR<XOR<capitulosUpdateToOneWithWhereWithoutTemasInput, capitulosUpdateWithoutTemasInput>, capitulosUncheckedUpdateWithoutTemasInput>
  }

  export type preguntasUpdateManyWithoutTemasNestedInput = {
    create?: XOR<preguntasCreateWithoutTemasInput, preguntasUncheckedCreateWithoutTemasInput> | preguntasCreateWithoutTemasInput[] | preguntasUncheckedCreateWithoutTemasInput[]
    connectOrCreate?: preguntasCreateOrConnectWithoutTemasInput | preguntasCreateOrConnectWithoutTemasInput[]
    upsert?: preguntasUpsertWithWhereUniqueWithoutTemasInput | preguntasUpsertWithWhereUniqueWithoutTemasInput[]
    set?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    disconnect?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    delete?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    connect?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    update?: preguntasUpdateWithWhereUniqueWithoutTemasInput | preguntasUpdateWithWhereUniqueWithoutTemasInput[]
    updateMany?: preguntasUpdateManyWithWhereWithoutTemasInput | preguntasUpdateManyWithWhereWithoutTemasInput[]
    deleteMany?: preguntasScalarWhereInput | preguntasScalarWhereInput[]
  }

  export type preguntasUncheckedUpdateManyWithoutTemasNestedInput = {
    create?: XOR<preguntasCreateWithoutTemasInput, preguntasUncheckedCreateWithoutTemasInput> | preguntasCreateWithoutTemasInput[] | preguntasUncheckedCreateWithoutTemasInput[]
    connectOrCreate?: preguntasCreateOrConnectWithoutTemasInput | preguntasCreateOrConnectWithoutTemasInput[]
    upsert?: preguntasUpsertWithWhereUniqueWithoutTemasInput | preguntasUpsertWithWhereUniqueWithoutTemasInput[]
    set?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    disconnect?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    delete?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    connect?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    update?: preguntasUpdateWithWhereUniqueWithoutTemasInput | preguntasUpdateWithWhereUniqueWithoutTemasInput[]
    updateMany?: preguntasUpdateManyWithWhereWithoutTemasInput | preguntasUpdateManyWithWhereWithoutTemasInput[]
    deleteMany?: preguntasScalarWhereInput | preguntasScalarWhereInput[]
  }

  export type calificacionesCreateNestedManyWithoutExamenesInput = {
    create?: XOR<calificacionesCreateWithoutExamenesInput, calificacionesUncheckedCreateWithoutExamenesInput> | calificacionesCreateWithoutExamenesInput[] | calificacionesUncheckedCreateWithoutExamenesInput[]
    connectOrCreate?: calificacionesCreateOrConnectWithoutExamenesInput | calificacionesCreateOrConnectWithoutExamenesInput[]
    createMany?: calificacionesCreateManyExamenesInputEnvelope
    connect?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
  }

  export type edicionesCursosCreateNestedOneWithoutExamenesInput = {
    create?: XOR<edicionesCursosCreateWithoutExamenesInput, edicionesCursosUncheckedCreateWithoutExamenesInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutExamenesInput
    connect?: edicionesCursosWhereUniqueInput
  }

  export type calificacionesUncheckedCreateNestedManyWithoutExamenesInput = {
    create?: XOR<calificacionesCreateWithoutExamenesInput, calificacionesUncheckedCreateWithoutExamenesInput> | calificacionesCreateWithoutExamenesInput[] | calificacionesUncheckedCreateWithoutExamenesInput[]
    connectOrCreate?: calificacionesCreateOrConnectWithoutExamenesInput | calificacionesCreateOrConnectWithoutExamenesInput[]
    createMany?: calificacionesCreateManyExamenesInputEnvelope
    connect?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
  }

  export type calificacionesUpdateManyWithoutExamenesNestedInput = {
    create?: XOR<calificacionesCreateWithoutExamenesInput, calificacionesUncheckedCreateWithoutExamenesInput> | calificacionesCreateWithoutExamenesInput[] | calificacionesUncheckedCreateWithoutExamenesInput[]
    connectOrCreate?: calificacionesCreateOrConnectWithoutExamenesInput | calificacionesCreateOrConnectWithoutExamenesInput[]
    upsert?: calificacionesUpsertWithWhereUniqueWithoutExamenesInput | calificacionesUpsertWithWhereUniqueWithoutExamenesInput[]
    createMany?: calificacionesCreateManyExamenesInputEnvelope
    set?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    disconnect?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    delete?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    connect?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    update?: calificacionesUpdateWithWhereUniqueWithoutExamenesInput | calificacionesUpdateWithWhereUniqueWithoutExamenesInput[]
    updateMany?: calificacionesUpdateManyWithWhereWithoutExamenesInput | calificacionesUpdateManyWithWhereWithoutExamenesInput[]
    deleteMany?: calificacionesScalarWhereInput | calificacionesScalarWhereInput[]
  }

  export type edicionesCursosUpdateOneRequiredWithoutExamenesNestedInput = {
    create?: XOR<edicionesCursosCreateWithoutExamenesInput, edicionesCursosUncheckedCreateWithoutExamenesInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutExamenesInput
    upsert?: edicionesCursosUpsertWithoutExamenesInput
    connect?: edicionesCursosWhereUniqueInput
    update?: XOR<XOR<edicionesCursosUpdateToOneWithWhereWithoutExamenesInput, edicionesCursosUpdateWithoutExamenesInput>, edicionesCursosUncheckedUpdateWithoutExamenesInput>
  }

  export type calificacionesUncheckedUpdateManyWithoutExamenesNestedInput = {
    create?: XOR<calificacionesCreateWithoutExamenesInput, calificacionesUncheckedCreateWithoutExamenesInput> | calificacionesCreateWithoutExamenesInput[] | calificacionesUncheckedCreateWithoutExamenesInput[]
    connectOrCreate?: calificacionesCreateOrConnectWithoutExamenesInput | calificacionesCreateOrConnectWithoutExamenesInput[]
    upsert?: calificacionesUpsertWithWhereUniqueWithoutExamenesInput | calificacionesUpsertWithWhereUniqueWithoutExamenesInput[]
    createMany?: calificacionesCreateManyExamenesInputEnvelope
    set?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    disconnect?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    delete?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    connect?: calificacionesWhereUniqueInput | calificacionesWhereUniqueInput[]
    update?: calificacionesUpdateWithWhereUniqueWithoutExamenesInput | calificacionesUpdateWithWhereUniqueWithoutExamenesInput[]
    updateMany?: calificacionesUpdateManyWithWhereWithoutExamenesInput | calificacionesUpdateManyWithWhereWithoutExamenesInput[]
    deleteMany?: calificacionesScalarWhereInput | calificacionesScalarWhereInput[]
  }

  export type clasesCreateNestedOneWithoutGrabacionesInput = {
    create?: XOR<clasesCreateWithoutGrabacionesInput, clasesUncheckedCreateWithoutGrabacionesInput>
    connectOrCreate?: clasesCreateOrConnectWithoutGrabacionesInput
    connect?: clasesWhereUniqueInput
  }

  export type usuariosAdministradoresCreateNestedOneWithoutGrabacionesInput = {
    create?: XOR<usuariosAdministradoresCreateWithoutGrabacionesInput, usuariosAdministradoresUncheckedCreateWithoutGrabacionesInput>
    connectOrCreate?: usuariosAdministradoresCreateOrConnectWithoutGrabacionesInput
    connect?: usuariosAdministradoresWhereUniqueInput
  }

  export type clasesUpdateOneRequiredWithoutGrabacionesNestedInput = {
    create?: XOR<clasesCreateWithoutGrabacionesInput, clasesUncheckedCreateWithoutGrabacionesInput>
    connectOrCreate?: clasesCreateOrConnectWithoutGrabacionesInput
    upsert?: clasesUpsertWithoutGrabacionesInput
    connect?: clasesWhereUniqueInput
    update?: XOR<XOR<clasesUpdateToOneWithWhereWithoutGrabacionesInput, clasesUpdateWithoutGrabacionesInput>, clasesUncheckedUpdateWithoutGrabacionesInput>
  }

  export type usuariosAdministradoresUpdateOneRequiredWithoutGrabacionesNestedInput = {
    create?: XOR<usuariosAdministradoresCreateWithoutGrabacionesInput, usuariosAdministradoresUncheckedCreateWithoutGrabacionesInput>
    connectOrCreate?: usuariosAdministradoresCreateOrConnectWithoutGrabacionesInput
    upsert?: usuariosAdministradoresUpsertWithoutGrabacionesInput
    connect?: usuariosAdministradoresWhereUniqueInput
    update?: XOR<XOR<usuariosAdministradoresUpdateToOneWithWhereWithoutGrabacionesInput, usuariosAdministradoresUpdateWithoutGrabacionesInput>, usuariosAdministradoresUncheckedUpdateWithoutGrabacionesInput>
  }

  export type comprasCreateNestedOneWithoutInscripcionesInput = {
    create?: XOR<comprasCreateWithoutInscripcionesInput, comprasUncheckedCreateWithoutInscripcionesInput>
    connectOrCreate?: comprasCreateOrConnectWithoutInscripcionesInput
    connect?: comprasWhereUniqueInput
  }

  export type edicionesCursosCreateNestedOneWithoutInscripcionesInput = {
    create?: XOR<edicionesCursosCreateWithoutInscripcionesInput, edicionesCursosUncheckedCreateWithoutInscripcionesInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutInscripcionesInput
    connect?: edicionesCursosWhereUniqueInput
  }

  export type estudiantesCreateNestedOneWithoutInscripcionesInput = {
    create?: XOR<estudiantesCreateWithoutInscripcionesInput, estudiantesUncheckedCreateWithoutInscripcionesInput>
    connectOrCreate?: estudiantesCreateOrConnectWithoutInscripcionesInput
    connect?: estudiantesWhereUniqueInput
  }

  export type comprasUpdateOneRequiredWithoutInscripcionesNestedInput = {
    create?: XOR<comprasCreateWithoutInscripcionesInput, comprasUncheckedCreateWithoutInscripcionesInput>
    connectOrCreate?: comprasCreateOrConnectWithoutInscripcionesInput
    upsert?: comprasUpsertWithoutInscripcionesInput
    connect?: comprasWhereUniqueInput
    update?: XOR<XOR<comprasUpdateToOneWithWhereWithoutInscripcionesInput, comprasUpdateWithoutInscripcionesInput>, comprasUncheckedUpdateWithoutInscripcionesInput>
  }

  export type edicionesCursosUpdateOneRequiredWithoutInscripcionesNestedInput = {
    create?: XOR<edicionesCursosCreateWithoutInscripcionesInput, edicionesCursosUncheckedCreateWithoutInscripcionesInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutInscripcionesInput
    upsert?: edicionesCursosUpsertWithoutInscripcionesInput
    connect?: edicionesCursosWhereUniqueInput
    update?: XOR<XOR<edicionesCursosUpdateToOneWithWhereWithoutInscripcionesInput, edicionesCursosUpdateWithoutInscripcionesInput>, edicionesCursosUncheckedUpdateWithoutInscripcionesInput>
  }

  export type estudiantesUpdateOneRequiredWithoutInscripcionesNestedInput = {
    create?: XOR<estudiantesCreateWithoutInscripcionesInput, estudiantesUncheckedCreateWithoutInscripcionesInput>
    connectOrCreate?: estudiantesCreateOrConnectWithoutInscripcionesInput
    upsert?: estudiantesUpsertWithoutInscripcionesInput
    connect?: estudiantesWhereUniqueInput
    update?: XOR<XOR<estudiantesUpdateToOneWithWhereWithoutInscripcionesInput, estudiantesUpdateWithoutInscripcionesInput>, estudiantesUncheckedUpdateWithoutInscripcionesInput>
  }

  export type clasesCreateNestedOneWithoutMaterialesInput = {
    create?: XOR<clasesCreateWithoutMaterialesInput, clasesUncheckedCreateWithoutMaterialesInput>
    connectOrCreate?: clasesCreateOrConnectWithoutMaterialesInput
    connect?: clasesWhereUniqueInput
  }

  export type EnumTipoMaterialFieldUpdateOperationsInput = {
    set?: $Enums.TipoMaterial
  }

  export type clasesUpdateOneRequiredWithoutMaterialesNestedInput = {
    create?: XOR<clasesCreateWithoutMaterialesInput, clasesUncheckedCreateWithoutMaterialesInput>
    connectOrCreate?: clasesCreateOrConnectWithoutMaterialesInput
    upsert?: clasesUpsertWithoutMaterialesInput
    connect?: clasesWhereUniqueInput
    update?: XOR<XOR<clasesUpdateToOneWithWhereWithoutMaterialesInput, clasesUpdateWithoutMaterialesInput>, clasesUncheckedUpdateWithoutMaterialesInput>
  }

  export type cursosCreateNestedOneWithoutObjetivosCursosInput = {
    create?: XOR<cursosCreateWithoutObjetivosCursosInput, cursosUncheckedCreateWithoutObjetivosCursosInput>
    connectOrCreate?: cursosCreateOrConnectWithoutObjetivosCursosInput
    connect?: cursosWhereUniqueInput
  }

  export type cursosUpdateOneRequiredWithoutObjetivosCursosNestedInput = {
    create?: XOR<cursosCreateWithoutObjetivosCursosInput, cursosUncheckedCreateWithoutObjetivosCursosInput>
    connectOrCreate?: cursosCreateOrConnectWithoutObjetivosCursosInput
    upsert?: cursosUpsertWithoutObjetivosCursosInput
    connect?: cursosWhereUniqueInput
    update?: XOR<XOR<cursosUpdateToOneWithWhereWithoutObjetivosCursosInput, cursosUpdateWithoutObjetivosCursosInput>, cursosUncheckedUpdateWithoutObjetivosCursosInput>
  }

  export type docenteCreateNestedOneWithoutPagosDocentesInput = {
    create?: XOR<docenteCreateWithoutPagosDocentesInput, docenteUncheckedCreateWithoutPagosDocentesInput>
    connectOrCreate?: docenteCreateOrConnectWithoutPagosDocentesInput
    connect?: docenteWhereUniqueInput
  }

  export type edicionesCursosCreateNestedOneWithoutPagosDocentesInput = {
    create?: XOR<edicionesCursosCreateWithoutPagosDocentesInput, edicionesCursosUncheckedCreateWithoutPagosDocentesInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutPagosDocentesInput
    connect?: edicionesCursosWhereUniqueInput
  }

  export type docenteUpdateOneRequiredWithoutPagosDocentesNestedInput = {
    create?: XOR<docenteCreateWithoutPagosDocentesInput, docenteUncheckedCreateWithoutPagosDocentesInput>
    connectOrCreate?: docenteCreateOrConnectWithoutPagosDocentesInput
    upsert?: docenteUpsertWithoutPagosDocentesInput
    connect?: docenteWhereUniqueInput
    update?: XOR<XOR<docenteUpdateToOneWithWhereWithoutPagosDocentesInput, docenteUpdateWithoutPagosDocentesInput>, docenteUncheckedUpdateWithoutPagosDocentesInput>
  }

  export type edicionesCursosUpdateOneRequiredWithoutPagosDocentesNestedInput = {
    create?: XOR<edicionesCursosCreateWithoutPagosDocentesInput, edicionesCursosUncheckedCreateWithoutPagosDocentesInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutPagosDocentesInput
    upsert?: edicionesCursosUpsertWithoutPagosDocentesInput
    connect?: edicionesCursosWhereUniqueInput
    update?: XOR<XOR<edicionesCursosUpdateToOneWithWhereWithoutPagosDocentesInput, edicionesCursosUpdateWithoutPagosDocentesInput>, edicionesCursosUncheckedUpdateWithoutPagosDocentesInput>
  }

  export type edicionesCursosCreateNestedOneWithoutPreciosCursosInput = {
    create?: XOR<edicionesCursosCreateWithoutPreciosCursosInput, edicionesCursosUncheckedCreateWithoutPreciosCursosInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutPreciosCursosInput
    connect?: edicionesCursosWhereUniqueInput
  }

  export type edicionesCursosUpdateOneRequiredWithoutPreciosCursosNestedInput = {
    create?: XOR<edicionesCursosCreateWithoutPreciosCursosInput, edicionesCursosUncheckedCreateWithoutPreciosCursosInput>
    connectOrCreate?: edicionesCursosCreateOrConnectWithoutPreciosCursosInput
    upsert?: edicionesCursosUpsertWithoutPreciosCursosInput
    connect?: edicionesCursosWhereUniqueInput
    update?: XOR<XOR<edicionesCursosUpdateToOneWithWhereWithoutPreciosCursosInput, edicionesCursosUpdateWithoutPreciosCursosInput>, edicionesCursosUncheckedUpdateWithoutPreciosCursosInput>
  }

  export type reaccionesPreguntasCreateNestedManyWithoutPreguntaInput = {
    create?: XOR<reaccionesPreguntasCreateWithoutPreguntaInput, reaccionesPreguntasUncheckedCreateWithoutPreguntaInput> | reaccionesPreguntasCreateWithoutPreguntaInput[] | reaccionesPreguntasUncheckedCreateWithoutPreguntaInput[]
    connectOrCreate?: reaccionesPreguntasCreateOrConnectWithoutPreguntaInput | reaccionesPreguntasCreateOrConnectWithoutPreguntaInput[]
    createMany?: reaccionesPreguntasCreateManyPreguntaInputEnvelope
    connect?: reaccionesPreguntasWhereUniqueInput | reaccionesPreguntasWhereUniqueInput[]
  }

  export type repasoRegistrosCreateNestedManyWithoutPreguntasInput = {
    create?: XOR<repasoRegistrosCreateWithoutPreguntasInput, repasoRegistrosUncheckedCreateWithoutPreguntasInput> | repasoRegistrosCreateWithoutPreguntasInput[] | repasoRegistrosUncheckedCreateWithoutPreguntasInput[]
    connectOrCreate?: repasoRegistrosCreateOrConnectWithoutPreguntasInput | repasoRegistrosCreateOrConnectWithoutPreguntasInput[]
    createMany?: repasoRegistrosCreateManyPreguntasInputEnvelope
    connect?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
  }

  export type respuestasIntentosCreateNestedManyWithoutPreguntasInput = {
    create?: XOR<respuestasIntentosCreateWithoutPreguntasInput, respuestasIntentosUncheckedCreateWithoutPreguntasInput> | respuestasIntentosCreateWithoutPreguntasInput[] | respuestasIntentosUncheckedCreateWithoutPreguntasInput[]
    connectOrCreate?: respuestasIntentosCreateOrConnectWithoutPreguntasInput | respuestasIntentosCreateOrConnectWithoutPreguntasInput[]
    createMany?: respuestasIntentosCreateManyPreguntasInputEnvelope
    connect?: respuestasIntentosWhereUniqueInput | respuestasIntentosWhereUniqueInput[]
  }

  export type areasCreateNestedManyWithoutPreguntasInput = {
    create?: XOR<areasCreateWithoutPreguntasInput, areasUncheckedCreateWithoutPreguntasInput> | areasCreateWithoutPreguntasInput[] | areasUncheckedCreateWithoutPreguntasInput[]
    connectOrCreate?: areasCreateOrConnectWithoutPreguntasInput | areasCreateOrConnectWithoutPreguntasInput[]
    connect?: areasWhereUniqueInput | areasWhereUniqueInput[]
  }

  export type banqueoCreateNestedManyWithoutPreguntasInput = {
    create?: XOR<banqueoCreateWithoutPreguntasInput, banqueoUncheckedCreateWithoutPreguntasInput> | banqueoCreateWithoutPreguntasInput[] | banqueoUncheckedCreateWithoutPreguntasInput[]
    connectOrCreate?: banqueoCreateOrConnectWithoutPreguntasInput | banqueoCreateOrConnectWithoutPreguntasInput[]
    connect?: banqueoWhereUniqueInput | banqueoWhereUniqueInput[]
  }

  export type capitulosCreateNestedManyWithoutPreguntasInput = {
    create?: XOR<capitulosCreateWithoutPreguntasInput, capitulosUncheckedCreateWithoutPreguntasInput> | capitulosCreateWithoutPreguntasInput[] | capitulosUncheckedCreateWithoutPreguntasInput[]
    connectOrCreate?: capitulosCreateOrConnectWithoutPreguntasInput | capitulosCreateOrConnectWithoutPreguntasInput[]
    connect?: capitulosWhereUniqueInput | capitulosWhereUniqueInput[]
  }

  export type temasCreateNestedManyWithoutPreguntasInput = {
    create?: XOR<temasCreateWithoutPreguntasInput, temasUncheckedCreateWithoutPreguntasInput> | temasCreateWithoutPreguntasInput[] | temasUncheckedCreateWithoutPreguntasInput[]
    connectOrCreate?: temasCreateOrConnectWithoutPreguntasInput | temasCreateOrConnectWithoutPreguntasInput[]
    connect?: temasWhereUniqueInput | temasWhereUniqueInput[]
  }

  export type reaccionesPreguntasUncheckedCreateNestedManyWithoutPreguntaInput = {
    create?: XOR<reaccionesPreguntasCreateWithoutPreguntaInput, reaccionesPreguntasUncheckedCreateWithoutPreguntaInput> | reaccionesPreguntasCreateWithoutPreguntaInput[] | reaccionesPreguntasUncheckedCreateWithoutPreguntaInput[]
    connectOrCreate?: reaccionesPreguntasCreateOrConnectWithoutPreguntaInput | reaccionesPreguntasCreateOrConnectWithoutPreguntaInput[]
    createMany?: reaccionesPreguntasCreateManyPreguntaInputEnvelope
    connect?: reaccionesPreguntasWhereUniqueInput | reaccionesPreguntasWhereUniqueInput[]
  }

  export type repasoRegistrosUncheckedCreateNestedManyWithoutPreguntasInput = {
    create?: XOR<repasoRegistrosCreateWithoutPreguntasInput, repasoRegistrosUncheckedCreateWithoutPreguntasInput> | repasoRegistrosCreateWithoutPreguntasInput[] | repasoRegistrosUncheckedCreateWithoutPreguntasInput[]
    connectOrCreate?: repasoRegistrosCreateOrConnectWithoutPreguntasInput | repasoRegistrosCreateOrConnectWithoutPreguntasInput[]
    createMany?: repasoRegistrosCreateManyPreguntasInputEnvelope
    connect?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
  }

  export type respuestasIntentosUncheckedCreateNestedManyWithoutPreguntasInput = {
    create?: XOR<respuestasIntentosCreateWithoutPreguntasInput, respuestasIntentosUncheckedCreateWithoutPreguntasInput> | respuestasIntentosCreateWithoutPreguntasInput[] | respuestasIntentosUncheckedCreateWithoutPreguntasInput[]
    connectOrCreate?: respuestasIntentosCreateOrConnectWithoutPreguntasInput | respuestasIntentosCreateOrConnectWithoutPreguntasInput[]
    createMany?: respuestasIntentosCreateManyPreguntasInputEnvelope
    connect?: respuestasIntentosWhereUniqueInput | respuestasIntentosWhereUniqueInput[]
  }

  export type areasUncheckedCreateNestedManyWithoutPreguntasInput = {
    create?: XOR<areasCreateWithoutPreguntasInput, areasUncheckedCreateWithoutPreguntasInput> | areasCreateWithoutPreguntasInput[] | areasUncheckedCreateWithoutPreguntasInput[]
    connectOrCreate?: areasCreateOrConnectWithoutPreguntasInput | areasCreateOrConnectWithoutPreguntasInput[]
    connect?: areasWhereUniqueInput | areasWhereUniqueInput[]
  }

  export type banqueoUncheckedCreateNestedManyWithoutPreguntasInput = {
    create?: XOR<banqueoCreateWithoutPreguntasInput, banqueoUncheckedCreateWithoutPreguntasInput> | banqueoCreateWithoutPreguntasInput[] | banqueoUncheckedCreateWithoutPreguntasInput[]
    connectOrCreate?: banqueoCreateOrConnectWithoutPreguntasInput | banqueoCreateOrConnectWithoutPreguntasInput[]
    connect?: banqueoWhereUniqueInput | banqueoWhereUniqueInput[]
  }

  export type capitulosUncheckedCreateNestedManyWithoutPreguntasInput = {
    create?: XOR<capitulosCreateWithoutPreguntasInput, capitulosUncheckedCreateWithoutPreguntasInput> | capitulosCreateWithoutPreguntasInput[] | capitulosUncheckedCreateWithoutPreguntasInput[]
    connectOrCreate?: capitulosCreateOrConnectWithoutPreguntasInput | capitulosCreateOrConnectWithoutPreguntasInput[]
    connect?: capitulosWhereUniqueInput | capitulosWhereUniqueInput[]
  }

  export type temasUncheckedCreateNestedManyWithoutPreguntasInput = {
    create?: XOR<temasCreateWithoutPreguntasInput, temasUncheckedCreateWithoutPreguntasInput> | temasCreateWithoutPreguntasInput[] | temasUncheckedCreateWithoutPreguntasInput[]
    connectOrCreate?: temasCreateOrConnectWithoutPreguntasInput | temasCreateOrConnectWithoutPreguntasInput[]
    connect?: temasWhereUniqueInput | temasWhereUniqueInput[]
  }

  export type EnumPreguntaEstadoFieldUpdateOperationsInput = {
    set?: $Enums.PreguntaEstado
  }

  export type EnumPreguntaDificultadFieldUpdateOperationsInput = {
    set?: $Enums.PreguntaDificultad
  }

  export type reaccionesPreguntasUpdateManyWithoutPreguntaNestedInput = {
    create?: XOR<reaccionesPreguntasCreateWithoutPreguntaInput, reaccionesPreguntasUncheckedCreateWithoutPreguntaInput> | reaccionesPreguntasCreateWithoutPreguntaInput[] | reaccionesPreguntasUncheckedCreateWithoutPreguntaInput[]
    connectOrCreate?: reaccionesPreguntasCreateOrConnectWithoutPreguntaInput | reaccionesPreguntasCreateOrConnectWithoutPreguntaInput[]
    upsert?: reaccionesPreguntasUpsertWithWhereUniqueWithoutPreguntaInput | reaccionesPreguntasUpsertWithWhereUniqueWithoutPreguntaInput[]
    createMany?: reaccionesPreguntasCreateManyPreguntaInputEnvelope
    set?: reaccionesPreguntasWhereUniqueInput | reaccionesPreguntasWhereUniqueInput[]
    disconnect?: reaccionesPreguntasWhereUniqueInput | reaccionesPreguntasWhereUniqueInput[]
    delete?: reaccionesPreguntasWhereUniqueInput | reaccionesPreguntasWhereUniqueInput[]
    connect?: reaccionesPreguntasWhereUniqueInput | reaccionesPreguntasWhereUniqueInput[]
    update?: reaccionesPreguntasUpdateWithWhereUniqueWithoutPreguntaInput | reaccionesPreguntasUpdateWithWhereUniqueWithoutPreguntaInput[]
    updateMany?: reaccionesPreguntasUpdateManyWithWhereWithoutPreguntaInput | reaccionesPreguntasUpdateManyWithWhereWithoutPreguntaInput[]
    deleteMany?: reaccionesPreguntasScalarWhereInput | reaccionesPreguntasScalarWhereInput[]
  }

  export type repasoRegistrosUpdateManyWithoutPreguntasNestedInput = {
    create?: XOR<repasoRegistrosCreateWithoutPreguntasInput, repasoRegistrosUncheckedCreateWithoutPreguntasInput> | repasoRegistrosCreateWithoutPreguntasInput[] | repasoRegistrosUncheckedCreateWithoutPreguntasInput[]
    connectOrCreate?: repasoRegistrosCreateOrConnectWithoutPreguntasInput | repasoRegistrosCreateOrConnectWithoutPreguntasInput[]
    upsert?: repasoRegistrosUpsertWithWhereUniqueWithoutPreguntasInput | repasoRegistrosUpsertWithWhereUniqueWithoutPreguntasInput[]
    createMany?: repasoRegistrosCreateManyPreguntasInputEnvelope
    set?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
    disconnect?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
    delete?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
    connect?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
    update?: repasoRegistrosUpdateWithWhereUniqueWithoutPreguntasInput | repasoRegistrosUpdateWithWhereUniqueWithoutPreguntasInput[]
    updateMany?: repasoRegistrosUpdateManyWithWhereWithoutPreguntasInput | repasoRegistrosUpdateManyWithWhereWithoutPreguntasInput[]
    deleteMany?: repasoRegistrosScalarWhereInput | repasoRegistrosScalarWhereInput[]
  }

  export type respuestasIntentosUpdateManyWithoutPreguntasNestedInput = {
    create?: XOR<respuestasIntentosCreateWithoutPreguntasInput, respuestasIntentosUncheckedCreateWithoutPreguntasInput> | respuestasIntentosCreateWithoutPreguntasInput[] | respuestasIntentosUncheckedCreateWithoutPreguntasInput[]
    connectOrCreate?: respuestasIntentosCreateOrConnectWithoutPreguntasInput | respuestasIntentosCreateOrConnectWithoutPreguntasInput[]
    upsert?: respuestasIntentosUpsertWithWhereUniqueWithoutPreguntasInput | respuestasIntentosUpsertWithWhereUniqueWithoutPreguntasInput[]
    createMany?: respuestasIntentosCreateManyPreguntasInputEnvelope
    set?: respuestasIntentosWhereUniqueInput | respuestasIntentosWhereUniqueInput[]
    disconnect?: respuestasIntentosWhereUniqueInput | respuestasIntentosWhereUniqueInput[]
    delete?: respuestasIntentosWhereUniqueInput | respuestasIntentosWhereUniqueInput[]
    connect?: respuestasIntentosWhereUniqueInput | respuestasIntentosWhereUniqueInput[]
    update?: respuestasIntentosUpdateWithWhereUniqueWithoutPreguntasInput | respuestasIntentosUpdateWithWhereUniqueWithoutPreguntasInput[]
    updateMany?: respuestasIntentosUpdateManyWithWhereWithoutPreguntasInput | respuestasIntentosUpdateManyWithWhereWithoutPreguntasInput[]
    deleteMany?: respuestasIntentosScalarWhereInput | respuestasIntentosScalarWhereInput[]
  }

  export type areasUpdateManyWithoutPreguntasNestedInput = {
    create?: XOR<areasCreateWithoutPreguntasInput, areasUncheckedCreateWithoutPreguntasInput> | areasCreateWithoutPreguntasInput[] | areasUncheckedCreateWithoutPreguntasInput[]
    connectOrCreate?: areasCreateOrConnectWithoutPreguntasInput | areasCreateOrConnectWithoutPreguntasInput[]
    upsert?: areasUpsertWithWhereUniqueWithoutPreguntasInput | areasUpsertWithWhereUniqueWithoutPreguntasInput[]
    set?: areasWhereUniqueInput | areasWhereUniqueInput[]
    disconnect?: areasWhereUniqueInput | areasWhereUniqueInput[]
    delete?: areasWhereUniqueInput | areasWhereUniqueInput[]
    connect?: areasWhereUniqueInput | areasWhereUniqueInput[]
    update?: areasUpdateWithWhereUniqueWithoutPreguntasInput | areasUpdateWithWhereUniqueWithoutPreguntasInput[]
    updateMany?: areasUpdateManyWithWhereWithoutPreguntasInput | areasUpdateManyWithWhereWithoutPreguntasInput[]
    deleteMany?: areasScalarWhereInput | areasScalarWhereInput[]
  }

  export type banqueoUpdateManyWithoutPreguntasNestedInput = {
    create?: XOR<banqueoCreateWithoutPreguntasInput, banqueoUncheckedCreateWithoutPreguntasInput> | banqueoCreateWithoutPreguntasInput[] | banqueoUncheckedCreateWithoutPreguntasInput[]
    connectOrCreate?: banqueoCreateOrConnectWithoutPreguntasInput | banqueoCreateOrConnectWithoutPreguntasInput[]
    upsert?: banqueoUpsertWithWhereUniqueWithoutPreguntasInput | banqueoUpsertWithWhereUniqueWithoutPreguntasInput[]
    set?: banqueoWhereUniqueInput | banqueoWhereUniqueInput[]
    disconnect?: banqueoWhereUniqueInput | banqueoWhereUniqueInput[]
    delete?: banqueoWhereUniqueInput | banqueoWhereUniqueInput[]
    connect?: banqueoWhereUniqueInput | banqueoWhereUniqueInput[]
    update?: banqueoUpdateWithWhereUniqueWithoutPreguntasInput | banqueoUpdateWithWhereUniqueWithoutPreguntasInput[]
    updateMany?: banqueoUpdateManyWithWhereWithoutPreguntasInput | banqueoUpdateManyWithWhereWithoutPreguntasInput[]
    deleteMany?: banqueoScalarWhereInput | banqueoScalarWhereInput[]
  }

  export type capitulosUpdateManyWithoutPreguntasNestedInput = {
    create?: XOR<capitulosCreateWithoutPreguntasInput, capitulosUncheckedCreateWithoutPreguntasInput> | capitulosCreateWithoutPreguntasInput[] | capitulosUncheckedCreateWithoutPreguntasInput[]
    connectOrCreate?: capitulosCreateOrConnectWithoutPreguntasInput | capitulosCreateOrConnectWithoutPreguntasInput[]
    upsert?: capitulosUpsertWithWhereUniqueWithoutPreguntasInput | capitulosUpsertWithWhereUniqueWithoutPreguntasInput[]
    set?: capitulosWhereUniqueInput | capitulosWhereUniqueInput[]
    disconnect?: capitulosWhereUniqueInput | capitulosWhereUniqueInput[]
    delete?: capitulosWhereUniqueInput | capitulosWhereUniqueInput[]
    connect?: capitulosWhereUniqueInput | capitulosWhereUniqueInput[]
    update?: capitulosUpdateWithWhereUniqueWithoutPreguntasInput | capitulosUpdateWithWhereUniqueWithoutPreguntasInput[]
    updateMany?: capitulosUpdateManyWithWhereWithoutPreguntasInput | capitulosUpdateManyWithWhereWithoutPreguntasInput[]
    deleteMany?: capitulosScalarWhereInput | capitulosScalarWhereInput[]
  }

  export type temasUpdateManyWithoutPreguntasNestedInput = {
    create?: XOR<temasCreateWithoutPreguntasInput, temasUncheckedCreateWithoutPreguntasInput> | temasCreateWithoutPreguntasInput[] | temasUncheckedCreateWithoutPreguntasInput[]
    connectOrCreate?: temasCreateOrConnectWithoutPreguntasInput | temasCreateOrConnectWithoutPreguntasInput[]
    upsert?: temasUpsertWithWhereUniqueWithoutPreguntasInput | temasUpsertWithWhereUniqueWithoutPreguntasInput[]
    set?: temasWhereUniqueInput | temasWhereUniqueInput[]
    disconnect?: temasWhereUniqueInput | temasWhereUniqueInput[]
    delete?: temasWhereUniqueInput | temasWhereUniqueInput[]
    connect?: temasWhereUniqueInput | temasWhereUniqueInput[]
    update?: temasUpdateWithWhereUniqueWithoutPreguntasInput | temasUpdateWithWhereUniqueWithoutPreguntasInput[]
    updateMany?: temasUpdateManyWithWhereWithoutPreguntasInput | temasUpdateManyWithWhereWithoutPreguntasInput[]
    deleteMany?: temasScalarWhereInput | temasScalarWhereInput[]
  }

  export type reaccionesPreguntasUncheckedUpdateManyWithoutPreguntaNestedInput = {
    create?: XOR<reaccionesPreguntasCreateWithoutPreguntaInput, reaccionesPreguntasUncheckedCreateWithoutPreguntaInput> | reaccionesPreguntasCreateWithoutPreguntaInput[] | reaccionesPreguntasUncheckedCreateWithoutPreguntaInput[]
    connectOrCreate?: reaccionesPreguntasCreateOrConnectWithoutPreguntaInput | reaccionesPreguntasCreateOrConnectWithoutPreguntaInput[]
    upsert?: reaccionesPreguntasUpsertWithWhereUniqueWithoutPreguntaInput | reaccionesPreguntasUpsertWithWhereUniqueWithoutPreguntaInput[]
    createMany?: reaccionesPreguntasCreateManyPreguntaInputEnvelope
    set?: reaccionesPreguntasWhereUniqueInput | reaccionesPreguntasWhereUniqueInput[]
    disconnect?: reaccionesPreguntasWhereUniqueInput | reaccionesPreguntasWhereUniqueInput[]
    delete?: reaccionesPreguntasWhereUniqueInput | reaccionesPreguntasWhereUniqueInput[]
    connect?: reaccionesPreguntasWhereUniqueInput | reaccionesPreguntasWhereUniqueInput[]
    update?: reaccionesPreguntasUpdateWithWhereUniqueWithoutPreguntaInput | reaccionesPreguntasUpdateWithWhereUniqueWithoutPreguntaInput[]
    updateMany?: reaccionesPreguntasUpdateManyWithWhereWithoutPreguntaInput | reaccionesPreguntasUpdateManyWithWhereWithoutPreguntaInput[]
    deleteMany?: reaccionesPreguntasScalarWhereInput | reaccionesPreguntasScalarWhereInput[]
  }

  export type repasoRegistrosUncheckedUpdateManyWithoutPreguntasNestedInput = {
    create?: XOR<repasoRegistrosCreateWithoutPreguntasInput, repasoRegistrosUncheckedCreateWithoutPreguntasInput> | repasoRegistrosCreateWithoutPreguntasInput[] | repasoRegistrosUncheckedCreateWithoutPreguntasInput[]
    connectOrCreate?: repasoRegistrosCreateOrConnectWithoutPreguntasInput | repasoRegistrosCreateOrConnectWithoutPreguntasInput[]
    upsert?: repasoRegistrosUpsertWithWhereUniqueWithoutPreguntasInput | repasoRegistrosUpsertWithWhereUniqueWithoutPreguntasInput[]
    createMany?: repasoRegistrosCreateManyPreguntasInputEnvelope
    set?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
    disconnect?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
    delete?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
    connect?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
    update?: repasoRegistrosUpdateWithWhereUniqueWithoutPreguntasInput | repasoRegistrosUpdateWithWhereUniqueWithoutPreguntasInput[]
    updateMany?: repasoRegistrosUpdateManyWithWhereWithoutPreguntasInput | repasoRegistrosUpdateManyWithWhereWithoutPreguntasInput[]
    deleteMany?: repasoRegistrosScalarWhereInput | repasoRegistrosScalarWhereInput[]
  }

  export type respuestasIntentosUncheckedUpdateManyWithoutPreguntasNestedInput = {
    create?: XOR<respuestasIntentosCreateWithoutPreguntasInput, respuestasIntentosUncheckedCreateWithoutPreguntasInput> | respuestasIntentosCreateWithoutPreguntasInput[] | respuestasIntentosUncheckedCreateWithoutPreguntasInput[]
    connectOrCreate?: respuestasIntentosCreateOrConnectWithoutPreguntasInput | respuestasIntentosCreateOrConnectWithoutPreguntasInput[]
    upsert?: respuestasIntentosUpsertWithWhereUniqueWithoutPreguntasInput | respuestasIntentosUpsertWithWhereUniqueWithoutPreguntasInput[]
    createMany?: respuestasIntentosCreateManyPreguntasInputEnvelope
    set?: respuestasIntentosWhereUniqueInput | respuestasIntentosWhereUniqueInput[]
    disconnect?: respuestasIntentosWhereUniqueInput | respuestasIntentosWhereUniqueInput[]
    delete?: respuestasIntentosWhereUniqueInput | respuestasIntentosWhereUniqueInput[]
    connect?: respuestasIntentosWhereUniqueInput | respuestasIntentosWhereUniqueInput[]
    update?: respuestasIntentosUpdateWithWhereUniqueWithoutPreguntasInput | respuestasIntentosUpdateWithWhereUniqueWithoutPreguntasInput[]
    updateMany?: respuestasIntentosUpdateManyWithWhereWithoutPreguntasInput | respuestasIntentosUpdateManyWithWhereWithoutPreguntasInput[]
    deleteMany?: respuestasIntentosScalarWhereInput | respuestasIntentosScalarWhereInput[]
  }

  export type areasUncheckedUpdateManyWithoutPreguntasNestedInput = {
    create?: XOR<areasCreateWithoutPreguntasInput, areasUncheckedCreateWithoutPreguntasInput> | areasCreateWithoutPreguntasInput[] | areasUncheckedCreateWithoutPreguntasInput[]
    connectOrCreate?: areasCreateOrConnectWithoutPreguntasInput | areasCreateOrConnectWithoutPreguntasInput[]
    upsert?: areasUpsertWithWhereUniqueWithoutPreguntasInput | areasUpsertWithWhereUniqueWithoutPreguntasInput[]
    set?: areasWhereUniqueInput | areasWhereUniqueInput[]
    disconnect?: areasWhereUniqueInput | areasWhereUniqueInput[]
    delete?: areasWhereUniqueInput | areasWhereUniqueInput[]
    connect?: areasWhereUniqueInput | areasWhereUniqueInput[]
    update?: areasUpdateWithWhereUniqueWithoutPreguntasInput | areasUpdateWithWhereUniqueWithoutPreguntasInput[]
    updateMany?: areasUpdateManyWithWhereWithoutPreguntasInput | areasUpdateManyWithWhereWithoutPreguntasInput[]
    deleteMany?: areasScalarWhereInput | areasScalarWhereInput[]
  }

  export type banqueoUncheckedUpdateManyWithoutPreguntasNestedInput = {
    create?: XOR<banqueoCreateWithoutPreguntasInput, banqueoUncheckedCreateWithoutPreguntasInput> | banqueoCreateWithoutPreguntasInput[] | banqueoUncheckedCreateWithoutPreguntasInput[]
    connectOrCreate?: banqueoCreateOrConnectWithoutPreguntasInput | banqueoCreateOrConnectWithoutPreguntasInput[]
    upsert?: banqueoUpsertWithWhereUniqueWithoutPreguntasInput | banqueoUpsertWithWhereUniqueWithoutPreguntasInput[]
    set?: banqueoWhereUniqueInput | banqueoWhereUniqueInput[]
    disconnect?: banqueoWhereUniqueInput | banqueoWhereUniqueInput[]
    delete?: banqueoWhereUniqueInput | banqueoWhereUniqueInput[]
    connect?: banqueoWhereUniqueInput | banqueoWhereUniqueInput[]
    update?: banqueoUpdateWithWhereUniqueWithoutPreguntasInput | banqueoUpdateWithWhereUniqueWithoutPreguntasInput[]
    updateMany?: banqueoUpdateManyWithWhereWithoutPreguntasInput | banqueoUpdateManyWithWhereWithoutPreguntasInput[]
    deleteMany?: banqueoScalarWhereInput | banqueoScalarWhereInput[]
  }

  export type capitulosUncheckedUpdateManyWithoutPreguntasNestedInput = {
    create?: XOR<capitulosCreateWithoutPreguntasInput, capitulosUncheckedCreateWithoutPreguntasInput> | capitulosCreateWithoutPreguntasInput[] | capitulosUncheckedCreateWithoutPreguntasInput[]
    connectOrCreate?: capitulosCreateOrConnectWithoutPreguntasInput | capitulosCreateOrConnectWithoutPreguntasInput[]
    upsert?: capitulosUpsertWithWhereUniqueWithoutPreguntasInput | capitulosUpsertWithWhereUniqueWithoutPreguntasInput[]
    set?: capitulosWhereUniqueInput | capitulosWhereUniqueInput[]
    disconnect?: capitulosWhereUniqueInput | capitulosWhereUniqueInput[]
    delete?: capitulosWhereUniqueInput | capitulosWhereUniqueInput[]
    connect?: capitulosWhereUniqueInput | capitulosWhereUniqueInput[]
    update?: capitulosUpdateWithWhereUniqueWithoutPreguntasInput | capitulosUpdateWithWhereUniqueWithoutPreguntasInput[]
    updateMany?: capitulosUpdateManyWithWhereWithoutPreguntasInput | capitulosUpdateManyWithWhereWithoutPreguntasInput[]
    deleteMany?: capitulosScalarWhereInput | capitulosScalarWhereInput[]
  }

  export type temasUncheckedUpdateManyWithoutPreguntasNestedInput = {
    create?: XOR<temasCreateWithoutPreguntasInput, temasUncheckedCreateWithoutPreguntasInput> | temasCreateWithoutPreguntasInput[] | temasUncheckedCreateWithoutPreguntasInput[]
    connectOrCreate?: temasCreateOrConnectWithoutPreguntasInput | temasCreateOrConnectWithoutPreguntasInput[]
    upsert?: temasUpsertWithWhereUniqueWithoutPreguntasInput | temasUpsertWithWhereUniqueWithoutPreguntasInput[]
    set?: temasWhereUniqueInput | temasWhereUniqueInput[]
    disconnect?: temasWhereUniqueInput | temasWhereUniqueInput[]
    delete?: temasWhereUniqueInput | temasWhereUniqueInput[]
    connect?: temasWhereUniqueInput | temasWhereUniqueInput[]
    update?: temasUpdateWithWhereUniqueWithoutPreguntasInput | temasUpdateWithWhereUniqueWithoutPreguntasInput[]
    updateMany?: temasUpdateManyWithWhereWithoutPreguntasInput | temasUpdateManyWithWhereWithoutPreguntasInput[]
    deleteMany?: temasScalarWhereInput | temasScalarWhereInput[]
  }

  export type preguntasCreateNestedOneWithoutReaccionesPreguntasInput = {
    create?: XOR<preguntasCreateWithoutReaccionesPreguntasInput, preguntasUncheckedCreateWithoutReaccionesPreguntasInput>
    connectOrCreate?: preguntasCreateOrConnectWithoutReaccionesPreguntasInput
    connect?: preguntasWhereUniqueInput
  }

  export type usuariosEstudiantesCreateNestedOneWithoutReaccionesPreguntasInput = {
    create?: XOR<usuariosEstudiantesCreateWithoutReaccionesPreguntasInput, usuariosEstudiantesUncheckedCreateWithoutReaccionesPreguntasInput>
    connectOrCreate?: usuariosEstudiantesCreateOrConnectWithoutReaccionesPreguntasInput
    connect?: usuariosEstudiantesWhereUniqueInput
  }

  export type EnumTipoReaccionFieldUpdateOperationsInput = {
    set?: $Enums.TipoReaccion
  }

  export type preguntasUpdateOneRequiredWithoutReaccionesPreguntasNestedInput = {
    create?: XOR<preguntasCreateWithoutReaccionesPreguntasInput, preguntasUncheckedCreateWithoutReaccionesPreguntasInput>
    connectOrCreate?: preguntasCreateOrConnectWithoutReaccionesPreguntasInput
    upsert?: preguntasUpsertWithoutReaccionesPreguntasInput
    connect?: preguntasWhereUniqueInput
    update?: XOR<XOR<preguntasUpdateToOneWithWhereWithoutReaccionesPreguntasInput, preguntasUpdateWithoutReaccionesPreguntasInput>, preguntasUncheckedUpdateWithoutReaccionesPreguntasInput>
  }

  export type usuariosEstudiantesUpdateOneRequiredWithoutReaccionesPreguntasNestedInput = {
    create?: XOR<usuariosEstudiantesCreateWithoutReaccionesPreguntasInput, usuariosEstudiantesUncheckedCreateWithoutReaccionesPreguntasInput>
    connectOrCreate?: usuariosEstudiantesCreateOrConnectWithoutReaccionesPreguntasInput
    upsert?: usuariosEstudiantesUpsertWithoutReaccionesPreguntasInput
    connect?: usuariosEstudiantesWhereUniqueInput
    update?: XOR<XOR<usuariosEstudiantesUpdateToOneWithWhereWithoutReaccionesPreguntasInput, usuariosEstudiantesUpdateWithoutReaccionesPreguntasInput>, usuariosEstudiantesUncheckedUpdateWithoutReaccionesPreguntasInput>
  }

  export type cursosCreateNestedOneWithoutRequisitosCursosInput = {
    create?: XOR<cursosCreateWithoutRequisitosCursosInput, cursosUncheckedCreateWithoutRequisitosCursosInput>
    connectOrCreate?: cursosCreateOrConnectWithoutRequisitosCursosInput
    connect?: cursosWhereUniqueInput
  }

  export type cursosUpdateOneRequiredWithoutRequisitosCursosNestedInput = {
    create?: XOR<cursosCreateWithoutRequisitosCursosInput, cursosUncheckedCreateWithoutRequisitosCursosInput>
    connectOrCreate?: cursosCreateOrConnectWithoutRequisitosCursosInput
    upsert?: cursosUpsertWithoutRequisitosCursosInput
    connect?: cursosWhereUniqueInput
    update?: XOR<XOR<cursosUpdateToOneWithWhereWithoutRequisitosCursosInput, cursosUpdateWithoutRequisitosCursosInput>, cursosUncheckedUpdateWithoutRequisitosCursosInput>
  }

  export type cursosCreateNestedOneWithoutReviewsCursosInput = {
    create?: XOR<cursosCreateWithoutReviewsCursosInput, cursosUncheckedCreateWithoutReviewsCursosInput>
    connectOrCreate?: cursosCreateOrConnectWithoutReviewsCursosInput
    connect?: cursosWhereUniqueInput
  }

  export type usuariosEstudiantesCreateNestedOneWithoutReviewsCursosInput = {
    create?: XOR<usuariosEstudiantesCreateWithoutReviewsCursosInput, usuariosEstudiantesUncheckedCreateWithoutReviewsCursosInput>
    connectOrCreate?: usuariosEstudiantesCreateOrConnectWithoutReviewsCursosInput
    connect?: usuariosEstudiantesWhereUniqueInput
  }

  export type cursosUpdateOneRequiredWithoutReviewsCursosNestedInput = {
    create?: XOR<cursosCreateWithoutReviewsCursosInput, cursosUncheckedCreateWithoutReviewsCursosInput>
    connectOrCreate?: cursosCreateOrConnectWithoutReviewsCursosInput
    upsert?: cursosUpsertWithoutReviewsCursosInput
    connect?: cursosWhereUniqueInput
    update?: XOR<XOR<cursosUpdateToOneWithWhereWithoutReviewsCursosInput, cursosUpdateWithoutReviewsCursosInput>, cursosUncheckedUpdateWithoutReviewsCursosInput>
  }

  export type usuariosEstudiantesUpdateOneWithoutReviewsCursosNestedInput = {
    create?: XOR<usuariosEstudiantesCreateWithoutReviewsCursosInput, usuariosEstudiantesUncheckedCreateWithoutReviewsCursosInput>
    connectOrCreate?: usuariosEstudiantesCreateOrConnectWithoutReviewsCursosInput
    upsert?: usuariosEstudiantesUpsertWithoutReviewsCursosInput
    disconnect?: usuariosEstudiantesWhereInput | boolean
    delete?: usuariosEstudiantesWhereInput | boolean
    connect?: usuariosEstudiantesWhereUniqueInput
    update?: XOR<XOR<usuariosEstudiantesUpdateToOneWithWhereWithoutReviewsCursosInput, usuariosEstudiantesUpdateWithoutReviewsCursosInput>, usuariosEstudiantesUncheckedUpdateWithoutReviewsCursosInput>
  }

  export type auditoriaCreateNestedManyWithoutUsuariosAdministradoresInput = {
    create?: XOR<auditoriaCreateWithoutUsuariosAdministradoresInput, auditoriaUncheckedCreateWithoutUsuariosAdministradoresInput> | auditoriaCreateWithoutUsuariosAdministradoresInput[] | auditoriaUncheckedCreateWithoutUsuariosAdministradoresInput[]
    connectOrCreate?: auditoriaCreateOrConnectWithoutUsuariosAdministradoresInput | auditoriaCreateOrConnectWithoutUsuariosAdministradoresInput[]
    createMany?: auditoriaCreateManyUsuariosAdministradoresInputEnvelope
    connect?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
  }

  export type docenteCreateNestedOneWithoutUsuariosAdministradoresInput = {
    create?: XOR<docenteCreateWithoutUsuariosAdministradoresInput, docenteUncheckedCreateWithoutUsuariosAdministradoresInput>
    connectOrCreate?: docenteCreateOrConnectWithoutUsuariosAdministradoresInput
    connect?: docenteWhereUniqueInput
  }

  export type grabacionesCreateNestedManyWithoutUsuariosAdministradoresInput = {
    create?: XOR<grabacionesCreateWithoutUsuariosAdministradoresInput, grabacionesUncheckedCreateWithoutUsuariosAdministradoresInput> | grabacionesCreateWithoutUsuariosAdministradoresInput[] | grabacionesUncheckedCreateWithoutUsuariosAdministradoresInput[]
    connectOrCreate?: grabacionesCreateOrConnectWithoutUsuariosAdministradoresInput | grabacionesCreateOrConnectWithoutUsuariosAdministradoresInput[]
    createMany?: grabacionesCreateManyUsuariosAdministradoresInputEnvelope
    connect?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
  }

  export type auditoriaUncheckedCreateNestedManyWithoutUsuariosAdministradoresInput = {
    create?: XOR<auditoriaCreateWithoutUsuariosAdministradoresInput, auditoriaUncheckedCreateWithoutUsuariosAdministradoresInput> | auditoriaCreateWithoutUsuariosAdministradoresInput[] | auditoriaUncheckedCreateWithoutUsuariosAdministradoresInput[]
    connectOrCreate?: auditoriaCreateOrConnectWithoutUsuariosAdministradoresInput | auditoriaCreateOrConnectWithoutUsuariosAdministradoresInput[]
    createMany?: auditoriaCreateManyUsuariosAdministradoresInputEnvelope
    connect?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
  }

  export type docenteUncheckedCreateNestedOneWithoutUsuariosAdministradoresInput = {
    create?: XOR<docenteCreateWithoutUsuariosAdministradoresInput, docenteUncheckedCreateWithoutUsuariosAdministradoresInput>
    connectOrCreate?: docenteCreateOrConnectWithoutUsuariosAdministradoresInput
    connect?: docenteWhereUniqueInput
  }

  export type grabacionesUncheckedCreateNestedManyWithoutUsuariosAdministradoresInput = {
    create?: XOR<grabacionesCreateWithoutUsuariosAdministradoresInput, grabacionesUncheckedCreateWithoutUsuariosAdministradoresInput> | grabacionesCreateWithoutUsuariosAdministradoresInput[] | grabacionesUncheckedCreateWithoutUsuariosAdministradoresInput[]
    connectOrCreate?: grabacionesCreateOrConnectWithoutUsuariosAdministradoresInput | grabacionesCreateOrConnectWithoutUsuariosAdministradoresInput[]
    createMany?: grabacionesCreateManyUsuariosAdministradoresInputEnvelope
    connect?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
  }

  export type EnumTipoCuentaFieldUpdateOperationsInput = {
    set?: $Enums.TipoCuenta
  }

  export type auditoriaUpdateManyWithoutUsuariosAdministradoresNestedInput = {
    create?: XOR<auditoriaCreateWithoutUsuariosAdministradoresInput, auditoriaUncheckedCreateWithoutUsuariosAdministradoresInput> | auditoriaCreateWithoutUsuariosAdministradoresInput[] | auditoriaUncheckedCreateWithoutUsuariosAdministradoresInput[]
    connectOrCreate?: auditoriaCreateOrConnectWithoutUsuariosAdministradoresInput | auditoriaCreateOrConnectWithoutUsuariosAdministradoresInput[]
    upsert?: auditoriaUpsertWithWhereUniqueWithoutUsuariosAdministradoresInput | auditoriaUpsertWithWhereUniqueWithoutUsuariosAdministradoresInput[]
    createMany?: auditoriaCreateManyUsuariosAdministradoresInputEnvelope
    set?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
    disconnect?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
    delete?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
    connect?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
    update?: auditoriaUpdateWithWhereUniqueWithoutUsuariosAdministradoresInput | auditoriaUpdateWithWhereUniqueWithoutUsuariosAdministradoresInput[]
    updateMany?: auditoriaUpdateManyWithWhereWithoutUsuariosAdministradoresInput | auditoriaUpdateManyWithWhereWithoutUsuariosAdministradoresInput[]
    deleteMany?: auditoriaScalarWhereInput | auditoriaScalarWhereInput[]
  }

  export type docenteUpdateOneWithoutUsuariosAdministradoresNestedInput = {
    create?: XOR<docenteCreateWithoutUsuariosAdministradoresInput, docenteUncheckedCreateWithoutUsuariosAdministradoresInput>
    connectOrCreate?: docenteCreateOrConnectWithoutUsuariosAdministradoresInput
    upsert?: docenteUpsertWithoutUsuariosAdministradoresInput
    disconnect?: docenteWhereInput | boolean
    delete?: docenteWhereInput | boolean
    connect?: docenteWhereUniqueInput
    update?: XOR<XOR<docenteUpdateToOneWithWhereWithoutUsuariosAdministradoresInput, docenteUpdateWithoutUsuariosAdministradoresInput>, docenteUncheckedUpdateWithoutUsuariosAdministradoresInput>
  }

  export type grabacionesUpdateManyWithoutUsuariosAdministradoresNestedInput = {
    create?: XOR<grabacionesCreateWithoutUsuariosAdministradoresInput, grabacionesUncheckedCreateWithoutUsuariosAdministradoresInput> | grabacionesCreateWithoutUsuariosAdministradoresInput[] | grabacionesUncheckedCreateWithoutUsuariosAdministradoresInput[]
    connectOrCreate?: grabacionesCreateOrConnectWithoutUsuariosAdministradoresInput | grabacionesCreateOrConnectWithoutUsuariosAdministradoresInput[]
    upsert?: grabacionesUpsertWithWhereUniqueWithoutUsuariosAdministradoresInput | grabacionesUpsertWithWhereUniqueWithoutUsuariosAdministradoresInput[]
    createMany?: grabacionesCreateManyUsuariosAdministradoresInputEnvelope
    set?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    disconnect?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    delete?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    connect?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    update?: grabacionesUpdateWithWhereUniqueWithoutUsuariosAdministradoresInput | grabacionesUpdateWithWhereUniqueWithoutUsuariosAdministradoresInput[]
    updateMany?: grabacionesUpdateManyWithWhereWithoutUsuariosAdministradoresInput | grabacionesUpdateManyWithWhereWithoutUsuariosAdministradoresInput[]
    deleteMany?: grabacionesScalarWhereInput | grabacionesScalarWhereInput[]
  }

  export type auditoriaUncheckedUpdateManyWithoutUsuariosAdministradoresNestedInput = {
    create?: XOR<auditoriaCreateWithoutUsuariosAdministradoresInput, auditoriaUncheckedCreateWithoutUsuariosAdministradoresInput> | auditoriaCreateWithoutUsuariosAdministradoresInput[] | auditoriaUncheckedCreateWithoutUsuariosAdministradoresInput[]
    connectOrCreate?: auditoriaCreateOrConnectWithoutUsuariosAdministradoresInput | auditoriaCreateOrConnectWithoutUsuariosAdministradoresInput[]
    upsert?: auditoriaUpsertWithWhereUniqueWithoutUsuariosAdministradoresInput | auditoriaUpsertWithWhereUniqueWithoutUsuariosAdministradoresInput[]
    createMany?: auditoriaCreateManyUsuariosAdministradoresInputEnvelope
    set?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
    disconnect?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
    delete?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
    connect?: auditoriaWhereUniqueInput | auditoriaWhereUniqueInput[]
    update?: auditoriaUpdateWithWhereUniqueWithoutUsuariosAdministradoresInput | auditoriaUpdateWithWhereUniqueWithoutUsuariosAdministradoresInput[]
    updateMany?: auditoriaUpdateManyWithWhereWithoutUsuariosAdministradoresInput | auditoriaUpdateManyWithWhereWithoutUsuariosAdministradoresInput[]
    deleteMany?: auditoriaScalarWhereInput | auditoriaScalarWhereInput[]
  }

  export type docenteUncheckedUpdateOneWithoutUsuariosAdministradoresNestedInput = {
    create?: XOR<docenteCreateWithoutUsuariosAdministradoresInput, docenteUncheckedCreateWithoutUsuariosAdministradoresInput>
    connectOrCreate?: docenteCreateOrConnectWithoutUsuariosAdministradoresInput
    upsert?: docenteUpsertWithoutUsuariosAdministradoresInput
    disconnect?: docenteWhereInput | boolean
    delete?: docenteWhereInput | boolean
    connect?: docenteWhereUniqueInput
    update?: XOR<XOR<docenteUpdateToOneWithWhereWithoutUsuariosAdministradoresInput, docenteUpdateWithoutUsuariosAdministradoresInput>, docenteUncheckedUpdateWithoutUsuariosAdministradoresInput>
  }

  export type grabacionesUncheckedUpdateManyWithoutUsuariosAdministradoresNestedInput = {
    create?: XOR<grabacionesCreateWithoutUsuariosAdministradoresInput, grabacionesUncheckedCreateWithoutUsuariosAdministradoresInput> | grabacionesCreateWithoutUsuariosAdministradoresInput[] | grabacionesUncheckedCreateWithoutUsuariosAdministradoresInput[]
    connectOrCreate?: grabacionesCreateOrConnectWithoutUsuariosAdministradoresInput | grabacionesCreateOrConnectWithoutUsuariosAdministradoresInput[]
    upsert?: grabacionesUpsertWithWhereUniqueWithoutUsuariosAdministradoresInput | grabacionesUpsertWithWhereUniqueWithoutUsuariosAdministradoresInput[]
    createMany?: grabacionesCreateManyUsuariosAdministradoresInputEnvelope
    set?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    disconnect?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    delete?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    connect?: grabacionesWhereUniqueInput | grabacionesWhereUniqueInput[]
    update?: grabacionesUpdateWithWhereUniqueWithoutUsuariosAdministradoresInput | grabacionesUpdateWithWhereUniqueWithoutUsuariosAdministradoresInput[]
    updateMany?: grabacionesUpdateManyWithWhereWithoutUsuariosAdministradoresInput | grabacionesUpdateManyWithWhereWithoutUsuariosAdministradoresInput[]
    deleteMany?: grabacionesScalarWhereInput | grabacionesScalarWhereInput[]
  }

  export type comprasCreateNestedManyWithoutUsuariosEstudiantesInput = {
    create?: XOR<comprasCreateWithoutUsuariosEstudiantesInput, comprasUncheckedCreateWithoutUsuariosEstudiantesInput> | comprasCreateWithoutUsuariosEstudiantesInput[] | comprasUncheckedCreateWithoutUsuariosEstudiantesInput[]
    connectOrCreate?: comprasCreateOrConnectWithoutUsuariosEstudiantesInput | comprasCreateOrConnectWithoutUsuariosEstudiantesInput[]
    createMany?: comprasCreateManyUsuariosEstudiantesInputEnvelope
    connect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
  }

  export type intentosCreateNestedManyWithoutUsuariosEstudiantesInput = {
    create?: XOR<intentosCreateWithoutUsuariosEstudiantesInput, intentosUncheckedCreateWithoutUsuariosEstudiantesInput> | intentosCreateWithoutUsuariosEstudiantesInput[] | intentosUncheckedCreateWithoutUsuariosEstudiantesInput[]
    connectOrCreate?: intentosCreateOrConnectWithoutUsuariosEstudiantesInput | intentosCreateOrConnectWithoutUsuariosEstudiantesInput[]
    createMany?: intentosCreateManyUsuariosEstudiantesInputEnvelope
    connect?: intentosWhereUniqueInput | intentosWhereUniqueInput[]
  }

  export type reaccionesPreguntasCreateNestedManyWithoutUsuariosEstudiantesInput = {
    create?: XOR<reaccionesPreguntasCreateWithoutUsuariosEstudiantesInput, reaccionesPreguntasUncheckedCreateWithoutUsuariosEstudiantesInput> | reaccionesPreguntasCreateWithoutUsuariosEstudiantesInput[] | reaccionesPreguntasUncheckedCreateWithoutUsuariosEstudiantesInput[]
    connectOrCreate?: reaccionesPreguntasCreateOrConnectWithoutUsuariosEstudiantesInput | reaccionesPreguntasCreateOrConnectWithoutUsuariosEstudiantesInput[]
    createMany?: reaccionesPreguntasCreateManyUsuariosEstudiantesInputEnvelope
    connect?: reaccionesPreguntasWhereUniqueInput | reaccionesPreguntasWhereUniqueInput[]
  }

  export type repasoRegistrosCreateNestedManyWithoutUsuariosEstudiantesInput = {
    create?: XOR<repasoRegistrosCreateWithoutUsuariosEstudiantesInput, repasoRegistrosUncheckedCreateWithoutUsuariosEstudiantesInput> | repasoRegistrosCreateWithoutUsuariosEstudiantesInput[] | repasoRegistrosUncheckedCreateWithoutUsuariosEstudiantesInput[]
    connectOrCreate?: repasoRegistrosCreateOrConnectWithoutUsuariosEstudiantesInput | repasoRegistrosCreateOrConnectWithoutUsuariosEstudiantesInput[]
    createMany?: repasoRegistrosCreateManyUsuariosEstudiantesInputEnvelope
    connect?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
  }

  export type reviewsCursosCreateNestedManyWithoutUsuariosEstudiantesInput = {
    create?: XOR<reviewsCursosCreateWithoutUsuariosEstudiantesInput, reviewsCursosUncheckedCreateWithoutUsuariosEstudiantesInput> | reviewsCursosCreateWithoutUsuariosEstudiantesInput[] | reviewsCursosUncheckedCreateWithoutUsuariosEstudiantesInput[]
    connectOrCreate?: reviewsCursosCreateOrConnectWithoutUsuariosEstudiantesInput | reviewsCursosCreateOrConnectWithoutUsuariosEstudiantesInput[]
    createMany?: reviewsCursosCreateManyUsuariosEstudiantesInputEnvelope
    connect?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
  }

  export type suscripcionesCreateNestedManyWithoutUsuariosEstudiantesInput = {
    create?: XOR<suscripcionesCreateWithoutUsuariosEstudiantesInput, suscripcionesUncheckedCreateWithoutUsuariosEstudiantesInput> | suscripcionesCreateWithoutUsuariosEstudiantesInput[] | suscripcionesUncheckedCreateWithoutUsuariosEstudiantesInput[]
    connectOrCreate?: suscripcionesCreateOrConnectWithoutUsuariosEstudiantesInput | suscripcionesCreateOrConnectWithoutUsuariosEstudiantesInput[]
    createMany?: suscripcionesCreateManyUsuariosEstudiantesInputEnvelope
    connect?: suscripcionesWhereUniqueInput | suscripcionesWhereUniqueInput[]
  }

  export type estudiantesCreateNestedOneWithoutUsuariosEstudiantesInput = {
    create?: XOR<estudiantesCreateWithoutUsuariosEstudiantesInput, estudiantesUncheckedCreateWithoutUsuariosEstudiantesInput>
    connectOrCreate?: estudiantesCreateOrConnectWithoutUsuariosEstudiantesInput
    connect?: estudiantesWhereUniqueInput
  }

  export type comprasUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput = {
    create?: XOR<comprasCreateWithoutUsuariosEstudiantesInput, comprasUncheckedCreateWithoutUsuariosEstudiantesInput> | comprasCreateWithoutUsuariosEstudiantesInput[] | comprasUncheckedCreateWithoutUsuariosEstudiantesInput[]
    connectOrCreate?: comprasCreateOrConnectWithoutUsuariosEstudiantesInput | comprasCreateOrConnectWithoutUsuariosEstudiantesInput[]
    createMany?: comprasCreateManyUsuariosEstudiantesInputEnvelope
    connect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
  }

  export type intentosUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput = {
    create?: XOR<intentosCreateWithoutUsuariosEstudiantesInput, intentosUncheckedCreateWithoutUsuariosEstudiantesInput> | intentosCreateWithoutUsuariosEstudiantesInput[] | intentosUncheckedCreateWithoutUsuariosEstudiantesInput[]
    connectOrCreate?: intentosCreateOrConnectWithoutUsuariosEstudiantesInput | intentosCreateOrConnectWithoutUsuariosEstudiantesInput[]
    createMany?: intentosCreateManyUsuariosEstudiantesInputEnvelope
    connect?: intentosWhereUniqueInput | intentosWhereUniqueInput[]
  }

  export type reaccionesPreguntasUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput = {
    create?: XOR<reaccionesPreguntasCreateWithoutUsuariosEstudiantesInput, reaccionesPreguntasUncheckedCreateWithoutUsuariosEstudiantesInput> | reaccionesPreguntasCreateWithoutUsuariosEstudiantesInput[] | reaccionesPreguntasUncheckedCreateWithoutUsuariosEstudiantesInput[]
    connectOrCreate?: reaccionesPreguntasCreateOrConnectWithoutUsuariosEstudiantesInput | reaccionesPreguntasCreateOrConnectWithoutUsuariosEstudiantesInput[]
    createMany?: reaccionesPreguntasCreateManyUsuariosEstudiantesInputEnvelope
    connect?: reaccionesPreguntasWhereUniqueInput | reaccionesPreguntasWhereUniqueInput[]
  }

  export type repasoRegistrosUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput = {
    create?: XOR<repasoRegistrosCreateWithoutUsuariosEstudiantesInput, repasoRegistrosUncheckedCreateWithoutUsuariosEstudiantesInput> | repasoRegistrosCreateWithoutUsuariosEstudiantesInput[] | repasoRegistrosUncheckedCreateWithoutUsuariosEstudiantesInput[]
    connectOrCreate?: repasoRegistrosCreateOrConnectWithoutUsuariosEstudiantesInput | repasoRegistrosCreateOrConnectWithoutUsuariosEstudiantesInput[]
    createMany?: repasoRegistrosCreateManyUsuariosEstudiantesInputEnvelope
    connect?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
  }

  export type reviewsCursosUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput = {
    create?: XOR<reviewsCursosCreateWithoutUsuariosEstudiantesInput, reviewsCursosUncheckedCreateWithoutUsuariosEstudiantesInput> | reviewsCursosCreateWithoutUsuariosEstudiantesInput[] | reviewsCursosUncheckedCreateWithoutUsuariosEstudiantesInput[]
    connectOrCreate?: reviewsCursosCreateOrConnectWithoutUsuariosEstudiantesInput | reviewsCursosCreateOrConnectWithoutUsuariosEstudiantesInput[]
    createMany?: reviewsCursosCreateManyUsuariosEstudiantesInputEnvelope
    connect?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
  }

  export type suscripcionesUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput = {
    create?: XOR<suscripcionesCreateWithoutUsuariosEstudiantesInput, suscripcionesUncheckedCreateWithoutUsuariosEstudiantesInput> | suscripcionesCreateWithoutUsuariosEstudiantesInput[] | suscripcionesUncheckedCreateWithoutUsuariosEstudiantesInput[]
    connectOrCreate?: suscripcionesCreateOrConnectWithoutUsuariosEstudiantesInput | suscripcionesCreateOrConnectWithoutUsuariosEstudiantesInput[]
    createMany?: suscripcionesCreateManyUsuariosEstudiantesInputEnvelope
    connect?: suscripcionesWhereUniqueInput | suscripcionesWhereUniqueInput[]
  }

  export type comprasUpdateManyWithoutUsuariosEstudiantesNestedInput = {
    create?: XOR<comprasCreateWithoutUsuariosEstudiantesInput, comprasUncheckedCreateWithoutUsuariosEstudiantesInput> | comprasCreateWithoutUsuariosEstudiantesInput[] | comprasUncheckedCreateWithoutUsuariosEstudiantesInput[]
    connectOrCreate?: comprasCreateOrConnectWithoutUsuariosEstudiantesInput | comprasCreateOrConnectWithoutUsuariosEstudiantesInput[]
    upsert?: comprasUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput | comprasUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput[]
    createMany?: comprasCreateManyUsuariosEstudiantesInputEnvelope
    set?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    disconnect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    delete?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    connect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    update?: comprasUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput | comprasUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput[]
    updateMany?: comprasUpdateManyWithWhereWithoutUsuariosEstudiantesInput | comprasUpdateManyWithWhereWithoutUsuariosEstudiantesInput[]
    deleteMany?: comprasScalarWhereInput | comprasScalarWhereInput[]
  }

  export type intentosUpdateManyWithoutUsuariosEstudiantesNestedInput = {
    create?: XOR<intentosCreateWithoutUsuariosEstudiantesInput, intentosUncheckedCreateWithoutUsuariosEstudiantesInput> | intentosCreateWithoutUsuariosEstudiantesInput[] | intentosUncheckedCreateWithoutUsuariosEstudiantesInput[]
    connectOrCreate?: intentosCreateOrConnectWithoutUsuariosEstudiantesInput | intentosCreateOrConnectWithoutUsuariosEstudiantesInput[]
    upsert?: intentosUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput | intentosUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput[]
    createMany?: intentosCreateManyUsuariosEstudiantesInputEnvelope
    set?: intentosWhereUniqueInput | intentosWhereUniqueInput[]
    disconnect?: intentosWhereUniqueInput | intentosWhereUniqueInput[]
    delete?: intentosWhereUniqueInput | intentosWhereUniqueInput[]
    connect?: intentosWhereUniqueInput | intentosWhereUniqueInput[]
    update?: intentosUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput | intentosUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput[]
    updateMany?: intentosUpdateManyWithWhereWithoutUsuariosEstudiantesInput | intentosUpdateManyWithWhereWithoutUsuariosEstudiantesInput[]
    deleteMany?: intentosScalarWhereInput | intentosScalarWhereInput[]
  }

  export type reaccionesPreguntasUpdateManyWithoutUsuariosEstudiantesNestedInput = {
    create?: XOR<reaccionesPreguntasCreateWithoutUsuariosEstudiantesInput, reaccionesPreguntasUncheckedCreateWithoutUsuariosEstudiantesInput> | reaccionesPreguntasCreateWithoutUsuariosEstudiantesInput[] | reaccionesPreguntasUncheckedCreateWithoutUsuariosEstudiantesInput[]
    connectOrCreate?: reaccionesPreguntasCreateOrConnectWithoutUsuariosEstudiantesInput | reaccionesPreguntasCreateOrConnectWithoutUsuariosEstudiantesInput[]
    upsert?: reaccionesPreguntasUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput | reaccionesPreguntasUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput[]
    createMany?: reaccionesPreguntasCreateManyUsuariosEstudiantesInputEnvelope
    set?: reaccionesPreguntasWhereUniqueInput | reaccionesPreguntasWhereUniqueInput[]
    disconnect?: reaccionesPreguntasWhereUniqueInput | reaccionesPreguntasWhereUniqueInput[]
    delete?: reaccionesPreguntasWhereUniqueInput | reaccionesPreguntasWhereUniqueInput[]
    connect?: reaccionesPreguntasWhereUniqueInput | reaccionesPreguntasWhereUniqueInput[]
    update?: reaccionesPreguntasUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput | reaccionesPreguntasUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput[]
    updateMany?: reaccionesPreguntasUpdateManyWithWhereWithoutUsuariosEstudiantesInput | reaccionesPreguntasUpdateManyWithWhereWithoutUsuariosEstudiantesInput[]
    deleteMany?: reaccionesPreguntasScalarWhereInput | reaccionesPreguntasScalarWhereInput[]
  }

  export type repasoRegistrosUpdateManyWithoutUsuariosEstudiantesNestedInput = {
    create?: XOR<repasoRegistrosCreateWithoutUsuariosEstudiantesInput, repasoRegistrosUncheckedCreateWithoutUsuariosEstudiantesInput> | repasoRegistrosCreateWithoutUsuariosEstudiantesInput[] | repasoRegistrosUncheckedCreateWithoutUsuariosEstudiantesInput[]
    connectOrCreate?: repasoRegistrosCreateOrConnectWithoutUsuariosEstudiantesInput | repasoRegistrosCreateOrConnectWithoutUsuariosEstudiantesInput[]
    upsert?: repasoRegistrosUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput | repasoRegistrosUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput[]
    createMany?: repasoRegistrosCreateManyUsuariosEstudiantesInputEnvelope
    set?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
    disconnect?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
    delete?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
    connect?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
    update?: repasoRegistrosUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput | repasoRegistrosUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput[]
    updateMany?: repasoRegistrosUpdateManyWithWhereWithoutUsuariosEstudiantesInput | repasoRegistrosUpdateManyWithWhereWithoutUsuariosEstudiantesInput[]
    deleteMany?: repasoRegistrosScalarWhereInput | repasoRegistrosScalarWhereInput[]
  }

  export type reviewsCursosUpdateManyWithoutUsuariosEstudiantesNestedInput = {
    create?: XOR<reviewsCursosCreateWithoutUsuariosEstudiantesInput, reviewsCursosUncheckedCreateWithoutUsuariosEstudiantesInput> | reviewsCursosCreateWithoutUsuariosEstudiantesInput[] | reviewsCursosUncheckedCreateWithoutUsuariosEstudiantesInput[]
    connectOrCreate?: reviewsCursosCreateOrConnectWithoutUsuariosEstudiantesInput | reviewsCursosCreateOrConnectWithoutUsuariosEstudiantesInput[]
    upsert?: reviewsCursosUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput | reviewsCursosUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput[]
    createMany?: reviewsCursosCreateManyUsuariosEstudiantesInputEnvelope
    set?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    disconnect?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    delete?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    connect?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    update?: reviewsCursosUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput | reviewsCursosUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput[]
    updateMany?: reviewsCursosUpdateManyWithWhereWithoutUsuariosEstudiantesInput | reviewsCursosUpdateManyWithWhereWithoutUsuariosEstudiantesInput[]
    deleteMany?: reviewsCursosScalarWhereInput | reviewsCursosScalarWhereInput[]
  }

  export type suscripcionesUpdateManyWithoutUsuariosEstudiantesNestedInput = {
    create?: XOR<suscripcionesCreateWithoutUsuariosEstudiantesInput, suscripcionesUncheckedCreateWithoutUsuariosEstudiantesInput> | suscripcionesCreateWithoutUsuariosEstudiantesInput[] | suscripcionesUncheckedCreateWithoutUsuariosEstudiantesInput[]
    connectOrCreate?: suscripcionesCreateOrConnectWithoutUsuariosEstudiantesInput | suscripcionesCreateOrConnectWithoutUsuariosEstudiantesInput[]
    upsert?: suscripcionesUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput | suscripcionesUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput[]
    createMany?: suscripcionesCreateManyUsuariosEstudiantesInputEnvelope
    set?: suscripcionesWhereUniqueInput | suscripcionesWhereUniqueInput[]
    disconnect?: suscripcionesWhereUniqueInput | suscripcionesWhereUniqueInput[]
    delete?: suscripcionesWhereUniqueInput | suscripcionesWhereUniqueInput[]
    connect?: suscripcionesWhereUniqueInput | suscripcionesWhereUniqueInput[]
    update?: suscripcionesUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput | suscripcionesUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput[]
    updateMany?: suscripcionesUpdateManyWithWhereWithoutUsuariosEstudiantesInput | suscripcionesUpdateManyWithWhereWithoutUsuariosEstudiantesInput[]
    deleteMany?: suscripcionesScalarWhereInput | suscripcionesScalarWhereInput[]
  }

  export type estudiantesUpdateOneWithoutUsuariosEstudiantesNestedInput = {
    create?: XOR<estudiantesCreateWithoutUsuariosEstudiantesInput, estudiantesUncheckedCreateWithoutUsuariosEstudiantesInput>
    connectOrCreate?: estudiantesCreateOrConnectWithoutUsuariosEstudiantesInput
    upsert?: estudiantesUpsertWithoutUsuariosEstudiantesInput
    disconnect?: estudiantesWhereInput | boolean
    delete?: estudiantesWhereInput | boolean
    connect?: estudiantesWhereUniqueInput
    update?: XOR<XOR<estudiantesUpdateToOneWithWhereWithoutUsuariosEstudiantesInput, estudiantesUpdateWithoutUsuariosEstudiantesInput>, estudiantesUncheckedUpdateWithoutUsuariosEstudiantesInput>
  }

  export type comprasUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput = {
    create?: XOR<comprasCreateWithoutUsuariosEstudiantesInput, comprasUncheckedCreateWithoutUsuariosEstudiantesInput> | comprasCreateWithoutUsuariosEstudiantesInput[] | comprasUncheckedCreateWithoutUsuariosEstudiantesInput[]
    connectOrCreate?: comprasCreateOrConnectWithoutUsuariosEstudiantesInput | comprasCreateOrConnectWithoutUsuariosEstudiantesInput[]
    upsert?: comprasUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput | comprasUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput[]
    createMany?: comprasCreateManyUsuariosEstudiantesInputEnvelope
    set?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    disconnect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    delete?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    connect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    update?: comprasUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput | comprasUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput[]
    updateMany?: comprasUpdateManyWithWhereWithoutUsuariosEstudiantesInput | comprasUpdateManyWithWhereWithoutUsuariosEstudiantesInput[]
    deleteMany?: comprasScalarWhereInput | comprasScalarWhereInput[]
  }

  export type intentosUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput = {
    create?: XOR<intentosCreateWithoutUsuariosEstudiantesInput, intentosUncheckedCreateWithoutUsuariosEstudiantesInput> | intentosCreateWithoutUsuariosEstudiantesInput[] | intentosUncheckedCreateWithoutUsuariosEstudiantesInput[]
    connectOrCreate?: intentosCreateOrConnectWithoutUsuariosEstudiantesInput | intentosCreateOrConnectWithoutUsuariosEstudiantesInput[]
    upsert?: intentosUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput | intentosUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput[]
    createMany?: intentosCreateManyUsuariosEstudiantesInputEnvelope
    set?: intentosWhereUniqueInput | intentosWhereUniqueInput[]
    disconnect?: intentosWhereUniqueInput | intentosWhereUniqueInput[]
    delete?: intentosWhereUniqueInput | intentosWhereUniqueInput[]
    connect?: intentosWhereUniqueInput | intentosWhereUniqueInput[]
    update?: intentosUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput | intentosUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput[]
    updateMany?: intentosUpdateManyWithWhereWithoutUsuariosEstudiantesInput | intentosUpdateManyWithWhereWithoutUsuariosEstudiantesInput[]
    deleteMany?: intentosScalarWhereInput | intentosScalarWhereInput[]
  }

  export type reaccionesPreguntasUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput = {
    create?: XOR<reaccionesPreguntasCreateWithoutUsuariosEstudiantesInput, reaccionesPreguntasUncheckedCreateWithoutUsuariosEstudiantesInput> | reaccionesPreguntasCreateWithoutUsuariosEstudiantesInput[] | reaccionesPreguntasUncheckedCreateWithoutUsuariosEstudiantesInput[]
    connectOrCreate?: reaccionesPreguntasCreateOrConnectWithoutUsuariosEstudiantesInput | reaccionesPreguntasCreateOrConnectWithoutUsuariosEstudiantesInput[]
    upsert?: reaccionesPreguntasUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput | reaccionesPreguntasUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput[]
    createMany?: reaccionesPreguntasCreateManyUsuariosEstudiantesInputEnvelope
    set?: reaccionesPreguntasWhereUniqueInput | reaccionesPreguntasWhereUniqueInput[]
    disconnect?: reaccionesPreguntasWhereUniqueInput | reaccionesPreguntasWhereUniqueInput[]
    delete?: reaccionesPreguntasWhereUniqueInput | reaccionesPreguntasWhereUniqueInput[]
    connect?: reaccionesPreguntasWhereUniqueInput | reaccionesPreguntasWhereUniqueInput[]
    update?: reaccionesPreguntasUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput | reaccionesPreguntasUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput[]
    updateMany?: reaccionesPreguntasUpdateManyWithWhereWithoutUsuariosEstudiantesInput | reaccionesPreguntasUpdateManyWithWhereWithoutUsuariosEstudiantesInput[]
    deleteMany?: reaccionesPreguntasScalarWhereInput | reaccionesPreguntasScalarWhereInput[]
  }

  export type repasoRegistrosUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput = {
    create?: XOR<repasoRegistrosCreateWithoutUsuariosEstudiantesInput, repasoRegistrosUncheckedCreateWithoutUsuariosEstudiantesInput> | repasoRegistrosCreateWithoutUsuariosEstudiantesInput[] | repasoRegistrosUncheckedCreateWithoutUsuariosEstudiantesInput[]
    connectOrCreate?: repasoRegistrosCreateOrConnectWithoutUsuariosEstudiantesInput | repasoRegistrosCreateOrConnectWithoutUsuariosEstudiantesInput[]
    upsert?: repasoRegistrosUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput | repasoRegistrosUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput[]
    createMany?: repasoRegistrosCreateManyUsuariosEstudiantesInputEnvelope
    set?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
    disconnect?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
    delete?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
    connect?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
    update?: repasoRegistrosUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput | repasoRegistrosUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput[]
    updateMany?: repasoRegistrosUpdateManyWithWhereWithoutUsuariosEstudiantesInput | repasoRegistrosUpdateManyWithWhereWithoutUsuariosEstudiantesInput[]
    deleteMany?: repasoRegistrosScalarWhereInput | repasoRegistrosScalarWhereInput[]
  }

  export type reviewsCursosUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput = {
    create?: XOR<reviewsCursosCreateWithoutUsuariosEstudiantesInput, reviewsCursosUncheckedCreateWithoutUsuariosEstudiantesInput> | reviewsCursosCreateWithoutUsuariosEstudiantesInput[] | reviewsCursosUncheckedCreateWithoutUsuariosEstudiantesInput[]
    connectOrCreate?: reviewsCursosCreateOrConnectWithoutUsuariosEstudiantesInput | reviewsCursosCreateOrConnectWithoutUsuariosEstudiantesInput[]
    upsert?: reviewsCursosUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput | reviewsCursosUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput[]
    createMany?: reviewsCursosCreateManyUsuariosEstudiantesInputEnvelope
    set?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    disconnect?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    delete?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    connect?: reviewsCursosWhereUniqueInput | reviewsCursosWhereUniqueInput[]
    update?: reviewsCursosUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput | reviewsCursosUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput[]
    updateMany?: reviewsCursosUpdateManyWithWhereWithoutUsuariosEstudiantesInput | reviewsCursosUpdateManyWithWhereWithoutUsuariosEstudiantesInput[]
    deleteMany?: reviewsCursosScalarWhereInput | reviewsCursosScalarWhereInput[]
  }

  export type suscripcionesUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput = {
    create?: XOR<suscripcionesCreateWithoutUsuariosEstudiantesInput, suscripcionesUncheckedCreateWithoutUsuariosEstudiantesInput> | suscripcionesCreateWithoutUsuariosEstudiantesInput[] | suscripcionesUncheckedCreateWithoutUsuariosEstudiantesInput[]
    connectOrCreate?: suscripcionesCreateOrConnectWithoutUsuariosEstudiantesInput | suscripcionesCreateOrConnectWithoutUsuariosEstudiantesInput[]
    upsert?: suscripcionesUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput | suscripcionesUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput[]
    createMany?: suscripcionesCreateManyUsuariosEstudiantesInputEnvelope
    set?: suscripcionesWhereUniqueInput | suscripcionesWhereUniqueInput[]
    disconnect?: suscripcionesWhereUniqueInput | suscripcionesWhereUniqueInput[]
    delete?: suscripcionesWhereUniqueInput | suscripcionesWhereUniqueInput[]
    connect?: suscripcionesWhereUniqueInput | suscripcionesWhereUniqueInput[]
    update?: suscripcionesUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput | suscripcionesUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput[]
    updateMany?: suscripcionesUpdateManyWithWhereWithoutUsuariosEstudiantesInput | suscripcionesUpdateManyWithWhereWithoutUsuariosEstudiantesInput[]
    deleteMany?: suscripcionesScalarWhereInput | suscripcionesScalarWhereInput[]
  }

  export type capitulosCreateNestedManyWithoutAreasInput = {
    create?: XOR<capitulosCreateWithoutAreasInput, capitulosUncheckedCreateWithoutAreasInput> | capitulosCreateWithoutAreasInput[] | capitulosUncheckedCreateWithoutAreasInput[]
    connectOrCreate?: capitulosCreateOrConnectWithoutAreasInput | capitulosCreateOrConnectWithoutAreasInput[]
    createMany?: capitulosCreateManyAreasInputEnvelope
    connect?: capitulosWhereUniqueInput | capitulosWhereUniqueInput[]
  }

  export type preguntasCreateNestedManyWithoutAreasInput = {
    create?: XOR<preguntasCreateWithoutAreasInput, preguntasUncheckedCreateWithoutAreasInput> | preguntasCreateWithoutAreasInput[] | preguntasUncheckedCreateWithoutAreasInput[]
    connectOrCreate?: preguntasCreateOrConnectWithoutAreasInput | preguntasCreateOrConnectWithoutAreasInput[]
    connect?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
  }

  export type capitulosUncheckedCreateNestedManyWithoutAreasInput = {
    create?: XOR<capitulosCreateWithoutAreasInput, capitulosUncheckedCreateWithoutAreasInput> | capitulosCreateWithoutAreasInput[] | capitulosUncheckedCreateWithoutAreasInput[]
    connectOrCreate?: capitulosCreateOrConnectWithoutAreasInput | capitulosCreateOrConnectWithoutAreasInput[]
    createMany?: capitulosCreateManyAreasInputEnvelope
    connect?: capitulosWhereUniqueInput | capitulosWhereUniqueInput[]
  }

  export type preguntasUncheckedCreateNestedManyWithoutAreasInput = {
    create?: XOR<preguntasCreateWithoutAreasInput, preguntasUncheckedCreateWithoutAreasInput> | preguntasCreateWithoutAreasInput[] | preguntasUncheckedCreateWithoutAreasInput[]
    connectOrCreate?: preguntasCreateOrConnectWithoutAreasInput | preguntasCreateOrConnectWithoutAreasInput[]
    connect?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
  }

  export type capitulosUpdateManyWithoutAreasNestedInput = {
    create?: XOR<capitulosCreateWithoutAreasInput, capitulosUncheckedCreateWithoutAreasInput> | capitulosCreateWithoutAreasInput[] | capitulosUncheckedCreateWithoutAreasInput[]
    connectOrCreate?: capitulosCreateOrConnectWithoutAreasInput | capitulosCreateOrConnectWithoutAreasInput[]
    upsert?: capitulosUpsertWithWhereUniqueWithoutAreasInput | capitulosUpsertWithWhereUniqueWithoutAreasInput[]
    createMany?: capitulosCreateManyAreasInputEnvelope
    set?: capitulosWhereUniqueInput | capitulosWhereUniqueInput[]
    disconnect?: capitulosWhereUniqueInput | capitulosWhereUniqueInput[]
    delete?: capitulosWhereUniqueInput | capitulosWhereUniqueInput[]
    connect?: capitulosWhereUniqueInput | capitulosWhereUniqueInput[]
    update?: capitulosUpdateWithWhereUniqueWithoutAreasInput | capitulosUpdateWithWhereUniqueWithoutAreasInput[]
    updateMany?: capitulosUpdateManyWithWhereWithoutAreasInput | capitulosUpdateManyWithWhereWithoutAreasInput[]
    deleteMany?: capitulosScalarWhereInput | capitulosScalarWhereInput[]
  }

  export type preguntasUpdateManyWithoutAreasNestedInput = {
    create?: XOR<preguntasCreateWithoutAreasInput, preguntasUncheckedCreateWithoutAreasInput> | preguntasCreateWithoutAreasInput[] | preguntasUncheckedCreateWithoutAreasInput[]
    connectOrCreate?: preguntasCreateOrConnectWithoutAreasInput | preguntasCreateOrConnectWithoutAreasInput[]
    upsert?: preguntasUpsertWithWhereUniqueWithoutAreasInput | preguntasUpsertWithWhereUniqueWithoutAreasInput[]
    set?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    disconnect?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    delete?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    connect?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    update?: preguntasUpdateWithWhereUniqueWithoutAreasInput | preguntasUpdateWithWhereUniqueWithoutAreasInput[]
    updateMany?: preguntasUpdateManyWithWhereWithoutAreasInput | preguntasUpdateManyWithWhereWithoutAreasInput[]
    deleteMany?: preguntasScalarWhereInput | preguntasScalarWhereInput[]
  }

  export type capitulosUncheckedUpdateManyWithoutAreasNestedInput = {
    create?: XOR<capitulosCreateWithoutAreasInput, capitulosUncheckedCreateWithoutAreasInput> | capitulosCreateWithoutAreasInput[] | capitulosUncheckedCreateWithoutAreasInput[]
    connectOrCreate?: capitulosCreateOrConnectWithoutAreasInput | capitulosCreateOrConnectWithoutAreasInput[]
    upsert?: capitulosUpsertWithWhereUniqueWithoutAreasInput | capitulosUpsertWithWhereUniqueWithoutAreasInput[]
    createMany?: capitulosCreateManyAreasInputEnvelope
    set?: capitulosWhereUniqueInput | capitulosWhereUniqueInput[]
    disconnect?: capitulosWhereUniqueInput | capitulosWhereUniqueInput[]
    delete?: capitulosWhereUniqueInput | capitulosWhereUniqueInput[]
    connect?: capitulosWhereUniqueInput | capitulosWhereUniqueInput[]
    update?: capitulosUpdateWithWhereUniqueWithoutAreasInput | capitulosUpdateWithWhereUniqueWithoutAreasInput[]
    updateMany?: capitulosUpdateManyWithWhereWithoutAreasInput | capitulosUpdateManyWithWhereWithoutAreasInput[]
    deleteMany?: capitulosScalarWhereInput | capitulosScalarWhereInput[]
  }

  export type preguntasUncheckedUpdateManyWithoutAreasNestedInput = {
    create?: XOR<preguntasCreateWithoutAreasInput, preguntasUncheckedCreateWithoutAreasInput> | preguntasCreateWithoutAreasInput[] | preguntasUncheckedCreateWithoutAreasInput[]
    connectOrCreate?: preguntasCreateOrConnectWithoutAreasInput | preguntasCreateOrConnectWithoutAreasInput[]
    upsert?: preguntasUpsertWithWhereUniqueWithoutAreasInput | preguntasUpsertWithWhereUniqueWithoutAreasInput[]
    set?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    disconnect?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    delete?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    connect?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    update?: preguntasUpdateWithWhereUniqueWithoutAreasInput | preguntasUpdateWithWhereUniqueWithoutAreasInput[]
    updateMany?: preguntasUpdateManyWithWhereWithoutAreasInput | preguntasUpdateManyWithWhereWithoutAreasInput[]
    deleteMany?: preguntasScalarWhereInput | preguntasScalarWhereInput[]
  }

  export type intentosCreateNestedManyWithoutBanqueoInput = {
    create?: XOR<intentosCreateWithoutBanqueoInput, intentosUncheckedCreateWithoutBanqueoInput> | intentosCreateWithoutBanqueoInput[] | intentosUncheckedCreateWithoutBanqueoInput[]
    connectOrCreate?: intentosCreateOrConnectWithoutBanqueoInput | intentosCreateOrConnectWithoutBanqueoInput[]
    createMany?: intentosCreateManyBanqueoInputEnvelope
    connect?: intentosWhereUniqueInput | intentosWhereUniqueInput[]
  }

  export type repasoRegistrosCreateNestedManyWithoutBanqueoInput = {
    create?: XOR<repasoRegistrosCreateWithoutBanqueoInput, repasoRegistrosUncheckedCreateWithoutBanqueoInput> | repasoRegistrosCreateWithoutBanqueoInput[] | repasoRegistrosUncheckedCreateWithoutBanqueoInput[]
    connectOrCreate?: repasoRegistrosCreateOrConnectWithoutBanqueoInput | repasoRegistrosCreateOrConnectWithoutBanqueoInput[]
    createMany?: repasoRegistrosCreateManyBanqueoInputEnvelope
    connect?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
  }

  export type preguntasCreateNestedManyWithoutBanqueoInput = {
    create?: XOR<preguntasCreateWithoutBanqueoInput, preguntasUncheckedCreateWithoutBanqueoInput> | preguntasCreateWithoutBanqueoInput[] | preguntasUncheckedCreateWithoutBanqueoInput[]
    connectOrCreate?: preguntasCreateOrConnectWithoutBanqueoInput | preguntasCreateOrConnectWithoutBanqueoInput[]
    connect?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
  }

  export type intentosUncheckedCreateNestedManyWithoutBanqueoInput = {
    create?: XOR<intentosCreateWithoutBanqueoInput, intentosUncheckedCreateWithoutBanqueoInput> | intentosCreateWithoutBanqueoInput[] | intentosUncheckedCreateWithoutBanqueoInput[]
    connectOrCreate?: intentosCreateOrConnectWithoutBanqueoInput | intentosCreateOrConnectWithoutBanqueoInput[]
    createMany?: intentosCreateManyBanqueoInputEnvelope
    connect?: intentosWhereUniqueInput | intentosWhereUniqueInput[]
  }

  export type repasoRegistrosUncheckedCreateNestedManyWithoutBanqueoInput = {
    create?: XOR<repasoRegistrosCreateWithoutBanqueoInput, repasoRegistrosUncheckedCreateWithoutBanqueoInput> | repasoRegistrosCreateWithoutBanqueoInput[] | repasoRegistrosUncheckedCreateWithoutBanqueoInput[]
    connectOrCreate?: repasoRegistrosCreateOrConnectWithoutBanqueoInput | repasoRegistrosCreateOrConnectWithoutBanqueoInput[]
    createMany?: repasoRegistrosCreateManyBanqueoInputEnvelope
    connect?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
  }

  export type preguntasUncheckedCreateNestedManyWithoutBanqueoInput = {
    create?: XOR<preguntasCreateWithoutBanqueoInput, preguntasUncheckedCreateWithoutBanqueoInput> | preguntasCreateWithoutBanqueoInput[] | preguntasUncheckedCreateWithoutBanqueoInput[]
    connectOrCreate?: preguntasCreateOrConnectWithoutBanqueoInput | preguntasCreateOrConnectWithoutBanqueoInput[]
    connect?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
  }

  export type EnumBanqueoTipoFieldUpdateOperationsInput = {
    set?: $Enums.BanqueoTipo
  }

  export type EnumBanqueoTipoCreadoFieldUpdateOperationsInput = {
    set?: $Enums.BanqueoTipoCreado
  }

  export type intentosUpdateManyWithoutBanqueoNestedInput = {
    create?: XOR<intentosCreateWithoutBanqueoInput, intentosUncheckedCreateWithoutBanqueoInput> | intentosCreateWithoutBanqueoInput[] | intentosUncheckedCreateWithoutBanqueoInput[]
    connectOrCreate?: intentosCreateOrConnectWithoutBanqueoInput | intentosCreateOrConnectWithoutBanqueoInput[]
    upsert?: intentosUpsertWithWhereUniqueWithoutBanqueoInput | intentosUpsertWithWhereUniqueWithoutBanqueoInput[]
    createMany?: intentosCreateManyBanqueoInputEnvelope
    set?: intentosWhereUniqueInput | intentosWhereUniqueInput[]
    disconnect?: intentosWhereUniqueInput | intentosWhereUniqueInput[]
    delete?: intentosWhereUniqueInput | intentosWhereUniqueInput[]
    connect?: intentosWhereUniqueInput | intentosWhereUniqueInput[]
    update?: intentosUpdateWithWhereUniqueWithoutBanqueoInput | intentosUpdateWithWhereUniqueWithoutBanqueoInput[]
    updateMany?: intentosUpdateManyWithWhereWithoutBanqueoInput | intentosUpdateManyWithWhereWithoutBanqueoInput[]
    deleteMany?: intentosScalarWhereInput | intentosScalarWhereInput[]
  }

  export type repasoRegistrosUpdateManyWithoutBanqueoNestedInput = {
    create?: XOR<repasoRegistrosCreateWithoutBanqueoInput, repasoRegistrosUncheckedCreateWithoutBanqueoInput> | repasoRegistrosCreateWithoutBanqueoInput[] | repasoRegistrosUncheckedCreateWithoutBanqueoInput[]
    connectOrCreate?: repasoRegistrosCreateOrConnectWithoutBanqueoInput | repasoRegistrosCreateOrConnectWithoutBanqueoInput[]
    upsert?: repasoRegistrosUpsertWithWhereUniqueWithoutBanqueoInput | repasoRegistrosUpsertWithWhereUniqueWithoutBanqueoInput[]
    createMany?: repasoRegistrosCreateManyBanqueoInputEnvelope
    set?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
    disconnect?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
    delete?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
    connect?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
    update?: repasoRegistrosUpdateWithWhereUniqueWithoutBanqueoInput | repasoRegistrosUpdateWithWhereUniqueWithoutBanqueoInput[]
    updateMany?: repasoRegistrosUpdateManyWithWhereWithoutBanqueoInput | repasoRegistrosUpdateManyWithWhereWithoutBanqueoInput[]
    deleteMany?: repasoRegistrosScalarWhereInput | repasoRegistrosScalarWhereInput[]
  }

  export type preguntasUpdateManyWithoutBanqueoNestedInput = {
    create?: XOR<preguntasCreateWithoutBanqueoInput, preguntasUncheckedCreateWithoutBanqueoInput> | preguntasCreateWithoutBanqueoInput[] | preguntasUncheckedCreateWithoutBanqueoInput[]
    connectOrCreate?: preguntasCreateOrConnectWithoutBanqueoInput | preguntasCreateOrConnectWithoutBanqueoInput[]
    upsert?: preguntasUpsertWithWhereUniqueWithoutBanqueoInput | preguntasUpsertWithWhereUniqueWithoutBanqueoInput[]
    set?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    disconnect?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    delete?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    connect?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    update?: preguntasUpdateWithWhereUniqueWithoutBanqueoInput | preguntasUpdateWithWhereUniqueWithoutBanqueoInput[]
    updateMany?: preguntasUpdateManyWithWhereWithoutBanqueoInput | preguntasUpdateManyWithWhereWithoutBanqueoInput[]
    deleteMany?: preguntasScalarWhereInput | preguntasScalarWhereInput[]
  }

  export type intentosUncheckedUpdateManyWithoutBanqueoNestedInput = {
    create?: XOR<intentosCreateWithoutBanqueoInput, intentosUncheckedCreateWithoutBanqueoInput> | intentosCreateWithoutBanqueoInput[] | intentosUncheckedCreateWithoutBanqueoInput[]
    connectOrCreate?: intentosCreateOrConnectWithoutBanqueoInput | intentosCreateOrConnectWithoutBanqueoInput[]
    upsert?: intentosUpsertWithWhereUniqueWithoutBanqueoInput | intentosUpsertWithWhereUniqueWithoutBanqueoInput[]
    createMany?: intentosCreateManyBanqueoInputEnvelope
    set?: intentosWhereUniqueInput | intentosWhereUniqueInput[]
    disconnect?: intentosWhereUniqueInput | intentosWhereUniqueInput[]
    delete?: intentosWhereUniqueInput | intentosWhereUniqueInput[]
    connect?: intentosWhereUniqueInput | intentosWhereUniqueInput[]
    update?: intentosUpdateWithWhereUniqueWithoutBanqueoInput | intentosUpdateWithWhereUniqueWithoutBanqueoInput[]
    updateMany?: intentosUpdateManyWithWhereWithoutBanqueoInput | intentosUpdateManyWithWhereWithoutBanqueoInput[]
    deleteMany?: intentosScalarWhereInput | intentosScalarWhereInput[]
  }

  export type repasoRegistrosUncheckedUpdateManyWithoutBanqueoNestedInput = {
    create?: XOR<repasoRegistrosCreateWithoutBanqueoInput, repasoRegistrosUncheckedCreateWithoutBanqueoInput> | repasoRegistrosCreateWithoutBanqueoInput[] | repasoRegistrosUncheckedCreateWithoutBanqueoInput[]
    connectOrCreate?: repasoRegistrosCreateOrConnectWithoutBanqueoInput | repasoRegistrosCreateOrConnectWithoutBanqueoInput[]
    upsert?: repasoRegistrosUpsertWithWhereUniqueWithoutBanqueoInput | repasoRegistrosUpsertWithWhereUniqueWithoutBanqueoInput[]
    createMany?: repasoRegistrosCreateManyBanqueoInputEnvelope
    set?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
    disconnect?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
    delete?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
    connect?: repasoRegistrosWhereUniqueInput | repasoRegistrosWhereUniqueInput[]
    update?: repasoRegistrosUpdateWithWhereUniqueWithoutBanqueoInput | repasoRegistrosUpdateWithWhereUniqueWithoutBanqueoInput[]
    updateMany?: repasoRegistrosUpdateManyWithWhereWithoutBanqueoInput | repasoRegistrosUpdateManyWithWhereWithoutBanqueoInput[]
    deleteMany?: repasoRegistrosScalarWhereInput | repasoRegistrosScalarWhereInput[]
  }

  export type preguntasUncheckedUpdateManyWithoutBanqueoNestedInput = {
    create?: XOR<preguntasCreateWithoutBanqueoInput, preguntasUncheckedCreateWithoutBanqueoInput> | preguntasCreateWithoutBanqueoInput[] | preguntasUncheckedCreateWithoutBanqueoInput[]
    connectOrCreate?: preguntasCreateOrConnectWithoutBanqueoInput | preguntasCreateOrConnectWithoutBanqueoInput[]
    upsert?: preguntasUpsertWithWhereUniqueWithoutBanqueoInput | preguntasUpsertWithWhereUniqueWithoutBanqueoInput[]
    set?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    disconnect?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    delete?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    connect?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    update?: preguntasUpdateWithWhereUniqueWithoutBanqueoInput | preguntasUpdateWithWhereUniqueWithoutBanqueoInput[]
    updateMany?: preguntasUpdateManyWithWhereWithoutBanqueoInput | preguntasUpdateManyWithWhereWithoutBanqueoInput[]
    deleteMany?: preguntasScalarWhereInput | preguntasScalarWhereInput[]
  }

  export type areasCreateNestedOneWithoutCapitulosInput = {
    create?: XOR<areasCreateWithoutCapitulosInput, areasUncheckedCreateWithoutCapitulosInput>
    connectOrCreate?: areasCreateOrConnectWithoutCapitulosInput
    connect?: areasWhereUniqueInput
  }

  export type temasCreateNestedManyWithoutCapitulosInput = {
    create?: XOR<temasCreateWithoutCapitulosInput, temasUncheckedCreateWithoutCapitulosInput> | temasCreateWithoutCapitulosInput[] | temasUncheckedCreateWithoutCapitulosInput[]
    connectOrCreate?: temasCreateOrConnectWithoutCapitulosInput | temasCreateOrConnectWithoutCapitulosInput[]
    createMany?: temasCreateManyCapitulosInputEnvelope
    connect?: temasWhereUniqueInput | temasWhereUniqueInput[]
  }

  export type preguntasCreateNestedManyWithoutCapitulosInput = {
    create?: XOR<preguntasCreateWithoutCapitulosInput, preguntasUncheckedCreateWithoutCapitulosInput> | preguntasCreateWithoutCapitulosInput[] | preguntasUncheckedCreateWithoutCapitulosInput[]
    connectOrCreate?: preguntasCreateOrConnectWithoutCapitulosInput | preguntasCreateOrConnectWithoutCapitulosInput[]
    connect?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
  }

  export type temasUncheckedCreateNestedManyWithoutCapitulosInput = {
    create?: XOR<temasCreateWithoutCapitulosInput, temasUncheckedCreateWithoutCapitulosInput> | temasCreateWithoutCapitulosInput[] | temasUncheckedCreateWithoutCapitulosInput[]
    connectOrCreate?: temasCreateOrConnectWithoutCapitulosInput | temasCreateOrConnectWithoutCapitulosInput[]
    createMany?: temasCreateManyCapitulosInputEnvelope
    connect?: temasWhereUniqueInput | temasWhereUniqueInput[]
  }

  export type preguntasUncheckedCreateNestedManyWithoutCapitulosInput = {
    create?: XOR<preguntasCreateWithoutCapitulosInput, preguntasUncheckedCreateWithoutCapitulosInput> | preguntasCreateWithoutCapitulosInput[] | preguntasUncheckedCreateWithoutCapitulosInput[]
    connectOrCreate?: preguntasCreateOrConnectWithoutCapitulosInput | preguntasCreateOrConnectWithoutCapitulosInput[]
    connect?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
  }

  export type areasUpdateOneWithoutCapitulosNestedInput = {
    create?: XOR<areasCreateWithoutCapitulosInput, areasUncheckedCreateWithoutCapitulosInput>
    connectOrCreate?: areasCreateOrConnectWithoutCapitulosInput
    upsert?: areasUpsertWithoutCapitulosInput
    disconnect?: areasWhereInput | boolean
    delete?: areasWhereInput | boolean
    connect?: areasWhereUniqueInput
    update?: XOR<XOR<areasUpdateToOneWithWhereWithoutCapitulosInput, areasUpdateWithoutCapitulosInput>, areasUncheckedUpdateWithoutCapitulosInput>
  }

  export type temasUpdateManyWithoutCapitulosNestedInput = {
    create?: XOR<temasCreateWithoutCapitulosInput, temasUncheckedCreateWithoutCapitulosInput> | temasCreateWithoutCapitulosInput[] | temasUncheckedCreateWithoutCapitulosInput[]
    connectOrCreate?: temasCreateOrConnectWithoutCapitulosInput | temasCreateOrConnectWithoutCapitulosInput[]
    upsert?: temasUpsertWithWhereUniqueWithoutCapitulosInput | temasUpsertWithWhereUniqueWithoutCapitulosInput[]
    createMany?: temasCreateManyCapitulosInputEnvelope
    set?: temasWhereUniqueInput | temasWhereUniqueInput[]
    disconnect?: temasWhereUniqueInput | temasWhereUniqueInput[]
    delete?: temasWhereUniqueInput | temasWhereUniqueInput[]
    connect?: temasWhereUniqueInput | temasWhereUniqueInput[]
    update?: temasUpdateWithWhereUniqueWithoutCapitulosInput | temasUpdateWithWhereUniqueWithoutCapitulosInput[]
    updateMany?: temasUpdateManyWithWhereWithoutCapitulosInput | temasUpdateManyWithWhereWithoutCapitulosInput[]
    deleteMany?: temasScalarWhereInput | temasScalarWhereInput[]
  }

  export type preguntasUpdateManyWithoutCapitulosNestedInput = {
    create?: XOR<preguntasCreateWithoutCapitulosInput, preguntasUncheckedCreateWithoutCapitulosInput> | preguntasCreateWithoutCapitulosInput[] | preguntasUncheckedCreateWithoutCapitulosInput[]
    connectOrCreate?: preguntasCreateOrConnectWithoutCapitulosInput | preguntasCreateOrConnectWithoutCapitulosInput[]
    upsert?: preguntasUpsertWithWhereUniqueWithoutCapitulosInput | preguntasUpsertWithWhereUniqueWithoutCapitulosInput[]
    set?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    disconnect?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    delete?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    connect?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    update?: preguntasUpdateWithWhereUniqueWithoutCapitulosInput | preguntasUpdateWithWhereUniqueWithoutCapitulosInput[]
    updateMany?: preguntasUpdateManyWithWhereWithoutCapitulosInput | preguntasUpdateManyWithWhereWithoutCapitulosInput[]
    deleteMany?: preguntasScalarWhereInput | preguntasScalarWhereInput[]
  }

  export type temasUncheckedUpdateManyWithoutCapitulosNestedInput = {
    create?: XOR<temasCreateWithoutCapitulosInput, temasUncheckedCreateWithoutCapitulosInput> | temasCreateWithoutCapitulosInput[] | temasUncheckedCreateWithoutCapitulosInput[]
    connectOrCreate?: temasCreateOrConnectWithoutCapitulosInput | temasCreateOrConnectWithoutCapitulosInput[]
    upsert?: temasUpsertWithWhereUniqueWithoutCapitulosInput | temasUpsertWithWhereUniqueWithoutCapitulosInput[]
    createMany?: temasCreateManyCapitulosInputEnvelope
    set?: temasWhereUniqueInput | temasWhereUniqueInput[]
    disconnect?: temasWhereUniqueInput | temasWhereUniqueInput[]
    delete?: temasWhereUniqueInput | temasWhereUniqueInput[]
    connect?: temasWhereUniqueInput | temasWhereUniqueInput[]
    update?: temasUpdateWithWhereUniqueWithoutCapitulosInput | temasUpdateWithWhereUniqueWithoutCapitulosInput[]
    updateMany?: temasUpdateManyWithWhereWithoutCapitulosInput | temasUpdateManyWithWhereWithoutCapitulosInput[]
    deleteMany?: temasScalarWhereInput | temasScalarWhereInput[]
  }

  export type preguntasUncheckedUpdateManyWithoutCapitulosNestedInput = {
    create?: XOR<preguntasCreateWithoutCapitulosInput, preguntasUncheckedCreateWithoutCapitulosInput> | preguntasCreateWithoutCapitulosInput[] | preguntasUncheckedCreateWithoutCapitulosInput[]
    connectOrCreate?: preguntasCreateOrConnectWithoutCapitulosInput | preguntasCreateOrConnectWithoutCapitulosInput[]
    upsert?: preguntasUpsertWithWhereUniqueWithoutCapitulosInput | preguntasUpsertWithWhereUniqueWithoutCapitulosInput[]
    set?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    disconnect?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    delete?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    connect?: preguntasWhereUniqueInput | preguntasWhereUniqueInput[]
    update?: preguntasUpdateWithWhereUniqueWithoutCapitulosInput | preguntasUpdateWithWhereUniqueWithoutCapitulosInput[]
    updateMany?: preguntasUpdateManyWithWhereWithoutCapitulosInput | preguntasUpdateManyWithWhereWithoutCapitulosInput[]
    deleteMany?: preguntasScalarWhereInput | preguntasScalarWhereInput[]
  }

  export type banqueoCreateNestedOneWithoutIntentosInput = {
    create?: XOR<banqueoCreateWithoutIntentosInput, banqueoUncheckedCreateWithoutIntentosInput>
    connectOrCreate?: banqueoCreateOrConnectWithoutIntentosInput
    connect?: banqueoWhereUniqueInput
  }

  export type usuariosEstudiantesCreateNestedOneWithoutIntentosInput = {
    create?: XOR<usuariosEstudiantesCreateWithoutIntentosInput, usuariosEstudiantesUncheckedCreateWithoutIntentosInput>
    connectOrCreate?: usuariosEstudiantesCreateOrConnectWithoutIntentosInput
    connect?: usuariosEstudiantesWhereUniqueInput
  }

  export type respuestasIntentosCreateNestedManyWithoutIntentosInput = {
    create?: XOR<respuestasIntentosCreateWithoutIntentosInput, respuestasIntentosUncheckedCreateWithoutIntentosInput> | respuestasIntentosCreateWithoutIntentosInput[] | respuestasIntentosUncheckedCreateWithoutIntentosInput[]
    connectOrCreate?: respuestasIntentosCreateOrConnectWithoutIntentosInput | respuestasIntentosCreateOrConnectWithoutIntentosInput[]
    createMany?: respuestasIntentosCreateManyIntentosInputEnvelope
    connect?: respuestasIntentosWhereUniqueInput | respuestasIntentosWhereUniqueInput[]
  }

  export type respuestasIntentosUncheckedCreateNestedManyWithoutIntentosInput = {
    create?: XOR<respuestasIntentosCreateWithoutIntentosInput, respuestasIntentosUncheckedCreateWithoutIntentosInput> | respuestasIntentosCreateWithoutIntentosInput[] | respuestasIntentosUncheckedCreateWithoutIntentosInput[]
    connectOrCreate?: respuestasIntentosCreateOrConnectWithoutIntentosInput | respuestasIntentosCreateOrConnectWithoutIntentosInput[]
    createMany?: respuestasIntentosCreateManyIntentosInputEnvelope
    connect?: respuestasIntentosWhereUniqueInput | respuestasIntentosWhereUniqueInput[]
  }

  export type EnumEstadoIntentoFieldUpdateOperationsInput = {
    set?: $Enums.EstadoIntento
  }

  export type banqueoUpdateOneRequiredWithoutIntentosNestedInput = {
    create?: XOR<banqueoCreateWithoutIntentosInput, banqueoUncheckedCreateWithoutIntentosInput>
    connectOrCreate?: banqueoCreateOrConnectWithoutIntentosInput
    upsert?: banqueoUpsertWithoutIntentosInput
    connect?: banqueoWhereUniqueInput
    update?: XOR<XOR<banqueoUpdateToOneWithWhereWithoutIntentosInput, banqueoUpdateWithoutIntentosInput>, banqueoUncheckedUpdateWithoutIntentosInput>
  }

  export type usuariosEstudiantesUpdateOneWithoutIntentosNestedInput = {
    create?: XOR<usuariosEstudiantesCreateWithoutIntentosInput, usuariosEstudiantesUncheckedCreateWithoutIntentosInput>
    connectOrCreate?: usuariosEstudiantesCreateOrConnectWithoutIntentosInput
    upsert?: usuariosEstudiantesUpsertWithoutIntentosInput
    disconnect?: usuariosEstudiantesWhereInput | boolean
    delete?: usuariosEstudiantesWhereInput | boolean
    connect?: usuariosEstudiantesWhereUniqueInput
    update?: XOR<XOR<usuariosEstudiantesUpdateToOneWithWhereWithoutIntentosInput, usuariosEstudiantesUpdateWithoutIntentosInput>, usuariosEstudiantesUncheckedUpdateWithoutIntentosInput>
  }

  export type respuestasIntentosUpdateManyWithoutIntentosNestedInput = {
    create?: XOR<respuestasIntentosCreateWithoutIntentosInput, respuestasIntentosUncheckedCreateWithoutIntentosInput> | respuestasIntentosCreateWithoutIntentosInput[] | respuestasIntentosUncheckedCreateWithoutIntentosInput[]
    connectOrCreate?: respuestasIntentosCreateOrConnectWithoutIntentosInput | respuestasIntentosCreateOrConnectWithoutIntentosInput[]
    upsert?: respuestasIntentosUpsertWithWhereUniqueWithoutIntentosInput | respuestasIntentosUpsertWithWhereUniqueWithoutIntentosInput[]
    createMany?: respuestasIntentosCreateManyIntentosInputEnvelope
    set?: respuestasIntentosWhereUniqueInput | respuestasIntentosWhereUniqueInput[]
    disconnect?: respuestasIntentosWhereUniqueInput | respuestasIntentosWhereUniqueInput[]
    delete?: respuestasIntentosWhereUniqueInput | respuestasIntentosWhereUniqueInput[]
    connect?: respuestasIntentosWhereUniqueInput | respuestasIntentosWhereUniqueInput[]
    update?: respuestasIntentosUpdateWithWhereUniqueWithoutIntentosInput | respuestasIntentosUpdateWithWhereUniqueWithoutIntentosInput[]
    updateMany?: respuestasIntentosUpdateManyWithWhereWithoutIntentosInput | respuestasIntentosUpdateManyWithWhereWithoutIntentosInput[]
    deleteMany?: respuestasIntentosScalarWhereInput | respuestasIntentosScalarWhereInput[]
  }

  export type respuestasIntentosUncheckedUpdateManyWithoutIntentosNestedInput = {
    create?: XOR<respuestasIntentosCreateWithoutIntentosInput, respuestasIntentosUncheckedCreateWithoutIntentosInput> | respuestasIntentosCreateWithoutIntentosInput[] | respuestasIntentosUncheckedCreateWithoutIntentosInput[]
    connectOrCreate?: respuestasIntentosCreateOrConnectWithoutIntentosInput | respuestasIntentosCreateOrConnectWithoutIntentosInput[]
    upsert?: respuestasIntentosUpsertWithWhereUniqueWithoutIntentosInput | respuestasIntentosUpsertWithWhereUniqueWithoutIntentosInput[]
    createMany?: respuestasIntentosCreateManyIntentosInputEnvelope
    set?: respuestasIntentosWhereUniqueInput | respuestasIntentosWhereUniqueInput[]
    disconnect?: respuestasIntentosWhereUniqueInput | respuestasIntentosWhereUniqueInput[]
    delete?: respuestasIntentosWhereUniqueInput | respuestasIntentosWhereUniqueInput[]
    connect?: respuestasIntentosWhereUniqueInput | respuestasIntentosWhereUniqueInput[]
    update?: respuestasIntentosUpdateWithWhereUniqueWithoutIntentosInput | respuestasIntentosUpdateWithWhereUniqueWithoutIntentosInput[]
    updateMany?: respuestasIntentosUpdateManyWithWhereWithoutIntentosInput | respuestasIntentosUpdateManyWithWhereWithoutIntentosInput[]
    deleteMany?: respuestasIntentosScalarWhereInput | respuestasIntentosScalarWhereInput[]
  }

  export type intentosCreateNestedOneWithoutRespuestasIntentosInput = {
    create?: XOR<intentosCreateWithoutRespuestasIntentosInput, intentosUncheckedCreateWithoutRespuestasIntentosInput>
    connectOrCreate?: intentosCreateOrConnectWithoutRespuestasIntentosInput
    connect?: intentosWhereUniqueInput
  }

  export type preguntasCreateNestedOneWithoutRespuestasIntentosInput = {
    create?: XOR<preguntasCreateWithoutRespuestasIntentosInput, preguntasUncheckedCreateWithoutRespuestasIntentosInput>
    connectOrCreate?: preguntasCreateOrConnectWithoutRespuestasIntentosInput
    connect?: preguntasWhereUniqueInput
  }

  export type EnumResultadoRespuestaFieldUpdateOperationsInput = {
    set?: $Enums.ResultadoRespuesta
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type intentosUpdateOneRequiredWithoutRespuestasIntentosNestedInput = {
    create?: XOR<intentosCreateWithoutRespuestasIntentosInput, intentosUncheckedCreateWithoutRespuestasIntentosInput>
    connectOrCreate?: intentosCreateOrConnectWithoutRespuestasIntentosInput
    upsert?: intentosUpsertWithoutRespuestasIntentosInput
    connect?: intentosWhereUniqueInput
    update?: XOR<XOR<intentosUpdateToOneWithWhereWithoutRespuestasIntentosInput, intentosUpdateWithoutRespuestasIntentosInput>, intentosUncheckedUpdateWithoutRespuestasIntentosInput>
  }

  export type preguntasUpdateOneRequiredWithoutRespuestasIntentosNestedInput = {
    create?: XOR<preguntasCreateWithoutRespuestasIntentosInput, preguntasUncheckedCreateWithoutRespuestasIntentosInput>
    connectOrCreate?: preguntasCreateOrConnectWithoutRespuestasIntentosInput
    upsert?: preguntasUpsertWithoutRespuestasIntentosInput
    connect?: preguntasWhereUniqueInput
    update?: XOR<XOR<preguntasUpdateToOneWithWhereWithoutRespuestasIntentosInput, preguntasUpdateWithoutRespuestasIntentosInput>, preguntasUncheckedUpdateWithoutRespuestasIntentosInput>
  }

  export type banqueoCreateNestedOneWithoutRepasoRegistrosInput = {
    create?: XOR<banqueoCreateWithoutRepasoRegistrosInput, banqueoUncheckedCreateWithoutRepasoRegistrosInput>
    connectOrCreate?: banqueoCreateOrConnectWithoutRepasoRegistrosInput
    connect?: banqueoWhereUniqueInput
  }

  export type preguntasCreateNestedOneWithoutRepasoRegistrosInput = {
    create?: XOR<preguntasCreateWithoutRepasoRegistrosInput, preguntasUncheckedCreateWithoutRepasoRegistrosInput>
    connectOrCreate?: preguntasCreateOrConnectWithoutRepasoRegistrosInput
    connect?: preguntasWhereUniqueInput
  }

  export type usuariosEstudiantesCreateNestedOneWithoutRepasoRegistrosInput = {
    create?: XOR<usuariosEstudiantesCreateWithoutRepasoRegistrosInput, usuariosEstudiantesUncheckedCreateWithoutRepasoRegistrosInput>
    connectOrCreate?: usuariosEstudiantesCreateOrConnectWithoutRepasoRegistrosInput
    connect?: usuariosEstudiantesWhereUniqueInput
  }

  export type banqueoUpdateOneRequiredWithoutRepasoRegistrosNestedInput = {
    create?: XOR<banqueoCreateWithoutRepasoRegistrosInput, banqueoUncheckedCreateWithoutRepasoRegistrosInput>
    connectOrCreate?: banqueoCreateOrConnectWithoutRepasoRegistrosInput
    upsert?: banqueoUpsertWithoutRepasoRegistrosInput
    connect?: banqueoWhereUniqueInput
    update?: XOR<XOR<banqueoUpdateToOneWithWhereWithoutRepasoRegistrosInput, banqueoUpdateWithoutRepasoRegistrosInput>, banqueoUncheckedUpdateWithoutRepasoRegistrosInput>
  }

  export type preguntasUpdateOneRequiredWithoutRepasoRegistrosNestedInput = {
    create?: XOR<preguntasCreateWithoutRepasoRegistrosInput, preguntasUncheckedCreateWithoutRepasoRegistrosInput>
    connectOrCreate?: preguntasCreateOrConnectWithoutRepasoRegistrosInput
    upsert?: preguntasUpsertWithoutRepasoRegistrosInput
    connect?: preguntasWhereUniqueInput
    update?: XOR<XOR<preguntasUpdateToOneWithWhereWithoutRepasoRegistrosInput, preguntasUpdateWithoutRepasoRegistrosInput>, preguntasUncheckedUpdateWithoutRepasoRegistrosInput>
  }

  export type usuariosEstudiantesUpdateOneRequiredWithoutRepasoRegistrosNestedInput = {
    create?: XOR<usuariosEstudiantesCreateWithoutRepasoRegistrosInput, usuariosEstudiantesUncheckedCreateWithoutRepasoRegistrosInput>
    connectOrCreate?: usuariosEstudiantesCreateOrConnectWithoutRepasoRegistrosInput
    upsert?: usuariosEstudiantesUpsertWithoutRepasoRegistrosInput
    connect?: usuariosEstudiantesWhereUniqueInput
    update?: XOR<XOR<usuariosEstudiantesUpdateToOneWithWhereWithoutRepasoRegistrosInput, usuariosEstudiantesUpdateWithoutRepasoRegistrosInput>, usuariosEstudiantesUncheckedUpdateWithoutRepasoRegistrosInput>
  }

  export type usuariosEstudiantesCreateNestedOneWithoutSuscripcionesInput = {
    create?: XOR<usuariosEstudiantesCreateWithoutSuscripcionesInput, usuariosEstudiantesUncheckedCreateWithoutSuscripcionesInput>
    connectOrCreate?: usuariosEstudiantesCreateOrConnectWithoutSuscripcionesInput
    connect?: usuariosEstudiantesWhereUniqueInput
  }

  export type EnumEstadoSuscripcionFieldUpdateOperationsInput = {
    set?: $Enums.EstadoSuscripcion
  }

  export type usuariosEstudiantesUpdateOneRequiredWithoutSuscripcionesNestedInput = {
    create?: XOR<usuariosEstudiantesCreateWithoutSuscripcionesInput, usuariosEstudiantesUncheckedCreateWithoutSuscripcionesInput>
    connectOrCreate?: usuariosEstudiantesCreateOrConnectWithoutSuscripcionesInput
    upsert?: usuariosEstudiantesUpsertWithoutSuscripcionesInput
    connect?: usuariosEstudiantesWhereUniqueInput
    update?: XOR<XOR<usuariosEstudiantesUpdateToOneWithWhereWithoutSuscripcionesInput, usuariosEstudiantesUpdateWithoutSuscripcionesInput>, usuariosEstudiantesUncheckedUpdateWithoutSuscripcionesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumTablaFilter<$PrismaModel = never> = {
    equals?: $Enums.Tabla | EnumTablaFieldRefInput<$PrismaModel>
    in?: $Enums.Tabla[] | ListEnumTablaFieldRefInput<$PrismaModel>
    notIn?: $Enums.Tabla[] | ListEnumTablaFieldRefInput<$PrismaModel>
    not?: NestedEnumTablaFilter<$PrismaModel> | $Enums.Tabla
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumAccionAuditoriaFilter<$PrismaModel = never> = {
    equals?: $Enums.AccionAuditoria | EnumAccionAuditoriaFieldRefInput<$PrismaModel>
    in?: $Enums.AccionAuditoria[] | ListEnumAccionAuditoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccionAuditoria[] | ListEnumAccionAuditoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumAccionAuditoriaFilter<$PrismaModel> | $Enums.AccionAuditoria
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumTablaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tabla | EnumTablaFieldRefInput<$PrismaModel>
    in?: $Enums.Tabla[] | ListEnumTablaFieldRefInput<$PrismaModel>
    notIn?: $Enums.Tabla[] | ListEnumTablaFieldRefInput<$PrismaModel>
    not?: NestedEnumTablaWithAggregatesFilter<$PrismaModel> | $Enums.Tabla
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTablaFilter<$PrismaModel>
    _max?: NestedEnumTablaFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAccionAuditoriaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccionAuditoria | EnumAccionAuditoriaFieldRefInput<$PrismaModel>
    in?: $Enums.AccionAuditoria[] | ListEnumAccionAuditoriaFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccionAuditoria[] | ListEnumAccionAuditoriaFieldRefInput<$PrismaModel>
    not?: NestedEnumAccionAuditoriaWithAggregatesFilter<$PrismaModel> | $Enums.AccionAuditoria
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccionAuditoriaFilter<$PrismaModel>
    _max?: NestedEnumAccionAuditoriaFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumTipoCertificadoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoCertificado | EnumTipoCertificadoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoCertificado[] | ListEnumTipoCertificadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoCertificado[] | ListEnumTipoCertificadoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoCertificadoFilter<$PrismaModel> | $Enums.TipoCertificado
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTipoCertificadoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoCertificado | EnumTipoCertificadoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoCertificado[] | ListEnumTipoCertificadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoCertificado[] | ListEnumTipoCertificadoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoCertificadoWithAggregatesFilter<$PrismaModel> | $Enums.TipoCertificado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoCertificadoFilter<$PrismaModel>
    _max?: NestedEnumTipoCertificadoFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumMetodoPagoFilter<$PrismaModel = never> = {
    equals?: $Enums.MetodoPago | EnumMetodoPagoFieldRefInput<$PrismaModel>
    in?: $Enums.MetodoPago[] | ListEnumMetodoPagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetodoPago[] | ListEnumMetodoPagoFieldRefInput<$PrismaModel>
    not?: NestedEnumMetodoPagoFilter<$PrismaModel> | $Enums.MetodoPago
  }

  export type NestedEnumEstadoPagoFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPago | EnumEstadoPagoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPago[] | ListEnumEstadoPagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoPago[] | ListEnumEstadoPagoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoPagoFilter<$PrismaModel> | $Enums.EstadoPago
  }

  export type NestedEnumMetodoPagoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MetodoPago | EnumMetodoPagoFieldRefInput<$PrismaModel>
    in?: $Enums.MetodoPago[] | ListEnumMetodoPagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetodoPago[] | ListEnumMetodoPagoFieldRefInput<$PrismaModel>
    not?: NestedEnumMetodoPagoWithAggregatesFilter<$PrismaModel> | $Enums.MetodoPago
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMetodoPagoFilter<$PrismaModel>
    _max?: NestedEnumMetodoPagoFilter<$PrismaModel>
  }

  export type NestedEnumEstadoPagoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoPago | EnumEstadoPagoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoPago[] | ListEnumEstadoPagoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoPago[] | ListEnumEstadoPagoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoPagoWithAggregatesFilter<$PrismaModel> | $Enums.EstadoPago
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoPagoFilter<$PrismaModel>
    _max?: NestedEnumEstadoPagoFilter<$PrismaModel>
  }

  export type NestedEnumEdicionEstadoFilter<$PrismaModel = never> = {
    equals?: $Enums.EdicionEstado | EnumEdicionEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.EdicionEstado[] | ListEnumEdicionEstadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EdicionEstado[] | ListEnumEdicionEstadoFieldRefInput<$PrismaModel>
    not?: NestedEnumEdicionEstadoFilter<$PrismaModel> | $Enums.EdicionEstado
  }

  export type NestedEnumEdicionEstadoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EdicionEstado | EnumEdicionEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.EdicionEstado[] | ListEnumEdicionEstadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EdicionEstado[] | ListEnumEdicionEstadoFieldRefInput<$PrismaModel>
    not?: NestedEnumEdicionEstadoWithAggregatesFilter<$PrismaModel> | $Enums.EdicionEstado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEdicionEstadoFilter<$PrismaModel>
    _max?: NestedEnumEdicionEstadoFilter<$PrismaModel>
  }

  export type NestedEnumTipoGeneroFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoGenero | EnumTipoGeneroFieldRefInput<$PrismaModel>
    in?: $Enums.TipoGenero[] | ListEnumTipoGeneroFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoGenero[] | ListEnumTipoGeneroFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoGeneroFilter<$PrismaModel> | $Enums.TipoGenero
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumTipoGeneroWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoGenero | EnumTipoGeneroFieldRefInput<$PrismaModel>
    in?: $Enums.TipoGenero[] | ListEnumTipoGeneroFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoGenero[] | ListEnumTipoGeneroFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoGeneroWithAggregatesFilter<$PrismaModel> | $Enums.TipoGenero
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoGeneroFilter<$PrismaModel>
    _max?: NestedEnumTipoGeneroFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTipoMaterialFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoMaterial | EnumTipoMaterialFieldRefInput<$PrismaModel>
    in?: $Enums.TipoMaterial[] | ListEnumTipoMaterialFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoMaterial[] | ListEnumTipoMaterialFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoMaterialFilter<$PrismaModel> | $Enums.TipoMaterial
  }

  export type NestedEnumTipoMaterialWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoMaterial | EnumTipoMaterialFieldRefInput<$PrismaModel>
    in?: $Enums.TipoMaterial[] | ListEnumTipoMaterialFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoMaterial[] | ListEnumTipoMaterialFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoMaterialWithAggregatesFilter<$PrismaModel> | $Enums.TipoMaterial
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoMaterialFilter<$PrismaModel>
    _max?: NestedEnumTipoMaterialFilter<$PrismaModel>
  }

  export type NestedEnumPreguntaEstadoFilter<$PrismaModel = never> = {
    equals?: $Enums.PreguntaEstado | EnumPreguntaEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.PreguntaEstado[] | ListEnumPreguntaEstadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.PreguntaEstado[] | ListEnumPreguntaEstadoFieldRefInput<$PrismaModel>
    not?: NestedEnumPreguntaEstadoFilter<$PrismaModel> | $Enums.PreguntaEstado
  }

  export type NestedEnumPreguntaDificultadFilter<$PrismaModel = never> = {
    equals?: $Enums.PreguntaDificultad | EnumPreguntaDificultadFieldRefInput<$PrismaModel>
    in?: $Enums.PreguntaDificultad[] | ListEnumPreguntaDificultadFieldRefInput<$PrismaModel>
    notIn?: $Enums.PreguntaDificultad[] | ListEnumPreguntaDificultadFieldRefInput<$PrismaModel>
    not?: NestedEnumPreguntaDificultadFilter<$PrismaModel> | $Enums.PreguntaDificultad
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumPreguntaEstadoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PreguntaEstado | EnumPreguntaEstadoFieldRefInput<$PrismaModel>
    in?: $Enums.PreguntaEstado[] | ListEnumPreguntaEstadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.PreguntaEstado[] | ListEnumPreguntaEstadoFieldRefInput<$PrismaModel>
    not?: NestedEnumPreguntaEstadoWithAggregatesFilter<$PrismaModel> | $Enums.PreguntaEstado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPreguntaEstadoFilter<$PrismaModel>
    _max?: NestedEnumPreguntaEstadoFilter<$PrismaModel>
  }

  export type NestedEnumPreguntaDificultadWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PreguntaDificultad | EnumPreguntaDificultadFieldRefInput<$PrismaModel>
    in?: $Enums.PreguntaDificultad[] | ListEnumPreguntaDificultadFieldRefInput<$PrismaModel>
    notIn?: $Enums.PreguntaDificultad[] | ListEnumPreguntaDificultadFieldRefInput<$PrismaModel>
    not?: NestedEnumPreguntaDificultadWithAggregatesFilter<$PrismaModel> | $Enums.PreguntaDificultad
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPreguntaDificultadFilter<$PrismaModel>
    _max?: NestedEnumPreguntaDificultadFilter<$PrismaModel>
  }

  export type NestedEnumTipoReaccionFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoReaccion | EnumTipoReaccionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoReaccion[] | ListEnumTipoReaccionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoReaccion[] | ListEnumTipoReaccionFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoReaccionFilter<$PrismaModel> | $Enums.TipoReaccion
  }

  export type NestedEnumTipoReaccionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoReaccion | EnumTipoReaccionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoReaccion[] | ListEnumTipoReaccionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoReaccion[] | ListEnumTipoReaccionFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoReaccionWithAggregatesFilter<$PrismaModel> | $Enums.TipoReaccion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoReaccionFilter<$PrismaModel>
    _max?: NestedEnumTipoReaccionFilter<$PrismaModel>
  }

  export type NestedEnumTipoCuentaFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoCuenta | EnumTipoCuentaFieldRefInput<$PrismaModel>
    in?: $Enums.TipoCuenta[] | ListEnumTipoCuentaFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoCuenta[] | ListEnumTipoCuentaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoCuentaFilter<$PrismaModel> | $Enums.TipoCuenta
  }

  export type NestedEnumTipoCuentaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoCuenta | EnumTipoCuentaFieldRefInput<$PrismaModel>
    in?: $Enums.TipoCuenta[] | ListEnumTipoCuentaFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoCuenta[] | ListEnumTipoCuentaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoCuentaWithAggregatesFilter<$PrismaModel> | $Enums.TipoCuenta
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoCuentaFilter<$PrismaModel>
    _max?: NestedEnumTipoCuentaFilter<$PrismaModel>
  }

  export type NestedEnumBanqueoTipoFilter<$PrismaModel = never> = {
    equals?: $Enums.BanqueoTipo | EnumBanqueoTipoFieldRefInput<$PrismaModel>
    in?: $Enums.BanqueoTipo[] | ListEnumBanqueoTipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.BanqueoTipo[] | ListEnumBanqueoTipoFieldRefInput<$PrismaModel>
    not?: NestedEnumBanqueoTipoFilter<$PrismaModel> | $Enums.BanqueoTipo
  }

  export type NestedEnumBanqueoTipoCreadoFilter<$PrismaModel = never> = {
    equals?: $Enums.BanqueoTipoCreado | EnumBanqueoTipoCreadoFieldRefInput<$PrismaModel>
    in?: $Enums.BanqueoTipoCreado[] | ListEnumBanqueoTipoCreadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.BanqueoTipoCreado[] | ListEnumBanqueoTipoCreadoFieldRefInput<$PrismaModel>
    not?: NestedEnumBanqueoTipoCreadoFilter<$PrismaModel> | $Enums.BanqueoTipoCreado
  }

  export type NestedEnumBanqueoTipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BanqueoTipo | EnumBanqueoTipoFieldRefInput<$PrismaModel>
    in?: $Enums.BanqueoTipo[] | ListEnumBanqueoTipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.BanqueoTipo[] | ListEnumBanqueoTipoFieldRefInput<$PrismaModel>
    not?: NestedEnumBanqueoTipoWithAggregatesFilter<$PrismaModel> | $Enums.BanqueoTipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBanqueoTipoFilter<$PrismaModel>
    _max?: NestedEnumBanqueoTipoFilter<$PrismaModel>
  }

  export type NestedEnumBanqueoTipoCreadoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BanqueoTipoCreado | EnumBanqueoTipoCreadoFieldRefInput<$PrismaModel>
    in?: $Enums.BanqueoTipoCreado[] | ListEnumBanqueoTipoCreadoFieldRefInput<$PrismaModel>
    notIn?: $Enums.BanqueoTipoCreado[] | ListEnumBanqueoTipoCreadoFieldRefInput<$PrismaModel>
    not?: NestedEnumBanqueoTipoCreadoWithAggregatesFilter<$PrismaModel> | $Enums.BanqueoTipoCreado
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBanqueoTipoCreadoFilter<$PrismaModel>
    _max?: NestedEnumBanqueoTipoCreadoFilter<$PrismaModel>
  }

  export type NestedEnumEstadoIntentoFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoIntento | EnumEstadoIntentoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoIntento[] | ListEnumEstadoIntentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoIntento[] | ListEnumEstadoIntentoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoIntentoFilter<$PrismaModel> | $Enums.EstadoIntento
  }

  export type NestedEnumEstadoIntentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoIntento | EnumEstadoIntentoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoIntento[] | ListEnumEstadoIntentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoIntento[] | ListEnumEstadoIntentoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoIntentoWithAggregatesFilter<$PrismaModel> | $Enums.EstadoIntento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoIntentoFilter<$PrismaModel>
    _max?: NestedEnumEstadoIntentoFilter<$PrismaModel>
  }

  export type NestedEnumResultadoRespuestaFilter<$PrismaModel = never> = {
    equals?: $Enums.ResultadoRespuesta | EnumResultadoRespuestaFieldRefInput<$PrismaModel>
    in?: $Enums.ResultadoRespuesta[] | ListEnumResultadoRespuestaFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResultadoRespuesta[] | ListEnumResultadoRespuestaFieldRefInput<$PrismaModel>
    not?: NestedEnumResultadoRespuestaFilter<$PrismaModel> | $Enums.ResultadoRespuesta
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumResultadoRespuestaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResultadoRespuesta | EnumResultadoRespuestaFieldRefInput<$PrismaModel>
    in?: $Enums.ResultadoRespuesta[] | ListEnumResultadoRespuestaFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResultadoRespuesta[] | ListEnumResultadoRespuestaFieldRefInput<$PrismaModel>
    not?: NestedEnumResultadoRespuestaWithAggregatesFilter<$PrismaModel> | $Enums.ResultadoRespuesta
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResultadoRespuestaFilter<$PrismaModel>
    _max?: NestedEnumResultadoRespuestaFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumEstadoSuscripcionFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoSuscripcion | EnumEstadoSuscripcionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoSuscripcion[] | ListEnumEstadoSuscripcionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoSuscripcion[] | ListEnumEstadoSuscripcionFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoSuscripcionFilter<$PrismaModel> | $Enums.EstadoSuscripcion
  }

  export type NestedEnumEstadoSuscripcionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoSuscripcion | EnumEstadoSuscripcionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoSuscripcion[] | ListEnumEstadoSuscripcionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoSuscripcion[] | ListEnumEstadoSuscripcionFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoSuscripcionWithAggregatesFilter<$PrismaModel> | $Enums.EstadoSuscripcion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoSuscripcionFilter<$PrismaModel>
    _max?: NestedEnumEstadoSuscripcionFilter<$PrismaModel>
  }

  export type usuariosAdministradoresCreateWithoutAuditoriaInput = {
    id?: string
    correo: string
    contrasena: string
    encargado?: string | null
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    tipo: $Enums.TipoCuenta
    docente?: docenteCreateNestedOneWithoutUsuariosAdministradoresInput
    grabaciones?: grabacionesCreateNestedManyWithoutUsuariosAdministradoresInput
  }

  export type usuariosAdministradoresUncheckedCreateWithoutAuditoriaInput = {
    id?: string
    correo: string
    contrasena: string
    encargado?: string | null
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    tipo: $Enums.TipoCuenta
    docente?: docenteUncheckedCreateNestedOneWithoutUsuariosAdministradoresInput
    grabaciones?: grabacionesUncheckedCreateNestedManyWithoutUsuariosAdministradoresInput
  }

  export type usuariosAdministradoresCreateOrConnectWithoutAuditoriaInput = {
    where: usuariosAdministradoresWhereUniqueInput
    create: XOR<usuariosAdministradoresCreateWithoutAuditoriaInput, usuariosAdministradoresUncheckedCreateWithoutAuditoriaInput>
  }

  export type usuariosAdministradoresUpsertWithoutAuditoriaInput = {
    update: XOR<usuariosAdministradoresUpdateWithoutAuditoriaInput, usuariosAdministradoresUncheckedUpdateWithoutAuditoriaInput>
    create: XOR<usuariosAdministradoresCreateWithoutAuditoriaInput, usuariosAdministradoresUncheckedCreateWithoutAuditoriaInput>
    where?: usuariosAdministradoresWhereInput
  }

  export type usuariosAdministradoresUpdateToOneWithWhereWithoutAuditoriaInput = {
    where?: usuariosAdministradoresWhereInput
    data: XOR<usuariosAdministradoresUpdateWithoutAuditoriaInput, usuariosAdministradoresUncheckedUpdateWithoutAuditoriaInput>
  }

  export type usuariosAdministradoresUpdateWithoutAuditoriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    encargado?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCuentaFieldUpdateOperationsInput | $Enums.TipoCuenta
    docente?: docenteUpdateOneWithoutUsuariosAdministradoresNestedInput
    grabaciones?: grabacionesUpdateManyWithoutUsuariosAdministradoresNestedInput
  }

  export type usuariosAdministradoresUncheckedUpdateWithoutAuditoriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    encargado?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCuentaFieldUpdateOperationsInput | $Enums.TipoCuenta
    docente?: docenteUncheckedUpdateOneWithoutUsuariosAdministradoresNestedInput
    grabaciones?: grabacionesUncheckedUpdateManyWithoutUsuariosAdministradoresNestedInput
  }

  export type cursosCreateWithoutBeneficiosCursosInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    cargaHoraria?: number
    codigo: string
    categoriasCursos?: categoriasCursosCreateNestedManyWithoutCursosInput
    edicionesCursos?: edicionesCursosCreateNestedManyWithoutCursosInput
    objetivosCursos?: objetivosCursosCreateNestedManyWithoutCursosInput
    requisitosCursos?: requisitosCursosCreateNestedManyWithoutCursosInput
    reviewsCursos?: reviewsCursosCreateNestedManyWithoutCursosInput
  }

  export type cursosUncheckedCreateWithoutBeneficiosCursosInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    cargaHoraria?: number
    codigo: string
    categoriasCursos?: categoriasCursosUncheckedCreateNestedManyWithoutCursosInput
    edicionesCursos?: edicionesCursosUncheckedCreateNestedManyWithoutCursosInput
    objetivosCursos?: objetivosCursosUncheckedCreateNestedManyWithoutCursosInput
    requisitosCursos?: requisitosCursosUncheckedCreateNestedManyWithoutCursosInput
    reviewsCursos?: reviewsCursosUncheckedCreateNestedManyWithoutCursosInput
  }

  export type cursosCreateOrConnectWithoutBeneficiosCursosInput = {
    where: cursosWhereUniqueInput
    create: XOR<cursosCreateWithoutBeneficiosCursosInput, cursosUncheckedCreateWithoutBeneficiosCursosInput>
  }

  export type cursosUpsertWithoutBeneficiosCursosInput = {
    update: XOR<cursosUpdateWithoutBeneficiosCursosInput, cursosUncheckedUpdateWithoutBeneficiosCursosInput>
    create: XOR<cursosCreateWithoutBeneficiosCursosInput, cursosUncheckedCreateWithoutBeneficiosCursosInput>
    where?: cursosWhereInput
  }

  export type cursosUpdateToOneWithWhereWithoutBeneficiosCursosInput = {
    where?: cursosWhereInput
    data: XOR<cursosUpdateWithoutBeneficiosCursosInput, cursosUncheckedUpdateWithoutBeneficiosCursosInput>
  }

  export type cursosUpdateWithoutBeneficiosCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    cargaHoraria?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    categoriasCursos?: categoriasCursosUpdateManyWithoutCursosNestedInput
    edicionesCursos?: edicionesCursosUpdateManyWithoutCursosNestedInput
    objetivosCursos?: objetivosCursosUpdateManyWithoutCursosNestedInput
    requisitosCursos?: requisitosCursosUpdateManyWithoutCursosNestedInput
    reviewsCursos?: reviewsCursosUpdateManyWithoutCursosNestedInput
  }

  export type cursosUncheckedUpdateWithoutBeneficiosCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    cargaHoraria?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    categoriasCursos?: categoriasCursosUncheckedUpdateManyWithoutCursosNestedInput
    edicionesCursos?: edicionesCursosUncheckedUpdateManyWithoutCursosNestedInput
    objetivosCursos?: objetivosCursosUncheckedUpdateManyWithoutCursosNestedInput
    requisitosCursos?: requisitosCursosUncheckedUpdateManyWithoutCursosNestedInput
    reviewsCursos?: reviewsCursosUncheckedUpdateManyWithoutCursosNestedInput
  }

  export type estudiantesCreateWithoutCalificacionesInput = {
    id?: string
    apellido?: string | null
    celular?: string | null
    pais?: string
    genero?: $Enums.TipoGenero
    fechaNacimiento?: Date | string | null
    nombre: string
    creadoEn?: Date | string
    actualizadoEn: Date | string
    nroUpdates?: number
    certificados?: certificadosCreateNestedManyWithoutEstudiantesInput
    inscripciones?: inscripcionesCreateNestedManyWithoutEstudiantesInput
    usuariosEstudiantes?: usuariosEstudiantesCreateNestedOneWithoutEstudiantesInput
  }

  export type estudiantesUncheckedCreateWithoutCalificacionesInput = {
    id?: string
    apellido?: string | null
    celular?: string | null
    pais?: string
    genero?: $Enums.TipoGenero
    fechaNacimiento?: Date | string | null
    nombre: string
    creadoEn?: Date | string
    actualizadoEn: Date | string
    nroUpdates?: number
    certificados?: certificadosUncheckedCreateNestedManyWithoutEstudiantesInput
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEstudiantesInput
    usuariosEstudiantes?: usuariosEstudiantesUncheckedCreateNestedOneWithoutEstudiantesInput
  }

  export type estudiantesCreateOrConnectWithoutCalificacionesInput = {
    where: estudiantesWhereUniqueInput
    create: XOR<estudiantesCreateWithoutCalificacionesInput, estudiantesUncheckedCreateWithoutCalificacionesInput>
  }

  export type examenesCreateWithoutCalificacionesInput = {
    id?: string
    descripcion?: string | null
    fechaDisponible: Date | string
    fechaLimite: Date | string
    notaMaxima: number
    notaMinima: number
    titulo: string
    creadoEn?: Date | string
    edicionesCursos: edicionesCursosCreateNestedOneWithoutExamenesInput
  }

  export type examenesUncheckedCreateWithoutCalificacionesInput = {
    id?: string
    edicionId: string
    descripcion?: string | null
    fechaDisponible: Date | string
    fechaLimite: Date | string
    notaMaxima: number
    notaMinima: number
    titulo: string
    creadoEn?: Date | string
  }

  export type examenesCreateOrConnectWithoutCalificacionesInput = {
    where: examenesWhereUniqueInput
    create: XOR<examenesCreateWithoutCalificacionesInput, examenesUncheckedCreateWithoutCalificacionesInput>
  }

  export type estudiantesUpsertWithoutCalificacionesInput = {
    update: XOR<estudiantesUpdateWithoutCalificacionesInput, estudiantesUncheckedUpdateWithoutCalificacionesInput>
    create: XOR<estudiantesCreateWithoutCalificacionesInput, estudiantesUncheckedCreateWithoutCalificacionesInput>
    where?: estudiantesWhereInput
  }

  export type estudiantesUpdateToOneWithWhereWithoutCalificacionesInput = {
    where?: estudiantesWhereInput
    data: XOR<estudiantesUpdateWithoutCalificacionesInput, estudiantesUncheckedUpdateWithoutCalificacionesInput>
  }

  export type estudiantesUpdateWithoutCalificacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: StringFieldUpdateOperationsInput | string
    genero?: EnumTipoGeneroFieldUpdateOperationsInput | $Enums.TipoGenero
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    nroUpdates?: IntFieldUpdateOperationsInput | number
    certificados?: certificadosUpdateManyWithoutEstudiantesNestedInput
    inscripciones?: inscripcionesUpdateManyWithoutEstudiantesNestedInput
    usuariosEstudiantes?: usuariosEstudiantesUpdateOneWithoutEstudiantesNestedInput
  }

  export type estudiantesUncheckedUpdateWithoutCalificacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: StringFieldUpdateOperationsInput | string
    genero?: EnumTipoGeneroFieldUpdateOperationsInput | $Enums.TipoGenero
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    nroUpdates?: IntFieldUpdateOperationsInput | number
    certificados?: certificadosUncheckedUpdateManyWithoutEstudiantesNestedInput
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEstudiantesNestedInput
    usuariosEstudiantes?: usuariosEstudiantesUncheckedUpdateOneWithoutEstudiantesNestedInput
  }

  export type examenesUpsertWithoutCalificacionesInput = {
    update: XOR<examenesUpdateWithoutCalificacionesInput, examenesUncheckedUpdateWithoutCalificacionesInput>
    create: XOR<examenesCreateWithoutCalificacionesInput, examenesUncheckedCreateWithoutCalificacionesInput>
    where?: examenesWhereInput
  }

  export type examenesUpdateToOneWithWhereWithoutCalificacionesInput = {
    where?: examenesWhereInput
    data: XOR<examenesUpdateWithoutCalificacionesInput, examenesUncheckedUpdateWithoutCalificacionesInput>
  }

  export type examenesUpdateWithoutCalificacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaDisponible?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    edicionesCursos?: edicionesCursosUpdateOneRequiredWithoutExamenesNestedInput
  }

  export type examenesUncheckedUpdateWithoutCalificacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaDisponible?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type categoriasCursosCreateWithoutCategoriasInput = {
    id?: string
    cursos: cursosCreateNestedOneWithoutCategoriasCursosInput
  }

  export type categoriasCursosUncheckedCreateWithoutCategoriasInput = {
    id?: string
    cursoId: string
  }

  export type categoriasCursosCreateOrConnectWithoutCategoriasInput = {
    where: categoriasCursosWhereUniqueInput
    create: XOR<categoriasCursosCreateWithoutCategoriasInput, categoriasCursosUncheckedCreateWithoutCategoriasInput>
  }

  export type categoriasCursosCreateManyCategoriasInputEnvelope = {
    data: categoriasCursosCreateManyCategoriasInput | categoriasCursosCreateManyCategoriasInput[]
    skipDuplicates?: boolean
  }

  export type categoriasCursosUpsertWithWhereUniqueWithoutCategoriasInput = {
    where: categoriasCursosWhereUniqueInput
    update: XOR<categoriasCursosUpdateWithoutCategoriasInput, categoriasCursosUncheckedUpdateWithoutCategoriasInput>
    create: XOR<categoriasCursosCreateWithoutCategoriasInput, categoriasCursosUncheckedCreateWithoutCategoriasInput>
  }

  export type categoriasCursosUpdateWithWhereUniqueWithoutCategoriasInput = {
    where: categoriasCursosWhereUniqueInput
    data: XOR<categoriasCursosUpdateWithoutCategoriasInput, categoriasCursosUncheckedUpdateWithoutCategoriasInput>
  }

  export type categoriasCursosUpdateManyWithWhereWithoutCategoriasInput = {
    where: categoriasCursosScalarWhereInput
    data: XOR<categoriasCursosUpdateManyMutationInput, categoriasCursosUncheckedUpdateManyWithoutCategoriasInput>
  }

  export type categoriasCursosScalarWhereInput = {
    AND?: categoriasCursosScalarWhereInput | categoriasCursosScalarWhereInput[]
    OR?: categoriasCursosScalarWhereInput[]
    NOT?: categoriasCursosScalarWhereInput | categoriasCursosScalarWhereInput[]
    id?: StringFilter<"categoriasCursos"> | string
    categoriaId?: StringFilter<"categoriasCursos"> | string
    cursoId?: StringFilter<"categoriasCursos"> | string
  }

  export type categoriasCreateWithoutCategoriasCursosInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type categoriasUncheckedCreateWithoutCategoriasCursosInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type categoriasCreateOrConnectWithoutCategoriasCursosInput = {
    where: categoriasWhereUniqueInput
    create: XOR<categoriasCreateWithoutCategoriasCursosInput, categoriasUncheckedCreateWithoutCategoriasCursosInput>
  }

  export type cursosCreateWithoutCategoriasCursosInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    cargaHoraria?: number
    codigo: string
    beneficiosCursos?: beneficiosCursosCreateNestedManyWithoutCursosInput
    edicionesCursos?: edicionesCursosCreateNestedManyWithoutCursosInput
    objetivosCursos?: objetivosCursosCreateNestedManyWithoutCursosInput
    requisitosCursos?: requisitosCursosCreateNestedManyWithoutCursosInput
    reviewsCursos?: reviewsCursosCreateNestedManyWithoutCursosInput
  }

  export type cursosUncheckedCreateWithoutCategoriasCursosInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    cargaHoraria?: number
    codigo: string
    beneficiosCursos?: beneficiosCursosUncheckedCreateNestedManyWithoutCursosInput
    edicionesCursos?: edicionesCursosUncheckedCreateNestedManyWithoutCursosInput
    objetivosCursos?: objetivosCursosUncheckedCreateNestedManyWithoutCursosInput
    requisitosCursos?: requisitosCursosUncheckedCreateNestedManyWithoutCursosInput
    reviewsCursos?: reviewsCursosUncheckedCreateNestedManyWithoutCursosInput
  }

  export type cursosCreateOrConnectWithoutCategoriasCursosInput = {
    where: cursosWhereUniqueInput
    create: XOR<cursosCreateWithoutCategoriasCursosInput, cursosUncheckedCreateWithoutCategoriasCursosInput>
  }

  export type categoriasUpsertWithoutCategoriasCursosInput = {
    update: XOR<categoriasUpdateWithoutCategoriasCursosInput, categoriasUncheckedUpdateWithoutCategoriasCursosInput>
    create: XOR<categoriasCreateWithoutCategoriasCursosInput, categoriasUncheckedCreateWithoutCategoriasCursosInput>
    where?: categoriasWhereInput
  }

  export type categoriasUpdateToOneWithWhereWithoutCategoriasCursosInput = {
    where?: categoriasWhereInput
    data: XOR<categoriasUpdateWithoutCategoriasCursosInput, categoriasUncheckedUpdateWithoutCategoriasCursosInput>
  }

  export type categoriasUpdateWithoutCategoriasCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type categoriasUncheckedUpdateWithoutCategoriasCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cursosUpsertWithoutCategoriasCursosInput = {
    update: XOR<cursosUpdateWithoutCategoriasCursosInput, cursosUncheckedUpdateWithoutCategoriasCursosInput>
    create: XOR<cursosCreateWithoutCategoriasCursosInput, cursosUncheckedCreateWithoutCategoriasCursosInput>
    where?: cursosWhereInput
  }

  export type cursosUpdateToOneWithWhereWithoutCategoriasCursosInput = {
    where?: cursosWhereInput
    data: XOR<cursosUpdateWithoutCategoriasCursosInput, cursosUncheckedUpdateWithoutCategoriasCursosInput>
  }

  export type cursosUpdateWithoutCategoriasCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    cargaHoraria?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    beneficiosCursos?: beneficiosCursosUpdateManyWithoutCursosNestedInput
    edicionesCursos?: edicionesCursosUpdateManyWithoutCursosNestedInput
    objetivosCursos?: objetivosCursosUpdateManyWithoutCursosNestedInput
    requisitosCursos?: requisitosCursosUpdateManyWithoutCursosNestedInput
    reviewsCursos?: reviewsCursosUpdateManyWithoutCursosNestedInput
  }

  export type cursosUncheckedUpdateWithoutCategoriasCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    cargaHoraria?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    beneficiosCursos?: beneficiosCursosUncheckedUpdateManyWithoutCursosNestedInput
    edicionesCursos?: edicionesCursosUncheckedUpdateManyWithoutCursosNestedInput
    objetivosCursos?: objetivosCursosUncheckedUpdateManyWithoutCursosNestedInput
    requisitosCursos?: requisitosCursosUncheckedUpdateManyWithoutCursosNestedInput
    reviewsCursos?: reviewsCursosUncheckedUpdateManyWithoutCursosNestedInput
  }

  export type edicionesCursosCreateWithoutCertificadosInput = {
    id?: string
    codigo: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    clases?: clasesCreateNestedManyWithoutEdicionesCursosInput
    compras?: comprasCreateNestedManyWithoutEdicionesCursosInput
    cursos: cursosCreateNestedOneWithoutEdicionesCursosInput
    docente?: docenteCreateNestedOneWithoutEdicionesCursosInput
    examenes?: examenesCreateNestedManyWithoutEdicionesCursosInput
    inscripciones?: inscripcionesCreateNestedManyWithoutEdicionesCursosInput
    pagosDocentes?: pagosDocentesCreateNestedOneWithoutEdicionesCursosInput
    preciosCursos?: preciosCursosCreateNestedManyWithoutEdicionesCursosInput
  }

  export type edicionesCursosUncheckedCreateWithoutCertificadosInput = {
    id?: string
    codigo: string
    cursoId: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    docenteId?: string | null
    clases?: clasesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    compras?: comprasUncheckedCreateNestedManyWithoutEdicionesCursosInput
    examenes?: examenesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    pagosDocentes?: pagosDocentesUncheckedCreateNestedOneWithoutEdicionesCursosInput
    preciosCursos?: preciosCursosUncheckedCreateNestedManyWithoutEdicionesCursosInput
  }

  export type edicionesCursosCreateOrConnectWithoutCertificadosInput = {
    where: edicionesCursosWhereUniqueInput
    create: XOR<edicionesCursosCreateWithoutCertificadosInput, edicionesCursosUncheckedCreateWithoutCertificadosInput>
  }

  export type estudiantesCreateWithoutCertificadosInput = {
    id?: string
    apellido?: string | null
    celular?: string | null
    pais?: string
    genero?: $Enums.TipoGenero
    fechaNacimiento?: Date | string | null
    nombre: string
    creadoEn?: Date | string
    actualizadoEn: Date | string
    nroUpdates?: number
    calificaciones?: calificacionesCreateNestedManyWithoutEstudiantesInput
    inscripciones?: inscripcionesCreateNestedManyWithoutEstudiantesInput
    usuariosEstudiantes?: usuariosEstudiantesCreateNestedOneWithoutEstudiantesInput
  }

  export type estudiantesUncheckedCreateWithoutCertificadosInput = {
    id?: string
    apellido?: string | null
    celular?: string | null
    pais?: string
    genero?: $Enums.TipoGenero
    fechaNacimiento?: Date | string | null
    nombre: string
    creadoEn?: Date | string
    actualizadoEn: Date | string
    nroUpdates?: number
    calificaciones?: calificacionesUncheckedCreateNestedManyWithoutEstudiantesInput
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEstudiantesInput
    usuariosEstudiantes?: usuariosEstudiantesUncheckedCreateNestedOneWithoutEstudiantesInput
  }

  export type estudiantesCreateOrConnectWithoutCertificadosInput = {
    where: estudiantesWhereUniqueInput
    create: XOR<estudiantesCreateWithoutCertificadosInput, estudiantesUncheckedCreateWithoutCertificadosInput>
  }

  export type edicionesCursosUpsertWithoutCertificadosInput = {
    update: XOR<edicionesCursosUpdateWithoutCertificadosInput, edicionesCursosUncheckedUpdateWithoutCertificadosInput>
    create: XOR<edicionesCursosCreateWithoutCertificadosInput, edicionesCursosUncheckedCreateWithoutCertificadosInput>
    where?: edicionesCursosWhereInput
  }

  export type edicionesCursosUpdateToOneWithWhereWithoutCertificadosInput = {
    where?: edicionesCursosWhereInput
    data: XOR<edicionesCursosUpdateWithoutCertificadosInput, edicionesCursosUncheckedUpdateWithoutCertificadosInput>
  }

  export type edicionesCursosUpdateWithoutCertificadosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    clases?: clasesUpdateManyWithoutEdicionesCursosNestedInput
    compras?: comprasUpdateManyWithoutEdicionesCursosNestedInput
    cursos?: cursosUpdateOneRequiredWithoutEdicionesCursosNestedInput
    docente?: docenteUpdateOneWithoutEdicionesCursosNestedInput
    examenes?: examenesUpdateManyWithoutEdicionesCursosNestedInput
    inscripciones?: inscripcionesUpdateManyWithoutEdicionesCursosNestedInput
    pagosDocentes?: pagosDocentesUpdateOneWithoutEdicionesCursosNestedInput
    preciosCursos?: preciosCursosUpdateManyWithoutEdicionesCursosNestedInput
  }

  export type edicionesCursosUncheckedUpdateWithoutCertificadosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docenteId?: NullableStringFieldUpdateOperationsInput | string | null
    clases?: clasesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    compras?: comprasUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    examenes?: examenesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    pagosDocentes?: pagosDocentesUncheckedUpdateOneWithoutEdicionesCursosNestedInput
    preciosCursos?: preciosCursosUncheckedUpdateManyWithoutEdicionesCursosNestedInput
  }

  export type estudiantesUpsertWithoutCertificadosInput = {
    update: XOR<estudiantesUpdateWithoutCertificadosInput, estudiantesUncheckedUpdateWithoutCertificadosInput>
    create: XOR<estudiantesCreateWithoutCertificadosInput, estudiantesUncheckedCreateWithoutCertificadosInput>
    where?: estudiantesWhereInput
  }

  export type estudiantesUpdateToOneWithWhereWithoutCertificadosInput = {
    where?: estudiantesWhereInput
    data: XOR<estudiantesUpdateWithoutCertificadosInput, estudiantesUncheckedUpdateWithoutCertificadosInput>
  }

  export type estudiantesUpdateWithoutCertificadosInput = {
    id?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: StringFieldUpdateOperationsInput | string
    genero?: EnumTipoGeneroFieldUpdateOperationsInput | $Enums.TipoGenero
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    nroUpdates?: IntFieldUpdateOperationsInput | number
    calificaciones?: calificacionesUpdateManyWithoutEstudiantesNestedInput
    inscripciones?: inscripcionesUpdateManyWithoutEstudiantesNestedInput
    usuariosEstudiantes?: usuariosEstudiantesUpdateOneWithoutEstudiantesNestedInput
  }

  export type estudiantesUncheckedUpdateWithoutCertificadosInput = {
    id?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: StringFieldUpdateOperationsInput | string
    genero?: EnumTipoGeneroFieldUpdateOperationsInput | $Enums.TipoGenero
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    nroUpdates?: IntFieldUpdateOperationsInput | number
    calificaciones?: calificacionesUncheckedUpdateManyWithoutEstudiantesNestedInput
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEstudiantesNestedInput
    usuariosEstudiantes?: usuariosEstudiantesUncheckedUpdateOneWithoutEstudiantesNestedInput
  }

  export type edicionesCursosCreateWithoutClasesInput = {
    id?: string
    codigo: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    certificados?: certificadosCreateNestedManyWithoutEdicionesCursosInput
    compras?: comprasCreateNestedManyWithoutEdicionesCursosInput
    cursos: cursosCreateNestedOneWithoutEdicionesCursosInput
    docente?: docenteCreateNestedOneWithoutEdicionesCursosInput
    examenes?: examenesCreateNestedManyWithoutEdicionesCursosInput
    inscripciones?: inscripcionesCreateNestedManyWithoutEdicionesCursosInput
    pagosDocentes?: pagosDocentesCreateNestedOneWithoutEdicionesCursosInput
    preciosCursos?: preciosCursosCreateNestedManyWithoutEdicionesCursosInput
  }

  export type edicionesCursosUncheckedCreateWithoutClasesInput = {
    id?: string
    codigo: string
    cursoId: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    docenteId?: string | null
    certificados?: certificadosUncheckedCreateNestedManyWithoutEdicionesCursosInput
    compras?: comprasUncheckedCreateNestedManyWithoutEdicionesCursosInput
    examenes?: examenesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    pagosDocentes?: pagosDocentesUncheckedCreateNestedOneWithoutEdicionesCursosInput
    preciosCursos?: preciosCursosUncheckedCreateNestedManyWithoutEdicionesCursosInput
  }

  export type edicionesCursosCreateOrConnectWithoutClasesInput = {
    where: edicionesCursosWhereUniqueInput
    create: XOR<edicionesCursosCreateWithoutClasesInput, edicionesCursosUncheckedCreateWithoutClasesInput>
  }

  export type grabacionesCreateWithoutClasesInput = {
    id?: string
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    duracionSegundos?: number | null
    completada?: boolean
    usuariosAdministradores: usuariosAdministradoresCreateNestedOneWithoutGrabacionesInput
  }

  export type grabacionesUncheckedCreateWithoutClasesInput = {
    id?: string
    usuarioId: string
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    duracionSegundos?: number | null
    completada?: boolean
  }

  export type grabacionesCreateOrConnectWithoutClasesInput = {
    where: grabacionesWhereUniqueInput
    create: XOR<grabacionesCreateWithoutClasesInput, grabacionesUncheckedCreateWithoutClasesInput>
  }

  export type grabacionesCreateManyClasesInputEnvelope = {
    data: grabacionesCreateManyClasesInput | grabacionesCreateManyClasesInput[]
    skipDuplicates?: boolean
  }

  export type materialesCreateWithoutClasesInput = {
    id?: string
    tipo?: $Enums.TipoMaterial
    titulo: string
    url: string
    creadoEn?: Date | string
  }

  export type materialesUncheckedCreateWithoutClasesInput = {
    id?: string
    tipo?: $Enums.TipoMaterial
    titulo: string
    url: string
    creadoEn?: Date | string
  }

  export type materialesCreateOrConnectWithoutClasesInput = {
    where: materialesWhereUniqueInput
    create: XOR<materialesCreateWithoutClasesInput, materialesUncheckedCreateWithoutClasesInput>
  }

  export type materialesCreateManyClasesInputEnvelope = {
    data: materialesCreateManyClasesInput | materialesCreateManyClasesInput[]
    skipDuplicates?: boolean
  }

  export type edicionesCursosUpsertWithoutClasesInput = {
    update: XOR<edicionesCursosUpdateWithoutClasesInput, edicionesCursosUncheckedUpdateWithoutClasesInput>
    create: XOR<edicionesCursosCreateWithoutClasesInput, edicionesCursosUncheckedCreateWithoutClasesInput>
    where?: edicionesCursosWhereInput
  }

  export type edicionesCursosUpdateToOneWithWhereWithoutClasesInput = {
    where?: edicionesCursosWhereInput
    data: XOR<edicionesCursosUpdateWithoutClasesInput, edicionesCursosUncheckedUpdateWithoutClasesInput>
  }

  export type edicionesCursosUpdateWithoutClasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    certificados?: certificadosUpdateManyWithoutEdicionesCursosNestedInput
    compras?: comprasUpdateManyWithoutEdicionesCursosNestedInput
    cursos?: cursosUpdateOneRequiredWithoutEdicionesCursosNestedInput
    docente?: docenteUpdateOneWithoutEdicionesCursosNestedInput
    examenes?: examenesUpdateManyWithoutEdicionesCursosNestedInput
    inscripciones?: inscripcionesUpdateManyWithoutEdicionesCursosNestedInput
    pagosDocentes?: pagosDocentesUpdateOneWithoutEdicionesCursosNestedInput
    preciosCursos?: preciosCursosUpdateManyWithoutEdicionesCursosNestedInput
  }

  export type edicionesCursosUncheckedUpdateWithoutClasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docenteId?: NullableStringFieldUpdateOperationsInput | string | null
    certificados?: certificadosUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    compras?: comprasUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    examenes?: examenesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    pagosDocentes?: pagosDocentesUncheckedUpdateOneWithoutEdicionesCursosNestedInput
    preciosCursos?: preciosCursosUncheckedUpdateManyWithoutEdicionesCursosNestedInput
  }

  export type grabacionesUpsertWithWhereUniqueWithoutClasesInput = {
    where: grabacionesWhereUniqueInput
    update: XOR<grabacionesUpdateWithoutClasesInput, grabacionesUncheckedUpdateWithoutClasesInput>
    create: XOR<grabacionesCreateWithoutClasesInput, grabacionesUncheckedCreateWithoutClasesInput>
  }

  export type grabacionesUpdateWithWhereUniqueWithoutClasesInput = {
    where: grabacionesWhereUniqueInput
    data: XOR<grabacionesUpdateWithoutClasesInput, grabacionesUncheckedUpdateWithoutClasesInput>
  }

  export type grabacionesUpdateManyWithWhereWithoutClasesInput = {
    where: grabacionesScalarWhereInput
    data: XOR<grabacionesUpdateManyMutationInput, grabacionesUncheckedUpdateManyWithoutClasesInput>
  }

  export type grabacionesScalarWhereInput = {
    AND?: grabacionesScalarWhereInput | grabacionesScalarWhereInput[]
    OR?: grabacionesScalarWhereInput[]
    NOT?: grabacionesScalarWhereInput | grabacionesScalarWhereInput[]
    id?: StringFilter<"grabaciones"> | string
    claseId?: StringFilter<"grabaciones"> | string
    usuarioId?: StringFilter<"grabaciones"> | string
    fechaInicio?: DateTimeFilter<"grabaciones"> | Date | string
    fechaFin?: DateTimeNullableFilter<"grabaciones"> | Date | string | null
    duracionSegundos?: IntNullableFilter<"grabaciones"> | number | null
    completada?: BoolFilter<"grabaciones"> | boolean
  }

  export type materialesUpsertWithWhereUniqueWithoutClasesInput = {
    where: materialesWhereUniqueInput
    update: XOR<materialesUpdateWithoutClasesInput, materialesUncheckedUpdateWithoutClasesInput>
    create: XOR<materialesCreateWithoutClasesInput, materialesUncheckedCreateWithoutClasesInput>
  }

  export type materialesUpdateWithWhereUniqueWithoutClasesInput = {
    where: materialesWhereUniqueInput
    data: XOR<materialesUpdateWithoutClasesInput, materialesUncheckedUpdateWithoutClasesInput>
  }

  export type materialesUpdateManyWithWhereWithoutClasesInput = {
    where: materialesScalarWhereInput
    data: XOR<materialesUpdateManyMutationInput, materialesUncheckedUpdateManyWithoutClasesInput>
  }

  export type materialesScalarWhereInput = {
    AND?: materialesScalarWhereInput | materialesScalarWhereInput[]
    OR?: materialesScalarWhereInput[]
    NOT?: materialesScalarWhereInput | materialesScalarWhereInput[]
    id?: StringFilter<"materiales"> | string
    claseId?: StringFilter<"materiales"> | string
    tipo?: EnumTipoMaterialFilter<"materiales"> | $Enums.TipoMaterial
    titulo?: StringFilter<"materiales"> | string
    url?: StringFilter<"materiales"> | string
    creadoEn?: DateTimeFilter<"materiales"> | Date | string
  }

  export type edicionesCursosCreateWithoutComprasInput = {
    id?: string
    codigo: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    certificados?: certificadosCreateNestedManyWithoutEdicionesCursosInput
    clases?: clasesCreateNestedManyWithoutEdicionesCursosInput
    cursos: cursosCreateNestedOneWithoutEdicionesCursosInput
    docente?: docenteCreateNestedOneWithoutEdicionesCursosInput
    examenes?: examenesCreateNestedManyWithoutEdicionesCursosInput
    inscripciones?: inscripcionesCreateNestedManyWithoutEdicionesCursosInput
    pagosDocentes?: pagosDocentesCreateNestedOneWithoutEdicionesCursosInput
    preciosCursos?: preciosCursosCreateNestedManyWithoutEdicionesCursosInput
  }

  export type edicionesCursosUncheckedCreateWithoutComprasInput = {
    id?: string
    codigo: string
    cursoId: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    docenteId?: string | null
    certificados?: certificadosUncheckedCreateNestedManyWithoutEdicionesCursosInput
    clases?: clasesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    examenes?: examenesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    pagosDocentes?: pagosDocentesUncheckedCreateNestedOneWithoutEdicionesCursosInput
    preciosCursos?: preciosCursosUncheckedCreateNestedManyWithoutEdicionesCursosInput
  }

  export type edicionesCursosCreateOrConnectWithoutComprasInput = {
    where: edicionesCursosWhereUniqueInput
    create: XOR<edicionesCursosCreateWithoutComprasInput, edicionesCursosUncheckedCreateWithoutComprasInput>
  }

  export type usuariosEstudiantesCreateWithoutComprasInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    avatar?: string | null
    registrado?: boolean
    intentos?: intentosCreateNestedManyWithoutUsuariosEstudiantesInput
    reaccionesPreguntas?: reaccionesPreguntasCreateNestedManyWithoutUsuariosEstudiantesInput
    repasoRegistros?: repasoRegistrosCreateNestedManyWithoutUsuariosEstudiantesInput
    reviewsCursos?: reviewsCursosCreateNestedManyWithoutUsuariosEstudiantesInput
    suscripciones?: suscripcionesCreateNestedManyWithoutUsuariosEstudiantesInput
    estudiantes?: estudiantesCreateNestedOneWithoutUsuariosEstudiantesInput
  }

  export type usuariosEstudiantesUncheckedCreateWithoutComprasInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    avatar?: string | null
    estudianteId?: string | null
    registrado?: boolean
    intentos?: intentosUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    reaccionesPreguntas?: reaccionesPreguntasUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    repasoRegistros?: repasoRegistrosUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    reviewsCursos?: reviewsCursosUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    suscripciones?: suscripcionesUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
  }

  export type usuariosEstudiantesCreateOrConnectWithoutComprasInput = {
    where: usuariosEstudiantesWhereUniqueInput
    create: XOR<usuariosEstudiantesCreateWithoutComprasInput, usuariosEstudiantesUncheckedCreateWithoutComprasInput>
  }

  export type inscripcionesCreateWithoutComprasInput = {
    id?: string
    estado?: boolean
    inscritoEn?: Date | string
    edicionesCursos: edicionesCursosCreateNestedOneWithoutInscripcionesInput
    estudiantes: estudiantesCreateNestedOneWithoutInscripcionesInput
  }

  export type inscripcionesUncheckedCreateWithoutComprasInput = {
    id?: string
    edicionId: string
    estado?: boolean
    estudianteId: string
    inscritoEn?: Date | string
  }

  export type inscripcionesCreateOrConnectWithoutComprasInput = {
    where: inscripcionesWhereUniqueInput
    create: XOR<inscripcionesCreateWithoutComprasInput, inscripcionesUncheckedCreateWithoutComprasInput>
  }

  export type edicionesCursosUpsertWithoutComprasInput = {
    update: XOR<edicionesCursosUpdateWithoutComprasInput, edicionesCursosUncheckedUpdateWithoutComprasInput>
    create: XOR<edicionesCursosCreateWithoutComprasInput, edicionesCursosUncheckedCreateWithoutComprasInput>
    where?: edicionesCursosWhereInput
  }

  export type edicionesCursosUpdateToOneWithWhereWithoutComprasInput = {
    where?: edicionesCursosWhereInput
    data: XOR<edicionesCursosUpdateWithoutComprasInput, edicionesCursosUncheckedUpdateWithoutComprasInput>
  }

  export type edicionesCursosUpdateWithoutComprasInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    certificados?: certificadosUpdateManyWithoutEdicionesCursosNestedInput
    clases?: clasesUpdateManyWithoutEdicionesCursosNestedInput
    cursos?: cursosUpdateOneRequiredWithoutEdicionesCursosNestedInput
    docente?: docenteUpdateOneWithoutEdicionesCursosNestedInput
    examenes?: examenesUpdateManyWithoutEdicionesCursosNestedInput
    inscripciones?: inscripcionesUpdateManyWithoutEdicionesCursosNestedInput
    pagosDocentes?: pagosDocentesUpdateOneWithoutEdicionesCursosNestedInput
    preciosCursos?: preciosCursosUpdateManyWithoutEdicionesCursosNestedInput
  }

  export type edicionesCursosUncheckedUpdateWithoutComprasInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docenteId?: NullableStringFieldUpdateOperationsInput | string | null
    certificados?: certificadosUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    clases?: clasesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    examenes?: examenesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    pagosDocentes?: pagosDocentesUncheckedUpdateOneWithoutEdicionesCursosNestedInput
    preciosCursos?: preciosCursosUncheckedUpdateManyWithoutEdicionesCursosNestedInput
  }

  export type usuariosEstudiantesUpsertWithoutComprasInput = {
    update: XOR<usuariosEstudiantesUpdateWithoutComprasInput, usuariosEstudiantesUncheckedUpdateWithoutComprasInput>
    create: XOR<usuariosEstudiantesCreateWithoutComprasInput, usuariosEstudiantesUncheckedCreateWithoutComprasInput>
    where?: usuariosEstudiantesWhereInput
  }

  export type usuariosEstudiantesUpdateToOneWithWhereWithoutComprasInput = {
    where?: usuariosEstudiantesWhereInput
    data: XOR<usuariosEstudiantesUpdateWithoutComprasInput, usuariosEstudiantesUncheckedUpdateWithoutComprasInput>
  }

  export type usuariosEstudiantesUpdateWithoutComprasInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
    intentos?: intentosUpdateManyWithoutUsuariosEstudiantesNestedInput
    reaccionesPreguntas?: reaccionesPreguntasUpdateManyWithoutUsuariosEstudiantesNestedInput
    repasoRegistros?: repasoRegistrosUpdateManyWithoutUsuariosEstudiantesNestedInput
    reviewsCursos?: reviewsCursosUpdateManyWithoutUsuariosEstudiantesNestedInput
    suscripciones?: suscripcionesUpdateManyWithoutUsuariosEstudiantesNestedInput
    estudiantes?: estudiantesUpdateOneWithoutUsuariosEstudiantesNestedInput
  }

  export type usuariosEstudiantesUncheckedUpdateWithoutComprasInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
    intentos?: intentosUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    reaccionesPreguntas?: reaccionesPreguntasUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    repasoRegistros?: repasoRegistrosUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    reviewsCursos?: reviewsCursosUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    suscripciones?: suscripcionesUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
  }

  export type inscripcionesUpsertWithoutComprasInput = {
    update: XOR<inscripcionesUpdateWithoutComprasInput, inscripcionesUncheckedUpdateWithoutComprasInput>
    create: XOR<inscripcionesCreateWithoutComprasInput, inscripcionesUncheckedCreateWithoutComprasInput>
    where?: inscripcionesWhereInput
  }

  export type inscripcionesUpdateToOneWithWhereWithoutComprasInput = {
    where?: inscripcionesWhereInput
    data: XOR<inscripcionesUpdateWithoutComprasInput, inscripcionesUncheckedUpdateWithoutComprasInput>
  }

  export type inscripcionesUpdateWithoutComprasInput = {
    id?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    inscritoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    edicionesCursos?: edicionesCursosUpdateOneRequiredWithoutInscripcionesNestedInput
    estudiantes?: estudiantesUpdateOneRequiredWithoutInscripcionesNestedInput
  }

  export type inscripcionesUncheckedUpdateWithoutComprasInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    estudianteId?: StringFieldUpdateOperationsInput | string
    inscritoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type beneficiosCursosCreateWithoutCursosInput = {
    id?: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type beneficiosCursosUncheckedCreateWithoutCursosInput = {
    id?: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type beneficiosCursosCreateOrConnectWithoutCursosInput = {
    where: beneficiosCursosWhereUniqueInput
    create: XOR<beneficiosCursosCreateWithoutCursosInput, beneficiosCursosUncheckedCreateWithoutCursosInput>
  }

  export type beneficiosCursosCreateManyCursosInputEnvelope = {
    data: beneficiosCursosCreateManyCursosInput | beneficiosCursosCreateManyCursosInput[]
    skipDuplicates?: boolean
  }

  export type categoriasCursosCreateWithoutCursosInput = {
    id?: string
    categorias: categoriasCreateNestedOneWithoutCategoriasCursosInput
  }

  export type categoriasCursosUncheckedCreateWithoutCursosInput = {
    id?: string
    categoriaId: string
  }

  export type categoriasCursosCreateOrConnectWithoutCursosInput = {
    where: categoriasCursosWhereUniqueInput
    create: XOR<categoriasCursosCreateWithoutCursosInput, categoriasCursosUncheckedCreateWithoutCursosInput>
  }

  export type categoriasCursosCreateManyCursosInputEnvelope = {
    data: categoriasCursosCreateManyCursosInput | categoriasCursosCreateManyCursosInput[]
    skipDuplicates?: boolean
  }

  export type edicionesCursosCreateWithoutCursosInput = {
    id?: string
    codigo: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    certificados?: certificadosCreateNestedManyWithoutEdicionesCursosInput
    clases?: clasesCreateNestedManyWithoutEdicionesCursosInput
    compras?: comprasCreateNestedManyWithoutEdicionesCursosInput
    docente?: docenteCreateNestedOneWithoutEdicionesCursosInput
    examenes?: examenesCreateNestedManyWithoutEdicionesCursosInput
    inscripciones?: inscripcionesCreateNestedManyWithoutEdicionesCursosInput
    pagosDocentes?: pagosDocentesCreateNestedOneWithoutEdicionesCursosInput
    preciosCursos?: preciosCursosCreateNestedManyWithoutEdicionesCursosInput
  }

  export type edicionesCursosUncheckedCreateWithoutCursosInput = {
    id?: string
    codigo: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    docenteId?: string | null
    certificados?: certificadosUncheckedCreateNestedManyWithoutEdicionesCursosInput
    clases?: clasesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    compras?: comprasUncheckedCreateNestedManyWithoutEdicionesCursosInput
    examenes?: examenesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    pagosDocentes?: pagosDocentesUncheckedCreateNestedOneWithoutEdicionesCursosInput
    preciosCursos?: preciosCursosUncheckedCreateNestedManyWithoutEdicionesCursosInput
  }

  export type edicionesCursosCreateOrConnectWithoutCursosInput = {
    where: edicionesCursosWhereUniqueInput
    create: XOR<edicionesCursosCreateWithoutCursosInput, edicionesCursosUncheckedCreateWithoutCursosInput>
  }

  export type edicionesCursosCreateManyCursosInputEnvelope = {
    data: edicionesCursosCreateManyCursosInput | edicionesCursosCreateManyCursosInput[]
    skipDuplicates?: boolean
  }

  export type objetivosCursosCreateWithoutCursosInput = {
    id?: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type objetivosCursosUncheckedCreateWithoutCursosInput = {
    id?: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type objetivosCursosCreateOrConnectWithoutCursosInput = {
    where: objetivosCursosWhereUniqueInput
    create: XOR<objetivosCursosCreateWithoutCursosInput, objetivosCursosUncheckedCreateWithoutCursosInput>
  }

  export type objetivosCursosCreateManyCursosInputEnvelope = {
    data: objetivosCursosCreateManyCursosInput | objetivosCursosCreateManyCursosInput[]
    skipDuplicates?: boolean
  }

  export type requisitosCursosCreateWithoutCursosInput = {
    id?: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type requisitosCursosUncheckedCreateWithoutCursosInput = {
    id?: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type requisitosCursosCreateOrConnectWithoutCursosInput = {
    where: requisitosCursosWhereUniqueInput
    create: XOR<requisitosCursosCreateWithoutCursosInput, requisitosCursosUncheckedCreateWithoutCursosInput>
  }

  export type requisitosCursosCreateManyCursosInputEnvelope = {
    data: requisitosCursosCreateManyCursosInput | requisitosCursosCreateManyCursosInput[]
    skipDuplicates?: boolean
  }

  export type reviewsCursosCreateWithoutCursosInput = {
    id?: string
    rating: number
    comentario?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    usuariosEstudiantes?: usuariosEstudiantesCreateNestedOneWithoutReviewsCursosInput
  }

  export type reviewsCursosUncheckedCreateWithoutCursosInput = {
    id?: string
    rating: number
    comentario?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    usuariosEstudiantesId?: string | null
  }

  export type reviewsCursosCreateOrConnectWithoutCursosInput = {
    where: reviewsCursosWhereUniqueInput
    create: XOR<reviewsCursosCreateWithoutCursosInput, reviewsCursosUncheckedCreateWithoutCursosInput>
  }

  export type reviewsCursosCreateManyCursosInputEnvelope = {
    data: reviewsCursosCreateManyCursosInput | reviewsCursosCreateManyCursosInput[]
    skipDuplicates?: boolean
  }

  export type beneficiosCursosUpsertWithWhereUniqueWithoutCursosInput = {
    where: beneficiosCursosWhereUniqueInput
    update: XOR<beneficiosCursosUpdateWithoutCursosInput, beneficiosCursosUncheckedUpdateWithoutCursosInput>
    create: XOR<beneficiosCursosCreateWithoutCursosInput, beneficiosCursosUncheckedCreateWithoutCursosInput>
  }

  export type beneficiosCursosUpdateWithWhereUniqueWithoutCursosInput = {
    where: beneficiosCursosWhereUniqueInput
    data: XOR<beneficiosCursosUpdateWithoutCursosInput, beneficiosCursosUncheckedUpdateWithoutCursosInput>
  }

  export type beneficiosCursosUpdateManyWithWhereWithoutCursosInput = {
    where: beneficiosCursosScalarWhereInput
    data: XOR<beneficiosCursosUpdateManyMutationInput, beneficiosCursosUncheckedUpdateManyWithoutCursosInput>
  }

  export type beneficiosCursosScalarWhereInput = {
    AND?: beneficiosCursosScalarWhereInput | beneficiosCursosScalarWhereInput[]
    OR?: beneficiosCursosScalarWhereInput[]
    NOT?: beneficiosCursosScalarWhereInput | beneficiosCursosScalarWhereInput[]
    id?: StringFilter<"beneficiosCursos"> | string
    cursoId?: StringFilter<"beneficiosCursos"> | string
    descripcion?: StringFilter<"beneficiosCursos"> | string
    orden?: IntFilter<"beneficiosCursos"> | number
    creadoEn?: DateTimeFilter<"beneficiosCursos"> | Date | string
  }

  export type categoriasCursosUpsertWithWhereUniqueWithoutCursosInput = {
    where: categoriasCursosWhereUniqueInput
    update: XOR<categoriasCursosUpdateWithoutCursosInput, categoriasCursosUncheckedUpdateWithoutCursosInput>
    create: XOR<categoriasCursosCreateWithoutCursosInput, categoriasCursosUncheckedCreateWithoutCursosInput>
  }

  export type categoriasCursosUpdateWithWhereUniqueWithoutCursosInput = {
    where: categoriasCursosWhereUniqueInput
    data: XOR<categoriasCursosUpdateWithoutCursosInput, categoriasCursosUncheckedUpdateWithoutCursosInput>
  }

  export type categoriasCursosUpdateManyWithWhereWithoutCursosInput = {
    where: categoriasCursosScalarWhereInput
    data: XOR<categoriasCursosUpdateManyMutationInput, categoriasCursosUncheckedUpdateManyWithoutCursosInput>
  }

  export type edicionesCursosUpsertWithWhereUniqueWithoutCursosInput = {
    where: edicionesCursosWhereUniqueInput
    update: XOR<edicionesCursosUpdateWithoutCursosInput, edicionesCursosUncheckedUpdateWithoutCursosInput>
    create: XOR<edicionesCursosCreateWithoutCursosInput, edicionesCursosUncheckedCreateWithoutCursosInput>
  }

  export type edicionesCursosUpdateWithWhereUniqueWithoutCursosInput = {
    where: edicionesCursosWhereUniqueInput
    data: XOR<edicionesCursosUpdateWithoutCursosInput, edicionesCursosUncheckedUpdateWithoutCursosInput>
  }

  export type edicionesCursosUpdateManyWithWhereWithoutCursosInput = {
    where: edicionesCursosScalarWhereInput
    data: XOR<edicionesCursosUpdateManyMutationInput, edicionesCursosUncheckedUpdateManyWithoutCursosInput>
  }

  export type edicionesCursosScalarWhereInput = {
    AND?: edicionesCursosScalarWhereInput | edicionesCursosScalarWhereInput[]
    OR?: edicionesCursosScalarWhereInput[]
    NOT?: edicionesCursosScalarWhereInput | edicionesCursosScalarWhereInput[]
    id?: StringFilter<"edicionesCursos"> | string
    codigo?: StringFilter<"edicionesCursos"> | string
    cursoId?: StringFilter<"edicionesCursos"> | string
    descripcion?: StringNullableFilter<"edicionesCursos"> | string | null
    estado?: EnumEdicionEstadoFilter<"edicionesCursos"> | $Enums.EdicionEstado
    fechaFin?: DateTimeFilter<"edicionesCursos"> | Date | string
    fechaInicio?: DateTimeFilter<"edicionesCursos"> | Date | string
    notaMaxima?: FloatFilter<"edicionesCursos"> | number
    notaMinima?: FloatFilter<"edicionesCursos"> | number
    urlWhatsapp?: StringNullableFilter<"edicionesCursos"> | string | null
    vigente?: BoolFilter<"edicionesCursos"> | boolean
    creadoEn?: DateTimeFilter<"edicionesCursos"> | Date | string
    actualizadoEn?: DateTimeFilter<"edicionesCursos"> | Date | string
    docenteId?: StringNullableFilter<"edicionesCursos"> | string | null
  }

  export type objetivosCursosUpsertWithWhereUniqueWithoutCursosInput = {
    where: objetivosCursosWhereUniqueInput
    update: XOR<objetivosCursosUpdateWithoutCursosInput, objetivosCursosUncheckedUpdateWithoutCursosInput>
    create: XOR<objetivosCursosCreateWithoutCursosInput, objetivosCursosUncheckedCreateWithoutCursosInput>
  }

  export type objetivosCursosUpdateWithWhereUniqueWithoutCursosInput = {
    where: objetivosCursosWhereUniqueInput
    data: XOR<objetivosCursosUpdateWithoutCursosInput, objetivosCursosUncheckedUpdateWithoutCursosInput>
  }

  export type objetivosCursosUpdateManyWithWhereWithoutCursosInput = {
    where: objetivosCursosScalarWhereInput
    data: XOR<objetivosCursosUpdateManyMutationInput, objetivosCursosUncheckedUpdateManyWithoutCursosInput>
  }

  export type objetivosCursosScalarWhereInput = {
    AND?: objetivosCursosScalarWhereInput | objetivosCursosScalarWhereInput[]
    OR?: objetivosCursosScalarWhereInput[]
    NOT?: objetivosCursosScalarWhereInput | objetivosCursosScalarWhereInput[]
    id?: StringFilter<"objetivosCursos"> | string
    cursoId?: StringFilter<"objetivosCursos"> | string
    descripcion?: StringFilter<"objetivosCursos"> | string
    orden?: IntFilter<"objetivosCursos"> | number
    creadoEn?: DateTimeFilter<"objetivosCursos"> | Date | string
  }

  export type requisitosCursosUpsertWithWhereUniqueWithoutCursosInput = {
    where: requisitosCursosWhereUniqueInput
    update: XOR<requisitosCursosUpdateWithoutCursosInput, requisitosCursosUncheckedUpdateWithoutCursosInput>
    create: XOR<requisitosCursosCreateWithoutCursosInput, requisitosCursosUncheckedCreateWithoutCursosInput>
  }

  export type requisitosCursosUpdateWithWhereUniqueWithoutCursosInput = {
    where: requisitosCursosWhereUniqueInput
    data: XOR<requisitosCursosUpdateWithoutCursosInput, requisitosCursosUncheckedUpdateWithoutCursosInput>
  }

  export type requisitosCursosUpdateManyWithWhereWithoutCursosInput = {
    where: requisitosCursosScalarWhereInput
    data: XOR<requisitosCursosUpdateManyMutationInput, requisitosCursosUncheckedUpdateManyWithoutCursosInput>
  }

  export type requisitosCursosScalarWhereInput = {
    AND?: requisitosCursosScalarWhereInput | requisitosCursosScalarWhereInput[]
    OR?: requisitosCursosScalarWhereInput[]
    NOT?: requisitosCursosScalarWhereInput | requisitosCursosScalarWhereInput[]
    id?: StringFilter<"requisitosCursos"> | string
    cursoId?: StringFilter<"requisitosCursos"> | string
    descripcion?: StringFilter<"requisitosCursos"> | string
    orden?: IntFilter<"requisitosCursos"> | number
    creadoEn?: DateTimeFilter<"requisitosCursos"> | Date | string
  }

  export type reviewsCursosUpsertWithWhereUniqueWithoutCursosInput = {
    where: reviewsCursosWhereUniqueInput
    update: XOR<reviewsCursosUpdateWithoutCursosInput, reviewsCursosUncheckedUpdateWithoutCursosInput>
    create: XOR<reviewsCursosCreateWithoutCursosInput, reviewsCursosUncheckedCreateWithoutCursosInput>
  }

  export type reviewsCursosUpdateWithWhereUniqueWithoutCursosInput = {
    where: reviewsCursosWhereUniqueInput
    data: XOR<reviewsCursosUpdateWithoutCursosInput, reviewsCursosUncheckedUpdateWithoutCursosInput>
  }

  export type reviewsCursosUpdateManyWithWhereWithoutCursosInput = {
    where: reviewsCursosScalarWhereInput
    data: XOR<reviewsCursosUpdateManyMutationInput, reviewsCursosUncheckedUpdateManyWithoutCursosInput>
  }

  export type reviewsCursosScalarWhereInput = {
    AND?: reviewsCursosScalarWhereInput | reviewsCursosScalarWhereInput[]
    OR?: reviewsCursosScalarWhereInput[]
    NOT?: reviewsCursosScalarWhereInput | reviewsCursosScalarWhereInput[]
    id?: StringFilter<"reviewsCursos"> | string
    cursoId?: StringFilter<"reviewsCursos"> | string
    rating?: IntFilter<"reviewsCursos"> | number
    comentario?: StringNullableFilter<"reviewsCursos"> | string | null
    creadoEn?: DateTimeFilter<"reviewsCursos"> | Date | string
    actualizadoEn?: DateTimeFilter<"reviewsCursos"> | Date | string
    usuariosEstudiantesId?: StringNullableFilter<"reviewsCursos"> | string | null
  }

  export type usuariosAdministradoresCreateWithoutDocenteInput = {
    id?: string
    correo: string
    contrasena: string
    encargado?: string | null
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    tipo: $Enums.TipoCuenta
    auditoria?: auditoriaCreateNestedManyWithoutUsuariosAdministradoresInput
    grabaciones?: grabacionesCreateNestedManyWithoutUsuariosAdministradoresInput
  }

  export type usuariosAdministradoresUncheckedCreateWithoutDocenteInput = {
    id?: string
    correo: string
    contrasena: string
    encargado?: string | null
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    tipo: $Enums.TipoCuenta
    auditoria?: auditoriaUncheckedCreateNestedManyWithoutUsuariosAdministradoresInput
    grabaciones?: grabacionesUncheckedCreateNestedManyWithoutUsuariosAdministradoresInput
  }

  export type usuariosAdministradoresCreateOrConnectWithoutDocenteInput = {
    where: usuariosAdministradoresWhereUniqueInput
    create: XOR<usuariosAdministradoresCreateWithoutDocenteInput, usuariosAdministradoresUncheckedCreateWithoutDocenteInput>
  }

  export type edicionesCursosCreateWithoutDocenteInput = {
    id?: string
    codigo: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    certificados?: certificadosCreateNestedManyWithoutEdicionesCursosInput
    clases?: clasesCreateNestedManyWithoutEdicionesCursosInput
    compras?: comprasCreateNestedManyWithoutEdicionesCursosInput
    cursos: cursosCreateNestedOneWithoutEdicionesCursosInput
    examenes?: examenesCreateNestedManyWithoutEdicionesCursosInput
    inscripciones?: inscripcionesCreateNestedManyWithoutEdicionesCursosInput
    pagosDocentes?: pagosDocentesCreateNestedOneWithoutEdicionesCursosInput
    preciosCursos?: preciosCursosCreateNestedManyWithoutEdicionesCursosInput
  }

  export type edicionesCursosUncheckedCreateWithoutDocenteInput = {
    id?: string
    codigo: string
    cursoId: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    certificados?: certificadosUncheckedCreateNestedManyWithoutEdicionesCursosInput
    clases?: clasesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    compras?: comprasUncheckedCreateNestedManyWithoutEdicionesCursosInput
    examenes?: examenesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    pagosDocentes?: pagosDocentesUncheckedCreateNestedOneWithoutEdicionesCursosInput
    preciosCursos?: preciosCursosUncheckedCreateNestedManyWithoutEdicionesCursosInput
  }

  export type edicionesCursosCreateOrConnectWithoutDocenteInput = {
    where: edicionesCursosWhereUniqueInput
    create: XOR<edicionesCursosCreateWithoutDocenteInput, edicionesCursosUncheckedCreateWithoutDocenteInput>
  }

  export type edicionesCursosCreateManyDocenteInputEnvelope = {
    data: edicionesCursosCreateManyDocenteInput | edicionesCursosCreateManyDocenteInput[]
    skipDuplicates?: boolean
  }

  export type pagosDocentesCreateWithoutDocenteInput = {
    id?: string
    monto: number
    deuda?: number
    estadoPago?: $Enums.EstadoPago
    fechaPago?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    edicionesCursos: edicionesCursosCreateNestedOneWithoutPagosDocentesInput
  }

  export type pagosDocentesUncheckedCreateWithoutDocenteInput = {
    id?: string
    edicionId: string
    monto: number
    deuda?: number
    estadoPago?: $Enums.EstadoPago
    fechaPago?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type pagosDocentesCreateOrConnectWithoutDocenteInput = {
    where: pagosDocentesWhereUniqueInput
    create: XOR<pagosDocentesCreateWithoutDocenteInput, pagosDocentesUncheckedCreateWithoutDocenteInput>
  }

  export type pagosDocentesCreateManyDocenteInputEnvelope = {
    data: pagosDocentesCreateManyDocenteInput | pagosDocentesCreateManyDocenteInput[]
    skipDuplicates?: boolean
  }

  export type usuariosAdministradoresUpsertWithoutDocenteInput = {
    update: XOR<usuariosAdministradoresUpdateWithoutDocenteInput, usuariosAdministradoresUncheckedUpdateWithoutDocenteInput>
    create: XOR<usuariosAdministradoresCreateWithoutDocenteInput, usuariosAdministradoresUncheckedCreateWithoutDocenteInput>
    where?: usuariosAdministradoresWhereInput
  }

  export type usuariosAdministradoresUpdateToOneWithWhereWithoutDocenteInput = {
    where?: usuariosAdministradoresWhereInput
    data: XOR<usuariosAdministradoresUpdateWithoutDocenteInput, usuariosAdministradoresUncheckedUpdateWithoutDocenteInput>
  }

  export type usuariosAdministradoresUpdateWithoutDocenteInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    encargado?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCuentaFieldUpdateOperationsInput | $Enums.TipoCuenta
    auditoria?: auditoriaUpdateManyWithoutUsuariosAdministradoresNestedInput
    grabaciones?: grabacionesUpdateManyWithoutUsuariosAdministradoresNestedInput
  }

  export type usuariosAdministradoresUncheckedUpdateWithoutDocenteInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    encargado?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCuentaFieldUpdateOperationsInput | $Enums.TipoCuenta
    auditoria?: auditoriaUncheckedUpdateManyWithoutUsuariosAdministradoresNestedInput
    grabaciones?: grabacionesUncheckedUpdateManyWithoutUsuariosAdministradoresNestedInput
  }

  export type edicionesCursosUpsertWithWhereUniqueWithoutDocenteInput = {
    where: edicionesCursosWhereUniqueInput
    update: XOR<edicionesCursosUpdateWithoutDocenteInput, edicionesCursosUncheckedUpdateWithoutDocenteInput>
    create: XOR<edicionesCursosCreateWithoutDocenteInput, edicionesCursosUncheckedCreateWithoutDocenteInput>
  }

  export type edicionesCursosUpdateWithWhereUniqueWithoutDocenteInput = {
    where: edicionesCursosWhereUniqueInput
    data: XOR<edicionesCursosUpdateWithoutDocenteInput, edicionesCursosUncheckedUpdateWithoutDocenteInput>
  }

  export type edicionesCursosUpdateManyWithWhereWithoutDocenteInput = {
    where: edicionesCursosScalarWhereInput
    data: XOR<edicionesCursosUpdateManyMutationInput, edicionesCursosUncheckedUpdateManyWithoutDocenteInput>
  }

  export type pagosDocentesUpsertWithWhereUniqueWithoutDocenteInput = {
    where: pagosDocentesWhereUniqueInput
    update: XOR<pagosDocentesUpdateWithoutDocenteInput, pagosDocentesUncheckedUpdateWithoutDocenteInput>
    create: XOR<pagosDocentesCreateWithoutDocenteInput, pagosDocentesUncheckedCreateWithoutDocenteInput>
  }

  export type pagosDocentesUpdateWithWhereUniqueWithoutDocenteInput = {
    where: pagosDocentesWhereUniqueInput
    data: XOR<pagosDocentesUpdateWithoutDocenteInput, pagosDocentesUncheckedUpdateWithoutDocenteInput>
  }

  export type pagosDocentesUpdateManyWithWhereWithoutDocenteInput = {
    where: pagosDocentesScalarWhereInput
    data: XOR<pagosDocentesUpdateManyMutationInput, pagosDocentesUncheckedUpdateManyWithoutDocenteInput>
  }

  export type pagosDocentesScalarWhereInput = {
    AND?: pagosDocentesScalarWhereInput | pagosDocentesScalarWhereInput[]
    OR?: pagosDocentesScalarWhereInput[]
    NOT?: pagosDocentesScalarWhereInput | pagosDocentesScalarWhereInput[]
    id?: StringFilter<"pagosDocentes"> | string
    docenteId?: StringFilter<"pagosDocentes"> | string
    edicionId?: StringFilter<"pagosDocentes"> | string
    monto?: FloatFilter<"pagosDocentes"> | number
    deuda?: FloatFilter<"pagosDocentes"> | number
    estadoPago?: EnumEstadoPagoFilter<"pagosDocentes"> | $Enums.EstadoPago
    fechaPago?: DateTimeNullableFilter<"pagosDocentes"> | Date | string | null
    creadoEn?: DateTimeFilter<"pagosDocentes"> | Date | string
    actualizadoEn?: DateTimeFilter<"pagosDocentes"> | Date | string
  }

  export type certificadosCreateWithoutEdicionesCursosInput = {
    id?: string
    codigoUnico: string
    fechaEmision: Date | string
    tipo?: $Enums.TipoCertificado
    notaFinal?: number | null
    urlCertificado?: string | null
    creadoEn?: Date | string
    estudiantes: estudiantesCreateNestedOneWithoutCertificadosInput
  }

  export type certificadosUncheckedCreateWithoutEdicionesCursosInput = {
    id?: string
    codigoUnico: string
    estudianteId: string
    fechaEmision: Date | string
    tipo?: $Enums.TipoCertificado
    notaFinal?: number | null
    urlCertificado?: string | null
    creadoEn?: Date | string
  }

  export type certificadosCreateOrConnectWithoutEdicionesCursosInput = {
    where: certificadosWhereUniqueInput
    create: XOR<certificadosCreateWithoutEdicionesCursosInput, certificadosUncheckedCreateWithoutEdicionesCursosInput>
  }

  export type certificadosCreateManyEdicionesCursosInputEnvelope = {
    data: certificadosCreateManyEdicionesCursosInput | certificadosCreateManyEdicionesCursosInput[]
    skipDuplicates?: boolean
  }

  export type clasesCreateWithoutEdicionesCursosInput = {
    id?: string
    descripcion: string
    duracion?: number | null
    fecha: Date | string
    orden: number
    titulo: string
    urlYoutube?: string | null
    creadoEn?: Date | string
    urlPresentacion?: string | null
    grabaciones?: grabacionesCreateNestedManyWithoutClasesInput
    materiales?: materialesCreateNestedManyWithoutClasesInput
  }

  export type clasesUncheckedCreateWithoutEdicionesCursosInput = {
    id?: string
    descripcion: string
    duracion?: number | null
    fecha: Date | string
    orden: number
    titulo: string
    urlYoutube?: string | null
    creadoEn?: Date | string
    urlPresentacion?: string | null
    grabaciones?: grabacionesUncheckedCreateNestedManyWithoutClasesInput
    materiales?: materialesUncheckedCreateNestedManyWithoutClasesInput
  }

  export type clasesCreateOrConnectWithoutEdicionesCursosInput = {
    where: clasesWhereUniqueInput
    create: XOR<clasesCreateWithoutEdicionesCursosInput, clasesUncheckedCreateWithoutEdicionesCursosInput>
  }

  export type clasesCreateManyEdicionesCursosInputEnvelope = {
    data: clasesCreateManyEdicionesCursosInput | clasesCreateManyEdicionesCursosInput[]
    skipDuplicates?: boolean
  }

  export type comprasCreateWithoutEdicionesCursosInput = {
    id?: string
    monto: number
    moneda?: string
    comprobado?: boolean
    providerId: string
    fechaCompra?: Date | string
    metodo?: $Enums.MetodoPago
    deuda?: number
    estadoPago?: $Enums.EstadoPago
    updatedAt: Date | string
    conDescuento?: boolean
    usuariosEstudiantes?: usuariosEstudiantesCreateNestedOneWithoutComprasInput
    inscripciones?: inscripcionesCreateNestedOneWithoutComprasInput
  }

  export type comprasUncheckedCreateWithoutEdicionesCursosInput = {
    id?: string
    monto: number
    moneda?: string
    comprobado?: boolean
    providerId: string
    fechaCompra?: Date | string
    metodo?: $Enums.MetodoPago
    deuda?: number
    usuariosEstudiantesId?: string | null
    estadoPago?: $Enums.EstadoPago
    updatedAt: Date | string
    conDescuento?: boolean
    inscripciones?: inscripcionesUncheckedCreateNestedOneWithoutComprasInput
  }

  export type comprasCreateOrConnectWithoutEdicionesCursosInput = {
    where: comprasWhereUniqueInput
    create: XOR<comprasCreateWithoutEdicionesCursosInput, comprasUncheckedCreateWithoutEdicionesCursosInput>
  }

  export type comprasCreateManyEdicionesCursosInputEnvelope = {
    data: comprasCreateManyEdicionesCursosInput | comprasCreateManyEdicionesCursosInput[]
    skipDuplicates?: boolean
  }

  export type cursosCreateWithoutEdicionesCursosInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    cargaHoraria?: number
    codigo: string
    beneficiosCursos?: beneficiosCursosCreateNestedManyWithoutCursosInput
    categoriasCursos?: categoriasCursosCreateNestedManyWithoutCursosInput
    objetivosCursos?: objetivosCursosCreateNestedManyWithoutCursosInput
    requisitosCursos?: requisitosCursosCreateNestedManyWithoutCursosInput
    reviewsCursos?: reviewsCursosCreateNestedManyWithoutCursosInput
  }

  export type cursosUncheckedCreateWithoutEdicionesCursosInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    cargaHoraria?: number
    codigo: string
    beneficiosCursos?: beneficiosCursosUncheckedCreateNestedManyWithoutCursosInput
    categoriasCursos?: categoriasCursosUncheckedCreateNestedManyWithoutCursosInput
    objetivosCursos?: objetivosCursosUncheckedCreateNestedManyWithoutCursosInput
    requisitosCursos?: requisitosCursosUncheckedCreateNestedManyWithoutCursosInput
    reviewsCursos?: reviewsCursosUncheckedCreateNestedManyWithoutCursosInput
  }

  export type cursosCreateOrConnectWithoutEdicionesCursosInput = {
    where: cursosWhereUniqueInput
    create: XOR<cursosCreateWithoutEdicionesCursosInput, cursosUncheckedCreateWithoutEdicionesCursosInput>
  }

  export type docenteCreateWithoutEdicionesCursosInput = {
    id?: string
    nombre_completo: string
    celular?: string | null
    especialidad: string
    experiencia?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    pais?: string
    usuariosAdministradores: usuariosAdministradoresCreateNestedOneWithoutDocenteInput
    pagosDocentes?: pagosDocentesCreateNestedManyWithoutDocenteInput
  }

  export type docenteUncheckedCreateWithoutEdicionesCursosInput = {
    id?: string
    nombre_completo: string
    celular?: string | null
    especialidad: string
    experiencia?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    usuarioId: string
    pais?: string
    pagosDocentes?: pagosDocentesUncheckedCreateNestedManyWithoutDocenteInput
  }

  export type docenteCreateOrConnectWithoutEdicionesCursosInput = {
    where: docenteWhereUniqueInput
    create: XOR<docenteCreateWithoutEdicionesCursosInput, docenteUncheckedCreateWithoutEdicionesCursosInput>
  }

  export type examenesCreateWithoutEdicionesCursosInput = {
    id?: string
    descripcion?: string | null
    fechaDisponible: Date | string
    fechaLimite: Date | string
    notaMaxima: number
    notaMinima: number
    titulo: string
    creadoEn?: Date | string
    calificaciones?: calificacionesCreateNestedManyWithoutExamenesInput
  }

  export type examenesUncheckedCreateWithoutEdicionesCursosInput = {
    id?: string
    descripcion?: string | null
    fechaDisponible: Date | string
    fechaLimite: Date | string
    notaMaxima: number
    notaMinima: number
    titulo: string
    creadoEn?: Date | string
    calificaciones?: calificacionesUncheckedCreateNestedManyWithoutExamenesInput
  }

  export type examenesCreateOrConnectWithoutEdicionesCursosInput = {
    where: examenesWhereUniqueInput
    create: XOR<examenesCreateWithoutEdicionesCursosInput, examenesUncheckedCreateWithoutEdicionesCursosInput>
  }

  export type examenesCreateManyEdicionesCursosInputEnvelope = {
    data: examenesCreateManyEdicionesCursosInput | examenesCreateManyEdicionesCursosInput[]
    skipDuplicates?: boolean
  }

  export type inscripcionesCreateWithoutEdicionesCursosInput = {
    id?: string
    estado?: boolean
    inscritoEn?: Date | string
    compras: comprasCreateNestedOneWithoutInscripcionesInput
    estudiantes: estudiantesCreateNestedOneWithoutInscripcionesInput
  }

  export type inscripcionesUncheckedCreateWithoutEdicionesCursosInput = {
    id?: string
    estado?: boolean
    estudianteId: string
    inscritoEn?: Date | string
    compraId: string
  }

  export type inscripcionesCreateOrConnectWithoutEdicionesCursosInput = {
    where: inscripcionesWhereUniqueInput
    create: XOR<inscripcionesCreateWithoutEdicionesCursosInput, inscripcionesUncheckedCreateWithoutEdicionesCursosInput>
  }

  export type inscripcionesCreateManyEdicionesCursosInputEnvelope = {
    data: inscripcionesCreateManyEdicionesCursosInput | inscripcionesCreateManyEdicionesCursosInput[]
    skipDuplicates?: boolean
  }

  export type pagosDocentesCreateWithoutEdicionesCursosInput = {
    id?: string
    monto: number
    deuda?: number
    estadoPago?: $Enums.EstadoPago
    fechaPago?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    docente: docenteCreateNestedOneWithoutPagosDocentesInput
  }

  export type pagosDocentesUncheckedCreateWithoutEdicionesCursosInput = {
    id?: string
    docenteId: string
    monto: number
    deuda?: number
    estadoPago?: $Enums.EstadoPago
    fechaPago?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type pagosDocentesCreateOrConnectWithoutEdicionesCursosInput = {
    where: pagosDocentesWhereUniqueInput
    create: XOR<pagosDocentesCreateWithoutEdicionesCursosInput, pagosDocentesUncheckedCreateWithoutEdicionesCursosInput>
  }

  export type preciosCursosCreateWithoutEdicionesCursosInput = {
    id?: string
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    esDescuento?: boolean
    esPrecioDefault?: boolean
    moneda?: string
    nombre: string
    porcentajeDescuento?: number | null
    precio: number
    precioOriginal?: number | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type preciosCursosUncheckedCreateWithoutEdicionesCursosInput = {
    id?: string
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    esDescuento?: boolean
    esPrecioDefault?: boolean
    moneda?: string
    nombre: string
    porcentajeDescuento?: number | null
    precio: number
    precioOriginal?: number | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type preciosCursosCreateOrConnectWithoutEdicionesCursosInput = {
    where: preciosCursosWhereUniqueInput
    create: XOR<preciosCursosCreateWithoutEdicionesCursosInput, preciosCursosUncheckedCreateWithoutEdicionesCursosInput>
  }

  export type preciosCursosCreateManyEdicionesCursosInputEnvelope = {
    data: preciosCursosCreateManyEdicionesCursosInput | preciosCursosCreateManyEdicionesCursosInput[]
    skipDuplicates?: boolean
  }

  export type certificadosUpsertWithWhereUniqueWithoutEdicionesCursosInput = {
    where: certificadosWhereUniqueInput
    update: XOR<certificadosUpdateWithoutEdicionesCursosInput, certificadosUncheckedUpdateWithoutEdicionesCursosInput>
    create: XOR<certificadosCreateWithoutEdicionesCursosInput, certificadosUncheckedCreateWithoutEdicionesCursosInput>
  }

  export type certificadosUpdateWithWhereUniqueWithoutEdicionesCursosInput = {
    where: certificadosWhereUniqueInput
    data: XOR<certificadosUpdateWithoutEdicionesCursosInput, certificadosUncheckedUpdateWithoutEdicionesCursosInput>
  }

  export type certificadosUpdateManyWithWhereWithoutEdicionesCursosInput = {
    where: certificadosScalarWhereInput
    data: XOR<certificadosUpdateManyMutationInput, certificadosUncheckedUpdateManyWithoutEdicionesCursosInput>
  }

  export type certificadosScalarWhereInput = {
    AND?: certificadosScalarWhereInput | certificadosScalarWhereInput[]
    OR?: certificadosScalarWhereInput[]
    NOT?: certificadosScalarWhereInput | certificadosScalarWhereInput[]
    id?: StringFilter<"certificados"> | string
    codigoUnico?: StringFilter<"certificados"> | string
    edicionId?: StringFilter<"certificados"> | string
    estudianteId?: StringFilter<"certificados"> | string
    fechaEmision?: DateTimeFilter<"certificados"> | Date | string
    tipo?: EnumTipoCertificadoFilter<"certificados"> | $Enums.TipoCertificado
    notaFinal?: FloatNullableFilter<"certificados"> | number | null
    urlCertificado?: StringNullableFilter<"certificados"> | string | null
    creadoEn?: DateTimeFilter<"certificados"> | Date | string
  }

  export type clasesUpsertWithWhereUniqueWithoutEdicionesCursosInput = {
    where: clasesWhereUniqueInput
    update: XOR<clasesUpdateWithoutEdicionesCursosInput, clasesUncheckedUpdateWithoutEdicionesCursosInput>
    create: XOR<clasesCreateWithoutEdicionesCursosInput, clasesUncheckedCreateWithoutEdicionesCursosInput>
  }

  export type clasesUpdateWithWhereUniqueWithoutEdicionesCursosInput = {
    where: clasesWhereUniqueInput
    data: XOR<clasesUpdateWithoutEdicionesCursosInput, clasesUncheckedUpdateWithoutEdicionesCursosInput>
  }

  export type clasesUpdateManyWithWhereWithoutEdicionesCursosInput = {
    where: clasesScalarWhereInput
    data: XOR<clasesUpdateManyMutationInput, clasesUncheckedUpdateManyWithoutEdicionesCursosInput>
  }

  export type clasesScalarWhereInput = {
    AND?: clasesScalarWhereInput | clasesScalarWhereInput[]
    OR?: clasesScalarWhereInput[]
    NOT?: clasesScalarWhereInput | clasesScalarWhereInput[]
    id?: StringFilter<"clases"> | string
    edicionId?: StringFilter<"clases"> | string
    descripcion?: StringFilter<"clases"> | string
    duracion?: IntNullableFilter<"clases"> | number | null
    fecha?: DateTimeFilter<"clases"> | Date | string
    orden?: IntFilter<"clases"> | number
    titulo?: StringFilter<"clases"> | string
    urlYoutube?: StringNullableFilter<"clases"> | string | null
    creadoEn?: DateTimeFilter<"clases"> | Date | string
    urlPresentacion?: StringNullableFilter<"clases"> | string | null
  }

  export type comprasUpsertWithWhereUniqueWithoutEdicionesCursosInput = {
    where: comprasWhereUniqueInput
    update: XOR<comprasUpdateWithoutEdicionesCursosInput, comprasUncheckedUpdateWithoutEdicionesCursosInput>
    create: XOR<comprasCreateWithoutEdicionesCursosInput, comprasUncheckedCreateWithoutEdicionesCursosInput>
  }

  export type comprasUpdateWithWhereUniqueWithoutEdicionesCursosInput = {
    where: comprasWhereUniqueInput
    data: XOR<comprasUpdateWithoutEdicionesCursosInput, comprasUncheckedUpdateWithoutEdicionesCursosInput>
  }

  export type comprasUpdateManyWithWhereWithoutEdicionesCursosInput = {
    where: comprasScalarWhereInput
    data: XOR<comprasUpdateManyMutationInput, comprasUncheckedUpdateManyWithoutEdicionesCursosInput>
  }

  export type comprasScalarWhereInput = {
    AND?: comprasScalarWhereInput | comprasScalarWhereInput[]
    OR?: comprasScalarWhereInput[]
    NOT?: comprasScalarWhereInput | comprasScalarWhereInput[]
    id?: StringFilter<"compras"> | string
    edicionId?: StringFilter<"compras"> | string
    monto?: FloatFilter<"compras"> | number
    moneda?: StringFilter<"compras"> | string
    comprobado?: BoolFilter<"compras"> | boolean
    providerId?: StringFilter<"compras"> | string
    fechaCompra?: DateTimeFilter<"compras"> | Date | string
    metodo?: EnumMetodoPagoFilter<"compras"> | $Enums.MetodoPago
    deuda?: FloatFilter<"compras"> | number
    usuariosEstudiantesId?: StringNullableFilter<"compras"> | string | null
    estadoPago?: EnumEstadoPagoFilter<"compras"> | $Enums.EstadoPago
    updatedAt?: DateTimeFilter<"compras"> | Date | string
    conDescuento?: BoolFilter<"compras"> | boolean
  }

  export type cursosUpsertWithoutEdicionesCursosInput = {
    update: XOR<cursosUpdateWithoutEdicionesCursosInput, cursosUncheckedUpdateWithoutEdicionesCursosInput>
    create: XOR<cursosCreateWithoutEdicionesCursosInput, cursosUncheckedCreateWithoutEdicionesCursosInput>
    where?: cursosWhereInput
  }

  export type cursosUpdateToOneWithWhereWithoutEdicionesCursosInput = {
    where?: cursosWhereInput
    data: XOR<cursosUpdateWithoutEdicionesCursosInput, cursosUncheckedUpdateWithoutEdicionesCursosInput>
  }

  export type cursosUpdateWithoutEdicionesCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    cargaHoraria?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    beneficiosCursos?: beneficiosCursosUpdateManyWithoutCursosNestedInput
    categoriasCursos?: categoriasCursosUpdateManyWithoutCursosNestedInput
    objetivosCursos?: objetivosCursosUpdateManyWithoutCursosNestedInput
    requisitosCursos?: requisitosCursosUpdateManyWithoutCursosNestedInput
    reviewsCursos?: reviewsCursosUpdateManyWithoutCursosNestedInput
  }

  export type cursosUncheckedUpdateWithoutEdicionesCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    cargaHoraria?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    beneficiosCursos?: beneficiosCursosUncheckedUpdateManyWithoutCursosNestedInput
    categoriasCursos?: categoriasCursosUncheckedUpdateManyWithoutCursosNestedInput
    objetivosCursos?: objetivosCursosUncheckedUpdateManyWithoutCursosNestedInput
    requisitosCursos?: requisitosCursosUncheckedUpdateManyWithoutCursosNestedInput
    reviewsCursos?: reviewsCursosUncheckedUpdateManyWithoutCursosNestedInput
  }

  export type docenteUpsertWithoutEdicionesCursosInput = {
    update: XOR<docenteUpdateWithoutEdicionesCursosInput, docenteUncheckedUpdateWithoutEdicionesCursosInput>
    create: XOR<docenteCreateWithoutEdicionesCursosInput, docenteUncheckedCreateWithoutEdicionesCursosInput>
    where?: docenteWhereInput
  }

  export type docenteUpdateToOneWithWhereWithoutEdicionesCursosInput = {
    where?: docenteWhereInput
    data: XOR<docenteUpdateWithoutEdicionesCursosInput, docenteUncheckedUpdateWithoutEdicionesCursosInput>
  }

  export type docenteUpdateWithoutEdicionesCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre_completo?: StringFieldUpdateOperationsInput | string
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    experiencia?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    pais?: StringFieldUpdateOperationsInput | string
    usuariosAdministradores?: usuariosAdministradoresUpdateOneRequiredWithoutDocenteNestedInput
    pagosDocentes?: pagosDocentesUpdateManyWithoutDocenteNestedInput
  }

  export type docenteUncheckedUpdateWithoutEdicionesCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre_completo?: StringFieldUpdateOperationsInput | string
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    experiencia?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    pagosDocentes?: pagosDocentesUncheckedUpdateManyWithoutDocenteNestedInput
  }

  export type examenesUpsertWithWhereUniqueWithoutEdicionesCursosInput = {
    where: examenesWhereUniqueInput
    update: XOR<examenesUpdateWithoutEdicionesCursosInput, examenesUncheckedUpdateWithoutEdicionesCursosInput>
    create: XOR<examenesCreateWithoutEdicionesCursosInput, examenesUncheckedCreateWithoutEdicionesCursosInput>
  }

  export type examenesUpdateWithWhereUniqueWithoutEdicionesCursosInput = {
    where: examenesWhereUniqueInput
    data: XOR<examenesUpdateWithoutEdicionesCursosInput, examenesUncheckedUpdateWithoutEdicionesCursosInput>
  }

  export type examenesUpdateManyWithWhereWithoutEdicionesCursosInput = {
    where: examenesScalarWhereInput
    data: XOR<examenesUpdateManyMutationInput, examenesUncheckedUpdateManyWithoutEdicionesCursosInput>
  }

  export type examenesScalarWhereInput = {
    AND?: examenesScalarWhereInput | examenesScalarWhereInput[]
    OR?: examenesScalarWhereInput[]
    NOT?: examenesScalarWhereInput | examenesScalarWhereInput[]
    id?: StringFilter<"examenes"> | string
    edicionId?: StringFilter<"examenes"> | string
    descripcion?: StringNullableFilter<"examenes"> | string | null
    fechaDisponible?: DateTimeFilter<"examenes"> | Date | string
    fechaLimite?: DateTimeFilter<"examenes"> | Date | string
    notaMaxima?: FloatFilter<"examenes"> | number
    notaMinima?: FloatFilter<"examenes"> | number
    titulo?: StringFilter<"examenes"> | string
    creadoEn?: DateTimeFilter<"examenes"> | Date | string
  }

  export type inscripcionesUpsertWithWhereUniqueWithoutEdicionesCursosInput = {
    where: inscripcionesWhereUniqueInput
    update: XOR<inscripcionesUpdateWithoutEdicionesCursosInput, inscripcionesUncheckedUpdateWithoutEdicionesCursosInput>
    create: XOR<inscripcionesCreateWithoutEdicionesCursosInput, inscripcionesUncheckedCreateWithoutEdicionesCursosInput>
  }

  export type inscripcionesUpdateWithWhereUniqueWithoutEdicionesCursosInput = {
    where: inscripcionesWhereUniqueInput
    data: XOR<inscripcionesUpdateWithoutEdicionesCursosInput, inscripcionesUncheckedUpdateWithoutEdicionesCursosInput>
  }

  export type inscripcionesUpdateManyWithWhereWithoutEdicionesCursosInput = {
    where: inscripcionesScalarWhereInput
    data: XOR<inscripcionesUpdateManyMutationInput, inscripcionesUncheckedUpdateManyWithoutEdicionesCursosInput>
  }

  export type inscripcionesScalarWhereInput = {
    AND?: inscripcionesScalarWhereInput | inscripcionesScalarWhereInput[]
    OR?: inscripcionesScalarWhereInput[]
    NOT?: inscripcionesScalarWhereInput | inscripcionesScalarWhereInput[]
    id?: StringFilter<"inscripciones"> | string
    edicionId?: StringFilter<"inscripciones"> | string
    estado?: BoolFilter<"inscripciones"> | boolean
    estudianteId?: StringFilter<"inscripciones"> | string
    inscritoEn?: DateTimeFilter<"inscripciones"> | Date | string
    compraId?: StringFilter<"inscripciones"> | string
  }

  export type pagosDocentesUpsertWithoutEdicionesCursosInput = {
    update: XOR<pagosDocentesUpdateWithoutEdicionesCursosInput, pagosDocentesUncheckedUpdateWithoutEdicionesCursosInput>
    create: XOR<pagosDocentesCreateWithoutEdicionesCursosInput, pagosDocentesUncheckedCreateWithoutEdicionesCursosInput>
    where?: pagosDocentesWhereInput
  }

  export type pagosDocentesUpdateToOneWithWhereWithoutEdicionesCursosInput = {
    where?: pagosDocentesWhereInput
    data: XOR<pagosDocentesUpdateWithoutEdicionesCursosInput, pagosDocentesUncheckedUpdateWithoutEdicionesCursosInput>
  }

  export type pagosDocentesUpdateWithoutEdicionesCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    deuda?: FloatFieldUpdateOperationsInput | number
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docente?: docenteUpdateOneRequiredWithoutPagosDocentesNestedInput
  }

  export type pagosDocentesUncheckedUpdateWithoutEdicionesCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    docenteId?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    deuda?: FloatFieldUpdateOperationsInput | number
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type preciosCursosUpsertWithWhereUniqueWithoutEdicionesCursosInput = {
    where: preciosCursosWhereUniqueInput
    update: XOR<preciosCursosUpdateWithoutEdicionesCursosInput, preciosCursosUncheckedUpdateWithoutEdicionesCursosInput>
    create: XOR<preciosCursosCreateWithoutEdicionesCursosInput, preciosCursosUncheckedCreateWithoutEdicionesCursosInput>
  }

  export type preciosCursosUpdateWithWhereUniqueWithoutEdicionesCursosInput = {
    where: preciosCursosWhereUniqueInput
    data: XOR<preciosCursosUpdateWithoutEdicionesCursosInput, preciosCursosUncheckedUpdateWithoutEdicionesCursosInput>
  }

  export type preciosCursosUpdateManyWithWhereWithoutEdicionesCursosInput = {
    where: preciosCursosScalarWhereInput
    data: XOR<preciosCursosUpdateManyMutationInput, preciosCursosUncheckedUpdateManyWithoutEdicionesCursosInput>
  }

  export type preciosCursosScalarWhereInput = {
    AND?: preciosCursosScalarWhereInput | preciosCursosScalarWhereInput[]
    OR?: preciosCursosScalarWhereInput[]
    NOT?: preciosCursosScalarWhereInput | preciosCursosScalarWhereInput[]
    id?: StringFilter<"preciosCursos"> | string
    edicionId?: StringFilter<"preciosCursos"> | string
    fechaInicio?: DateTimeNullableFilter<"preciosCursos"> | Date | string | null
    fechaFin?: DateTimeNullableFilter<"preciosCursos"> | Date | string | null
    esDescuento?: BoolFilter<"preciosCursos"> | boolean
    esPrecioDefault?: BoolFilter<"preciosCursos"> | boolean
    moneda?: StringFilter<"preciosCursos"> | string
    nombre?: StringFilter<"preciosCursos"> | string
    porcentajeDescuento?: FloatNullableFilter<"preciosCursos"> | number | null
    precio?: FloatFilter<"preciosCursos"> | number
    precioOriginal?: FloatNullableFilter<"preciosCursos"> | number | null
    creadoEn?: DateTimeFilter<"preciosCursos"> | Date | string
    actualizadoEn?: DateTimeFilter<"preciosCursos"> | Date | string
  }

  export type calificacionesCreateWithoutEstudiantesInput = {
    id?: string
    aprobado?: boolean
    comentarios?: string | null
    nota: number
    creadoEn?: Date | string
    examenes: examenesCreateNestedOneWithoutCalificacionesInput
  }

  export type calificacionesUncheckedCreateWithoutEstudiantesInput = {
    id?: string
    aprobado?: boolean
    comentarios?: string | null
    examenId: string
    nota: number
    creadoEn?: Date | string
  }

  export type calificacionesCreateOrConnectWithoutEstudiantesInput = {
    where: calificacionesWhereUniqueInput
    create: XOR<calificacionesCreateWithoutEstudiantesInput, calificacionesUncheckedCreateWithoutEstudiantesInput>
  }

  export type calificacionesCreateManyEstudiantesInputEnvelope = {
    data: calificacionesCreateManyEstudiantesInput | calificacionesCreateManyEstudiantesInput[]
    skipDuplicates?: boolean
  }

  export type certificadosCreateWithoutEstudiantesInput = {
    id?: string
    codigoUnico: string
    fechaEmision: Date | string
    tipo?: $Enums.TipoCertificado
    notaFinal?: number | null
    urlCertificado?: string | null
    creadoEn?: Date | string
    edicionesCursos: edicionesCursosCreateNestedOneWithoutCertificadosInput
  }

  export type certificadosUncheckedCreateWithoutEstudiantesInput = {
    id?: string
    codigoUnico: string
    edicionId: string
    fechaEmision: Date | string
    tipo?: $Enums.TipoCertificado
    notaFinal?: number | null
    urlCertificado?: string | null
    creadoEn?: Date | string
  }

  export type certificadosCreateOrConnectWithoutEstudiantesInput = {
    where: certificadosWhereUniqueInput
    create: XOR<certificadosCreateWithoutEstudiantesInput, certificadosUncheckedCreateWithoutEstudiantesInput>
  }

  export type certificadosCreateManyEstudiantesInputEnvelope = {
    data: certificadosCreateManyEstudiantesInput | certificadosCreateManyEstudiantesInput[]
    skipDuplicates?: boolean
  }

  export type inscripcionesCreateWithoutEstudiantesInput = {
    id?: string
    estado?: boolean
    inscritoEn?: Date | string
    compras: comprasCreateNestedOneWithoutInscripcionesInput
    edicionesCursos: edicionesCursosCreateNestedOneWithoutInscripcionesInput
  }

  export type inscripcionesUncheckedCreateWithoutEstudiantesInput = {
    id?: string
    edicionId: string
    estado?: boolean
    inscritoEn?: Date | string
    compraId: string
  }

  export type inscripcionesCreateOrConnectWithoutEstudiantesInput = {
    where: inscripcionesWhereUniqueInput
    create: XOR<inscripcionesCreateWithoutEstudiantesInput, inscripcionesUncheckedCreateWithoutEstudiantesInput>
  }

  export type inscripcionesCreateManyEstudiantesInputEnvelope = {
    data: inscripcionesCreateManyEstudiantesInput | inscripcionesCreateManyEstudiantesInput[]
    skipDuplicates?: boolean
  }

  export type usuariosEstudiantesCreateWithoutEstudiantesInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    avatar?: string | null
    registrado?: boolean
    compras?: comprasCreateNestedManyWithoutUsuariosEstudiantesInput
    intentos?: intentosCreateNestedManyWithoutUsuariosEstudiantesInput
    reaccionesPreguntas?: reaccionesPreguntasCreateNestedManyWithoutUsuariosEstudiantesInput
    repasoRegistros?: repasoRegistrosCreateNestedManyWithoutUsuariosEstudiantesInput
    reviewsCursos?: reviewsCursosCreateNestedManyWithoutUsuariosEstudiantesInput
    suscripciones?: suscripcionesCreateNestedManyWithoutUsuariosEstudiantesInput
  }

  export type usuariosEstudiantesUncheckedCreateWithoutEstudiantesInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    avatar?: string | null
    registrado?: boolean
    compras?: comprasUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    intentos?: intentosUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    reaccionesPreguntas?: reaccionesPreguntasUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    repasoRegistros?: repasoRegistrosUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    reviewsCursos?: reviewsCursosUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    suscripciones?: suscripcionesUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
  }

  export type usuariosEstudiantesCreateOrConnectWithoutEstudiantesInput = {
    where: usuariosEstudiantesWhereUniqueInput
    create: XOR<usuariosEstudiantesCreateWithoutEstudiantesInput, usuariosEstudiantesUncheckedCreateWithoutEstudiantesInput>
  }

  export type calificacionesUpsertWithWhereUniqueWithoutEstudiantesInput = {
    where: calificacionesWhereUniqueInput
    update: XOR<calificacionesUpdateWithoutEstudiantesInput, calificacionesUncheckedUpdateWithoutEstudiantesInput>
    create: XOR<calificacionesCreateWithoutEstudiantesInput, calificacionesUncheckedCreateWithoutEstudiantesInput>
  }

  export type calificacionesUpdateWithWhereUniqueWithoutEstudiantesInput = {
    where: calificacionesWhereUniqueInput
    data: XOR<calificacionesUpdateWithoutEstudiantesInput, calificacionesUncheckedUpdateWithoutEstudiantesInput>
  }

  export type calificacionesUpdateManyWithWhereWithoutEstudiantesInput = {
    where: calificacionesScalarWhereInput
    data: XOR<calificacionesUpdateManyMutationInput, calificacionesUncheckedUpdateManyWithoutEstudiantesInput>
  }

  export type calificacionesScalarWhereInput = {
    AND?: calificacionesScalarWhereInput | calificacionesScalarWhereInput[]
    OR?: calificacionesScalarWhereInput[]
    NOT?: calificacionesScalarWhereInput | calificacionesScalarWhereInput[]
    id?: StringFilter<"calificaciones"> | string
    aprobado?: BoolFilter<"calificaciones"> | boolean
    comentarios?: StringNullableFilter<"calificaciones"> | string | null
    estudianteId?: StringFilter<"calificaciones"> | string
    examenId?: StringFilter<"calificaciones"> | string
    nota?: FloatFilter<"calificaciones"> | number
    creadoEn?: DateTimeFilter<"calificaciones"> | Date | string
  }

  export type certificadosUpsertWithWhereUniqueWithoutEstudiantesInput = {
    where: certificadosWhereUniqueInput
    update: XOR<certificadosUpdateWithoutEstudiantesInput, certificadosUncheckedUpdateWithoutEstudiantesInput>
    create: XOR<certificadosCreateWithoutEstudiantesInput, certificadosUncheckedCreateWithoutEstudiantesInput>
  }

  export type certificadosUpdateWithWhereUniqueWithoutEstudiantesInput = {
    where: certificadosWhereUniqueInput
    data: XOR<certificadosUpdateWithoutEstudiantesInput, certificadosUncheckedUpdateWithoutEstudiantesInput>
  }

  export type certificadosUpdateManyWithWhereWithoutEstudiantesInput = {
    where: certificadosScalarWhereInput
    data: XOR<certificadosUpdateManyMutationInput, certificadosUncheckedUpdateManyWithoutEstudiantesInput>
  }

  export type inscripcionesUpsertWithWhereUniqueWithoutEstudiantesInput = {
    where: inscripcionesWhereUniqueInput
    update: XOR<inscripcionesUpdateWithoutEstudiantesInput, inscripcionesUncheckedUpdateWithoutEstudiantesInput>
    create: XOR<inscripcionesCreateWithoutEstudiantesInput, inscripcionesUncheckedCreateWithoutEstudiantesInput>
  }

  export type inscripcionesUpdateWithWhereUniqueWithoutEstudiantesInput = {
    where: inscripcionesWhereUniqueInput
    data: XOR<inscripcionesUpdateWithoutEstudiantesInput, inscripcionesUncheckedUpdateWithoutEstudiantesInput>
  }

  export type inscripcionesUpdateManyWithWhereWithoutEstudiantesInput = {
    where: inscripcionesScalarWhereInput
    data: XOR<inscripcionesUpdateManyMutationInput, inscripcionesUncheckedUpdateManyWithoutEstudiantesInput>
  }

  export type usuariosEstudiantesUpsertWithoutEstudiantesInput = {
    update: XOR<usuariosEstudiantesUpdateWithoutEstudiantesInput, usuariosEstudiantesUncheckedUpdateWithoutEstudiantesInput>
    create: XOR<usuariosEstudiantesCreateWithoutEstudiantesInput, usuariosEstudiantesUncheckedCreateWithoutEstudiantesInput>
    where?: usuariosEstudiantesWhereInput
  }

  export type usuariosEstudiantesUpdateToOneWithWhereWithoutEstudiantesInput = {
    where?: usuariosEstudiantesWhereInput
    data: XOR<usuariosEstudiantesUpdateWithoutEstudiantesInput, usuariosEstudiantesUncheckedUpdateWithoutEstudiantesInput>
  }

  export type usuariosEstudiantesUpdateWithoutEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
    compras?: comprasUpdateManyWithoutUsuariosEstudiantesNestedInput
    intentos?: intentosUpdateManyWithoutUsuariosEstudiantesNestedInput
    reaccionesPreguntas?: reaccionesPreguntasUpdateManyWithoutUsuariosEstudiantesNestedInput
    repasoRegistros?: repasoRegistrosUpdateManyWithoutUsuariosEstudiantesNestedInput
    reviewsCursos?: reviewsCursosUpdateManyWithoutUsuariosEstudiantesNestedInput
    suscripciones?: suscripcionesUpdateManyWithoutUsuariosEstudiantesNestedInput
  }

  export type usuariosEstudiantesUncheckedUpdateWithoutEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
    compras?: comprasUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    intentos?: intentosUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    reaccionesPreguntas?: reaccionesPreguntasUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    repasoRegistros?: repasoRegistrosUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    reviewsCursos?: reviewsCursosUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    suscripciones?: suscripcionesUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
  }

  export type capitulosCreateWithoutTemasInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    areas?: areasCreateNestedOneWithoutCapitulosInput
    preguntas?: preguntasCreateNestedManyWithoutCapitulosInput
  }

  export type capitulosUncheckedCreateWithoutTemasInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    areaId?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    preguntas?: preguntasUncheckedCreateNestedManyWithoutCapitulosInput
  }

  export type capitulosCreateOrConnectWithoutTemasInput = {
    where: capitulosWhereUniqueInput
    create: XOR<capitulosCreateWithoutTemasInput, capitulosUncheckedCreateWithoutTemasInput>
  }

  export type preguntasCreateWithoutTemasInput = {
    id?: string
    codigo: string
    enunciado: string
    explicacion?: string | null
    referencia?: string | null
    opciones: JsonNullValueInput | InputJsonValue
    solucion: JsonNullValueInput | InputJsonValue
    estado?: $Enums.PreguntaEstado
    gestion: number
    likes?: number
    dislikes?: number
    dificultad?: $Enums.PreguntaDificultad
    dificultadActualizadaEn?: Date | string | null
    tasaAcierto?: number
    totalBien?: number
    totalMal?: number
    totalRespondidas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    reaccionesPreguntas?: reaccionesPreguntasCreateNestedManyWithoutPreguntaInput
    repasoRegistros?: repasoRegistrosCreateNestedManyWithoutPreguntasInput
    respuestasIntentos?: respuestasIntentosCreateNestedManyWithoutPreguntasInput
    areas?: areasCreateNestedManyWithoutPreguntasInput
    banqueo?: banqueoCreateNestedManyWithoutPreguntasInput
    capitulos?: capitulosCreateNestedManyWithoutPreguntasInput
  }

  export type preguntasUncheckedCreateWithoutTemasInput = {
    id?: string
    codigo: string
    enunciado: string
    explicacion?: string | null
    referencia?: string | null
    opciones: JsonNullValueInput | InputJsonValue
    solucion: JsonNullValueInput | InputJsonValue
    estado?: $Enums.PreguntaEstado
    gestion: number
    likes?: number
    dislikes?: number
    dificultad?: $Enums.PreguntaDificultad
    dificultadActualizadaEn?: Date | string | null
    tasaAcierto?: number
    totalBien?: number
    totalMal?: number
    totalRespondidas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    reaccionesPreguntas?: reaccionesPreguntasUncheckedCreateNestedManyWithoutPreguntaInput
    repasoRegistros?: repasoRegistrosUncheckedCreateNestedManyWithoutPreguntasInput
    respuestasIntentos?: respuestasIntentosUncheckedCreateNestedManyWithoutPreguntasInput
    areas?: areasUncheckedCreateNestedManyWithoutPreguntasInput
    banqueo?: banqueoUncheckedCreateNestedManyWithoutPreguntasInput
    capitulos?: capitulosUncheckedCreateNestedManyWithoutPreguntasInput
  }

  export type preguntasCreateOrConnectWithoutTemasInput = {
    where: preguntasWhereUniqueInput
    create: XOR<preguntasCreateWithoutTemasInput, preguntasUncheckedCreateWithoutTemasInput>
  }

  export type capitulosUpsertWithoutTemasInput = {
    update: XOR<capitulosUpdateWithoutTemasInput, capitulosUncheckedUpdateWithoutTemasInput>
    create: XOR<capitulosCreateWithoutTemasInput, capitulosUncheckedCreateWithoutTemasInput>
    where?: capitulosWhereInput
  }

  export type capitulosUpdateToOneWithWhereWithoutTemasInput = {
    where?: capitulosWhereInput
    data: XOR<capitulosUpdateWithoutTemasInput, capitulosUncheckedUpdateWithoutTemasInput>
  }

  export type capitulosUpdateWithoutTemasInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    areas?: areasUpdateOneWithoutCapitulosNestedInput
    preguntas?: preguntasUpdateManyWithoutCapitulosNestedInput
  }

  export type capitulosUncheckedUpdateWithoutTemasInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    preguntas?: preguntasUncheckedUpdateManyWithoutCapitulosNestedInput
  }

  export type preguntasUpsertWithWhereUniqueWithoutTemasInput = {
    where: preguntasWhereUniqueInput
    update: XOR<preguntasUpdateWithoutTemasInput, preguntasUncheckedUpdateWithoutTemasInput>
    create: XOR<preguntasCreateWithoutTemasInput, preguntasUncheckedCreateWithoutTemasInput>
  }

  export type preguntasUpdateWithWhereUniqueWithoutTemasInput = {
    where: preguntasWhereUniqueInput
    data: XOR<preguntasUpdateWithoutTemasInput, preguntasUncheckedUpdateWithoutTemasInput>
  }

  export type preguntasUpdateManyWithWhereWithoutTemasInput = {
    where: preguntasScalarWhereInput
    data: XOR<preguntasUpdateManyMutationInput, preguntasUncheckedUpdateManyWithoutTemasInput>
  }

  export type preguntasScalarWhereInput = {
    AND?: preguntasScalarWhereInput | preguntasScalarWhereInput[]
    OR?: preguntasScalarWhereInput[]
    NOT?: preguntasScalarWhereInput | preguntasScalarWhereInput[]
    id?: StringFilter<"preguntas"> | string
    codigo?: StringFilter<"preguntas"> | string
    enunciado?: StringFilter<"preguntas"> | string
    explicacion?: StringNullableFilter<"preguntas"> | string | null
    referencia?: StringNullableFilter<"preguntas"> | string | null
    opciones?: JsonFilter<"preguntas">
    solucion?: JsonFilter<"preguntas">
    estado?: EnumPreguntaEstadoFilter<"preguntas"> | $Enums.PreguntaEstado
    gestion?: IntFilter<"preguntas"> | number
    likes?: IntFilter<"preguntas"> | number
    dislikes?: IntFilter<"preguntas"> | number
    dificultad?: EnumPreguntaDificultadFilter<"preguntas"> | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: DateTimeNullableFilter<"preguntas"> | Date | string | null
    tasaAcierto?: IntFilter<"preguntas"> | number
    totalBien?: IntFilter<"preguntas"> | number
    totalMal?: IntFilter<"preguntas"> | number
    totalRespondidas?: IntFilter<"preguntas"> | number
    creadoEn?: DateTimeFilter<"preguntas"> | Date | string
    actualizadoEn?: DateTimeFilter<"preguntas"> | Date | string
  }

  export type calificacionesCreateWithoutExamenesInput = {
    id?: string
    aprobado?: boolean
    comentarios?: string | null
    nota: number
    creadoEn?: Date | string
    estudiantes: estudiantesCreateNestedOneWithoutCalificacionesInput
  }

  export type calificacionesUncheckedCreateWithoutExamenesInput = {
    id?: string
    aprobado?: boolean
    comentarios?: string | null
    estudianteId: string
    nota: number
    creadoEn?: Date | string
  }

  export type calificacionesCreateOrConnectWithoutExamenesInput = {
    where: calificacionesWhereUniqueInput
    create: XOR<calificacionesCreateWithoutExamenesInput, calificacionesUncheckedCreateWithoutExamenesInput>
  }

  export type calificacionesCreateManyExamenesInputEnvelope = {
    data: calificacionesCreateManyExamenesInput | calificacionesCreateManyExamenesInput[]
    skipDuplicates?: boolean
  }

  export type edicionesCursosCreateWithoutExamenesInput = {
    id?: string
    codigo: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    certificados?: certificadosCreateNestedManyWithoutEdicionesCursosInput
    clases?: clasesCreateNestedManyWithoutEdicionesCursosInput
    compras?: comprasCreateNestedManyWithoutEdicionesCursosInput
    cursos: cursosCreateNestedOneWithoutEdicionesCursosInput
    docente?: docenteCreateNestedOneWithoutEdicionesCursosInput
    inscripciones?: inscripcionesCreateNestedManyWithoutEdicionesCursosInput
    pagosDocentes?: pagosDocentesCreateNestedOneWithoutEdicionesCursosInput
    preciosCursos?: preciosCursosCreateNestedManyWithoutEdicionesCursosInput
  }

  export type edicionesCursosUncheckedCreateWithoutExamenesInput = {
    id?: string
    codigo: string
    cursoId: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    docenteId?: string | null
    certificados?: certificadosUncheckedCreateNestedManyWithoutEdicionesCursosInput
    clases?: clasesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    compras?: comprasUncheckedCreateNestedManyWithoutEdicionesCursosInput
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    pagosDocentes?: pagosDocentesUncheckedCreateNestedOneWithoutEdicionesCursosInput
    preciosCursos?: preciosCursosUncheckedCreateNestedManyWithoutEdicionesCursosInput
  }

  export type edicionesCursosCreateOrConnectWithoutExamenesInput = {
    where: edicionesCursosWhereUniqueInput
    create: XOR<edicionesCursosCreateWithoutExamenesInput, edicionesCursosUncheckedCreateWithoutExamenesInput>
  }

  export type calificacionesUpsertWithWhereUniqueWithoutExamenesInput = {
    where: calificacionesWhereUniqueInput
    update: XOR<calificacionesUpdateWithoutExamenesInput, calificacionesUncheckedUpdateWithoutExamenesInput>
    create: XOR<calificacionesCreateWithoutExamenesInput, calificacionesUncheckedCreateWithoutExamenesInput>
  }

  export type calificacionesUpdateWithWhereUniqueWithoutExamenesInput = {
    where: calificacionesWhereUniqueInput
    data: XOR<calificacionesUpdateWithoutExamenesInput, calificacionesUncheckedUpdateWithoutExamenesInput>
  }

  export type calificacionesUpdateManyWithWhereWithoutExamenesInput = {
    where: calificacionesScalarWhereInput
    data: XOR<calificacionesUpdateManyMutationInput, calificacionesUncheckedUpdateManyWithoutExamenesInput>
  }

  export type edicionesCursosUpsertWithoutExamenesInput = {
    update: XOR<edicionesCursosUpdateWithoutExamenesInput, edicionesCursosUncheckedUpdateWithoutExamenesInput>
    create: XOR<edicionesCursosCreateWithoutExamenesInput, edicionesCursosUncheckedCreateWithoutExamenesInput>
    where?: edicionesCursosWhereInput
  }

  export type edicionesCursosUpdateToOneWithWhereWithoutExamenesInput = {
    where?: edicionesCursosWhereInput
    data: XOR<edicionesCursosUpdateWithoutExamenesInput, edicionesCursosUncheckedUpdateWithoutExamenesInput>
  }

  export type edicionesCursosUpdateWithoutExamenesInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    certificados?: certificadosUpdateManyWithoutEdicionesCursosNestedInput
    clases?: clasesUpdateManyWithoutEdicionesCursosNestedInput
    compras?: comprasUpdateManyWithoutEdicionesCursosNestedInput
    cursos?: cursosUpdateOneRequiredWithoutEdicionesCursosNestedInput
    docente?: docenteUpdateOneWithoutEdicionesCursosNestedInput
    inscripciones?: inscripcionesUpdateManyWithoutEdicionesCursosNestedInput
    pagosDocentes?: pagosDocentesUpdateOneWithoutEdicionesCursosNestedInput
    preciosCursos?: preciosCursosUpdateManyWithoutEdicionesCursosNestedInput
  }

  export type edicionesCursosUncheckedUpdateWithoutExamenesInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docenteId?: NullableStringFieldUpdateOperationsInput | string | null
    certificados?: certificadosUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    clases?: clasesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    compras?: comprasUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    pagosDocentes?: pagosDocentesUncheckedUpdateOneWithoutEdicionesCursosNestedInput
    preciosCursos?: preciosCursosUncheckedUpdateManyWithoutEdicionesCursosNestedInput
  }

  export type clasesCreateWithoutGrabacionesInput = {
    id?: string
    descripcion: string
    duracion?: number | null
    fecha: Date | string
    orden: number
    titulo: string
    urlYoutube?: string | null
    creadoEn?: Date | string
    urlPresentacion?: string | null
    edicionesCursos: edicionesCursosCreateNestedOneWithoutClasesInput
    materiales?: materialesCreateNestedManyWithoutClasesInput
  }

  export type clasesUncheckedCreateWithoutGrabacionesInput = {
    id?: string
    edicionId: string
    descripcion: string
    duracion?: number | null
    fecha: Date | string
    orden: number
    titulo: string
    urlYoutube?: string | null
    creadoEn?: Date | string
    urlPresentacion?: string | null
    materiales?: materialesUncheckedCreateNestedManyWithoutClasesInput
  }

  export type clasesCreateOrConnectWithoutGrabacionesInput = {
    where: clasesWhereUniqueInput
    create: XOR<clasesCreateWithoutGrabacionesInput, clasesUncheckedCreateWithoutGrabacionesInput>
  }

  export type usuariosAdministradoresCreateWithoutGrabacionesInput = {
    id?: string
    correo: string
    contrasena: string
    encargado?: string | null
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    tipo: $Enums.TipoCuenta
    auditoria?: auditoriaCreateNestedManyWithoutUsuariosAdministradoresInput
    docente?: docenteCreateNestedOneWithoutUsuariosAdministradoresInput
  }

  export type usuariosAdministradoresUncheckedCreateWithoutGrabacionesInput = {
    id?: string
    correo: string
    contrasena: string
    encargado?: string | null
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    tipo: $Enums.TipoCuenta
    auditoria?: auditoriaUncheckedCreateNestedManyWithoutUsuariosAdministradoresInput
    docente?: docenteUncheckedCreateNestedOneWithoutUsuariosAdministradoresInput
  }

  export type usuariosAdministradoresCreateOrConnectWithoutGrabacionesInput = {
    where: usuariosAdministradoresWhereUniqueInput
    create: XOR<usuariosAdministradoresCreateWithoutGrabacionesInput, usuariosAdministradoresUncheckedCreateWithoutGrabacionesInput>
  }

  export type clasesUpsertWithoutGrabacionesInput = {
    update: XOR<clasesUpdateWithoutGrabacionesInput, clasesUncheckedUpdateWithoutGrabacionesInput>
    create: XOR<clasesCreateWithoutGrabacionesInput, clasesUncheckedCreateWithoutGrabacionesInput>
    where?: clasesWhereInput
  }

  export type clasesUpdateToOneWithWhereWithoutGrabacionesInput = {
    where?: clasesWhereInput
    data: XOR<clasesUpdateWithoutGrabacionesInput, clasesUncheckedUpdateWithoutGrabacionesInput>
  }

  export type clasesUpdateWithoutGrabacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    orden?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    urlYoutube?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    urlPresentacion?: NullableStringFieldUpdateOperationsInput | string | null
    edicionesCursos?: edicionesCursosUpdateOneRequiredWithoutClasesNestedInput
    materiales?: materialesUpdateManyWithoutClasesNestedInput
  }

  export type clasesUncheckedUpdateWithoutGrabacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    orden?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    urlYoutube?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    urlPresentacion?: NullableStringFieldUpdateOperationsInput | string | null
    materiales?: materialesUncheckedUpdateManyWithoutClasesNestedInput
  }

  export type usuariosAdministradoresUpsertWithoutGrabacionesInput = {
    update: XOR<usuariosAdministradoresUpdateWithoutGrabacionesInput, usuariosAdministradoresUncheckedUpdateWithoutGrabacionesInput>
    create: XOR<usuariosAdministradoresCreateWithoutGrabacionesInput, usuariosAdministradoresUncheckedCreateWithoutGrabacionesInput>
    where?: usuariosAdministradoresWhereInput
  }

  export type usuariosAdministradoresUpdateToOneWithWhereWithoutGrabacionesInput = {
    where?: usuariosAdministradoresWhereInput
    data: XOR<usuariosAdministradoresUpdateWithoutGrabacionesInput, usuariosAdministradoresUncheckedUpdateWithoutGrabacionesInput>
  }

  export type usuariosAdministradoresUpdateWithoutGrabacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    encargado?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCuentaFieldUpdateOperationsInput | $Enums.TipoCuenta
    auditoria?: auditoriaUpdateManyWithoutUsuariosAdministradoresNestedInput
    docente?: docenteUpdateOneWithoutUsuariosAdministradoresNestedInput
  }

  export type usuariosAdministradoresUncheckedUpdateWithoutGrabacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    encargado?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCuentaFieldUpdateOperationsInput | $Enums.TipoCuenta
    auditoria?: auditoriaUncheckedUpdateManyWithoutUsuariosAdministradoresNestedInput
    docente?: docenteUncheckedUpdateOneWithoutUsuariosAdministradoresNestedInput
  }

  export type comprasCreateWithoutInscripcionesInput = {
    id?: string
    monto: number
    moneda?: string
    comprobado?: boolean
    providerId: string
    fechaCompra?: Date | string
    metodo?: $Enums.MetodoPago
    deuda?: number
    estadoPago?: $Enums.EstadoPago
    updatedAt: Date | string
    conDescuento?: boolean
    edicionesCursos: edicionesCursosCreateNestedOneWithoutComprasInput
    usuariosEstudiantes?: usuariosEstudiantesCreateNestedOneWithoutComprasInput
  }

  export type comprasUncheckedCreateWithoutInscripcionesInput = {
    id?: string
    edicionId: string
    monto: number
    moneda?: string
    comprobado?: boolean
    providerId: string
    fechaCompra?: Date | string
    metodo?: $Enums.MetodoPago
    deuda?: number
    usuariosEstudiantesId?: string | null
    estadoPago?: $Enums.EstadoPago
    updatedAt: Date | string
    conDescuento?: boolean
  }

  export type comprasCreateOrConnectWithoutInscripcionesInput = {
    where: comprasWhereUniqueInput
    create: XOR<comprasCreateWithoutInscripcionesInput, comprasUncheckedCreateWithoutInscripcionesInput>
  }

  export type edicionesCursosCreateWithoutInscripcionesInput = {
    id?: string
    codigo: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    certificados?: certificadosCreateNestedManyWithoutEdicionesCursosInput
    clases?: clasesCreateNestedManyWithoutEdicionesCursosInput
    compras?: comprasCreateNestedManyWithoutEdicionesCursosInput
    cursos: cursosCreateNestedOneWithoutEdicionesCursosInput
    docente?: docenteCreateNestedOneWithoutEdicionesCursosInput
    examenes?: examenesCreateNestedManyWithoutEdicionesCursosInput
    pagosDocentes?: pagosDocentesCreateNestedOneWithoutEdicionesCursosInput
    preciosCursos?: preciosCursosCreateNestedManyWithoutEdicionesCursosInput
  }

  export type edicionesCursosUncheckedCreateWithoutInscripcionesInput = {
    id?: string
    codigo: string
    cursoId: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    docenteId?: string | null
    certificados?: certificadosUncheckedCreateNestedManyWithoutEdicionesCursosInput
    clases?: clasesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    compras?: comprasUncheckedCreateNestedManyWithoutEdicionesCursosInput
    examenes?: examenesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    pagosDocentes?: pagosDocentesUncheckedCreateNestedOneWithoutEdicionesCursosInput
    preciosCursos?: preciosCursosUncheckedCreateNestedManyWithoutEdicionesCursosInput
  }

  export type edicionesCursosCreateOrConnectWithoutInscripcionesInput = {
    where: edicionesCursosWhereUniqueInput
    create: XOR<edicionesCursosCreateWithoutInscripcionesInput, edicionesCursosUncheckedCreateWithoutInscripcionesInput>
  }

  export type estudiantesCreateWithoutInscripcionesInput = {
    id?: string
    apellido?: string | null
    celular?: string | null
    pais?: string
    genero?: $Enums.TipoGenero
    fechaNacimiento?: Date | string | null
    nombre: string
    creadoEn?: Date | string
    actualizadoEn: Date | string
    nroUpdates?: number
    calificaciones?: calificacionesCreateNestedManyWithoutEstudiantesInput
    certificados?: certificadosCreateNestedManyWithoutEstudiantesInput
    usuariosEstudiantes?: usuariosEstudiantesCreateNestedOneWithoutEstudiantesInput
  }

  export type estudiantesUncheckedCreateWithoutInscripcionesInput = {
    id?: string
    apellido?: string | null
    celular?: string | null
    pais?: string
    genero?: $Enums.TipoGenero
    fechaNacimiento?: Date | string | null
    nombre: string
    creadoEn?: Date | string
    actualizadoEn: Date | string
    nroUpdates?: number
    calificaciones?: calificacionesUncheckedCreateNestedManyWithoutEstudiantesInput
    certificados?: certificadosUncheckedCreateNestedManyWithoutEstudiantesInput
    usuariosEstudiantes?: usuariosEstudiantesUncheckedCreateNestedOneWithoutEstudiantesInput
  }

  export type estudiantesCreateOrConnectWithoutInscripcionesInput = {
    where: estudiantesWhereUniqueInput
    create: XOR<estudiantesCreateWithoutInscripcionesInput, estudiantesUncheckedCreateWithoutInscripcionesInput>
  }

  export type comprasUpsertWithoutInscripcionesInput = {
    update: XOR<comprasUpdateWithoutInscripcionesInput, comprasUncheckedUpdateWithoutInscripcionesInput>
    create: XOR<comprasCreateWithoutInscripcionesInput, comprasUncheckedCreateWithoutInscripcionesInput>
    where?: comprasWhereInput
  }

  export type comprasUpdateToOneWithWhereWithoutInscripcionesInput = {
    where?: comprasWhereInput
    data: XOR<comprasUpdateWithoutInscripcionesInput, comprasUncheckedUpdateWithoutInscripcionesInput>
  }

  export type comprasUpdateWithoutInscripcionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: StringFieldUpdateOperationsInput | string
    comprobado?: BoolFieldUpdateOperationsInput | boolean
    providerId?: StringFieldUpdateOperationsInput | string
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    deuda?: FloatFieldUpdateOperationsInput | number
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conDescuento?: BoolFieldUpdateOperationsInput | boolean
    edicionesCursos?: edicionesCursosUpdateOneRequiredWithoutComprasNestedInput
    usuariosEstudiantes?: usuariosEstudiantesUpdateOneWithoutComprasNestedInput
  }

  export type comprasUncheckedUpdateWithoutInscripcionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: StringFieldUpdateOperationsInput | string
    comprobado?: BoolFieldUpdateOperationsInput | boolean
    providerId?: StringFieldUpdateOperationsInput | string
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    deuda?: FloatFieldUpdateOperationsInput | number
    usuariosEstudiantesId?: NullableStringFieldUpdateOperationsInput | string | null
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conDescuento?: BoolFieldUpdateOperationsInput | boolean
  }

  export type edicionesCursosUpsertWithoutInscripcionesInput = {
    update: XOR<edicionesCursosUpdateWithoutInscripcionesInput, edicionesCursosUncheckedUpdateWithoutInscripcionesInput>
    create: XOR<edicionesCursosCreateWithoutInscripcionesInput, edicionesCursosUncheckedCreateWithoutInscripcionesInput>
    where?: edicionesCursosWhereInput
  }

  export type edicionesCursosUpdateToOneWithWhereWithoutInscripcionesInput = {
    where?: edicionesCursosWhereInput
    data: XOR<edicionesCursosUpdateWithoutInscripcionesInput, edicionesCursosUncheckedUpdateWithoutInscripcionesInput>
  }

  export type edicionesCursosUpdateWithoutInscripcionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    certificados?: certificadosUpdateManyWithoutEdicionesCursosNestedInput
    clases?: clasesUpdateManyWithoutEdicionesCursosNestedInput
    compras?: comprasUpdateManyWithoutEdicionesCursosNestedInput
    cursos?: cursosUpdateOneRequiredWithoutEdicionesCursosNestedInput
    docente?: docenteUpdateOneWithoutEdicionesCursosNestedInput
    examenes?: examenesUpdateManyWithoutEdicionesCursosNestedInput
    pagosDocentes?: pagosDocentesUpdateOneWithoutEdicionesCursosNestedInput
    preciosCursos?: preciosCursosUpdateManyWithoutEdicionesCursosNestedInput
  }

  export type edicionesCursosUncheckedUpdateWithoutInscripcionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docenteId?: NullableStringFieldUpdateOperationsInput | string | null
    certificados?: certificadosUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    clases?: clasesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    compras?: comprasUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    examenes?: examenesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    pagosDocentes?: pagosDocentesUncheckedUpdateOneWithoutEdicionesCursosNestedInput
    preciosCursos?: preciosCursosUncheckedUpdateManyWithoutEdicionesCursosNestedInput
  }

  export type estudiantesUpsertWithoutInscripcionesInput = {
    update: XOR<estudiantesUpdateWithoutInscripcionesInput, estudiantesUncheckedUpdateWithoutInscripcionesInput>
    create: XOR<estudiantesCreateWithoutInscripcionesInput, estudiantesUncheckedCreateWithoutInscripcionesInput>
    where?: estudiantesWhereInput
  }

  export type estudiantesUpdateToOneWithWhereWithoutInscripcionesInput = {
    where?: estudiantesWhereInput
    data: XOR<estudiantesUpdateWithoutInscripcionesInput, estudiantesUncheckedUpdateWithoutInscripcionesInput>
  }

  export type estudiantesUpdateWithoutInscripcionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: StringFieldUpdateOperationsInput | string
    genero?: EnumTipoGeneroFieldUpdateOperationsInput | $Enums.TipoGenero
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    nroUpdates?: IntFieldUpdateOperationsInput | number
    calificaciones?: calificacionesUpdateManyWithoutEstudiantesNestedInput
    certificados?: certificadosUpdateManyWithoutEstudiantesNestedInput
    usuariosEstudiantes?: usuariosEstudiantesUpdateOneWithoutEstudiantesNestedInput
  }

  export type estudiantesUncheckedUpdateWithoutInscripcionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: StringFieldUpdateOperationsInput | string
    genero?: EnumTipoGeneroFieldUpdateOperationsInput | $Enums.TipoGenero
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    nroUpdates?: IntFieldUpdateOperationsInput | number
    calificaciones?: calificacionesUncheckedUpdateManyWithoutEstudiantesNestedInput
    certificados?: certificadosUncheckedUpdateManyWithoutEstudiantesNestedInput
    usuariosEstudiantes?: usuariosEstudiantesUncheckedUpdateOneWithoutEstudiantesNestedInput
  }

  export type clasesCreateWithoutMaterialesInput = {
    id?: string
    descripcion: string
    duracion?: number | null
    fecha: Date | string
    orden: number
    titulo: string
    urlYoutube?: string | null
    creadoEn?: Date | string
    urlPresentacion?: string | null
    edicionesCursos: edicionesCursosCreateNestedOneWithoutClasesInput
    grabaciones?: grabacionesCreateNestedManyWithoutClasesInput
  }

  export type clasesUncheckedCreateWithoutMaterialesInput = {
    id?: string
    edicionId: string
    descripcion: string
    duracion?: number | null
    fecha: Date | string
    orden: number
    titulo: string
    urlYoutube?: string | null
    creadoEn?: Date | string
    urlPresentacion?: string | null
    grabaciones?: grabacionesUncheckedCreateNestedManyWithoutClasesInput
  }

  export type clasesCreateOrConnectWithoutMaterialesInput = {
    where: clasesWhereUniqueInput
    create: XOR<clasesCreateWithoutMaterialesInput, clasesUncheckedCreateWithoutMaterialesInput>
  }

  export type clasesUpsertWithoutMaterialesInput = {
    update: XOR<clasesUpdateWithoutMaterialesInput, clasesUncheckedUpdateWithoutMaterialesInput>
    create: XOR<clasesCreateWithoutMaterialesInput, clasesUncheckedCreateWithoutMaterialesInput>
    where?: clasesWhereInput
  }

  export type clasesUpdateToOneWithWhereWithoutMaterialesInput = {
    where?: clasesWhereInput
    data: XOR<clasesUpdateWithoutMaterialesInput, clasesUncheckedUpdateWithoutMaterialesInput>
  }

  export type clasesUpdateWithoutMaterialesInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    orden?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    urlYoutube?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    urlPresentacion?: NullableStringFieldUpdateOperationsInput | string | null
    edicionesCursos?: edicionesCursosUpdateOneRequiredWithoutClasesNestedInput
    grabaciones?: grabacionesUpdateManyWithoutClasesNestedInput
  }

  export type clasesUncheckedUpdateWithoutMaterialesInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    orden?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    urlYoutube?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    urlPresentacion?: NullableStringFieldUpdateOperationsInput | string | null
    grabaciones?: grabacionesUncheckedUpdateManyWithoutClasesNestedInput
  }

  export type cursosCreateWithoutObjetivosCursosInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    cargaHoraria?: number
    codigo: string
    beneficiosCursos?: beneficiosCursosCreateNestedManyWithoutCursosInput
    categoriasCursos?: categoriasCursosCreateNestedManyWithoutCursosInput
    edicionesCursos?: edicionesCursosCreateNestedManyWithoutCursosInput
    requisitosCursos?: requisitosCursosCreateNestedManyWithoutCursosInput
    reviewsCursos?: reviewsCursosCreateNestedManyWithoutCursosInput
  }

  export type cursosUncheckedCreateWithoutObjetivosCursosInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    cargaHoraria?: number
    codigo: string
    beneficiosCursos?: beneficiosCursosUncheckedCreateNestedManyWithoutCursosInput
    categoriasCursos?: categoriasCursosUncheckedCreateNestedManyWithoutCursosInput
    edicionesCursos?: edicionesCursosUncheckedCreateNestedManyWithoutCursosInput
    requisitosCursos?: requisitosCursosUncheckedCreateNestedManyWithoutCursosInput
    reviewsCursos?: reviewsCursosUncheckedCreateNestedManyWithoutCursosInput
  }

  export type cursosCreateOrConnectWithoutObjetivosCursosInput = {
    where: cursosWhereUniqueInput
    create: XOR<cursosCreateWithoutObjetivosCursosInput, cursosUncheckedCreateWithoutObjetivosCursosInput>
  }

  export type cursosUpsertWithoutObjetivosCursosInput = {
    update: XOR<cursosUpdateWithoutObjetivosCursosInput, cursosUncheckedUpdateWithoutObjetivosCursosInput>
    create: XOR<cursosCreateWithoutObjetivosCursosInput, cursosUncheckedCreateWithoutObjetivosCursosInput>
    where?: cursosWhereInput
  }

  export type cursosUpdateToOneWithWhereWithoutObjetivosCursosInput = {
    where?: cursosWhereInput
    data: XOR<cursosUpdateWithoutObjetivosCursosInput, cursosUncheckedUpdateWithoutObjetivosCursosInput>
  }

  export type cursosUpdateWithoutObjetivosCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    cargaHoraria?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    beneficiosCursos?: beneficiosCursosUpdateManyWithoutCursosNestedInput
    categoriasCursos?: categoriasCursosUpdateManyWithoutCursosNestedInput
    edicionesCursos?: edicionesCursosUpdateManyWithoutCursosNestedInput
    requisitosCursos?: requisitosCursosUpdateManyWithoutCursosNestedInput
    reviewsCursos?: reviewsCursosUpdateManyWithoutCursosNestedInput
  }

  export type cursosUncheckedUpdateWithoutObjetivosCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    cargaHoraria?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    beneficiosCursos?: beneficiosCursosUncheckedUpdateManyWithoutCursosNestedInput
    categoriasCursos?: categoriasCursosUncheckedUpdateManyWithoutCursosNestedInput
    edicionesCursos?: edicionesCursosUncheckedUpdateManyWithoutCursosNestedInput
    requisitosCursos?: requisitosCursosUncheckedUpdateManyWithoutCursosNestedInput
    reviewsCursos?: reviewsCursosUncheckedUpdateManyWithoutCursosNestedInput
  }

  export type docenteCreateWithoutPagosDocentesInput = {
    id?: string
    nombre_completo: string
    celular?: string | null
    especialidad: string
    experiencia?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    pais?: string
    usuariosAdministradores: usuariosAdministradoresCreateNestedOneWithoutDocenteInput
    edicionesCursos?: edicionesCursosCreateNestedManyWithoutDocenteInput
  }

  export type docenteUncheckedCreateWithoutPagosDocentesInput = {
    id?: string
    nombre_completo: string
    celular?: string | null
    especialidad: string
    experiencia?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    usuarioId: string
    pais?: string
    edicionesCursos?: edicionesCursosUncheckedCreateNestedManyWithoutDocenteInput
  }

  export type docenteCreateOrConnectWithoutPagosDocentesInput = {
    where: docenteWhereUniqueInput
    create: XOR<docenteCreateWithoutPagosDocentesInput, docenteUncheckedCreateWithoutPagosDocentesInput>
  }

  export type edicionesCursosCreateWithoutPagosDocentesInput = {
    id?: string
    codigo: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    certificados?: certificadosCreateNestedManyWithoutEdicionesCursosInput
    clases?: clasesCreateNestedManyWithoutEdicionesCursosInput
    compras?: comprasCreateNestedManyWithoutEdicionesCursosInput
    cursos: cursosCreateNestedOneWithoutEdicionesCursosInput
    docente?: docenteCreateNestedOneWithoutEdicionesCursosInput
    examenes?: examenesCreateNestedManyWithoutEdicionesCursosInput
    inscripciones?: inscripcionesCreateNestedManyWithoutEdicionesCursosInput
    preciosCursos?: preciosCursosCreateNestedManyWithoutEdicionesCursosInput
  }

  export type edicionesCursosUncheckedCreateWithoutPagosDocentesInput = {
    id?: string
    codigo: string
    cursoId: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    docenteId?: string | null
    certificados?: certificadosUncheckedCreateNestedManyWithoutEdicionesCursosInput
    clases?: clasesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    compras?: comprasUncheckedCreateNestedManyWithoutEdicionesCursosInput
    examenes?: examenesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    preciosCursos?: preciosCursosUncheckedCreateNestedManyWithoutEdicionesCursosInput
  }

  export type edicionesCursosCreateOrConnectWithoutPagosDocentesInput = {
    where: edicionesCursosWhereUniqueInput
    create: XOR<edicionesCursosCreateWithoutPagosDocentesInput, edicionesCursosUncheckedCreateWithoutPagosDocentesInput>
  }

  export type docenteUpsertWithoutPagosDocentesInput = {
    update: XOR<docenteUpdateWithoutPagosDocentesInput, docenteUncheckedUpdateWithoutPagosDocentesInput>
    create: XOR<docenteCreateWithoutPagosDocentesInput, docenteUncheckedCreateWithoutPagosDocentesInput>
    where?: docenteWhereInput
  }

  export type docenteUpdateToOneWithWhereWithoutPagosDocentesInput = {
    where?: docenteWhereInput
    data: XOR<docenteUpdateWithoutPagosDocentesInput, docenteUncheckedUpdateWithoutPagosDocentesInput>
  }

  export type docenteUpdateWithoutPagosDocentesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre_completo?: StringFieldUpdateOperationsInput | string
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    experiencia?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    pais?: StringFieldUpdateOperationsInput | string
    usuariosAdministradores?: usuariosAdministradoresUpdateOneRequiredWithoutDocenteNestedInput
    edicionesCursos?: edicionesCursosUpdateManyWithoutDocenteNestedInput
  }

  export type docenteUncheckedUpdateWithoutPagosDocentesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre_completo?: StringFieldUpdateOperationsInput | string
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    experiencia?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    edicionesCursos?: edicionesCursosUncheckedUpdateManyWithoutDocenteNestedInput
  }

  export type edicionesCursosUpsertWithoutPagosDocentesInput = {
    update: XOR<edicionesCursosUpdateWithoutPagosDocentesInput, edicionesCursosUncheckedUpdateWithoutPagosDocentesInput>
    create: XOR<edicionesCursosCreateWithoutPagosDocentesInput, edicionesCursosUncheckedCreateWithoutPagosDocentesInput>
    where?: edicionesCursosWhereInput
  }

  export type edicionesCursosUpdateToOneWithWhereWithoutPagosDocentesInput = {
    where?: edicionesCursosWhereInput
    data: XOR<edicionesCursosUpdateWithoutPagosDocentesInput, edicionesCursosUncheckedUpdateWithoutPagosDocentesInput>
  }

  export type edicionesCursosUpdateWithoutPagosDocentesInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    certificados?: certificadosUpdateManyWithoutEdicionesCursosNestedInput
    clases?: clasesUpdateManyWithoutEdicionesCursosNestedInput
    compras?: comprasUpdateManyWithoutEdicionesCursosNestedInput
    cursos?: cursosUpdateOneRequiredWithoutEdicionesCursosNestedInput
    docente?: docenteUpdateOneWithoutEdicionesCursosNestedInput
    examenes?: examenesUpdateManyWithoutEdicionesCursosNestedInput
    inscripciones?: inscripcionesUpdateManyWithoutEdicionesCursosNestedInput
    preciosCursos?: preciosCursosUpdateManyWithoutEdicionesCursosNestedInput
  }

  export type edicionesCursosUncheckedUpdateWithoutPagosDocentesInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docenteId?: NullableStringFieldUpdateOperationsInput | string | null
    certificados?: certificadosUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    clases?: clasesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    compras?: comprasUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    examenes?: examenesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    preciosCursos?: preciosCursosUncheckedUpdateManyWithoutEdicionesCursosNestedInput
  }

  export type edicionesCursosCreateWithoutPreciosCursosInput = {
    id?: string
    codigo: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    certificados?: certificadosCreateNestedManyWithoutEdicionesCursosInput
    clases?: clasesCreateNestedManyWithoutEdicionesCursosInput
    compras?: comprasCreateNestedManyWithoutEdicionesCursosInput
    cursos: cursosCreateNestedOneWithoutEdicionesCursosInput
    docente?: docenteCreateNestedOneWithoutEdicionesCursosInput
    examenes?: examenesCreateNestedManyWithoutEdicionesCursosInput
    inscripciones?: inscripcionesCreateNestedManyWithoutEdicionesCursosInput
    pagosDocentes?: pagosDocentesCreateNestedOneWithoutEdicionesCursosInput
  }

  export type edicionesCursosUncheckedCreateWithoutPreciosCursosInput = {
    id?: string
    codigo: string
    cursoId: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    docenteId?: string | null
    certificados?: certificadosUncheckedCreateNestedManyWithoutEdicionesCursosInput
    clases?: clasesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    compras?: comprasUncheckedCreateNestedManyWithoutEdicionesCursosInput
    examenes?: examenesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEdicionesCursosInput
    pagosDocentes?: pagosDocentesUncheckedCreateNestedOneWithoutEdicionesCursosInput
  }

  export type edicionesCursosCreateOrConnectWithoutPreciosCursosInput = {
    where: edicionesCursosWhereUniqueInput
    create: XOR<edicionesCursosCreateWithoutPreciosCursosInput, edicionesCursosUncheckedCreateWithoutPreciosCursosInput>
  }

  export type edicionesCursosUpsertWithoutPreciosCursosInput = {
    update: XOR<edicionesCursosUpdateWithoutPreciosCursosInput, edicionesCursosUncheckedUpdateWithoutPreciosCursosInput>
    create: XOR<edicionesCursosCreateWithoutPreciosCursosInput, edicionesCursosUncheckedCreateWithoutPreciosCursosInput>
    where?: edicionesCursosWhereInput
  }

  export type edicionesCursosUpdateToOneWithWhereWithoutPreciosCursosInput = {
    where?: edicionesCursosWhereInput
    data: XOR<edicionesCursosUpdateWithoutPreciosCursosInput, edicionesCursosUncheckedUpdateWithoutPreciosCursosInput>
  }

  export type edicionesCursosUpdateWithoutPreciosCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    certificados?: certificadosUpdateManyWithoutEdicionesCursosNestedInput
    clases?: clasesUpdateManyWithoutEdicionesCursosNestedInput
    compras?: comprasUpdateManyWithoutEdicionesCursosNestedInput
    cursos?: cursosUpdateOneRequiredWithoutEdicionesCursosNestedInput
    docente?: docenteUpdateOneWithoutEdicionesCursosNestedInput
    examenes?: examenesUpdateManyWithoutEdicionesCursosNestedInput
    inscripciones?: inscripcionesUpdateManyWithoutEdicionesCursosNestedInput
    pagosDocentes?: pagosDocentesUpdateOneWithoutEdicionesCursosNestedInput
  }

  export type edicionesCursosUncheckedUpdateWithoutPreciosCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docenteId?: NullableStringFieldUpdateOperationsInput | string | null
    certificados?: certificadosUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    clases?: clasesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    compras?: comprasUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    examenes?: examenesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    pagosDocentes?: pagosDocentesUncheckedUpdateOneWithoutEdicionesCursosNestedInput
  }

  export type reaccionesPreguntasCreateWithoutPreguntaInput = {
    id?: string
    tipo: $Enums.TipoReaccion
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    usuariosEstudiantes: usuariosEstudiantesCreateNestedOneWithoutReaccionesPreguntasInput
  }

  export type reaccionesPreguntasUncheckedCreateWithoutPreguntaInput = {
    id?: string
    usuarioEstudianteId: string
    tipo: $Enums.TipoReaccion
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type reaccionesPreguntasCreateOrConnectWithoutPreguntaInput = {
    where: reaccionesPreguntasWhereUniqueInput
    create: XOR<reaccionesPreguntasCreateWithoutPreguntaInput, reaccionesPreguntasUncheckedCreateWithoutPreguntaInput>
  }

  export type reaccionesPreguntasCreateManyPreguntaInputEnvelope = {
    data: reaccionesPreguntasCreateManyPreguntaInput | reaccionesPreguntasCreateManyPreguntaInput[]
    skipDuplicates?: boolean
  }

  export type repasoRegistrosCreateWithoutPreguntasInput = {
    id?: string
    esCorrecta: boolean
    creadoEn?: Date | string
    banqueo: banqueoCreateNestedOneWithoutRepasoRegistrosInput
    usuariosEstudiantes: usuariosEstudiantesCreateNestedOneWithoutRepasoRegistrosInput
  }

  export type repasoRegistrosUncheckedCreateWithoutPreguntasInput = {
    id?: string
    usuarioEstudianteId: string
    banqueoId: string
    esCorrecta: boolean
    creadoEn?: Date | string
  }

  export type repasoRegistrosCreateOrConnectWithoutPreguntasInput = {
    where: repasoRegistrosWhereUniqueInput
    create: XOR<repasoRegistrosCreateWithoutPreguntasInput, repasoRegistrosUncheckedCreateWithoutPreguntasInput>
  }

  export type repasoRegistrosCreateManyPreguntasInputEnvelope = {
    data: repasoRegistrosCreateManyPreguntasInput | repasoRegistrosCreateManyPreguntasInput[]
    skipDuplicates?: boolean
  }

  export type respuestasIntentosCreateWithoutPreguntasInput = {
    id?: string
    respuesta?: NullableJsonNullValueInput | InputJsonValue
    resultado?: $Enums.ResultadoRespuesta
    esCorrecta?: boolean | null
    respondida?: boolean
    visitada?: boolean
    marcadaRevision?: boolean
    tiempoConsumidoSeg?: number
    orden?: number | null
    respondidaEn?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    intentos: intentosCreateNestedOneWithoutRespuestasIntentosInput
  }

  export type respuestasIntentosUncheckedCreateWithoutPreguntasInput = {
    id?: string
    intentoId: string
    respuesta?: NullableJsonNullValueInput | InputJsonValue
    resultado?: $Enums.ResultadoRespuesta
    esCorrecta?: boolean | null
    respondida?: boolean
    visitada?: boolean
    marcadaRevision?: boolean
    tiempoConsumidoSeg?: number
    orden?: number | null
    respondidaEn?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type respuestasIntentosCreateOrConnectWithoutPreguntasInput = {
    where: respuestasIntentosWhereUniqueInput
    create: XOR<respuestasIntentosCreateWithoutPreguntasInput, respuestasIntentosUncheckedCreateWithoutPreguntasInput>
  }

  export type respuestasIntentosCreateManyPreguntasInputEnvelope = {
    data: respuestasIntentosCreateManyPreguntasInput | respuestasIntentosCreateManyPreguntasInput[]
    skipDuplicates?: boolean
  }

  export type areasCreateWithoutPreguntasInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    capitulos?: capitulosCreateNestedManyWithoutAreasInput
  }

  export type areasUncheckedCreateWithoutPreguntasInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    capitulos?: capitulosUncheckedCreateNestedManyWithoutAreasInput
  }

  export type areasCreateOrConnectWithoutPreguntasInput = {
    where: areasWhereUniqueInput
    create: XOR<areasCreateWithoutPreguntasInput, areasUncheckedCreateWithoutPreguntasInput>
  }

  export type banqueoCreateWithoutPreguntasInput = {
    id?: string
    titulo: string
    tipo: $Enums.BanqueoTipo
    tipoCreado: $Enums.BanqueoTipoCreado
    duracion: number
    maxPreguntas: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    intentos?: intentosCreateNestedManyWithoutBanqueoInput
    repasoRegistros?: repasoRegistrosCreateNestedManyWithoutBanqueoInput
  }

  export type banqueoUncheckedCreateWithoutPreguntasInput = {
    id?: string
    titulo: string
    tipo: $Enums.BanqueoTipo
    tipoCreado: $Enums.BanqueoTipoCreado
    duracion: number
    maxPreguntas: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    intentos?: intentosUncheckedCreateNestedManyWithoutBanqueoInput
    repasoRegistros?: repasoRegistrosUncheckedCreateNestedManyWithoutBanqueoInput
  }

  export type banqueoCreateOrConnectWithoutPreguntasInput = {
    where: banqueoWhereUniqueInput
    create: XOR<banqueoCreateWithoutPreguntasInput, banqueoUncheckedCreateWithoutPreguntasInput>
  }

  export type capitulosCreateWithoutPreguntasInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    areas?: areasCreateNestedOneWithoutCapitulosInput
    temas?: temasCreateNestedManyWithoutCapitulosInput
  }

  export type capitulosUncheckedCreateWithoutPreguntasInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    areaId?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    temas?: temasUncheckedCreateNestedManyWithoutCapitulosInput
  }

  export type capitulosCreateOrConnectWithoutPreguntasInput = {
    where: capitulosWhereUniqueInput
    create: XOR<capitulosCreateWithoutPreguntasInput, capitulosUncheckedCreateWithoutPreguntasInput>
  }

  export type temasCreateWithoutPreguntasInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    capitulos?: capitulosCreateNestedOneWithoutTemasInput
  }

  export type temasUncheckedCreateWithoutPreguntasInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    capituloId?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type temasCreateOrConnectWithoutPreguntasInput = {
    where: temasWhereUniqueInput
    create: XOR<temasCreateWithoutPreguntasInput, temasUncheckedCreateWithoutPreguntasInput>
  }

  export type reaccionesPreguntasUpsertWithWhereUniqueWithoutPreguntaInput = {
    where: reaccionesPreguntasWhereUniqueInput
    update: XOR<reaccionesPreguntasUpdateWithoutPreguntaInput, reaccionesPreguntasUncheckedUpdateWithoutPreguntaInput>
    create: XOR<reaccionesPreguntasCreateWithoutPreguntaInput, reaccionesPreguntasUncheckedCreateWithoutPreguntaInput>
  }

  export type reaccionesPreguntasUpdateWithWhereUniqueWithoutPreguntaInput = {
    where: reaccionesPreguntasWhereUniqueInput
    data: XOR<reaccionesPreguntasUpdateWithoutPreguntaInput, reaccionesPreguntasUncheckedUpdateWithoutPreguntaInput>
  }

  export type reaccionesPreguntasUpdateManyWithWhereWithoutPreguntaInput = {
    where: reaccionesPreguntasScalarWhereInput
    data: XOR<reaccionesPreguntasUpdateManyMutationInput, reaccionesPreguntasUncheckedUpdateManyWithoutPreguntaInput>
  }

  export type reaccionesPreguntasScalarWhereInput = {
    AND?: reaccionesPreguntasScalarWhereInput | reaccionesPreguntasScalarWhereInput[]
    OR?: reaccionesPreguntasScalarWhereInput[]
    NOT?: reaccionesPreguntasScalarWhereInput | reaccionesPreguntasScalarWhereInput[]
    id?: StringFilter<"reaccionesPreguntas"> | string
    preguntaId?: StringFilter<"reaccionesPreguntas"> | string
    usuarioEstudianteId?: StringFilter<"reaccionesPreguntas"> | string
    tipo?: EnumTipoReaccionFilter<"reaccionesPreguntas"> | $Enums.TipoReaccion
    creadoEn?: DateTimeFilter<"reaccionesPreguntas"> | Date | string
    actualizadoEn?: DateTimeFilter<"reaccionesPreguntas"> | Date | string
  }

  export type repasoRegistrosUpsertWithWhereUniqueWithoutPreguntasInput = {
    where: repasoRegistrosWhereUniqueInput
    update: XOR<repasoRegistrosUpdateWithoutPreguntasInput, repasoRegistrosUncheckedUpdateWithoutPreguntasInput>
    create: XOR<repasoRegistrosCreateWithoutPreguntasInput, repasoRegistrosUncheckedCreateWithoutPreguntasInput>
  }

  export type repasoRegistrosUpdateWithWhereUniqueWithoutPreguntasInput = {
    where: repasoRegistrosWhereUniqueInput
    data: XOR<repasoRegistrosUpdateWithoutPreguntasInput, repasoRegistrosUncheckedUpdateWithoutPreguntasInput>
  }

  export type repasoRegistrosUpdateManyWithWhereWithoutPreguntasInput = {
    where: repasoRegistrosScalarWhereInput
    data: XOR<repasoRegistrosUpdateManyMutationInput, repasoRegistrosUncheckedUpdateManyWithoutPreguntasInput>
  }

  export type repasoRegistrosScalarWhereInput = {
    AND?: repasoRegistrosScalarWhereInput | repasoRegistrosScalarWhereInput[]
    OR?: repasoRegistrosScalarWhereInput[]
    NOT?: repasoRegistrosScalarWhereInput | repasoRegistrosScalarWhereInput[]
    id?: StringFilter<"repasoRegistros"> | string
    usuarioEstudianteId?: StringFilter<"repasoRegistros"> | string
    banqueoId?: StringFilter<"repasoRegistros"> | string
    preguntaId?: StringFilter<"repasoRegistros"> | string
    esCorrecta?: BoolFilter<"repasoRegistros"> | boolean
    creadoEn?: DateTimeFilter<"repasoRegistros"> | Date | string
  }

  export type respuestasIntentosUpsertWithWhereUniqueWithoutPreguntasInput = {
    where: respuestasIntentosWhereUniqueInput
    update: XOR<respuestasIntentosUpdateWithoutPreguntasInput, respuestasIntentosUncheckedUpdateWithoutPreguntasInput>
    create: XOR<respuestasIntentosCreateWithoutPreguntasInput, respuestasIntentosUncheckedCreateWithoutPreguntasInput>
  }

  export type respuestasIntentosUpdateWithWhereUniqueWithoutPreguntasInput = {
    where: respuestasIntentosWhereUniqueInput
    data: XOR<respuestasIntentosUpdateWithoutPreguntasInput, respuestasIntentosUncheckedUpdateWithoutPreguntasInput>
  }

  export type respuestasIntentosUpdateManyWithWhereWithoutPreguntasInput = {
    where: respuestasIntentosScalarWhereInput
    data: XOR<respuestasIntentosUpdateManyMutationInput, respuestasIntentosUncheckedUpdateManyWithoutPreguntasInput>
  }

  export type respuestasIntentosScalarWhereInput = {
    AND?: respuestasIntentosScalarWhereInput | respuestasIntentosScalarWhereInput[]
    OR?: respuestasIntentosScalarWhereInput[]
    NOT?: respuestasIntentosScalarWhereInput | respuestasIntentosScalarWhereInput[]
    id?: StringFilter<"respuestasIntentos"> | string
    intentoId?: StringFilter<"respuestasIntentos"> | string
    preguntaId?: StringFilter<"respuestasIntentos"> | string
    respuesta?: JsonNullableFilter<"respuestasIntentos">
    resultado?: EnumResultadoRespuestaFilter<"respuestasIntentos"> | $Enums.ResultadoRespuesta
    esCorrecta?: BoolNullableFilter<"respuestasIntentos"> | boolean | null
    respondida?: BoolFilter<"respuestasIntentos"> | boolean
    visitada?: BoolFilter<"respuestasIntentos"> | boolean
    marcadaRevision?: BoolFilter<"respuestasIntentos"> | boolean
    tiempoConsumidoSeg?: IntFilter<"respuestasIntentos"> | number
    orden?: IntNullableFilter<"respuestasIntentos"> | number | null
    respondidaEn?: DateTimeNullableFilter<"respuestasIntentos"> | Date | string | null
    creadoEn?: DateTimeFilter<"respuestasIntentos"> | Date | string
    actualizadoEn?: DateTimeFilter<"respuestasIntentos"> | Date | string
  }

  export type areasUpsertWithWhereUniqueWithoutPreguntasInput = {
    where: areasWhereUniqueInput
    update: XOR<areasUpdateWithoutPreguntasInput, areasUncheckedUpdateWithoutPreguntasInput>
    create: XOR<areasCreateWithoutPreguntasInput, areasUncheckedCreateWithoutPreguntasInput>
  }

  export type areasUpdateWithWhereUniqueWithoutPreguntasInput = {
    where: areasWhereUniqueInput
    data: XOR<areasUpdateWithoutPreguntasInput, areasUncheckedUpdateWithoutPreguntasInput>
  }

  export type areasUpdateManyWithWhereWithoutPreguntasInput = {
    where: areasScalarWhereInput
    data: XOR<areasUpdateManyMutationInput, areasUncheckedUpdateManyWithoutPreguntasInput>
  }

  export type areasScalarWhereInput = {
    AND?: areasScalarWhereInput | areasScalarWhereInput[]
    OR?: areasScalarWhereInput[]
    NOT?: areasScalarWhereInput | areasScalarWhereInput[]
    id?: StringFilter<"areas"> | string
    titulo?: StringFilter<"areas"> | string
    descripcion?: StringNullableFilter<"areas"> | string | null
    creadoEn?: DateTimeFilter<"areas"> | Date | string
    actualizadoEn?: DateTimeFilter<"areas"> | Date | string
  }

  export type banqueoUpsertWithWhereUniqueWithoutPreguntasInput = {
    where: banqueoWhereUniqueInput
    update: XOR<banqueoUpdateWithoutPreguntasInput, banqueoUncheckedUpdateWithoutPreguntasInput>
    create: XOR<banqueoCreateWithoutPreguntasInput, banqueoUncheckedCreateWithoutPreguntasInput>
  }

  export type banqueoUpdateWithWhereUniqueWithoutPreguntasInput = {
    where: banqueoWhereUniqueInput
    data: XOR<banqueoUpdateWithoutPreguntasInput, banqueoUncheckedUpdateWithoutPreguntasInput>
  }

  export type banqueoUpdateManyWithWhereWithoutPreguntasInput = {
    where: banqueoScalarWhereInput
    data: XOR<banqueoUpdateManyMutationInput, banqueoUncheckedUpdateManyWithoutPreguntasInput>
  }

  export type banqueoScalarWhereInput = {
    AND?: banqueoScalarWhereInput | banqueoScalarWhereInput[]
    OR?: banqueoScalarWhereInput[]
    NOT?: banqueoScalarWhereInput | banqueoScalarWhereInput[]
    id?: StringFilter<"banqueo"> | string
    titulo?: StringFilter<"banqueo"> | string
    tipo?: EnumBanqueoTipoFilter<"banqueo"> | $Enums.BanqueoTipo
    tipoCreado?: EnumBanqueoTipoCreadoFilter<"banqueo"> | $Enums.BanqueoTipoCreado
    duracion?: IntFilter<"banqueo"> | number
    maxPreguntas?: IntFilter<"banqueo"> | number
    creadoEn?: DateTimeFilter<"banqueo"> | Date | string
    actualizadoEn?: DateTimeFilter<"banqueo"> | Date | string
  }

  export type capitulosUpsertWithWhereUniqueWithoutPreguntasInput = {
    where: capitulosWhereUniqueInput
    update: XOR<capitulosUpdateWithoutPreguntasInput, capitulosUncheckedUpdateWithoutPreguntasInput>
    create: XOR<capitulosCreateWithoutPreguntasInput, capitulosUncheckedCreateWithoutPreguntasInput>
  }

  export type capitulosUpdateWithWhereUniqueWithoutPreguntasInput = {
    where: capitulosWhereUniqueInput
    data: XOR<capitulosUpdateWithoutPreguntasInput, capitulosUncheckedUpdateWithoutPreguntasInput>
  }

  export type capitulosUpdateManyWithWhereWithoutPreguntasInput = {
    where: capitulosScalarWhereInput
    data: XOR<capitulosUpdateManyMutationInput, capitulosUncheckedUpdateManyWithoutPreguntasInput>
  }

  export type capitulosScalarWhereInput = {
    AND?: capitulosScalarWhereInput | capitulosScalarWhereInput[]
    OR?: capitulosScalarWhereInput[]
    NOT?: capitulosScalarWhereInput | capitulosScalarWhereInput[]
    id?: StringFilter<"capitulos"> | string
    titulo?: StringFilter<"capitulos"> | string
    descripcion?: StringNullableFilter<"capitulos"> | string | null
    areaId?: StringNullableFilter<"capitulos"> | string | null
    creadoEn?: DateTimeFilter<"capitulos"> | Date | string
    actualizadoEn?: DateTimeFilter<"capitulos"> | Date | string
  }

  export type temasUpsertWithWhereUniqueWithoutPreguntasInput = {
    where: temasWhereUniqueInput
    update: XOR<temasUpdateWithoutPreguntasInput, temasUncheckedUpdateWithoutPreguntasInput>
    create: XOR<temasCreateWithoutPreguntasInput, temasUncheckedCreateWithoutPreguntasInput>
  }

  export type temasUpdateWithWhereUniqueWithoutPreguntasInput = {
    where: temasWhereUniqueInput
    data: XOR<temasUpdateWithoutPreguntasInput, temasUncheckedUpdateWithoutPreguntasInput>
  }

  export type temasUpdateManyWithWhereWithoutPreguntasInput = {
    where: temasScalarWhereInput
    data: XOR<temasUpdateManyMutationInput, temasUncheckedUpdateManyWithoutPreguntasInput>
  }

  export type temasScalarWhereInput = {
    AND?: temasScalarWhereInput | temasScalarWhereInput[]
    OR?: temasScalarWhereInput[]
    NOT?: temasScalarWhereInput | temasScalarWhereInput[]
    id?: StringFilter<"temas"> | string
    titulo?: StringFilter<"temas"> | string
    descripcion?: StringNullableFilter<"temas"> | string | null
    capituloId?: StringNullableFilter<"temas"> | string | null
    creadoEn?: DateTimeFilter<"temas"> | Date | string
    actualizadoEn?: DateTimeFilter<"temas"> | Date | string
  }

  export type preguntasCreateWithoutReaccionesPreguntasInput = {
    id?: string
    codigo: string
    enunciado: string
    explicacion?: string | null
    referencia?: string | null
    opciones: JsonNullValueInput | InputJsonValue
    solucion: JsonNullValueInput | InputJsonValue
    estado?: $Enums.PreguntaEstado
    gestion: number
    likes?: number
    dislikes?: number
    dificultad?: $Enums.PreguntaDificultad
    dificultadActualizadaEn?: Date | string | null
    tasaAcierto?: number
    totalBien?: number
    totalMal?: number
    totalRespondidas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    repasoRegistros?: repasoRegistrosCreateNestedManyWithoutPreguntasInput
    respuestasIntentos?: respuestasIntentosCreateNestedManyWithoutPreguntasInput
    areas?: areasCreateNestedManyWithoutPreguntasInput
    banqueo?: banqueoCreateNestedManyWithoutPreguntasInput
    capitulos?: capitulosCreateNestedManyWithoutPreguntasInput
    temas?: temasCreateNestedManyWithoutPreguntasInput
  }

  export type preguntasUncheckedCreateWithoutReaccionesPreguntasInput = {
    id?: string
    codigo: string
    enunciado: string
    explicacion?: string | null
    referencia?: string | null
    opciones: JsonNullValueInput | InputJsonValue
    solucion: JsonNullValueInput | InputJsonValue
    estado?: $Enums.PreguntaEstado
    gestion: number
    likes?: number
    dislikes?: number
    dificultad?: $Enums.PreguntaDificultad
    dificultadActualizadaEn?: Date | string | null
    tasaAcierto?: number
    totalBien?: number
    totalMal?: number
    totalRespondidas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    repasoRegistros?: repasoRegistrosUncheckedCreateNestedManyWithoutPreguntasInput
    respuestasIntentos?: respuestasIntentosUncheckedCreateNestedManyWithoutPreguntasInput
    areas?: areasUncheckedCreateNestedManyWithoutPreguntasInput
    banqueo?: banqueoUncheckedCreateNestedManyWithoutPreguntasInput
    capitulos?: capitulosUncheckedCreateNestedManyWithoutPreguntasInput
    temas?: temasUncheckedCreateNestedManyWithoutPreguntasInput
  }

  export type preguntasCreateOrConnectWithoutReaccionesPreguntasInput = {
    where: preguntasWhereUniqueInput
    create: XOR<preguntasCreateWithoutReaccionesPreguntasInput, preguntasUncheckedCreateWithoutReaccionesPreguntasInput>
  }

  export type usuariosEstudiantesCreateWithoutReaccionesPreguntasInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    avatar?: string | null
    registrado?: boolean
    compras?: comprasCreateNestedManyWithoutUsuariosEstudiantesInput
    intentos?: intentosCreateNestedManyWithoutUsuariosEstudiantesInput
    repasoRegistros?: repasoRegistrosCreateNestedManyWithoutUsuariosEstudiantesInput
    reviewsCursos?: reviewsCursosCreateNestedManyWithoutUsuariosEstudiantesInput
    suscripciones?: suscripcionesCreateNestedManyWithoutUsuariosEstudiantesInput
    estudiantes?: estudiantesCreateNestedOneWithoutUsuariosEstudiantesInput
  }

  export type usuariosEstudiantesUncheckedCreateWithoutReaccionesPreguntasInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    avatar?: string | null
    estudianteId?: string | null
    registrado?: boolean
    compras?: comprasUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    intentos?: intentosUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    repasoRegistros?: repasoRegistrosUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    reviewsCursos?: reviewsCursosUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    suscripciones?: suscripcionesUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
  }

  export type usuariosEstudiantesCreateOrConnectWithoutReaccionesPreguntasInput = {
    where: usuariosEstudiantesWhereUniqueInput
    create: XOR<usuariosEstudiantesCreateWithoutReaccionesPreguntasInput, usuariosEstudiantesUncheckedCreateWithoutReaccionesPreguntasInput>
  }

  export type preguntasUpsertWithoutReaccionesPreguntasInput = {
    update: XOR<preguntasUpdateWithoutReaccionesPreguntasInput, preguntasUncheckedUpdateWithoutReaccionesPreguntasInput>
    create: XOR<preguntasCreateWithoutReaccionesPreguntasInput, preguntasUncheckedCreateWithoutReaccionesPreguntasInput>
    where?: preguntasWhereInput
  }

  export type preguntasUpdateToOneWithWhereWithoutReaccionesPreguntasInput = {
    where?: preguntasWhereInput
    data: XOR<preguntasUpdateWithoutReaccionesPreguntasInput, preguntasUncheckedUpdateWithoutReaccionesPreguntasInput>
  }

  export type preguntasUpdateWithoutReaccionesPreguntasInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    enunciado?: StringFieldUpdateOperationsInput | string
    explicacion?: NullableStringFieldUpdateOperationsInput | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    opciones?: JsonNullValueInput | InputJsonValue
    solucion?: JsonNullValueInput | InputJsonValue
    estado?: EnumPreguntaEstadoFieldUpdateOperationsInput | $Enums.PreguntaEstado
    gestion?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumPreguntaDificultadFieldUpdateOperationsInput | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasaAcierto?: IntFieldUpdateOperationsInput | number
    totalBien?: IntFieldUpdateOperationsInput | number
    totalMal?: IntFieldUpdateOperationsInput | number
    totalRespondidas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    repasoRegistros?: repasoRegistrosUpdateManyWithoutPreguntasNestedInput
    respuestasIntentos?: respuestasIntentosUpdateManyWithoutPreguntasNestedInput
    areas?: areasUpdateManyWithoutPreguntasNestedInput
    banqueo?: banqueoUpdateManyWithoutPreguntasNestedInput
    capitulos?: capitulosUpdateManyWithoutPreguntasNestedInput
    temas?: temasUpdateManyWithoutPreguntasNestedInput
  }

  export type preguntasUncheckedUpdateWithoutReaccionesPreguntasInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    enunciado?: StringFieldUpdateOperationsInput | string
    explicacion?: NullableStringFieldUpdateOperationsInput | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    opciones?: JsonNullValueInput | InputJsonValue
    solucion?: JsonNullValueInput | InputJsonValue
    estado?: EnumPreguntaEstadoFieldUpdateOperationsInput | $Enums.PreguntaEstado
    gestion?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumPreguntaDificultadFieldUpdateOperationsInput | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasaAcierto?: IntFieldUpdateOperationsInput | number
    totalBien?: IntFieldUpdateOperationsInput | number
    totalMal?: IntFieldUpdateOperationsInput | number
    totalRespondidas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    repasoRegistros?: repasoRegistrosUncheckedUpdateManyWithoutPreguntasNestedInput
    respuestasIntentos?: respuestasIntentosUncheckedUpdateManyWithoutPreguntasNestedInput
    areas?: areasUncheckedUpdateManyWithoutPreguntasNestedInput
    banqueo?: banqueoUncheckedUpdateManyWithoutPreguntasNestedInput
    capitulos?: capitulosUncheckedUpdateManyWithoutPreguntasNestedInput
    temas?: temasUncheckedUpdateManyWithoutPreguntasNestedInput
  }

  export type usuariosEstudiantesUpsertWithoutReaccionesPreguntasInput = {
    update: XOR<usuariosEstudiantesUpdateWithoutReaccionesPreguntasInput, usuariosEstudiantesUncheckedUpdateWithoutReaccionesPreguntasInput>
    create: XOR<usuariosEstudiantesCreateWithoutReaccionesPreguntasInput, usuariosEstudiantesUncheckedCreateWithoutReaccionesPreguntasInput>
    where?: usuariosEstudiantesWhereInput
  }

  export type usuariosEstudiantesUpdateToOneWithWhereWithoutReaccionesPreguntasInput = {
    where?: usuariosEstudiantesWhereInput
    data: XOR<usuariosEstudiantesUpdateWithoutReaccionesPreguntasInput, usuariosEstudiantesUncheckedUpdateWithoutReaccionesPreguntasInput>
  }

  export type usuariosEstudiantesUpdateWithoutReaccionesPreguntasInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
    compras?: comprasUpdateManyWithoutUsuariosEstudiantesNestedInput
    intentos?: intentosUpdateManyWithoutUsuariosEstudiantesNestedInput
    repasoRegistros?: repasoRegistrosUpdateManyWithoutUsuariosEstudiantesNestedInput
    reviewsCursos?: reviewsCursosUpdateManyWithoutUsuariosEstudiantesNestedInput
    suscripciones?: suscripcionesUpdateManyWithoutUsuariosEstudiantesNestedInput
    estudiantes?: estudiantesUpdateOneWithoutUsuariosEstudiantesNestedInput
  }

  export type usuariosEstudiantesUncheckedUpdateWithoutReaccionesPreguntasInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
    compras?: comprasUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    intentos?: intentosUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    repasoRegistros?: repasoRegistrosUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    reviewsCursos?: reviewsCursosUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    suscripciones?: suscripcionesUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
  }

  export type cursosCreateWithoutRequisitosCursosInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    cargaHoraria?: number
    codigo: string
    beneficiosCursos?: beneficiosCursosCreateNestedManyWithoutCursosInput
    categoriasCursos?: categoriasCursosCreateNestedManyWithoutCursosInput
    edicionesCursos?: edicionesCursosCreateNestedManyWithoutCursosInput
    objetivosCursos?: objetivosCursosCreateNestedManyWithoutCursosInput
    reviewsCursos?: reviewsCursosCreateNestedManyWithoutCursosInput
  }

  export type cursosUncheckedCreateWithoutRequisitosCursosInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    cargaHoraria?: number
    codigo: string
    beneficiosCursos?: beneficiosCursosUncheckedCreateNestedManyWithoutCursosInput
    categoriasCursos?: categoriasCursosUncheckedCreateNestedManyWithoutCursosInput
    edicionesCursos?: edicionesCursosUncheckedCreateNestedManyWithoutCursosInput
    objetivosCursos?: objetivosCursosUncheckedCreateNestedManyWithoutCursosInput
    reviewsCursos?: reviewsCursosUncheckedCreateNestedManyWithoutCursosInput
  }

  export type cursosCreateOrConnectWithoutRequisitosCursosInput = {
    where: cursosWhereUniqueInput
    create: XOR<cursosCreateWithoutRequisitosCursosInput, cursosUncheckedCreateWithoutRequisitosCursosInput>
  }

  export type cursosUpsertWithoutRequisitosCursosInput = {
    update: XOR<cursosUpdateWithoutRequisitosCursosInput, cursosUncheckedUpdateWithoutRequisitosCursosInput>
    create: XOR<cursosCreateWithoutRequisitosCursosInput, cursosUncheckedCreateWithoutRequisitosCursosInput>
    where?: cursosWhereInput
  }

  export type cursosUpdateToOneWithWhereWithoutRequisitosCursosInput = {
    where?: cursosWhereInput
    data: XOR<cursosUpdateWithoutRequisitosCursosInput, cursosUncheckedUpdateWithoutRequisitosCursosInput>
  }

  export type cursosUpdateWithoutRequisitosCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    cargaHoraria?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    beneficiosCursos?: beneficiosCursosUpdateManyWithoutCursosNestedInput
    categoriasCursos?: categoriasCursosUpdateManyWithoutCursosNestedInput
    edicionesCursos?: edicionesCursosUpdateManyWithoutCursosNestedInput
    objetivosCursos?: objetivosCursosUpdateManyWithoutCursosNestedInput
    reviewsCursos?: reviewsCursosUpdateManyWithoutCursosNestedInput
  }

  export type cursosUncheckedUpdateWithoutRequisitosCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    cargaHoraria?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    beneficiosCursos?: beneficiosCursosUncheckedUpdateManyWithoutCursosNestedInput
    categoriasCursos?: categoriasCursosUncheckedUpdateManyWithoutCursosNestedInput
    edicionesCursos?: edicionesCursosUncheckedUpdateManyWithoutCursosNestedInput
    objetivosCursos?: objetivosCursosUncheckedUpdateManyWithoutCursosNestedInput
    reviewsCursos?: reviewsCursosUncheckedUpdateManyWithoutCursosNestedInput
  }

  export type cursosCreateWithoutReviewsCursosInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    cargaHoraria?: number
    codigo: string
    beneficiosCursos?: beneficiosCursosCreateNestedManyWithoutCursosInput
    categoriasCursos?: categoriasCursosCreateNestedManyWithoutCursosInput
    edicionesCursos?: edicionesCursosCreateNestedManyWithoutCursosInput
    objetivosCursos?: objetivosCursosCreateNestedManyWithoutCursosInput
    requisitosCursos?: requisitosCursosCreateNestedManyWithoutCursosInput
  }

  export type cursosUncheckedCreateWithoutReviewsCursosInput = {
    id?: string
    descripcion: string
    titulo: string
    urlMiniatura?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    descripcionCorta?: string | null
    enVivo?: boolean
    urlCurso?: string | null
    cargaHoraria?: number
    codigo: string
    beneficiosCursos?: beneficiosCursosUncheckedCreateNestedManyWithoutCursosInput
    categoriasCursos?: categoriasCursosUncheckedCreateNestedManyWithoutCursosInput
    edicionesCursos?: edicionesCursosUncheckedCreateNestedManyWithoutCursosInput
    objetivosCursos?: objetivosCursosUncheckedCreateNestedManyWithoutCursosInput
    requisitosCursos?: requisitosCursosUncheckedCreateNestedManyWithoutCursosInput
  }

  export type cursosCreateOrConnectWithoutReviewsCursosInput = {
    where: cursosWhereUniqueInput
    create: XOR<cursosCreateWithoutReviewsCursosInput, cursosUncheckedCreateWithoutReviewsCursosInput>
  }

  export type usuariosEstudiantesCreateWithoutReviewsCursosInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    avatar?: string | null
    registrado?: boolean
    compras?: comprasCreateNestedManyWithoutUsuariosEstudiantesInput
    intentos?: intentosCreateNestedManyWithoutUsuariosEstudiantesInput
    reaccionesPreguntas?: reaccionesPreguntasCreateNestedManyWithoutUsuariosEstudiantesInput
    repasoRegistros?: repasoRegistrosCreateNestedManyWithoutUsuariosEstudiantesInput
    suscripciones?: suscripcionesCreateNestedManyWithoutUsuariosEstudiantesInput
    estudiantes?: estudiantesCreateNestedOneWithoutUsuariosEstudiantesInput
  }

  export type usuariosEstudiantesUncheckedCreateWithoutReviewsCursosInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    avatar?: string | null
    estudianteId?: string | null
    registrado?: boolean
    compras?: comprasUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    intentos?: intentosUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    reaccionesPreguntas?: reaccionesPreguntasUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    repasoRegistros?: repasoRegistrosUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    suscripciones?: suscripcionesUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
  }

  export type usuariosEstudiantesCreateOrConnectWithoutReviewsCursosInput = {
    where: usuariosEstudiantesWhereUniqueInput
    create: XOR<usuariosEstudiantesCreateWithoutReviewsCursosInput, usuariosEstudiantesUncheckedCreateWithoutReviewsCursosInput>
  }

  export type cursosUpsertWithoutReviewsCursosInput = {
    update: XOR<cursosUpdateWithoutReviewsCursosInput, cursosUncheckedUpdateWithoutReviewsCursosInput>
    create: XOR<cursosCreateWithoutReviewsCursosInput, cursosUncheckedCreateWithoutReviewsCursosInput>
    where?: cursosWhereInput
  }

  export type cursosUpdateToOneWithWhereWithoutReviewsCursosInput = {
    where?: cursosWhereInput
    data: XOR<cursosUpdateWithoutReviewsCursosInput, cursosUncheckedUpdateWithoutReviewsCursosInput>
  }

  export type cursosUpdateWithoutReviewsCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    cargaHoraria?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    beneficiosCursos?: beneficiosCursosUpdateManyWithoutCursosNestedInput
    categoriasCursos?: categoriasCursosUpdateManyWithoutCursosNestedInput
    edicionesCursos?: edicionesCursosUpdateManyWithoutCursosNestedInput
    objetivosCursos?: objetivosCursosUpdateManyWithoutCursosNestedInput
    requisitosCursos?: requisitosCursosUpdateManyWithoutCursosNestedInput
  }

  export type cursosUncheckedUpdateWithoutReviewsCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    urlMiniatura?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcionCorta?: NullableStringFieldUpdateOperationsInput | string | null
    enVivo?: BoolFieldUpdateOperationsInput | boolean
    urlCurso?: NullableStringFieldUpdateOperationsInput | string | null
    cargaHoraria?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    beneficiosCursos?: beneficiosCursosUncheckedUpdateManyWithoutCursosNestedInput
    categoriasCursos?: categoriasCursosUncheckedUpdateManyWithoutCursosNestedInput
    edicionesCursos?: edicionesCursosUncheckedUpdateManyWithoutCursosNestedInput
    objetivosCursos?: objetivosCursosUncheckedUpdateManyWithoutCursosNestedInput
    requisitosCursos?: requisitosCursosUncheckedUpdateManyWithoutCursosNestedInput
  }

  export type usuariosEstudiantesUpsertWithoutReviewsCursosInput = {
    update: XOR<usuariosEstudiantesUpdateWithoutReviewsCursosInput, usuariosEstudiantesUncheckedUpdateWithoutReviewsCursosInput>
    create: XOR<usuariosEstudiantesCreateWithoutReviewsCursosInput, usuariosEstudiantesUncheckedCreateWithoutReviewsCursosInput>
    where?: usuariosEstudiantesWhereInput
  }

  export type usuariosEstudiantesUpdateToOneWithWhereWithoutReviewsCursosInput = {
    where?: usuariosEstudiantesWhereInput
    data: XOR<usuariosEstudiantesUpdateWithoutReviewsCursosInput, usuariosEstudiantesUncheckedUpdateWithoutReviewsCursosInput>
  }

  export type usuariosEstudiantesUpdateWithoutReviewsCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
    compras?: comprasUpdateManyWithoutUsuariosEstudiantesNestedInput
    intentos?: intentosUpdateManyWithoutUsuariosEstudiantesNestedInput
    reaccionesPreguntas?: reaccionesPreguntasUpdateManyWithoutUsuariosEstudiantesNestedInput
    repasoRegistros?: repasoRegistrosUpdateManyWithoutUsuariosEstudiantesNestedInput
    suscripciones?: suscripcionesUpdateManyWithoutUsuariosEstudiantesNestedInput
    estudiantes?: estudiantesUpdateOneWithoutUsuariosEstudiantesNestedInput
  }

  export type usuariosEstudiantesUncheckedUpdateWithoutReviewsCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
    compras?: comprasUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    intentos?: intentosUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    reaccionesPreguntas?: reaccionesPreguntasUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    repasoRegistros?: repasoRegistrosUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    suscripciones?: suscripcionesUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
  }

  export type auditoriaCreateWithoutUsuariosAdministradoresInput = {
    id?: string
    tabla: $Enums.Tabla
    registroId?: string | null
    accion: $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    creadoEn?: Date | string
  }

  export type auditoriaUncheckedCreateWithoutUsuariosAdministradoresInput = {
    id?: string
    tabla: $Enums.Tabla
    registroId?: string | null
    accion: $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    creadoEn?: Date | string
  }

  export type auditoriaCreateOrConnectWithoutUsuariosAdministradoresInput = {
    where: auditoriaWhereUniqueInput
    create: XOR<auditoriaCreateWithoutUsuariosAdministradoresInput, auditoriaUncheckedCreateWithoutUsuariosAdministradoresInput>
  }

  export type auditoriaCreateManyUsuariosAdministradoresInputEnvelope = {
    data: auditoriaCreateManyUsuariosAdministradoresInput | auditoriaCreateManyUsuariosAdministradoresInput[]
    skipDuplicates?: boolean
  }

  export type docenteCreateWithoutUsuariosAdministradoresInput = {
    id?: string
    nombre_completo: string
    celular?: string | null
    especialidad: string
    experiencia?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    pais?: string
    edicionesCursos?: edicionesCursosCreateNestedManyWithoutDocenteInput
    pagosDocentes?: pagosDocentesCreateNestedManyWithoutDocenteInput
  }

  export type docenteUncheckedCreateWithoutUsuariosAdministradoresInput = {
    id?: string
    nombre_completo: string
    celular?: string | null
    especialidad: string
    experiencia?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    pais?: string
    edicionesCursos?: edicionesCursosUncheckedCreateNestedManyWithoutDocenteInput
    pagosDocentes?: pagosDocentesUncheckedCreateNestedManyWithoutDocenteInput
  }

  export type docenteCreateOrConnectWithoutUsuariosAdministradoresInput = {
    where: docenteWhereUniqueInput
    create: XOR<docenteCreateWithoutUsuariosAdministradoresInput, docenteUncheckedCreateWithoutUsuariosAdministradoresInput>
  }

  export type grabacionesCreateWithoutUsuariosAdministradoresInput = {
    id?: string
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    duracionSegundos?: number | null
    completada?: boolean
    clases: clasesCreateNestedOneWithoutGrabacionesInput
  }

  export type grabacionesUncheckedCreateWithoutUsuariosAdministradoresInput = {
    id?: string
    claseId: string
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    duracionSegundos?: number | null
    completada?: boolean
  }

  export type grabacionesCreateOrConnectWithoutUsuariosAdministradoresInput = {
    where: grabacionesWhereUniqueInput
    create: XOR<grabacionesCreateWithoutUsuariosAdministradoresInput, grabacionesUncheckedCreateWithoutUsuariosAdministradoresInput>
  }

  export type grabacionesCreateManyUsuariosAdministradoresInputEnvelope = {
    data: grabacionesCreateManyUsuariosAdministradoresInput | grabacionesCreateManyUsuariosAdministradoresInput[]
    skipDuplicates?: boolean
  }

  export type auditoriaUpsertWithWhereUniqueWithoutUsuariosAdministradoresInput = {
    where: auditoriaWhereUniqueInput
    update: XOR<auditoriaUpdateWithoutUsuariosAdministradoresInput, auditoriaUncheckedUpdateWithoutUsuariosAdministradoresInput>
    create: XOR<auditoriaCreateWithoutUsuariosAdministradoresInput, auditoriaUncheckedCreateWithoutUsuariosAdministradoresInput>
  }

  export type auditoriaUpdateWithWhereUniqueWithoutUsuariosAdministradoresInput = {
    where: auditoriaWhereUniqueInput
    data: XOR<auditoriaUpdateWithoutUsuariosAdministradoresInput, auditoriaUncheckedUpdateWithoutUsuariosAdministradoresInput>
  }

  export type auditoriaUpdateManyWithWhereWithoutUsuariosAdministradoresInput = {
    where: auditoriaScalarWhereInput
    data: XOR<auditoriaUpdateManyMutationInput, auditoriaUncheckedUpdateManyWithoutUsuariosAdministradoresInput>
  }

  export type auditoriaScalarWhereInput = {
    AND?: auditoriaScalarWhereInput | auditoriaScalarWhereInput[]
    OR?: auditoriaScalarWhereInput[]
    NOT?: auditoriaScalarWhereInput | auditoriaScalarWhereInput[]
    id?: StringFilter<"auditoria"> | string
    tabla?: EnumTablaFilter<"auditoria"> | $Enums.Tabla
    registroId?: StringNullableFilter<"auditoria"> | string | null
    accion?: EnumAccionAuditoriaFilter<"auditoria"> | $Enums.AccionAuditoria
    detalles?: JsonNullableFilter<"auditoria">
    usuarioId?: StringFilter<"auditoria"> | string
    creadoEn?: DateTimeFilter<"auditoria"> | Date | string
  }

  export type docenteUpsertWithoutUsuariosAdministradoresInput = {
    update: XOR<docenteUpdateWithoutUsuariosAdministradoresInput, docenteUncheckedUpdateWithoutUsuariosAdministradoresInput>
    create: XOR<docenteCreateWithoutUsuariosAdministradoresInput, docenteUncheckedCreateWithoutUsuariosAdministradoresInput>
    where?: docenteWhereInput
  }

  export type docenteUpdateToOneWithWhereWithoutUsuariosAdministradoresInput = {
    where?: docenteWhereInput
    data: XOR<docenteUpdateWithoutUsuariosAdministradoresInput, docenteUncheckedUpdateWithoutUsuariosAdministradoresInput>
  }

  export type docenteUpdateWithoutUsuariosAdministradoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre_completo?: StringFieldUpdateOperationsInput | string
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    experiencia?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    pais?: StringFieldUpdateOperationsInput | string
    edicionesCursos?: edicionesCursosUpdateManyWithoutDocenteNestedInput
    pagosDocentes?: pagosDocentesUpdateManyWithoutDocenteNestedInput
  }

  export type docenteUncheckedUpdateWithoutUsuariosAdministradoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre_completo?: StringFieldUpdateOperationsInput | string
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    especialidad?: StringFieldUpdateOperationsInput | string
    experiencia?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    pais?: StringFieldUpdateOperationsInput | string
    edicionesCursos?: edicionesCursosUncheckedUpdateManyWithoutDocenteNestedInput
    pagosDocentes?: pagosDocentesUncheckedUpdateManyWithoutDocenteNestedInput
  }

  export type grabacionesUpsertWithWhereUniqueWithoutUsuariosAdministradoresInput = {
    where: grabacionesWhereUniqueInput
    update: XOR<grabacionesUpdateWithoutUsuariosAdministradoresInput, grabacionesUncheckedUpdateWithoutUsuariosAdministradoresInput>
    create: XOR<grabacionesCreateWithoutUsuariosAdministradoresInput, grabacionesUncheckedCreateWithoutUsuariosAdministradoresInput>
  }

  export type grabacionesUpdateWithWhereUniqueWithoutUsuariosAdministradoresInput = {
    where: grabacionesWhereUniqueInput
    data: XOR<grabacionesUpdateWithoutUsuariosAdministradoresInput, grabacionesUncheckedUpdateWithoutUsuariosAdministradoresInput>
  }

  export type grabacionesUpdateManyWithWhereWithoutUsuariosAdministradoresInput = {
    where: grabacionesScalarWhereInput
    data: XOR<grabacionesUpdateManyMutationInput, grabacionesUncheckedUpdateManyWithoutUsuariosAdministradoresInput>
  }

  export type comprasCreateWithoutUsuariosEstudiantesInput = {
    id?: string
    monto: number
    moneda?: string
    comprobado?: boolean
    providerId: string
    fechaCompra?: Date | string
    metodo?: $Enums.MetodoPago
    deuda?: number
    estadoPago?: $Enums.EstadoPago
    updatedAt: Date | string
    conDescuento?: boolean
    edicionesCursos: edicionesCursosCreateNestedOneWithoutComprasInput
    inscripciones?: inscripcionesCreateNestedOneWithoutComprasInput
  }

  export type comprasUncheckedCreateWithoutUsuariosEstudiantesInput = {
    id?: string
    edicionId: string
    monto: number
    moneda?: string
    comprobado?: boolean
    providerId: string
    fechaCompra?: Date | string
    metodo?: $Enums.MetodoPago
    deuda?: number
    estadoPago?: $Enums.EstadoPago
    updatedAt: Date | string
    conDescuento?: boolean
    inscripciones?: inscripcionesUncheckedCreateNestedOneWithoutComprasInput
  }

  export type comprasCreateOrConnectWithoutUsuariosEstudiantesInput = {
    where: comprasWhereUniqueInput
    create: XOR<comprasCreateWithoutUsuariosEstudiantesInput, comprasUncheckedCreateWithoutUsuariosEstudiantesInput>
  }

  export type comprasCreateManyUsuariosEstudiantesInputEnvelope = {
    data: comprasCreateManyUsuariosEstudiantesInput | comprasCreateManyUsuariosEstudiantesInput[]
    skipDuplicates?: boolean
  }

  export type intentosCreateWithoutUsuariosEstudiantesInput = {
    id?: string
    tiempoDuracion: number
    correctas?: number
    incorrectas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    estado?: $Enums.EstadoIntento
    banqueo: banqueoCreateNestedOneWithoutIntentosInput
    respuestasIntentos?: respuestasIntentosCreateNestedManyWithoutIntentosInput
  }

  export type intentosUncheckedCreateWithoutUsuariosEstudiantesInput = {
    id?: string
    banqueoId: string
    tiempoDuracion: number
    correctas?: number
    incorrectas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    estado?: $Enums.EstadoIntento
    respuestasIntentos?: respuestasIntentosUncheckedCreateNestedManyWithoutIntentosInput
  }

  export type intentosCreateOrConnectWithoutUsuariosEstudiantesInput = {
    where: intentosWhereUniqueInput
    create: XOR<intentosCreateWithoutUsuariosEstudiantesInput, intentosUncheckedCreateWithoutUsuariosEstudiantesInput>
  }

  export type intentosCreateManyUsuariosEstudiantesInputEnvelope = {
    data: intentosCreateManyUsuariosEstudiantesInput | intentosCreateManyUsuariosEstudiantesInput[]
    skipDuplicates?: boolean
  }

  export type reaccionesPreguntasCreateWithoutUsuariosEstudiantesInput = {
    id?: string
    tipo: $Enums.TipoReaccion
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    pregunta: preguntasCreateNestedOneWithoutReaccionesPreguntasInput
  }

  export type reaccionesPreguntasUncheckedCreateWithoutUsuariosEstudiantesInput = {
    id?: string
    preguntaId: string
    tipo: $Enums.TipoReaccion
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type reaccionesPreguntasCreateOrConnectWithoutUsuariosEstudiantesInput = {
    where: reaccionesPreguntasWhereUniqueInput
    create: XOR<reaccionesPreguntasCreateWithoutUsuariosEstudiantesInput, reaccionesPreguntasUncheckedCreateWithoutUsuariosEstudiantesInput>
  }

  export type reaccionesPreguntasCreateManyUsuariosEstudiantesInputEnvelope = {
    data: reaccionesPreguntasCreateManyUsuariosEstudiantesInput | reaccionesPreguntasCreateManyUsuariosEstudiantesInput[]
    skipDuplicates?: boolean
  }

  export type repasoRegistrosCreateWithoutUsuariosEstudiantesInput = {
    id?: string
    esCorrecta: boolean
    creadoEn?: Date | string
    banqueo: banqueoCreateNestedOneWithoutRepasoRegistrosInput
    preguntas: preguntasCreateNestedOneWithoutRepasoRegistrosInput
  }

  export type repasoRegistrosUncheckedCreateWithoutUsuariosEstudiantesInput = {
    id?: string
    banqueoId: string
    preguntaId: string
    esCorrecta: boolean
    creadoEn?: Date | string
  }

  export type repasoRegistrosCreateOrConnectWithoutUsuariosEstudiantesInput = {
    where: repasoRegistrosWhereUniqueInput
    create: XOR<repasoRegistrosCreateWithoutUsuariosEstudiantesInput, repasoRegistrosUncheckedCreateWithoutUsuariosEstudiantesInput>
  }

  export type repasoRegistrosCreateManyUsuariosEstudiantesInputEnvelope = {
    data: repasoRegistrosCreateManyUsuariosEstudiantesInput | repasoRegistrosCreateManyUsuariosEstudiantesInput[]
    skipDuplicates?: boolean
  }

  export type reviewsCursosCreateWithoutUsuariosEstudiantesInput = {
    id?: string
    rating: number
    comentario?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    cursos: cursosCreateNestedOneWithoutReviewsCursosInput
  }

  export type reviewsCursosUncheckedCreateWithoutUsuariosEstudiantesInput = {
    id?: string
    cursoId: string
    rating: number
    comentario?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type reviewsCursosCreateOrConnectWithoutUsuariosEstudiantesInput = {
    where: reviewsCursosWhereUniqueInput
    create: XOR<reviewsCursosCreateWithoutUsuariosEstudiantesInput, reviewsCursosUncheckedCreateWithoutUsuariosEstudiantesInput>
  }

  export type reviewsCursosCreateManyUsuariosEstudiantesInputEnvelope = {
    data: reviewsCursosCreateManyUsuariosEstudiantesInput | reviewsCursosCreateManyUsuariosEstudiantesInput[]
    skipDuplicates?: boolean
  }

  export type suscripcionesCreateWithoutUsuariosEstudiantesInput = {
    id?: string
    montoUsd: number
    fechaInicio?: Date | string
    fechaFin: Date | string
    estado?: $Enums.EstadoSuscripcion
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type suscripcionesUncheckedCreateWithoutUsuariosEstudiantesInput = {
    id?: string
    montoUsd: number
    fechaInicio?: Date | string
    fechaFin: Date | string
    estado?: $Enums.EstadoSuscripcion
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type suscripcionesCreateOrConnectWithoutUsuariosEstudiantesInput = {
    where: suscripcionesWhereUniqueInput
    create: XOR<suscripcionesCreateWithoutUsuariosEstudiantesInput, suscripcionesUncheckedCreateWithoutUsuariosEstudiantesInput>
  }

  export type suscripcionesCreateManyUsuariosEstudiantesInputEnvelope = {
    data: suscripcionesCreateManyUsuariosEstudiantesInput | suscripcionesCreateManyUsuariosEstudiantesInput[]
    skipDuplicates?: boolean
  }

  export type estudiantesCreateWithoutUsuariosEstudiantesInput = {
    id?: string
    apellido?: string | null
    celular?: string | null
    pais?: string
    genero?: $Enums.TipoGenero
    fechaNacimiento?: Date | string | null
    nombre: string
    creadoEn?: Date | string
    actualizadoEn: Date | string
    nroUpdates?: number
    calificaciones?: calificacionesCreateNestedManyWithoutEstudiantesInput
    certificados?: certificadosCreateNestedManyWithoutEstudiantesInput
    inscripciones?: inscripcionesCreateNestedManyWithoutEstudiantesInput
  }

  export type estudiantesUncheckedCreateWithoutUsuariosEstudiantesInput = {
    id?: string
    apellido?: string | null
    celular?: string | null
    pais?: string
    genero?: $Enums.TipoGenero
    fechaNacimiento?: Date | string | null
    nombre: string
    creadoEn?: Date | string
    actualizadoEn: Date | string
    nroUpdates?: number
    calificaciones?: calificacionesUncheckedCreateNestedManyWithoutEstudiantesInput
    certificados?: certificadosUncheckedCreateNestedManyWithoutEstudiantesInput
    inscripciones?: inscripcionesUncheckedCreateNestedManyWithoutEstudiantesInput
  }

  export type estudiantesCreateOrConnectWithoutUsuariosEstudiantesInput = {
    where: estudiantesWhereUniqueInput
    create: XOR<estudiantesCreateWithoutUsuariosEstudiantesInput, estudiantesUncheckedCreateWithoutUsuariosEstudiantesInput>
  }

  export type comprasUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput = {
    where: comprasWhereUniqueInput
    update: XOR<comprasUpdateWithoutUsuariosEstudiantesInput, comprasUncheckedUpdateWithoutUsuariosEstudiantesInput>
    create: XOR<comprasCreateWithoutUsuariosEstudiantesInput, comprasUncheckedCreateWithoutUsuariosEstudiantesInput>
  }

  export type comprasUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput = {
    where: comprasWhereUniqueInput
    data: XOR<comprasUpdateWithoutUsuariosEstudiantesInput, comprasUncheckedUpdateWithoutUsuariosEstudiantesInput>
  }

  export type comprasUpdateManyWithWhereWithoutUsuariosEstudiantesInput = {
    where: comprasScalarWhereInput
    data: XOR<comprasUpdateManyMutationInput, comprasUncheckedUpdateManyWithoutUsuariosEstudiantesInput>
  }

  export type intentosUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput = {
    where: intentosWhereUniqueInput
    update: XOR<intentosUpdateWithoutUsuariosEstudiantesInput, intentosUncheckedUpdateWithoutUsuariosEstudiantesInput>
    create: XOR<intentosCreateWithoutUsuariosEstudiantesInput, intentosUncheckedCreateWithoutUsuariosEstudiantesInput>
  }

  export type intentosUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput = {
    where: intentosWhereUniqueInput
    data: XOR<intentosUpdateWithoutUsuariosEstudiantesInput, intentosUncheckedUpdateWithoutUsuariosEstudiantesInput>
  }

  export type intentosUpdateManyWithWhereWithoutUsuariosEstudiantesInput = {
    where: intentosScalarWhereInput
    data: XOR<intentosUpdateManyMutationInput, intentosUncheckedUpdateManyWithoutUsuariosEstudiantesInput>
  }

  export type intentosScalarWhereInput = {
    AND?: intentosScalarWhereInput | intentosScalarWhereInput[]
    OR?: intentosScalarWhereInput[]
    NOT?: intentosScalarWhereInput | intentosScalarWhereInput[]
    id?: StringFilter<"intentos"> | string
    banqueoId?: StringFilter<"intentos"> | string
    usuarioEstudianteId?: StringNullableFilter<"intentos"> | string | null
    tiempoDuracion?: IntFilter<"intentos"> | number
    correctas?: IntFilter<"intentos"> | number
    incorrectas?: IntFilter<"intentos"> | number
    creadoEn?: DateTimeFilter<"intentos"> | Date | string
    actualizadoEn?: DateTimeFilter<"intentos"> | Date | string
    estado?: EnumEstadoIntentoFilter<"intentos"> | $Enums.EstadoIntento
  }

  export type reaccionesPreguntasUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput = {
    where: reaccionesPreguntasWhereUniqueInput
    update: XOR<reaccionesPreguntasUpdateWithoutUsuariosEstudiantesInput, reaccionesPreguntasUncheckedUpdateWithoutUsuariosEstudiantesInput>
    create: XOR<reaccionesPreguntasCreateWithoutUsuariosEstudiantesInput, reaccionesPreguntasUncheckedCreateWithoutUsuariosEstudiantesInput>
  }

  export type reaccionesPreguntasUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput = {
    where: reaccionesPreguntasWhereUniqueInput
    data: XOR<reaccionesPreguntasUpdateWithoutUsuariosEstudiantesInput, reaccionesPreguntasUncheckedUpdateWithoutUsuariosEstudiantesInput>
  }

  export type reaccionesPreguntasUpdateManyWithWhereWithoutUsuariosEstudiantesInput = {
    where: reaccionesPreguntasScalarWhereInput
    data: XOR<reaccionesPreguntasUpdateManyMutationInput, reaccionesPreguntasUncheckedUpdateManyWithoutUsuariosEstudiantesInput>
  }

  export type repasoRegistrosUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput = {
    where: repasoRegistrosWhereUniqueInput
    update: XOR<repasoRegistrosUpdateWithoutUsuariosEstudiantesInput, repasoRegistrosUncheckedUpdateWithoutUsuariosEstudiantesInput>
    create: XOR<repasoRegistrosCreateWithoutUsuariosEstudiantesInput, repasoRegistrosUncheckedCreateWithoutUsuariosEstudiantesInput>
  }

  export type repasoRegistrosUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput = {
    where: repasoRegistrosWhereUniqueInput
    data: XOR<repasoRegistrosUpdateWithoutUsuariosEstudiantesInput, repasoRegistrosUncheckedUpdateWithoutUsuariosEstudiantesInput>
  }

  export type repasoRegistrosUpdateManyWithWhereWithoutUsuariosEstudiantesInput = {
    where: repasoRegistrosScalarWhereInput
    data: XOR<repasoRegistrosUpdateManyMutationInput, repasoRegistrosUncheckedUpdateManyWithoutUsuariosEstudiantesInput>
  }

  export type reviewsCursosUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput = {
    where: reviewsCursosWhereUniqueInput
    update: XOR<reviewsCursosUpdateWithoutUsuariosEstudiantesInput, reviewsCursosUncheckedUpdateWithoutUsuariosEstudiantesInput>
    create: XOR<reviewsCursosCreateWithoutUsuariosEstudiantesInput, reviewsCursosUncheckedCreateWithoutUsuariosEstudiantesInput>
  }

  export type reviewsCursosUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput = {
    where: reviewsCursosWhereUniqueInput
    data: XOR<reviewsCursosUpdateWithoutUsuariosEstudiantesInput, reviewsCursosUncheckedUpdateWithoutUsuariosEstudiantesInput>
  }

  export type reviewsCursosUpdateManyWithWhereWithoutUsuariosEstudiantesInput = {
    where: reviewsCursosScalarWhereInput
    data: XOR<reviewsCursosUpdateManyMutationInput, reviewsCursosUncheckedUpdateManyWithoutUsuariosEstudiantesInput>
  }

  export type suscripcionesUpsertWithWhereUniqueWithoutUsuariosEstudiantesInput = {
    where: suscripcionesWhereUniqueInput
    update: XOR<suscripcionesUpdateWithoutUsuariosEstudiantesInput, suscripcionesUncheckedUpdateWithoutUsuariosEstudiantesInput>
    create: XOR<suscripcionesCreateWithoutUsuariosEstudiantesInput, suscripcionesUncheckedCreateWithoutUsuariosEstudiantesInput>
  }

  export type suscripcionesUpdateWithWhereUniqueWithoutUsuariosEstudiantesInput = {
    where: suscripcionesWhereUniqueInput
    data: XOR<suscripcionesUpdateWithoutUsuariosEstudiantesInput, suscripcionesUncheckedUpdateWithoutUsuariosEstudiantesInput>
  }

  export type suscripcionesUpdateManyWithWhereWithoutUsuariosEstudiantesInput = {
    where: suscripcionesScalarWhereInput
    data: XOR<suscripcionesUpdateManyMutationInput, suscripcionesUncheckedUpdateManyWithoutUsuariosEstudiantesInput>
  }

  export type suscripcionesScalarWhereInput = {
    AND?: suscripcionesScalarWhereInput | suscripcionesScalarWhereInput[]
    OR?: suscripcionesScalarWhereInput[]
    NOT?: suscripcionesScalarWhereInput | suscripcionesScalarWhereInput[]
    id?: StringFilter<"suscripciones"> | string
    usuarioEstudianteId?: StringFilter<"suscripciones"> | string
    montoUsd?: FloatFilter<"suscripciones"> | number
    fechaInicio?: DateTimeFilter<"suscripciones"> | Date | string
    fechaFin?: DateTimeFilter<"suscripciones"> | Date | string
    estado?: EnumEstadoSuscripcionFilter<"suscripciones"> | $Enums.EstadoSuscripcion
    creadoEn?: DateTimeFilter<"suscripciones"> | Date | string
    actualizadoEn?: DateTimeFilter<"suscripciones"> | Date | string
  }

  export type estudiantesUpsertWithoutUsuariosEstudiantesInput = {
    update: XOR<estudiantesUpdateWithoutUsuariosEstudiantesInput, estudiantesUncheckedUpdateWithoutUsuariosEstudiantesInput>
    create: XOR<estudiantesCreateWithoutUsuariosEstudiantesInput, estudiantesUncheckedCreateWithoutUsuariosEstudiantesInput>
    where?: estudiantesWhereInput
  }

  export type estudiantesUpdateToOneWithWhereWithoutUsuariosEstudiantesInput = {
    where?: estudiantesWhereInput
    data: XOR<estudiantesUpdateWithoutUsuariosEstudiantesInput, estudiantesUncheckedUpdateWithoutUsuariosEstudiantesInput>
  }

  export type estudiantesUpdateWithoutUsuariosEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: StringFieldUpdateOperationsInput | string
    genero?: EnumTipoGeneroFieldUpdateOperationsInput | $Enums.TipoGenero
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    nroUpdates?: IntFieldUpdateOperationsInput | number
    calificaciones?: calificacionesUpdateManyWithoutEstudiantesNestedInput
    certificados?: certificadosUpdateManyWithoutEstudiantesNestedInput
    inscripciones?: inscripcionesUpdateManyWithoutEstudiantesNestedInput
  }

  export type estudiantesUncheckedUpdateWithoutUsuariosEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    pais?: StringFieldUpdateOperationsInput | string
    genero?: EnumTipoGeneroFieldUpdateOperationsInput | $Enums.TipoGenero
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    nroUpdates?: IntFieldUpdateOperationsInput | number
    calificaciones?: calificacionesUncheckedUpdateManyWithoutEstudiantesNestedInput
    certificados?: certificadosUncheckedUpdateManyWithoutEstudiantesNestedInput
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEstudiantesNestedInput
  }

  export type capitulosCreateWithoutAreasInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    temas?: temasCreateNestedManyWithoutCapitulosInput
    preguntas?: preguntasCreateNestedManyWithoutCapitulosInput
  }

  export type capitulosUncheckedCreateWithoutAreasInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    temas?: temasUncheckedCreateNestedManyWithoutCapitulosInput
    preguntas?: preguntasUncheckedCreateNestedManyWithoutCapitulosInput
  }

  export type capitulosCreateOrConnectWithoutAreasInput = {
    where: capitulosWhereUniqueInput
    create: XOR<capitulosCreateWithoutAreasInput, capitulosUncheckedCreateWithoutAreasInput>
  }

  export type capitulosCreateManyAreasInputEnvelope = {
    data: capitulosCreateManyAreasInput | capitulosCreateManyAreasInput[]
    skipDuplicates?: boolean
  }

  export type preguntasCreateWithoutAreasInput = {
    id?: string
    codigo: string
    enunciado: string
    explicacion?: string | null
    referencia?: string | null
    opciones: JsonNullValueInput | InputJsonValue
    solucion: JsonNullValueInput | InputJsonValue
    estado?: $Enums.PreguntaEstado
    gestion: number
    likes?: number
    dislikes?: number
    dificultad?: $Enums.PreguntaDificultad
    dificultadActualizadaEn?: Date | string | null
    tasaAcierto?: number
    totalBien?: number
    totalMal?: number
    totalRespondidas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    reaccionesPreguntas?: reaccionesPreguntasCreateNestedManyWithoutPreguntaInput
    repasoRegistros?: repasoRegistrosCreateNestedManyWithoutPreguntasInput
    respuestasIntentos?: respuestasIntentosCreateNestedManyWithoutPreguntasInput
    banqueo?: banqueoCreateNestedManyWithoutPreguntasInput
    capitulos?: capitulosCreateNestedManyWithoutPreguntasInput
    temas?: temasCreateNestedManyWithoutPreguntasInput
  }

  export type preguntasUncheckedCreateWithoutAreasInput = {
    id?: string
    codigo: string
    enunciado: string
    explicacion?: string | null
    referencia?: string | null
    opciones: JsonNullValueInput | InputJsonValue
    solucion: JsonNullValueInput | InputJsonValue
    estado?: $Enums.PreguntaEstado
    gestion: number
    likes?: number
    dislikes?: number
    dificultad?: $Enums.PreguntaDificultad
    dificultadActualizadaEn?: Date | string | null
    tasaAcierto?: number
    totalBien?: number
    totalMal?: number
    totalRespondidas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    reaccionesPreguntas?: reaccionesPreguntasUncheckedCreateNestedManyWithoutPreguntaInput
    repasoRegistros?: repasoRegistrosUncheckedCreateNestedManyWithoutPreguntasInput
    respuestasIntentos?: respuestasIntentosUncheckedCreateNestedManyWithoutPreguntasInput
    banqueo?: banqueoUncheckedCreateNestedManyWithoutPreguntasInput
    capitulos?: capitulosUncheckedCreateNestedManyWithoutPreguntasInput
    temas?: temasUncheckedCreateNestedManyWithoutPreguntasInput
  }

  export type preguntasCreateOrConnectWithoutAreasInput = {
    where: preguntasWhereUniqueInput
    create: XOR<preguntasCreateWithoutAreasInput, preguntasUncheckedCreateWithoutAreasInput>
  }

  export type capitulosUpsertWithWhereUniqueWithoutAreasInput = {
    where: capitulosWhereUniqueInput
    update: XOR<capitulosUpdateWithoutAreasInput, capitulosUncheckedUpdateWithoutAreasInput>
    create: XOR<capitulosCreateWithoutAreasInput, capitulosUncheckedCreateWithoutAreasInput>
  }

  export type capitulosUpdateWithWhereUniqueWithoutAreasInput = {
    where: capitulosWhereUniqueInput
    data: XOR<capitulosUpdateWithoutAreasInput, capitulosUncheckedUpdateWithoutAreasInput>
  }

  export type capitulosUpdateManyWithWhereWithoutAreasInput = {
    where: capitulosScalarWhereInput
    data: XOR<capitulosUpdateManyMutationInput, capitulosUncheckedUpdateManyWithoutAreasInput>
  }

  export type preguntasUpsertWithWhereUniqueWithoutAreasInput = {
    where: preguntasWhereUniqueInput
    update: XOR<preguntasUpdateWithoutAreasInput, preguntasUncheckedUpdateWithoutAreasInput>
    create: XOR<preguntasCreateWithoutAreasInput, preguntasUncheckedCreateWithoutAreasInput>
  }

  export type preguntasUpdateWithWhereUniqueWithoutAreasInput = {
    where: preguntasWhereUniqueInput
    data: XOR<preguntasUpdateWithoutAreasInput, preguntasUncheckedUpdateWithoutAreasInput>
  }

  export type preguntasUpdateManyWithWhereWithoutAreasInput = {
    where: preguntasScalarWhereInput
    data: XOR<preguntasUpdateManyMutationInput, preguntasUncheckedUpdateManyWithoutAreasInput>
  }

  export type intentosCreateWithoutBanqueoInput = {
    id?: string
    tiempoDuracion: number
    correctas?: number
    incorrectas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    estado?: $Enums.EstadoIntento
    usuariosEstudiantes?: usuariosEstudiantesCreateNestedOneWithoutIntentosInput
    respuestasIntentos?: respuestasIntentosCreateNestedManyWithoutIntentosInput
  }

  export type intentosUncheckedCreateWithoutBanqueoInput = {
    id?: string
    usuarioEstudianteId?: string | null
    tiempoDuracion: number
    correctas?: number
    incorrectas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    estado?: $Enums.EstadoIntento
    respuestasIntentos?: respuestasIntentosUncheckedCreateNestedManyWithoutIntentosInput
  }

  export type intentosCreateOrConnectWithoutBanqueoInput = {
    where: intentosWhereUniqueInput
    create: XOR<intentosCreateWithoutBanqueoInput, intentosUncheckedCreateWithoutBanqueoInput>
  }

  export type intentosCreateManyBanqueoInputEnvelope = {
    data: intentosCreateManyBanqueoInput | intentosCreateManyBanqueoInput[]
    skipDuplicates?: boolean
  }

  export type repasoRegistrosCreateWithoutBanqueoInput = {
    id?: string
    esCorrecta: boolean
    creadoEn?: Date | string
    preguntas: preguntasCreateNestedOneWithoutRepasoRegistrosInput
    usuariosEstudiantes: usuariosEstudiantesCreateNestedOneWithoutRepasoRegistrosInput
  }

  export type repasoRegistrosUncheckedCreateWithoutBanqueoInput = {
    id?: string
    usuarioEstudianteId: string
    preguntaId: string
    esCorrecta: boolean
    creadoEn?: Date | string
  }

  export type repasoRegistrosCreateOrConnectWithoutBanqueoInput = {
    where: repasoRegistrosWhereUniqueInput
    create: XOR<repasoRegistrosCreateWithoutBanqueoInput, repasoRegistrosUncheckedCreateWithoutBanqueoInput>
  }

  export type repasoRegistrosCreateManyBanqueoInputEnvelope = {
    data: repasoRegistrosCreateManyBanqueoInput | repasoRegistrosCreateManyBanqueoInput[]
    skipDuplicates?: boolean
  }

  export type preguntasCreateWithoutBanqueoInput = {
    id?: string
    codigo: string
    enunciado: string
    explicacion?: string | null
    referencia?: string | null
    opciones: JsonNullValueInput | InputJsonValue
    solucion: JsonNullValueInput | InputJsonValue
    estado?: $Enums.PreguntaEstado
    gestion: number
    likes?: number
    dislikes?: number
    dificultad?: $Enums.PreguntaDificultad
    dificultadActualizadaEn?: Date | string | null
    tasaAcierto?: number
    totalBien?: number
    totalMal?: number
    totalRespondidas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    reaccionesPreguntas?: reaccionesPreguntasCreateNestedManyWithoutPreguntaInput
    repasoRegistros?: repasoRegistrosCreateNestedManyWithoutPreguntasInput
    respuestasIntentos?: respuestasIntentosCreateNestedManyWithoutPreguntasInput
    areas?: areasCreateNestedManyWithoutPreguntasInput
    capitulos?: capitulosCreateNestedManyWithoutPreguntasInput
    temas?: temasCreateNestedManyWithoutPreguntasInput
  }

  export type preguntasUncheckedCreateWithoutBanqueoInput = {
    id?: string
    codigo: string
    enunciado: string
    explicacion?: string | null
    referencia?: string | null
    opciones: JsonNullValueInput | InputJsonValue
    solucion: JsonNullValueInput | InputJsonValue
    estado?: $Enums.PreguntaEstado
    gestion: number
    likes?: number
    dislikes?: number
    dificultad?: $Enums.PreguntaDificultad
    dificultadActualizadaEn?: Date | string | null
    tasaAcierto?: number
    totalBien?: number
    totalMal?: number
    totalRespondidas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    reaccionesPreguntas?: reaccionesPreguntasUncheckedCreateNestedManyWithoutPreguntaInput
    repasoRegistros?: repasoRegistrosUncheckedCreateNestedManyWithoutPreguntasInput
    respuestasIntentos?: respuestasIntentosUncheckedCreateNestedManyWithoutPreguntasInput
    areas?: areasUncheckedCreateNestedManyWithoutPreguntasInput
    capitulos?: capitulosUncheckedCreateNestedManyWithoutPreguntasInput
    temas?: temasUncheckedCreateNestedManyWithoutPreguntasInput
  }

  export type preguntasCreateOrConnectWithoutBanqueoInput = {
    where: preguntasWhereUniqueInput
    create: XOR<preguntasCreateWithoutBanqueoInput, preguntasUncheckedCreateWithoutBanqueoInput>
  }

  export type intentosUpsertWithWhereUniqueWithoutBanqueoInput = {
    where: intentosWhereUniqueInput
    update: XOR<intentosUpdateWithoutBanqueoInput, intentosUncheckedUpdateWithoutBanqueoInput>
    create: XOR<intentosCreateWithoutBanqueoInput, intentosUncheckedCreateWithoutBanqueoInput>
  }

  export type intentosUpdateWithWhereUniqueWithoutBanqueoInput = {
    where: intentosWhereUniqueInput
    data: XOR<intentosUpdateWithoutBanqueoInput, intentosUncheckedUpdateWithoutBanqueoInput>
  }

  export type intentosUpdateManyWithWhereWithoutBanqueoInput = {
    where: intentosScalarWhereInput
    data: XOR<intentosUpdateManyMutationInput, intentosUncheckedUpdateManyWithoutBanqueoInput>
  }

  export type repasoRegistrosUpsertWithWhereUniqueWithoutBanqueoInput = {
    where: repasoRegistrosWhereUniqueInput
    update: XOR<repasoRegistrosUpdateWithoutBanqueoInput, repasoRegistrosUncheckedUpdateWithoutBanqueoInput>
    create: XOR<repasoRegistrosCreateWithoutBanqueoInput, repasoRegistrosUncheckedCreateWithoutBanqueoInput>
  }

  export type repasoRegistrosUpdateWithWhereUniqueWithoutBanqueoInput = {
    where: repasoRegistrosWhereUniqueInput
    data: XOR<repasoRegistrosUpdateWithoutBanqueoInput, repasoRegistrosUncheckedUpdateWithoutBanqueoInput>
  }

  export type repasoRegistrosUpdateManyWithWhereWithoutBanqueoInput = {
    where: repasoRegistrosScalarWhereInput
    data: XOR<repasoRegistrosUpdateManyMutationInput, repasoRegistrosUncheckedUpdateManyWithoutBanqueoInput>
  }

  export type preguntasUpsertWithWhereUniqueWithoutBanqueoInput = {
    where: preguntasWhereUniqueInput
    update: XOR<preguntasUpdateWithoutBanqueoInput, preguntasUncheckedUpdateWithoutBanqueoInput>
    create: XOR<preguntasCreateWithoutBanqueoInput, preguntasUncheckedCreateWithoutBanqueoInput>
  }

  export type preguntasUpdateWithWhereUniqueWithoutBanqueoInput = {
    where: preguntasWhereUniqueInput
    data: XOR<preguntasUpdateWithoutBanqueoInput, preguntasUncheckedUpdateWithoutBanqueoInput>
  }

  export type preguntasUpdateManyWithWhereWithoutBanqueoInput = {
    where: preguntasScalarWhereInput
    data: XOR<preguntasUpdateManyMutationInput, preguntasUncheckedUpdateManyWithoutBanqueoInput>
  }

  export type areasCreateWithoutCapitulosInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    preguntas?: preguntasCreateNestedManyWithoutAreasInput
  }

  export type areasUncheckedCreateWithoutCapitulosInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    preguntas?: preguntasUncheckedCreateNestedManyWithoutAreasInput
  }

  export type areasCreateOrConnectWithoutCapitulosInput = {
    where: areasWhereUniqueInput
    create: XOR<areasCreateWithoutCapitulosInput, areasUncheckedCreateWithoutCapitulosInput>
  }

  export type temasCreateWithoutCapitulosInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    preguntas?: preguntasCreateNestedManyWithoutTemasInput
  }

  export type temasUncheckedCreateWithoutCapitulosInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    preguntas?: preguntasUncheckedCreateNestedManyWithoutTemasInput
  }

  export type temasCreateOrConnectWithoutCapitulosInput = {
    where: temasWhereUniqueInput
    create: XOR<temasCreateWithoutCapitulosInput, temasUncheckedCreateWithoutCapitulosInput>
  }

  export type temasCreateManyCapitulosInputEnvelope = {
    data: temasCreateManyCapitulosInput | temasCreateManyCapitulosInput[]
    skipDuplicates?: boolean
  }

  export type preguntasCreateWithoutCapitulosInput = {
    id?: string
    codigo: string
    enunciado: string
    explicacion?: string | null
    referencia?: string | null
    opciones: JsonNullValueInput | InputJsonValue
    solucion: JsonNullValueInput | InputJsonValue
    estado?: $Enums.PreguntaEstado
    gestion: number
    likes?: number
    dislikes?: number
    dificultad?: $Enums.PreguntaDificultad
    dificultadActualizadaEn?: Date | string | null
    tasaAcierto?: number
    totalBien?: number
    totalMal?: number
    totalRespondidas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    reaccionesPreguntas?: reaccionesPreguntasCreateNestedManyWithoutPreguntaInput
    repasoRegistros?: repasoRegistrosCreateNestedManyWithoutPreguntasInput
    respuestasIntentos?: respuestasIntentosCreateNestedManyWithoutPreguntasInput
    areas?: areasCreateNestedManyWithoutPreguntasInput
    banqueo?: banqueoCreateNestedManyWithoutPreguntasInput
    temas?: temasCreateNestedManyWithoutPreguntasInput
  }

  export type preguntasUncheckedCreateWithoutCapitulosInput = {
    id?: string
    codigo: string
    enunciado: string
    explicacion?: string | null
    referencia?: string | null
    opciones: JsonNullValueInput | InputJsonValue
    solucion: JsonNullValueInput | InputJsonValue
    estado?: $Enums.PreguntaEstado
    gestion: number
    likes?: number
    dislikes?: number
    dificultad?: $Enums.PreguntaDificultad
    dificultadActualizadaEn?: Date | string | null
    tasaAcierto?: number
    totalBien?: number
    totalMal?: number
    totalRespondidas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    reaccionesPreguntas?: reaccionesPreguntasUncheckedCreateNestedManyWithoutPreguntaInput
    repasoRegistros?: repasoRegistrosUncheckedCreateNestedManyWithoutPreguntasInput
    respuestasIntentos?: respuestasIntentosUncheckedCreateNestedManyWithoutPreguntasInput
    areas?: areasUncheckedCreateNestedManyWithoutPreguntasInput
    banqueo?: banqueoUncheckedCreateNestedManyWithoutPreguntasInput
    temas?: temasUncheckedCreateNestedManyWithoutPreguntasInput
  }

  export type preguntasCreateOrConnectWithoutCapitulosInput = {
    where: preguntasWhereUniqueInput
    create: XOR<preguntasCreateWithoutCapitulosInput, preguntasUncheckedCreateWithoutCapitulosInput>
  }

  export type areasUpsertWithoutCapitulosInput = {
    update: XOR<areasUpdateWithoutCapitulosInput, areasUncheckedUpdateWithoutCapitulosInput>
    create: XOR<areasCreateWithoutCapitulosInput, areasUncheckedCreateWithoutCapitulosInput>
    where?: areasWhereInput
  }

  export type areasUpdateToOneWithWhereWithoutCapitulosInput = {
    where?: areasWhereInput
    data: XOR<areasUpdateWithoutCapitulosInput, areasUncheckedUpdateWithoutCapitulosInput>
  }

  export type areasUpdateWithoutCapitulosInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    preguntas?: preguntasUpdateManyWithoutAreasNestedInput
  }

  export type areasUncheckedUpdateWithoutCapitulosInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    preguntas?: preguntasUncheckedUpdateManyWithoutAreasNestedInput
  }

  export type temasUpsertWithWhereUniqueWithoutCapitulosInput = {
    where: temasWhereUniqueInput
    update: XOR<temasUpdateWithoutCapitulosInput, temasUncheckedUpdateWithoutCapitulosInput>
    create: XOR<temasCreateWithoutCapitulosInput, temasUncheckedCreateWithoutCapitulosInput>
  }

  export type temasUpdateWithWhereUniqueWithoutCapitulosInput = {
    where: temasWhereUniqueInput
    data: XOR<temasUpdateWithoutCapitulosInput, temasUncheckedUpdateWithoutCapitulosInput>
  }

  export type temasUpdateManyWithWhereWithoutCapitulosInput = {
    where: temasScalarWhereInput
    data: XOR<temasUpdateManyMutationInput, temasUncheckedUpdateManyWithoutCapitulosInput>
  }

  export type preguntasUpsertWithWhereUniqueWithoutCapitulosInput = {
    where: preguntasWhereUniqueInput
    update: XOR<preguntasUpdateWithoutCapitulosInput, preguntasUncheckedUpdateWithoutCapitulosInput>
    create: XOR<preguntasCreateWithoutCapitulosInput, preguntasUncheckedCreateWithoutCapitulosInput>
  }

  export type preguntasUpdateWithWhereUniqueWithoutCapitulosInput = {
    where: preguntasWhereUniqueInput
    data: XOR<preguntasUpdateWithoutCapitulosInput, preguntasUncheckedUpdateWithoutCapitulosInput>
  }

  export type preguntasUpdateManyWithWhereWithoutCapitulosInput = {
    where: preguntasScalarWhereInput
    data: XOR<preguntasUpdateManyMutationInput, preguntasUncheckedUpdateManyWithoutCapitulosInput>
  }

  export type banqueoCreateWithoutIntentosInput = {
    id?: string
    titulo: string
    tipo: $Enums.BanqueoTipo
    tipoCreado: $Enums.BanqueoTipoCreado
    duracion: number
    maxPreguntas: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    repasoRegistros?: repasoRegistrosCreateNestedManyWithoutBanqueoInput
    preguntas?: preguntasCreateNestedManyWithoutBanqueoInput
  }

  export type banqueoUncheckedCreateWithoutIntentosInput = {
    id?: string
    titulo: string
    tipo: $Enums.BanqueoTipo
    tipoCreado: $Enums.BanqueoTipoCreado
    duracion: number
    maxPreguntas: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    repasoRegistros?: repasoRegistrosUncheckedCreateNestedManyWithoutBanqueoInput
    preguntas?: preguntasUncheckedCreateNestedManyWithoutBanqueoInput
  }

  export type banqueoCreateOrConnectWithoutIntentosInput = {
    where: banqueoWhereUniqueInput
    create: XOR<banqueoCreateWithoutIntentosInput, banqueoUncheckedCreateWithoutIntentosInput>
  }

  export type usuariosEstudiantesCreateWithoutIntentosInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    avatar?: string | null
    registrado?: boolean
    compras?: comprasCreateNestedManyWithoutUsuariosEstudiantesInput
    reaccionesPreguntas?: reaccionesPreguntasCreateNestedManyWithoutUsuariosEstudiantesInput
    repasoRegistros?: repasoRegistrosCreateNestedManyWithoutUsuariosEstudiantesInput
    reviewsCursos?: reviewsCursosCreateNestedManyWithoutUsuariosEstudiantesInput
    suscripciones?: suscripcionesCreateNestedManyWithoutUsuariosEstudiantesInput
    estudiantes?: estudiantesCreateNestedOneWithoutUsuariosEstudiantesInput
  }

  export type usuariosEstudiantesUncheckedCreateWithoutIntentosInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    avatar?: string | null
    estudianteId?: string | null
    registrado?: boolean
    compras?: comprasUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    reaccionesPreguntas?: reaccionesPreguntasUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    repasoRegistros?: repasoRegistrosUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    reviewsCursos?: reviewsCursosUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    suscripciones?: suscripcionesUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
  }

  export type usuariosEstudiantesCreateOrConnectWithoutIntentosInput = {
    where: usuariosEstudiantesWhereUniqueInput
    create: XOR<usuariosEstudiantesCreateWithoutIntentosInput, usuariosEstudiantesUncheckedCreateWithoutIntentosInput>
  }

  export type respuestasIntentosCreateWithoutIntentosInput = {
    id?: string
    respuesta?: NullableJsonNullValueInput | InputJsonValue
    resultado?: $Enums.ResultadoRespuesta
    esCorrecta?: boolean | null
    respondida?: boolean
    visitada?: boolean
    marcadaRevision?: boolean
    tiempoConsumidoSeg?: number
    orden?: number | null
    respondidaEn?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    preguntas: preguntasCreateNestedOneWithoutRespuestasIntentosInput
  }

  export type respuestasIntentosUncheckedCreateWithoutIntentosInput = {
    id?: string
    preguntaId: string
    respuesta?: NullableJsonNullValueInput | InputJsonValue
    resultado?: $Enums.ResultadoRespuesta
    esCorrecta?: boolean | null
    respondida?: boolean
    visitada?: boolean
    marcadaRevision?: boolean
    tiempoConsumidoSeg?: number
    orden?: number | null
    respondidaEn?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type respuestasIntentosCreateOrConnectWithoutIntentosInput = {
    where: respuestasIntentosWhereUniqueInput
    create: XOR<respuestasIntentosCreateWithoutIntentosInput, respuestasIntentosUncheckedCreateWithoutIntentosInput>
  }

  export type respuestasIntentosCreateManyIntentosInputEnvelope = {
    data: respuestasIntentosCreateManyIntentosInput | respuestasIntentosCreateManyIntentosInput[]
    skipDuplicates?: boolean
  }

  export type banqueoUpsertWithoutIntentosInput = {
    update: XOR<banqueoUpdateWithoutIntentosInput, banqueoUncheckedUpdateWithoutIntentosInput>
    create: XOR<banqueoCreateWithoutIntentosInput, banqueoUncheckedCreateWithoutIntentosInput>
    where?: banqueoWhereInput
  }

  export type banqueoUpdateToOneWithWhereWithoutIntentosInput = {
    where?: banqueoWhereInput
    data: XOR<banqueoUpdateWithoutIntentosInput, banqueoUncheckedUpdateWithoutIntentosInput>
  }

  export type banqueoUpdateWithoutIntentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    tipo?: EnumBanqueoTipoFieldUpdateOperationsInput | $Enums.BanqueoTipo
    tipoCreado?: EnumBanqueoTipoCreadoFieldUpdateOperationsInput | $Enums.BanqueoTipoCreado
    duracion?: IntFieldUpdateOperationsInput | number
    maxPreguntas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    repasoRegistros?: repasoRegistrosUpdateManyWithoutBanqueoNestedInput
    preguntas?: preguntasUpdateManyWithoutBanqueoNestedInput
  }

  export type banqueoUncheckedUpdateWithoutIntentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    tipo?: EnumBanqueoTipoFieldUpdateOperationsInput | $Enums.BanqueoTipo
    tipoCreado?: EnumBanqueoTipoCreadoFieldUpdateOperationsInput | $Enums.BanqueoTipoCreado
    duracion?: IntFieldUpdateOperationsInput | number
    maxPreguntas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    repasoRegistros?: repasoRegistrosUncheckedUpdateManyWithoutBanqueoNestedInput
    preguntas?: preguntasUncheckedUpdateManyWithoutBanqueoNestedInput
  }

  export type usuariosEstudiantesUpsertWithoutIntentosInput = {
    update: XOR<usuariosEstudiantesUpdateWithoutIntentosInput, usuariosEstudiantesUncheckedUpdateWithoutIntentosInput>
    create: XOR<usuariosEstudiantesCreateWithoutIntentosInput, usuariosEstudiantesUncheckedCreateWithoutIntentosInput>
    where?: usuariosEstudiantesWhereInput
  }

  export type usuariosEstudiantesUpdateToOneWithWhereWithoutIntentosInput = {
    where?: usuariosEstudiantesWhereInput
    data: XOR<usuariosEstudiantesUpdateWithoutIntentosInput, usuariosEstudiantesUncheckedUpdateWithoutIntentosInput>
  }

  export type usuariosEstudiantesUpdateWithoutIntentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
    compras?: comprasUpdateManyWithoutUsuariosEstudiantesNestedInput
    reaccionesPreguntas?: reaccionesPreguntasUpdateManyWithoutUsuariosEstudiantesNestedInput
    repasoRegistros?: repasoRegistrosUpdateManyWithoutUsuariosEstudiantesNestedInput
    reviewsCursos?: reviewsCursosUpdateManyWithoutUsuariosEstudiantesNestedInput
    suscripciones?: suscripcionesUpdateManyWithoutUsuariosEstudiantesNestedInput
    estudiantes?: estudiantesUpdateOneWithoutUsuariosEstudiantesNestedInput
  }

  export type usuariosEstudiantesUncheckedUpdateWithoutIntentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
    compras?: comprasUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    reaccionesPreguntas?: reaccionesPreguntasUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    repasoRegistros?: repasoRegistrosUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    reviewsCursos?: reviewsCursosUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    suscripciones?: suscripcionesUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
  }

  export type respuestasIntentosUpsertWithWhereUniqueWithoutIntentosInput = {
    where: respuestasIntentosWhereUniqueInput
    update: XOR<respuestasIntentosUpdateWithoutIntentosInput, respuestasIntentosUncheckedUpdateWithoutIntentosInput>
    create: XOR<respuestasIntentosCreateWithoutIntentosInput, respuestasIntentosUncheckedCreateWithoutIntentosInput>
  }

  export type respuestasIntentosUpdateWithWhereUniqueWithoutIntentosInput = {
    where: respuestasIntentosWhereUniqueInput
    data: XOR<respuestasIntentosUpdateWithoutIntentosInput, respuestasIntentosUncheckedUpdateWithoutIntentosInput>
  }

  export type respuestasIntentosUpdateManyWithWhereWithoutIntentosInput = {
    where: respuestasIntentosScalarWhereInput
    data: XOR<respuestasIntentosUpdateManyMutationInput, respuestasIntentosUncheckedUpdateManyWithoutIntentosInput>
  }

  export type intentosCreateWithoutRespuestasIntentosInput = {
    id?: string
    tiempoDuracion: number
    correctas?: number
    incorrectas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    estado?: $Enums.EstadoIntento
    banqueo: banqueoCreateNestedOneWithoutIntentosInput
    usuariosEstudiantes?: usuariosEstudiantesCreateNestedOneWithoutIntentosInput
  }

  export type intentosUncheckedCreateWithoutRespuestasIntentosInput = {
    id?: string
    banqueoId: string
    usuarioEstudianteId?: string | null
    tiempoDuracion: number
    correctas?: number
    incorrectas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    estado?: $Enums.EstadoIntento
  }

  export type intentosCreateOrConnectWithoutRespuestasIntentosInput = {
    where: intentosWhereUniqueInput
    create: XOR<intentosCreateWithoutRespuestasIntentosInput, intentosUncheckedCreateWithoutRespuestasIntentosInput>
  }

  export type preguntasCreateWithoutRespuestasIntentosInput = {
    id?: string
    codigo: string
    enunciado: string
    explicacion?: string | null
    referencia?: string | null
    opciones: JsonNullValueInput | InputJsonValue
    solucion: JsonNullValueInput | InputJsonValue
    estado?: $Enums.PreguntaEstado
    gestion: number
    likes?: number
    dislikes?: number
    dificultad?: $Enums.PreguntaDificultad
    dificultadActualizadaEn?: Date | string | null
    tasaAcierto?: number
    totalBien?: number
    totalMal?: number
    totalRespondidas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    reaccionesPreguntas?: reaccionesPreguntasCreateNestedManyWithoutPreguntaInput
    repasoRegistros?: repasoRegistrosCreateNestedManyWithoutPreguntasInput
    areas?: areasCreateNestedManyWithoutPreguntasInput
    banqueo?: banqueoCreateNestedManyWithoutPreguntasInput
    capitulos?: capitulosCreateNestedManyWithoutPreguntasInput
    temas?: temasCreateNestedManyWithoutPreguntasInput
  }

  export type preguntasUncheckedCreateWithoutRespuestasIntentosInput = {
    id?: string
    codigo: string
    enunciado: string
    explicacion?: string | null
    referencia?: string | null
    opciones: JsonNullValueInput | InputJsonValue
    solucion: JsonNullValueInput | InputJsonValue
    estado?: $Enums.PreguntaEstado
    gestion: number
    likes?: number
    dislikes?: number
    dificultad?: $Enums.PreguntaDificultad
    dificultadActualizadaEn?: Date | string | null
    tasaAcierto?: number
    totalBien?: number
    totalMal?: number
    totalRespondidas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    reaccionesPreguntas?: reaccionesPreguntasUncheckedCreateNestedManyWithoutPreguntaInput
    repasoRegistros?: repasoRegistrosUncheckedCreateNestedManyWithoutPreguntasInput
    areas?: areasUncheckedCreateNestedManyWithoutPreguntasInput
    banqueo?: banqueoUncheckedCreateNestedManyWithoutPreguntasInput
    capitulos?: capitulosUncheckedCreateNestedManyWithoutPreguntasInput
    temas?: temasUncheckedCreateNestedManyWithoutPreguntasInput
  }

  export type preguntasCreateOrConnectWithoutRespuestasIntentosInput = {
    where: preguntasWhereUniqueInput
    create: XOR<preguntasCreateWithoutRespuestasIntentosInput, preguntasUncheckedCreateWithoutRespuestasIntentosInput>
  }

  export type intentosUpsertWithoutRespuestasIntentosInput = {
    update: XOR<intentosUpdateWithoutRespuestasIntentosInput, intentosUncheckedUpdateWithoutRespuestasIntentosInput>
    create: XOR<intentosCreateWithoutRespuestasIntentosInput, intentosUncheckedCreateWithoutRespuestasIntentosInput>
    where?: intentosWhereInput
  }

  export type intentosUpdateToOneWithWhereWithoutRespuestasIntentosInput = {
    where?: intentosWhereInput
    data: XOR<intentosUpdateWithoutRespuestasIntentosInput, intentosUncheckedUpdateWithoutRespuestasIntentosInput>
  }

  export type intentosUpdateWithoutRespuestasIntentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    tiempoDuracion?: IntFieldUpdateOperationsInput | number
    correctas?: IntFieldUpdateOperationsInput | number
    incorrectas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoIntentoFieldUpdateOperationsInput | $Enums.EstadoIntento
    banqueo?: banqueoUpdateOneRequiredWithoutIntentosNestedInput
    usuariosEstudiantes?: usuariosEstudiantesUpdateOneWithoutIntentosNestedInput
  }

  export type intentosUncheckedUpdateWithoutRespuestasIntentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    banqueoId?: StringFieldUpdateOperationsInput | string
    usuarioEstudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    tiempoDuracion?: IntFieldUpdateOperationsInput | number
    correctas?: IntFieldUpdateOperationsInput | number
    incorrectas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoIntentoFieldUpdateOperationsInput | $Enums.EstadoIntento
  }

  export type preguntasUpsertWithoutRespuestasIntentosInput = {
    update: XOR<preguntasUpdateWithoutRespuestasIntentosInput, preguntasUncheckedUpdateWithoutRespuestasIntentosInput>
    create: XOR<preguntasCreateWithoutRespuestasIntentosInput, preguntasUncheckedCreateWithoutRespuestasIntentosInput>
    where?: preguntasWhereInput
  }

  export type preguntasUpdateToOneWithWhereWithoutRespuestasIntentosInput = {
    where?: preguntasWhereInput
    data: XOR<preguntasUpdateWithoutRespuestasIntentosInput, preguntasUncheckedUpdateWithoutRespuestasIntentosInput>
  }

  export type preguntasUpdateWithoutRespuestasIntentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    enunciado?: StringFieldUpdateOperationsInput | string
    explicacion?: NullableStringFieldUpdateOperationsInput | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    opciones?: JsonNullValueInput | InputJsonValue
    solucion?: JsonNullValueInput | InputJsonValue
    estado?: EnumPreguntaEstadoFieldUpdateOperationsInput | $Enums.PreguntaEstado
    gestion?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumPreguntaDificultadFieldUpdateOperationsInput | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasaAcierto?: IntFieldUpdateOperationsInput | number
    totalBien?: IntFieldUpdateOperationsInput | number
    totalMal?: IntFieldUpdateOperationsInput | number
    totalRespondidas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    reaccionesPreguntas?: reaccionesPreguntasUpdateManyWithoutPreguntaNestedInput
    repasoRegistros?: repasoRegistrosUpdateManyWithoutPreguntasNestedInput
    areas?: areasUpdateManyWithoutPreguntasNestedInput
    banqueo?: banqueoUpdateManyWithoutPreguntasNestedInput
    capitulos?: capitulosUpdateManyWithoutPreguntasNestedInput
    temas?: temasUpdateManyWithoutPreguntasNestedInput
  }

  export type preguntasUncheckedUpdateWithoutRespuestasIntentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    enunciado?: StringFieldUpdateOperationsInput | string
    explicacion?: NullableStringFieldUpdateOperationsInput | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    opciones?: JsonNullValueInput | InputJsonValue
    solucion?: JsonNullValueInput | InputJsonValue
    estado?: EnumPreguntaEstadoFieldUpdateOperationsInput | $Enums.PreguntaEstado
    gestion?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumPreguntaDificultadFieldUpdateOperationsInput | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasaAcierto?: IntFieldUpdateOperationsInput | number
    totalBien?: IntFieldUpdateOperationsInput | number
    totalMal?: IntFieldUpdateOperationsInput | number
    totalRespondidas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    reaccionesPreguntas?: reaccionesPreguntasUncheckedUpdateManyWithoutPreguntaNestedInput
    repasoRegistros?: repasoRegistrosUncheckedUpdateManyWithoutPreguntasNestedInput
    areas?: areasUncheckedUpdateManyWithoutPreguntasNestedInput
    banqueo?: banqueoUncheckedUpdateManyWithoutPreguntasNestedInput
    capitulos?: capitulosUncheckedUpdateManyWithoutPreguntasNestedInput
    temas?: temasUncheckedUpdateManyWithoutPreguntasNestedInput
  }

  export type banqueoCreateWithoutRepasoRegistrosInput = {
    id?: string
    titulo: string
    tipo: $Enums.BanqueoTipo
    tipoCreado: $Enums.BanqueoTipoCreado
    duracion: number
    maxPreguntas: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    intentos?: intentosCreateNestedManyWithoutBanqueoInput
    preguntas?: preguntasCreateNestedManyWithoutBanqueoInput
  }

  export type banqueoUncheckedCreateWithoutRepasoRegistrosInput = {
    id?: string
    titulo: string
    tipo: $Enums.BanqueoTipo
    tipoCreado: $Enums.BanqueoTipoCreado
    duracion: number
    maxPreguntas: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    intentos?: intentosUncheckedCreateNestedManyWithoutBanqueoInput
    preguntas?: preguntasUncheckedCreateNestedManyWithoutBanqueoInput
  }

  export type banqueoCreateOrConnectWithoutRepasoRegistrosInput = {
    where: banqueoWhereUniqueInput
    create: XOR<banqueoCreateWithoutRepasoRegistrosInput, banqueoUncheckedCreateWithoutRepasoRegistrosInput>
  }

  export type preguntasCreateWithoutRepasoRegistrosInput = {
    id?: string
    codigo: string
    enunciado: string
    explicacion?: string | null
    referencia?: string | null
    opciones: JsonNullValueInput | InputJsonValue
    solucion: JsonNullValueInput | InputJsonValue
    estado?: $Enums.PreguntaEstado
    gestion: number
    likes?: number
    dislikes?: number
    dificultad?: $Enums.PreguntaDificultad
    dificultadActualizadaEn?: Date | string | null
    tasaAcierto?: number
    totalBien?: number
    totalMal?: number
    totalRespondidas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    reaccionesPreguntas?: reaccionesPreguntasCreateNestedManyWithoutPreguntaInput
    respuestasIntentos?: respuestasIntentosCreateNestedManyWithoutPreguntasInput
    areas?: areasCreateNestedManyWithoutPreguntasInput
    banqueo?: banqueoCreateNestedManyWithoutPreguntasInput
    capitulos?: capitulosCreateNestedManyWithoutPreguntasInput
    temas?: temasCreateNestedManyWithoutPreguntasInput
  }

  export type preguntasUncheckedCreateWithoutRepasoRegistrosInput = {
    id?: string
    codigo: string
    enunciado: string
    explicacion?: string | null
    referencia?: string | null
    opciones: JsonNullValueInput | InputJsonValue
    solucion: JsonNullValueInput | InputJsonValue
    estado?: $Enums.PreguntaEstado
    gestion: number
    likes?: number
    dislikes?: number
    dificultad?: $Enums.PreguntaDificultad
    dificultadActualizadaEn?: Date | string | null
    tasaAcierto?: number
    totalBien?: number
    totalMal?: number
    totalRespondidas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    reaccionesPreguntas?: reaccionesPreguntasUncheckedCreateNestedManyWithoutPreguntaInput
    respuestasIntentos?: respuestasIntentosUncheckedCreateNestedManyWithoutPreguntasInput
    areas?: areasUncheckedCreateNestedManyWithoutPreguntasInput
    banqueo?: banqueoUncheckedCreateNestedManyWithoutPreguntasInput
    capitulos?: capitulosUncheckedCreateNestedManyWithoutPreguntasInput
    temas?: temasUncheckedCreateNestedManyWithoutPreguntasInput
  }

  export type preguntasCreateOrConnectWithoutRepasoRegistrosInput = {
    where: preguntasWhereUniqueInput
    create: XOR<preguntasCreateWithoutRepasoRegistrosInput, preguntasUncheckedCreateWithoutRepasoRegistrosInput>
  }

  export type usuariosEstudiantesCreateWithoutRepasoRegistrosInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    avatar?: string | null
    registrado?: boolean
    compras?: comprasCreateNestedManyWithoutUsuariosEstudiantesInput
    intentos?: intentosCreateNestedManyWithoutUsuariosEstudiantesInput
    reaccionesPreguntas?: reaccionesPreguntasCreateNestedManyWithoutUsuariosEstudiantesInput
    reviewsCursos?: reviewsCursosCreateNestedManyWithoutUsuariosEstudiantesInput
    suscripciones?: suscripcionesCreateNestedManyWithoutUsuariosEstudiantesInput
    estudiantes?: estudiantesCreateNestedOneWithoutUsuariosEstudiantesInput
  }

  export type usuariosEstudiantesUncheckedCreateWithoutRepasoRegistrosInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    avatar?: string | null
    estudianteId?: string | null
    registrado?: boolean
    compras?: comprasUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    intentos?: intentosUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    reaccionesPreguntas?: reaccionesPreguntasUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    reviewsCursos?: reviewsCursosUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    suscripciones?: suscripcionesUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
  }

  export type usuariosEstudiantesCreateOrConnectWithoutRepasoRegistrosInput = {
    where: usuariosEstudiantesWhereUniqueInput
    create: XOR<usuariosEstudiantesCreateWithoutRepasoRegistrosInput, usuariosEstudiantesUncheckedCreateWithoutRepasoRegistrosInput>
  }

  export type banqueoUpsertWithoutRepasoRegistrosInput = {
    update: XOR<banqueoUpdateWithoutRepasoRegistrosInput, banqueoUncheckedUpdateWithoutRepasoRegistrosInput>
    create: XOR<banqueoCreateWithoutRepasoRegistrosInput, banqueoUncheckedCreateWithoutRepasoRegistrosInput>
    where?: banqueoWhereInput
  }

  export type banqueoUpdateToOneWithWhereWithoutRepasoRegistrosInput = {
    where?: banqueoWhereInput
    data: XOR<banqueoUpdateWithoutRepasoRegistrosInput, banqueoUncheckedUpdateWithoutRepasoRegistrosInput>
  }

  export type banqueoUpdateWithoutRepasoRegistrosInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    tipo?: EnumBanqueoTipoFieldUpdateOperationsInput | $Enums.BanqueoTipo
    tipoCreado?: EnumBanqueoTipoCreadoFieldUpdateOperationsInput | $Enums.BanqueoTipoCreado
    duracion?: IntFieldUpdateOperationsInput | number
    maxPreguntas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    intentos?: intentosUpdateManyWithoutBanqueoNestedInput
    preguntas?: preguntasUpdateManyWithoutBanqueoNestedInput
  }

  export type banqueoUncheckedUpdateWithoutRepasoRegistrosInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    tipo?: EnumBanqueoTipoFieldUpdateOperationsInput | $Enums.BanqueoTipo
    tipoCreado?: EnumBanqueoTipoCreadoFieldUpdateOperationsInput | $Enums.BanqueoTipoCreado
    duracion?: IntFieldUpdateOperationsInput | number
    maxPreguntas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    intentos?: intentosUncheckedUpdateManyWithoutBanqueoNestedInput
    preguntas?: preguntasUncheckedUpdateManyWithoutBanqueoNestedInput
  }

  export type preguntasUpsertWithoutRepasoRegistrosInput = {
    update: XOR<preguntasUpdateWithoutRepasoRegistrosInput, preguntasUncheckedUpdateWithoutRepasoRegistrosInput>
    create: XOR<preguntasCreateWithoutRepasoRegistrosInput, preguntasUncheckedCreateWithoutRepasoRegistrosInput>
    where?: preguntasWhereInput
  }

  export type preguntasUpdateToOneWithWhereWithoutRepasoRegistrosInput = {
    where?: preguntasWhereInput
    data: XOR<preguntasUpdateWithoutRepasoRegistrosInput, preguntasUncheckedUpdateWithoutRepasoRegistrosInput>
  }

  export type preguntasUpdateWithoutRepasoRegistrosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    enunciado?: StringFieldUpdateOperationsInput | string
    explicacion?: NullableStringFieldUpdateOperationsInput | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    opciones?: JsonNullValueInput | InputJsonValue
    solucion?: JsonNullValueInput | InputJsonValue
    estado?: EnumPreguntaEstadoFieldUpdateOperationsInput | $Enums.PreguntaEstado
    gestion?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumPreguntaDificultadFieldUpdateOperationsInput | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasaAcierto?: IntFieldUpdateOperationsInput | number
    totalBien?: IntFieldUpdateOperationsInput | number
    totalMal?: IntFieldUpdateOperationsInput | number
    totalRespondidas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    reaccionesPreguntas?: reaccionesPreguntasUpdateManyWithoutPreguntaNestedInput
    respuestasIntentos?: respuestasIntentosUpdateManyWithoutPreguntasNestedInput
    areas?: areasUpdateManyWithoutPreguntasNestedInput
    banqueo?: banqueoUpdateManyWithoutPreguntasNestedInput
    capitulos?: capitulosUpdateManyWithoutPreguntasNestedInput
    temas?: temasUpdateManyWithoutPreguntasNestedInput
  }

  export type preguntasUncheckedUpdateWithoutRepasoRegistrosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    enunciado?: StringFieldUpdateOperationsInput | string
    explicacion?: NullableStringFieldUpdateOperationsInput | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    opciones?: JsonNullValueInput | InputJsonValue
    solucion?: JsonNullValueInput | InputJsonValue
    estado?: EnumPreguntaEstadoFieldUpdateOperationsInput | $Enums.PreguntaEstado
    gestion?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumPreguntaDificultadFieldUpdateOperationsInput | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasaAcierto?: IntFieldUpdateOperationsInput | number
    totalBien?: IntFieldUpdateOperationsInput | number
    totalMal?: IntFieldUpdateOperationsInput | number
    totalRespondidas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    reaccionesPreguntas?: reaccionesPreguntasUncheckedUpdateManyWithoutPreguntaNestedInput
    respuestasIntentos?: respuestasIntentosUncheckedUpdateManyWithoutPreguntasNestedInput
    areas?: areasUncheckedUpdateManyWithoutPreguntasNestedInput
    banqueo?: banqueoUncheckedUpdateManyWithoutPreguntasNestedInput
    capitulos?: capitulosUncheckedUpdateManyWithoutPreguntasNestedInput
    temas?: temasUncheckedUpdateManyWithoutPreguntasNestedInput
  }

  export type usuariosEstudiantesUpsertWithoutRepasoRegistrosInput = {
    update: XOR<usuariosEstudiantesUpdateWithoutRepasoRegistrosInput, usuariosEstudiantesUncheckedUpdateWithoutRepasoRegistrosInput>
    create: XOR<usuariosEstudiantesCreateWithoutRepasoRegistrosInput, usuariosEstudiantesUncheckedCreateWithoutRepasoRegistrosInput>
    where?: usuariosEstudiantesWhereInput
  }

  export type usuariosEstudiantesUpdateToOneWithWhereWithoutRepasoRegistrosInput = {
    where?: usuariosEstudiantesWhereInput
    data: XOR<usuariosEstudiantesUpdateWithoutRepasoRegistrosInput, usuariosEstudiantesUncheckedUpdateWithoutRepasoRegistrosInput>
  }

  export type usuariosEstudiantesUpdateWithoutRepasoRegistrosInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
    compras?: comprasUpdateManyWithoutUsuariosEstudiantesNestedInput
    intentos?: intentosUpdateManyWithoutUsuariosEstudiantesNestedInput
    reaccionesPreguntas?: reaccionesPreguntasUpdateManyWithoutUsuariosEstudiantesNestedInput
    reviewsCursos?: reviewsCursosUpdateManyWithoutUsuariosEstudiantesNestedInput
    suscripciones?: suscripcionesUpdateManyWithoutUsuariosEstudiantesNestedInput
    estudiantes?: estudiantesUpdateOneWithoutUsuariosEstudiantesNestedInput
  }

  export type usuariosEstudiantesUncheckedUpdateWithoutRepasoRegistrosInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
    compras?: comprasUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    intentos?: intentosUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    reaccionesPreguntas?: reaccionesPreguntasUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    reviewsCursos?: reviewsCursosUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    suscripciones?: suscripcionesUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
  }

  export type usuariosEstudiantesCreateWithoutSuscripcionesInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    avatar?: string | null
    registrado?: boolean
    compras?: comprasCreateNestedManyWithoutUsuariosEstudiantesInput
    intentos?: intentosCreateNestedManyWithoutUsuariosEstudiantesInput
    reaccionesPreguntas?: reaccionesPreguntasCreateNestedManyWithoutUsuariosEstudiantesInput
    repasoRegistros?: repasoRegistrosCreateNestedManyWithoutUsuariosEstudiantesInput
    reviewsCursos?: reviewsCursosCreateNestedManyWithoutUsuariosEstudiantesInput
    estudiantes?: estudiantesCreateNestedOneWithoutUsuariosEstudiantesInput
  }

  export type usuariosEstudiantesUncheckedCreateWithoutSuscripcionesInput = {
    id?: string
    correo: string
    contrasena: string
    usuario: string
    estado?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    avatar?: string | null
    estudianteId?: string | null
    registrado?: boolean
    compras?: comprasUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    intentos?: intentosUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    reaccionesPreguntas?: reaccionesPreguntasUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    repasoRegistros?: repasoRegistrosUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
    reviewsCursos?: reviewsCursosUncheckedCreateNestedManyWithoutUsuariosEstudiantesInput
  }

  export type usuariosEstudiantesCreateOrConnectWithoutSuscripcionesInput = {
    where: usuariosEstudiantesWhereUniqueInput
    create: XOR<usuariosEstudiantesCreateWithoutSuscripcionesInput, usuariosEstudiantesUncheckedCreateWithoutSuscripcionesInput>
  }

  export type usuariosEstudiantesUpsertWithoutSuscripcionesInput = {
    update: XOR<usuariosEstudiantesUpdateWithoutSuscripcionesInput, usuariosEstudiantesUncheckedUpdateWithoutSuscripcionesInput>
    create: XOR<usuariosEstudiantesCreateWithoutSuscripcionesInput, usuariosEstudiantesUncheckedCreateWithoutSuscripcionesInput>
    where?: usuariosEstudiantesWhereInput
  }

  export type usuariosEstudiantesUpdateToOneWithWhereWithoutSuscripcionesInput = {
    where?: usuariosEstudiantesWhereInput
    data: XOR<usuariosEstudiantesUpdateWithoutSuscripcionesInput, usuariosEstudiantesUncheckedUpdateWithoutSuscripcionesInput>
  }

  export type usuariosEstudiantesUpdateWithoutSuscripcionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
    compras?: comprasUpdateManyWithoutUsuariosEstudiantesNestedInput
    intentos?: intentosUpdateManyWithoutUsuariosEstudiantesNestedInput
    reaccionesPreguntas?: reaccionesPreguntasUpdateManyWithoutUsuariosEstudiantesNestedInput
    repasoRegistros?: repasoRegistrosUpdateManyWithoutUsuariosEstudiantesNestedInput
    reviewsCursos?: reviewsCursosUpdateManyWithoutUsuariosEstudiantesNestedInput
    estudiantes?: estudiantesUpdateOneWithoutUsuariosEstudiantesNestedInput
  }

  export type usuariosEstudiantesUncheckedUpdateWithoutSuscripcionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    contrasena?: StringFieldUpdateOperationsInput | string
    usuario?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    registrado?: BoolFieldUpdateOperationsInput | boolean
    compras?: comprasUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    intentos?: intentosUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    reaccionesPreguntas?: reaccionesPreguntasUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    repasoRegistros?: repasoRegistrosUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
    reviewsCursos?: reviewsCursosUncheckedUpdateManyWithoutUsuariosEstudiantesNestedInput
  }

  export type categoriasCursosCreateManyCategoriasInput = {
    id?: string
    cursoId: string
  }

  export type categoriasCursosUpdateWithoutCategoriasInput = {
    id?: StringFieldUpdateOperationsInput | string
    cursos?: cursosUpdateOneRequiredWithoutCategoriasCursosNestedInput
  }

  export type categoriasCursosUncheckedUpdateWithoutCategoriasInput = {
    id?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
  }

  export type categoriasCursosUncheckedUpdateManyWithoutCategoriasInput = {
    id?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
  }

  export type grabacionesCreateManyClasesInput = {
    id?: string
    usuarioId: string
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    duracionSegundos?: number | null
    completada?: boolean
  }

  export type materialesCreateManyClasesInput = {
    id?: string
    tipo?: $Enums.TipoMaterial
    titulo: string
    url: string
    creadoEn?: Date | string
  }

  export type grabacionesUpdateWithoutClasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duracionSegundos?: NullableIntFieldUpdateOperationsInput | number | null
    completada?: BoolFieldUpdateOperationsInput | boolean
    usuariosAdministradores?: usuariosAdministradoresUpdateOneRequiredWithoutGrabacionesNestedInput
  }

  export type grabacionesUncheckedUpdateWithoutClasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duracionSegundos?: NullableIntFieldUpdateOperationsInput | number | null
    completada?: BoolFieldUpdateOperationsInput | boolean
  }

  export type grabacionesUncheckedUpdateManyWithoutClasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duracionSegundos?: NullableIntFieldUpdateOperationsInput | number | null
    completada?: BoolFieldUpdateOperationsInput | boolean
  }

  export type materialesUpdateWithoutClasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoMaterialFieldUpdateOperationsInput | $Enums.TipoMaterial
    titulo?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type materialesUncheckedUpdateWithoutClasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoMaterialFieldUpdateOperationsInput | $Enums.TipoMaterial
    titulo?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type materialesUncheckedUpdateManyWithoutClasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoMaterialFieldUpdateOperationsInput | $Enums.TipoMaterial
    titulo?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type beneficiosCursosCreateManyCursosInput = {
    id?: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type categoriasCursosCreateManyCursosInput = {
    id?: string
    categoriaId: string
  }

  export type edicionesCursosCreateManyCursosInput = {
    id?: string
    codigo: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
    docenteId?: string | null
  }

  export type objetivosCursosCreateManyCursosInput = {
    id?: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type requisitosCursosCreateManyCursosInput = {
    id?: string
    descripcion: string
    orden: number
    creadoEn?: Date | string
  }

  export type reviewsCursosCreateManyCursosInput = {
    id?: string
    rating: number
    comentario?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
    usuariosEstudiantesId?: string | null
  }

  export type beneficiosCursosUpdateWithoutCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type beneficiosCursosUncheckedUpdateWithoutCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type beneficiosCursosUncheckedUpdateManyWithoutCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type categoriasCursosUpdateWithoutCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    categorias?: categoriasUpdateOneRequiredWithoutCategoriasCursosNestedInput
  }

  export type categoriasCursosUncheckedUpdateWithoutCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoriaId?: StringFieldUpdateOperationsInput | string
  }

  export type categoriasCursosUncheckedUpdateManyWithoutCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoriaId?: StringFieldUpdateOperationsInput | string
  }

  export type edicionesCursosUpdateWithoutCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    certificados?: certificadosUpdateManyWithoutEdicionesCursosNestedInput
    clases?: clasesUpdateManyWithoutEdicionesCursosNestedInput
    compras?: comprasUpdateManyWithoutEdicionesCursosNestedInput
    docente?: docenteUpdateOneWithoutEdicionesCursosNestedInput
    examenes?: examenesUpdateManyWithoutEdicionesCursosNestedInput
    inscripciones?: inscripcionesUpdateManyWithoutEdicionesCursosNestedInput
    pagosDocentes?: pagosDocentesUpdateOneWithoutEdicionesCursosNestedInput
    preciosCursos?: preciosCursosUpdateManyWithoutEdicionesCursosNestedInput
  }

  export type edicionesCursosUncheckedUpdateWithoutCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docenteId?: NullableStringFieldUpdateOperationsInput | string | null
    certificados?: certificadosUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    clases?: clasesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    compras?: comprasUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    examenes?: examenesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    pagosDocentes?: pagosDocentesUncheckedUpdateOneWithoutEdicionesCursosNestedInput
    preciosCursos?: preciosCursosUncheckedUpdateManyWithoutEdicionesCursosNestedInput
  }

  export type edicionesCursosUncheckedUpdateManyWithoutCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    docenteId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type objetivosCursosUpdateWithoutCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type objetivosCursosUncheckedUpdateWithoutCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type objetivosCursosUncheckedUpdateManyWithoutCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requisitosCursosUpdateWithoutCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requisitosCursosUncheckedUpdateWithoutCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type requisitosCursosUncheckedUpdateManyWithoutCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewsCursosUpdateWithoutCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosEstudiantes?: usuariosEstudiantesUpdateOneWithoutReviewsCursosNestedInput
  }

  export type reviewsCursosUncheckedUpdateWithoutCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosEstudiantesId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reviewsCursosUncheckedUpdateManyWithoutCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosEstudiantesId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type edicionesCursosCreateManyDocenteInput = {
    id?: string
    codigo: string
    cursoId: string
    descripcion?: string | null
    estado?: $Enums.EdicionEstado
    fechaFin: Date | string
    fechaInicio: Date | string
    notaMaxima?: number
    notaMinima?: number
    urlWhatsapp?: string | null
    vigente?: boolean
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type pagosDocentesCreateManyDocenteInput = {
    id?: string
    edicionId: string
    monto: number
    deuda?: number
    estadoPago?: $Enums.EstadoPago
    fechaPago?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type edicionesCursosUpdateWithoutDocenteInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    certificados?: certificadosUpdateManyWithoutEdicionesCursosNestedInput
    clases?: clasesUpdateManyWithoutEdicionesCursosNestedInput
    compras?: comprasUpdateManyWithoutEdicionesCursosNestedInput
    cursos?: cursosUpdateOneRequiredWithoutEdicionesCursosNestedInput
    examenes?: examenesUpdateManyWithoutEdicionesCursosNestedInput
    inscripciones?: inscripcionesUpdateManyWithoutEdicionesCursosNestedInput
    pagosDocentes?: pagosDocentesUpdateOneWithoutEdicionesCursosNestedInput
    preciosCursos?: preciosCursosUpdateManyWithoutEdicionesCursosNestedInput
  }

  export type edicionesCursosUncheckedUpdateWithoutDocenteInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    certificados?: certificadosUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    clases?: clasesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    compras?: comprasUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    examenes?: examenesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    inscripciones?: inscripcionesUncheckedUpdateManyWithoutEdicionesCursosNestedInput
    pagosDocentes?: pagosDocentesUncheckedUpdateOneWithoutEdicionesCursosNestedInput
    preciosCursos?: preciosCursosUncheckedUpdateManyWithoutEdicionesCursosNestedInput
  }

  export type edicionesCursosUncheckedUpdateManyWithoutDocenteInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEdicionEstadoFieldUpdateOperationsInput | $Enums.EdicionEstado
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    urlWhatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    vigente?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pagosDocentesUpdateWithoutDocenteInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    deuda?: FloatFieldUpdateOperationsInput | number
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    edicionesCursos?: edicionesCursosUpdateOneRequiredWithoutPagosDocentesNestedInput
  }

  export type pagosDocentesUncheckedUpdateWithoutDocenteInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    deuda?: FloatFieldUpdateOperationsInput | number
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pagosDocentesUncheckedUpdateManyWithoutDocenteInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    deuda?: FloatFieldUpdateOperationsInput | number
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type certificadosCreateManyEdicionesCursosInput = {
    id?: string
    codigoUnico: string
    estudianteId: string
    fechaEmision: Date | string
    tipo?: $Enums.TipoCertificado
    notaFinal?: number | null
    urlCertificado?: string | null
    creadoEn?: Date | string
  }

  export type clasesCreateManyEdicionesCursosInput = {
    id?: string
    descripcion: string
    duracion?: number | null
    fecha: Date | string
    orden: number
    titulo: string
    urlYoutube?: string | null
    creadoEn?: Date | string
    urlPresentacion?: string | null
  }

  export type comprasCreateManyEdicionesCursosInput = {
    id?: string
    monto: number
    moneda?: string
    comprobado?: boolean
    providerId: string
    fechaCompra?: Date | string
    metodo?: $Enums.MetodoPago
    deuda?: number
    usuariosEstudiantesId?: string | null
    estadoPago?: $Enums.EstadoPago
    updatedAt: Date | string
    conDescuento?: boolean
  }

  export type examenesCreateManyEdicionesCursosInput = {
    id?: string
    descripcion?: string | null
    fechaDisponible: Date | string
    fechaLimite: Date | string
    notaMaxima: number
    notaMinima: number
    titulo: string
    creadoEn?: Date | string
  }

  export type inscripcionesCreateManyEdicionesCursosInput = {
    id?: string
    estado?: boolean
    estudianteId: string
    inscritoEn?: Date | string
    compraId: string
  }

  export type preciosCursosCreateManyEdicionesCursosInput = {
    id?: string
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    esDescuento?: boolean
    esPrecioDefault?: boolean
    moneda?: string
    nombre: string
    porcentajeDescuento?: number | null
    precio: number
    precioOriginal?: number | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type certificadosUpdateWithoutEdicionesCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigoUnico?: StringFieldUpdateOperationsInput | string
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCertificadoFieldUpdateOperationsInput | $Enums.TipoCertificado
    notaFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    urlCertificado?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiantes?: estudiantesUpdateOneRequiredWithoutCertificadosNestedInput
  }

  export type certificadosUncheckedUpdateWithoutEdicionesCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigoUnico?: StringFieldUpdateOperationsInput | string
    estudianteId?: StringFieldUpdateOperationsInput | string
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCertificadoFieldUpdateOperationsInput | $Enums.TipoCertificado
    notaFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    urlCertificado?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type certificadosUncheckedUpdateManyWithoutEdicionesCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigoUnico?: StringFieldUpdateOperationsInput | string
    estudianteId?: StringFieldUpdateOperationsInput | string
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCertificadoFieldUpdateOperationsInput | $Enums.TipoCertificado
    notaFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    urlCertificado?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clasesUpdateWithoutEdicionesCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    orden?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    urlYoutube?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    urlPresentacion?: NullableStringFieldUpdateOperationsInput | string | null
    grabaciones?: grabacionesUpdateManyWithoutClasesNestedInput
    materiales?: materialesUpdateManyWithoutClasesNestedInput
  }

  export type clasesUncheckedUpdateWithoutEdicionesCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    orden?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    urlYoutube?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    urlPresentacion?: NullableStringFieldUpdateOperationsInput | string | null
    grabaciones?: grabacionesUncheckedUpdateManyWithoutClasesNestedInput
    materiales?: materialesUncheckedUpdateManyWithoutClasesNestedInput
  }

  export type clasesUncheckedUpdateManyWithoutEdicionesCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    orden?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    urlYoutube?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    urlPresentacion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type comprasUpdateWithoutEdicionesCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: StringFieldUpdateOperationsInput | string
    comprobado?: BoolFieldUpdateOperationsInput | boolean
    providerId?: StringFieldUpdateOperationsInput | string
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    deuda?: FloatFieldUpdateOperationsInput | number
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conDescuento?: BoolFieldUpdateOperationsInput | boolean
    usuariosEstudiantes?: usuariosEstudiantesUpdateOneWithoutComprasNestedInput
    inscripciones?: inscripcionesUpdateOneWithoutComprasNestedInput
  }

  export type comprasUncheckedUpdateWithoutEdicionesCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: StringFieldUpdateOperationsInput | string
    comprobado?: BoolFieldUpdateOperationsInput | boolean
    providerId?: StringFieldUpdateOperationsInput | string
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    deuda?: FloatFieldUpdateOperationsInput | number
    usuariosEstudiantesId?: NullableStringFieldUpdateOperationsInput | string | null
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conDescuento?: BoolFieldUpdateOperationsInput | boolean
    inscripciones?: inscripcionesUncheckedUpdateOneWithoutComprasNestedInput
  }

  export type comprasUncheckedUpdateManyWithoutEdicionesCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: StringFieldUpdateOperationsInput | string
    comprobado?: BoolFieldUpdateOperationsInput | boolean
    providerId?: StringFieldUpdateOperationsInput | string
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    deuda?: FloatFieldUpdateOperationsInput | number
    usuariosEstudiantesId?: NullableStringFieldUpdateOperationsInput | string | null
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conDescuento?: BoolFieldUpdateOperationsInput | boolean
  }

  export type examenesUpdateWithoutEdicionesCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaDisponible?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    calificaciones?: calificacionesUpdateManyWithoutExamenesNestedInput
  }

  export type examenesUncheckedUpdateWithoutEdicionesCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaDisponible?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    calificaciones?: calificacionesUncheckedUpdateManyWithoutExamenesNestedInput
  }

  export type examenesUncheckedUpdateManyWithoutEdicionesCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaDisponible?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaLimite?: DateTimeFieldUpdateOperationsInput | Date | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    notaMinima?: FloatFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inscripcionesUpdateWithoutEdicionesCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    inscritoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    compras?: comprasUpdateOneRequiredWithoutInscripcionesNestedInput
    estudiantes?: estudiantesUpdateOneRequiredWithoutInscripcionesNestedInput
  }

  export type inscripcionesUncheckedUpdateWithoutEdicionesCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    estudianteId?: StringFieldUpdateOperationsInput | string
    inscritoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    compraId?: StringFieldUpdateOperationsInput | string
  }

  export type inscripcionesUncheckedUpdateManyWithoutEdicionesCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    estudianteId?: StringFieldUpdateOperationsInput | string
    inscritoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    compraId?: StringFieldUpdateOperationsInput | string
  }

  export type preciosCursosUpdateWithoutEdicionesCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    esDescuento?: BoolFieldUpdateOperationsInput | boolean
    esPrecioDefault?: BoolFieldUpdateOperationsInput | boolean
    moneda?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    porcentajeDescuento?: NullableFloatFieldUpdateOperationsInput | number | null
    precio?: FloatFieldUpdateOperationsInput | number
    precioOriginal?: NullableFloatFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type preciosCursosUncheckedUpdateWithoutEdicionesCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    esDescuento?: BoolFieldUpdateOperationsInput | boolean
    esPrecioDefault?: BoolFieldUpdateOperationsInput | boolean
    moneda?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    porcentajeDescuento?: NullableFloatFieldUpdateOperationsInput | number | null
    precio?: FloatFieldUpdateOperationsInput | number
    precioOriginal?: NullableFloatFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type preciosCursosUncheckedUpdateManyWithoutEdicionesCursosInput = {
    id?: StringFieldUpdateOperationsInput | string
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    esDescuento?: BoolFieldUpdateOperationsInput | boolean
    esPrecioDefault?: BoolFieldUpdateOperationsInput | boolean
    moneda?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    porcentajeDescuento?: NullableFloatFieldUpdateOperationsInput | number | null
    precio?: FloatFieldUpdateOperationsInput | number
    precioOriginal?: NullableFloatFieldUpdateOperationsInput | number | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type calificacionesCreateManyEstudiantesInput = {
    id?: string
    aprobado?: boolean
    comentarios?: string | null
    examenId: string
    nota: number
    creadoEn?: Date | string
  }

  export type certificadosCreateManyEstudiantesInput = {
    id?: string
    codigoUnico: string
    edicionId: string
    fechaEmision: Date | string
    tipo?: $Enums.TipoCertificado
    notaFinal?: number | null
    urlCertificado?: string | null
    creadoEn?: Date | string
  }

  export type inscripcionesCreateManyEstudiantesInput = {
    id?: string
    edicionId: string
    estado?: boolean
    inscritoEn?: Date | string
    compraId: string
  }

  export type calificacionesUpdateWithoutEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    nota?: FloatFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    examenes?: examenesUpdateOneRequiredWithoutCalificacionesNestedInput
  }

  export type calificacionesUncheckedUpdateWithoutEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    examenId?: StringFieldUpdateOperationsInput | string
    nota?: FloatFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type calificacionesUncheckedUpdateManyWithoutEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    examenId?: StringFieldUpdateOperationsInput | string
    nota?: FloatFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type certificadosUpdateWithoutEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigoUnico?: StringFieldUpdateOperationsInput | string
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCertificadoFieldUpdateOperationsInput | $Enums.TipoCertificado
    notaFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    urlCertificado?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    edicionesCursos?: edicionesCursosUpdateOneRequiredWithoutCertificadosNestedInput
  }

  export type certificadosUncheckedUpdateWithoutEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigoUnico?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCertificadoFieldUpdateOperationsInput | $Enums.TipoCertificado
    notaFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    urlCertificado?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type certificadosUncheckedUpdateManyWithoutEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigoUnico?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: EnumTipoCertificadoFieldUpdateOperationsInput | $Enums.TipoCertificado
    notaFinal?: NullableFloatFieldUpdateOperationsInput | number | null
    urlCertificado?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inscripcionesUpdateWithoutEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    inscritoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    compras?: comprasUpdateOneRequiredWithoutInscripcionesNestedInput
    edicionesCursos?: edicionesCursosUpdateOneRequiredWithoutInscripcionesNestedInput
  }

  export type inscripcionesUncheckedUpdateWithoutEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    inscritoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    compraId?: StringFieldUpdateOperationsInput | string
  }

  export type inscripcionesUncheckedUpdateManyWithoutEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    inscritoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    compraId?: StringFieldUpdateOperationsInput | string
  }

  export type preguntasUpdateWithoutTemasInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    enunciado?: StringFieldUpdateOperationsInput | string
    explicacion?: NullableStringFieldUpdateOperationsInput | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    opciones?: JsonNullValueInput | InputJsonValue
    solucion?: JsonNullValueInput | InputJsonValue
    estado?: EnumPreguntaEstadoFieldUpdateOperationsInput | $Enums.PreguntaEstado
    gestion?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumPreguntaDificultadFieldUpdateOperationsInput | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasaAcierto?: IntFieldUpdateOperationsInput | number
    totalBien?: IntFieldUpdateOperationsInput | number
    totalMal?: IntFieldUpdateOperationsInput | number
    totalRespondidas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    reaccionesPreguntas?: reaccionesPreguntasUpdateManyWithoutPreguntaNestedInput
    repasoRegistros?: repasoRegistrosUpdateManyWithoutPreguntasNestedInput
    respuestasIntentos?: respuestasIntentosUpdateManyWithoutPreguntasNestedInput
    areas?: areasUpdateManyWithoutPreguntasNestedInput
    banqueo?: banqueoUpdateManyWithoutPreguntasNestedInput
    capitulos?: capitulosUpdateManyWithoutPreguntasNestedInput
  }

  export type preguntasUncheckedUpdateWithoutTemasInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    enunciado?: StringFieldUpdateOperationsInput | string
    explicacion?: NullableStringFieldUpdateOperationsInput | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    opciones?: JsonNullValueInput | InputJsonValue
    solucion?: JsonNullValueInput | InputJsonValue
    estado?: EnumPreguntaEstadoFieldUpdateOperationsInput | $Enums.PreguntaEstado
    gestion?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumPreguntaDificultadFieldUpdateOperationsInput | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasaAcierto?: IntFieldUpdateOperationsInput | number
    totalBien?: IntFieldUpdateOperationsInput | number
    totalMal?: IntFieldUpdateOperationsInput | number
    totalRespondidas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    reaccionesPreguntas?: reaccionesPreguntasUncheckedUpdateManyWithoutPreguntaNestedInput
    repasoRegistros?: repasoRegistrosUncheckedUpdateManyWithoutPreguntasNestedInput
    respuestasIntentos?: respuestasIntentosUncheckedUpdateManyWithoutPreguntasNestedInput
    areas?: areasUncheckedUpdateManyWithoutPreguntasNestedInput
    banqueo?: banqueoUncheckedUpdateManyWithoutPreguntasNestedInput
    capitulos?: capitulosUncheckedUpdateManyWithoutPreguntasNestedInput
  }

  export type preguntasUncheckedUpdateManyWithoutTemasInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    enunciado?: StringFieldUpdateOperationsInput | string
    explicacion?: NullableStringFieldUpdateOperationsInput | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    opciones?: JsonNullValueInput | InputJsonValue
    solucion?: JsonNullValueInput | InputJsonValue
    estado?: EnumPreguntaEstadoFieldUpdateOperationsInput | $Enums.PreguntaEstado
    gestion?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumPreguntaDificultadFieldUpdateOperationsInput | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasaAcierto?: IntFieldUpdateOperationsInput | number
    totalBien?: IntFieldUpdateOperationsInput | number
    totalMal?: IntFieldUpdateOperationsInput | number
    totalRespondidas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type calificacionesCreateManyExamenesInput = {
    id?: string
    aprobado?: boolean
    comentarios?: string | null
    estudianteId: string
    nota: number
    creadoEn?: Date | string
  }

  export type calificacionesUpdateWithoutExamenesInput = {
    id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    nota?: FloatFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    estudiantes?: estudiantesUpdateOneRequiredWithoutCalificacionesNestedInput
  }

  export type calificacionesUncheckedUpdateWithoutExamenesInput = {
    id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: StringFieldUpdateOperationsInput | string
    nota?: FloatFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type calificacionesUncheckedUpdateManyWithoutExamenesInput = {
    id?: StringFieldUpdateOperationsInput | string
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    comentarios?: NullableStringFieldUpdateOperationsInput | string | null
    estudianteId?: StringFieldUpdateOperationsInput | string
    nota?: FloatFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reaccionesPreguntasCreateManyPreguntaInput = {
    id?: string
    usuarioEstudianteId: string
    tipo: $Enums.TipoReaccion
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type repasoRegistrosCreateManyPreguntasInput = {
    id?: string
    usuarioEstudianteId: string
    banqueoId: string
    esCorrecta: boolean
    creadoEn?: Date | string
  }

  export type respuestasIntentosCreateManyPreguntasInput = {
    id?: string
    intentoId: string
    respuesta?: NullableJsonNullValueInput | InputJsonValue
    resultado?: $Enums.ResultadoRespuesta
    esCorrecta?: boolean | null
    respondida?: boolean
    visitada?: boolean
    marcadaRevision?: boolean
    tiempoConsumidoSeg?: number
    orden?: number | null
    respondidaEn?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type reaccionesPreguntasUpdateWithoutPreguntaInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoReaccionFieldUpdateOperationsInput | $Enums.TipoReaccion
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosEstudiantes?: usuariosEstudiantesUpdateOneRequiredWithoutReaccionesPreguntasNestedInput
  }

  export type reaccionesPreguntasUncheckedUpdateWithoutPreguntaInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioEstudianteId?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoReaccionFieldUpdateOperationsInput | $Enums.TipoReaccion
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reaccionesPreguntasUncheckedUpdateManyWithoutPreguntaInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioEstudianteId?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoReaccionFieldUpdateOperationsInput | $Enums.TipoReaccion
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type repasoRegistrosUpdateWithoutPreguntasInput = {
    id?: StringFieldUpdateOperationsInput | string
    esCorrecta?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    banqueo?: banqueoUpdateOneRequiredWithoutRepasoRegistrosNestedInput
    usuariosEstudiantes?: usuariosEstudiantesUpdateOneRequiredWithoutRepasoRegistrosNestedInput
  }

  export type repasoRegistrosUncheckedUpdateWithoutPreguntasInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioEstudianteId?: StringFieldUpdateOperationsInput | string
    banqueoId?: StringFieldUpdateOperationsInput | string
    esCorrecta?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type repasoRegistrosUncheckedUpdateManyWithoutPreguntasInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioEstudianteId?: StringFieldUpdateOperationsInput | string
    banqueoId?: StringFieldUpdateOperationsInput | string
    esCorrecta?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type respuestasIntentosUpdateWithoutPreguntasInput = {
    id?: StringFieldUpdateOperationsInput | string
    respuesta?: NullableJsonNullValueInput | InputJsonValue
    resultado?: EnumResultadoRespuestaFieldUpdateOperationsInput | $Enums.ResultadoRespuesta
    esCorrecta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    respondida?: BoolFieldUpdateOperationsInput | boolean
    visitada?: BoolFieldUpdateOperationsInput | boolean
    marcadaRevision?: BoolFieldUpdateOperationsInput | boolean
    tiempoConsumidoSeg?: IntFieldUpdateOperationsInput | number
    orden?: NullableIntFieldUpdateOperationsInput | number | null
    respondidaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    intentos?: intentosUpdateOneRequiredWithoutRespuestasIntentosNestedInput
  }

  export type respuestasIntentosUncheckedUpdateWithoutPreguntasInput = {
    id?: StringFieldUpdateOperationsInput | string
    intentoId?: StringFieldUpdateOperationsInput | string
    respuesta?: NullableJsonNullValueInput | InputJsonValue
    resultado?: EnumResultadoRespuestaFieldUpdateOperationsInput | $Enums.ResultadoRespuesta
    esCorrecta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    respondida?: BoolFieldUpdateOperationsInput | boolean
    visitada?: BoolFieldUpdateOperationsInput | boolean
    marcadaRevision?: BoolFieldUpdateOperationsInput | boolean
    tiempoConsumidoSeg?: IntFieldUpdateOperationsInput | number
    orden?: NullableIntFieldUpdateOperationsInput | number | null
    respondidaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type respuestasIntentosUncheckedUpdateManyWithoutPreguntasInput = {
    id?: StringFieldUpdateOperationsInput | string
    intentoId?: StringFieldUpdateOperationsInput | string
    respuesta?: NullableJsonNullValueInput | InputJsonValue
    resultado?: EnumResultadoRespuestaFieldUpdateOperationsInput | $Enums.ResultadoRespuesta
    esCorrecta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    respondida?: BoolFieldUpdateOperationsInput | boolean
    visitada?: BoolFieldUpdateOperationsInput | boolean
    marcadaRevision?: BoolFieldUpdateOperationsInput | boolean
    tiempoConsumidoSeg?: IntFieldUpdateOperationsInput | number
    orden?: NullableIntFieldUpdateOperationsInput | number | null
    respondidaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type areasUpdateWithoutPreguntasInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    capitulos?: capitulosUpdateManyWithoutAreasNestedInput
  }

  export type areasUncheckedUpdateWithoutPreguntasInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    capitulos?: capitulosUncheckedUpdateManyWithoutAreasNestedInput
  }

  export type areasUncheckedUpdateManyWithoutPreguntasInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type banqueoUpdateWithoutPreguntasInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    tipo?: EnumBanqueoTipoFieldUpdateOperationsInput | $Enums.BanqueoTipo
    tipoCreado?: EnumBanqueoTipoCreadoFieldUpdateOperationsInput | $Enums.BanqueoTipoCreado
    duracion?: IntFieldUpdateOperationsInput | number
    maxPreguntas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    intentos?: intentosUpdateManyWithoutBanqueoNestedInput
    repasoRegistros?: repasoRegistrosUpdateManyWithoutBanqueoNestedInput
  }

  export type banqueoUncheckedUpdateWithoutPreguntasInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    tipo?: EnumBanqueoTipoFieldUpdateOperationsInput | $Enums.BanqueoTipo
    tipoCreado?: EnumBanqueoTipoCreadoFieldUpdateOperationsInput | $Enums.BanqueoTipoCreado
    duracion?: IntFieldUpdateOperationsInput | number
    maxPreguntas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    intentos?: intentosUncheckedUpdateManyWithoutBanqueoNestedInput
    repasoRegistros?: repasoRegistrosUncheckedUpdateManyWithoutBanqueoNestedInput
  }

  export type banqueoUncheckedUpdateManyWithoutPreguntasInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    tipo?: EnumBanqueoTipoFieldUpdateOperationsInput | $Enums.BanqueoTipo
    tipoCreado?: EnumBanqueoTipoCreadoFieldUpdateOperationsInput | $Enums.BanqueoTipoCreado
    duracion?: IntFieldUpdateOperationsInput | number
    maxPreguntas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type capitulosUpdateWithoutPreguntasInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    areas?: areasUpdateOneWithoutCapitulosNestedInput
    temas?: temasUpdateManyWithoutCapitulosNestedInput
  }

  export type capitulosUncheckedUpdateWithoutPreguntasInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    temas?: temasUncheckedUpdateManyWithoutCapitulosNestedInput
  }

  export type capitulosUncheckedUpdateManyWithoutPreguntasInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    areaId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type temasUpdateWithoutPreguntasInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    capitulos?: capitulosUpdateOneWithoutTemasNestedInput
  }

  export type temasUncheckedUpdateWithoutPreguntasInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    capituloId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type temasUncheckedUpdateManyWithoutPreguntasInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    capituloId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auditoriaCreateManyUsuariosAdministradoresInput = {
    id?: string
    tabla: $Enums.Tabla
    registroId?: string | null
    accion: $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    creadoEn?: Date | string
  }

  export type grabacionesCreateManyUsuariosAdministradoresInput = {
    id?: string
    claseId: string
    fechaInicio?: Date | string
    fechaFin?: Date | string | null
    duracionSegundos?: number | null
    completada?: boolean
  }

  export type auditoriaUpdateWithoutUsuariosAdministradoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    tabla?: EnumTablaFieldUpdateOperationsInput | $Enums.Tabla
    registroId?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: EnumAccionAuditoriaFieldUpdateOperationsInput | $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auditoriaUncheckedUpdateWithoutUsuariosAdministradoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    tabla?: EnumTablaFieldUpdateOperationsInput | $Enums.Tabla
    registroId?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: EnumAccionAuditoriaFieldUpdateOperationsInput | $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auditoriaUncheckedUpdateManyWithoutUsuariosAdministradoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    tabla?: EnumTablaFieldUpdateOperationsInput | $Enums.Tabla
    registroId?: NullableStringFieldUpdateOperationsInput | string | null
    accion?: EnumAccionAuditoriaFieldUpdateOperationsInput | $Enums.AccionAuditoria
    detalles?: NullableJsonNullValueInput | InputJsonValue
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type grabacionesUpdateWithoutUsuariosAdministradoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duracionSegundos?: NullableIntFieldUpdateOperationsInput | number | null
    completada?: BoolFieldUpdateOperationsInput | boolean
    clases?: clasesUpdateOneRequiredWithoutGrabacionesNestedInput
  }

  export type grabacionesUncheckedUpdateWithoutUsuariosAdministradoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    claseId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duracionSegundos?: NullableIntFieldUpdateOperationsInput | number | null
    completada?: BoolFieldUpdateOperationsInput | boolean
  }

  export type grabacionesUncheckedUpdateManyWithoutUsuariosAdministradoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    claseId?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duracionSegundos?: NullableIntFieldUpdateOperationsInput | number | null
    completada?: BoolFieldUpdateOperationsInput | boolean
  }

  export type comprasCreateManyUsuariosEstudiantesInput = {
    id?: string
    edicionId: string
    monto: number
    moneda?: string
    comprobado?: boolean
    providerId: string
    fechaCompra?: Date | string
    metodo?: $Enums.MetodoPago
    deuda?: number
    estadoPago?: $Enums.EstadoPago
    updatedAt: Date | string
    conDescuento?: boolean
  }

  export type intentosCreateManyUsuariosEstudiantesInput = {
    id?: string
    banqueoId: string
    tiempoDuracion: number
    correctas?: number
    incorrectas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    estado?: $Enums.EstadoIntento
  }

  export type reaccionesPreguntasCreateManyUsuariosEstudiantesInput = {
    id?: string
    preguntaId: string
    tipo: $Enums.TipoReaccion
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type repasoRegistrosCreateManyUsuariosEstudiantesInput = {
    id?: string
    banqueoId: string
    preguntaId: string
    esCorrecta: boolean
    creadoEn?: Date | string
  }

  export type reviewsCursosCreateManyUsuariosEstudiantesInput = {
    id?: string
    cursoId: string
    rating: number
    comentario?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type suscripcionesCreateManyUsuariosEstudiantesInput = {
    id?: string
    montoUsd: number
    fechaInicio?: Date | string
    fechaFin: Date | string
    estado?: $Enums.EstadoSuscripcion
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type comprasUpdateWithoutUsuariosEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: StringFieldUpdateOperationsInput | string
    comprobado?: BoolFieldUpdateOperationsInput | boolean
    providerId?: StringFieldUpdateOperationsInput | string
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    deuda?: FloatFieldUpdateOperationsInput | number
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conDescuento?: BoolFieldUpdateOperationsInput | boolean
    edicionesCursos?: edicionesCursosUpdateOneRequiredWithoutComprasNestedInput
    inscripciones?: inscripcionesUpdateOneWithoutComprasNestedInput
  }

  export type comprasUncheckedUpdateWithoutUsuariosEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: StringFieldUpdateOperationsInput | string
    comprobado?: BoolFieldUpdateOperationsInput | boolean
    providerId?: StringFieldUpdateOperationsInput | string
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    deuda?: FloatFieldUpdateOperationsInput | number
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conDescuento?: BoolFieldUpdateOperationsInput | boolean
    inscripciones?: inscripcionesUncheckedUpdateOneWithoutComprasNestedInput
  }

  export type comprasUncheckedUpdateManyWithoutUsuariosEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    edicionId?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: StringFieldUpdateOperationsInput | string
    comprobado?: BoolFieldUpdateOperationsInput | boolean
    providerId?: StringFieldUpdateOperationsInput | string
    fechaCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    metodo?: EnumMetodoPagoFieldUpdateOperationsInput | $Enums.MetodoPago
    deuda?: FloatFieldUpdateOperationsInput | number
    estadoPago?: EnumEstadoPagoFieldUpdateOperationsInput | $Enums.EstadoPago
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conDescuento?: BoolFieldUpdateOperationsInput | boolean
  }

  export type intentosUpdateWithoutUsuariosEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tiempoDuracion?: IntFieldUpdateOperationsInput | number
    correctas?: IntFieldUpdateOperationsInput | number
    incorrectas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoIntentoFieldUpdateOperationsInput | $Enums.EstadoIntento
    banqueo?: banqueoUpdateOneRequiredWithoutIntentosNestedInput
    respuestasIntentos?: respuestasIntentosUpdateManyWithoutIntentosNestedInput
  }

  export type intentosUncheckedUpdateWithoutUsuariosEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    banqueoId?: StringFieldUpdateOperationsInput | string
    tiempoDuracion?: IntFieldUpdateOperationsInput | number
    correctas?: IntFieldUpdateOperationsInput | number
    incorrectas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoIntentoFieldUpdateOperationsInput | $Enums.EstadoIntento
    respuestasIntentos?: respuestasIntentosUncheckedUpdateManyWithoutIntentosNestedInput
  }

  export type intentosUncheckedUpdateManyWithoutUsuariosEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    banqueoId?: StringFieldUpdateOperationsInput | string
    tiempoDuracion?: IntFieldUpdateOperationsInput | number
    correctas?: IntFieldUpdateOperationsInput | number
    incorrectas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoIntentoFieldUpdateOperationsInput | $Enums.EstadoIntento
  }

  export type reaccionesPreguntasUpdateWithoutUsuariosEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoReaccionFieldUpdateOperationsInput | $Enums.TipoReaccion
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    pregunta?: preguntasUpdateOneRequiredWithoutReaccionesPreguntasNestedInput
  }

  export type reaccionesPreguntasUncheckedUpdateWithoutUsuariosEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    preguntaId?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoReaccionFieldUpdateOperationsInput | $Enums.TipoReaccion
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reaccionesPreguntasUncheckedUpdateManyWithoutUsuariosEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    preguntaId?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoReaccionFieldUpdateOperationsInput | $Enums.TipoReaccion
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type repasoRegistrosUpdateWithoutUsuariosEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    esCorrecta?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    banqueo?: banqueoUpdateOneRequiredWithoutRepasoRegistrosNestedInput
    preguntas?: preguntasUpdateOneRequiredWithoutRepasoRegistrosNestedInput
  }

  export type repasoRegistrosUncheckedUpdateWithoutUsuariosEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    banqueoId?: StringFieldUpdateOperationsInput | string
    preguntaId?: StringFieldUpdateOperationsInput | string
    esCorrecta?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type repasoRegistrosUncheckedUpdateManyWithoutUsuariosEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    banqueoId?: StringFieldUpdateOperationsInput | string
    preguntaId?: StringFieldUpdateOperationsInput | string
    esCorrecta?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewsCursosUpdateWithoutUsuariosEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    cursos?: cursosUpdateOneRequiredWithoutReviewsCursosNestedInput
  }

  export type reviewsCursosUncheckedUpdateWithoutUsuariosEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewsCursosUncheckedUpdateManyWithoutUsuariosEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    cursoId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type suscripcionesUpdateWithoutUsuariosEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    montoUsd?: FloatFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoSuscripcionFieldUpdateOperationsInput | $Enums.EstadoSuscripcion
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type suscripcionesUncheckedUpdateWithoutUsuariosEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    montoUsd?: FloatFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoSuscripcionFieldUpdateOperationsInput | $Enums.EstadoSuscripcion
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type suscripcionesUncheckedUpdateManyWithoutUsuariosEstudiantesInput = {
    id?: StringFieldUpdateOperationsInput | string
    montoUsd?: FloatFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoSuscripcionFieldUpdateOperationsInput | $Enums.EstadoSuscripcion
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type capitulosCreateManyAreasInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type capitulosUpdateWithoutAreasInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    temas?: temasUpdateManyWithoutCapitulosNestedInput
    preguntas?: preguntasUpdateManyWithoutCapitulosNestedInput
  }

  export type capitulosUncheckedUpdateWithoutAreasInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    temas?: temasUncheckedUpdateManyWithoutCapitulosNestedInput
    preguntas?: preguntasUncheckedUpdateManyWithoutCapitulosNestedInput
  }

  export type capitulosUncheckedUpdateManyWithoutAreasInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type preguntasUpdateWithoutAreasInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    enunciado?: StringFieldUpdateOperationsInput | string
    explicacion?: NullableStringFieldUpdateOperationsInput | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    opciones?: JsonNullValueInput | InputJsonValue
    solucion?: JsonNullValueInput | InputJsonValue
    estado?: EnumPreguntaEstadoFieldUpdateOperationsInput | $Enums.PreguntaEstado
    gestion?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumPreguntaDificultadFieldUpdateOperationsInput | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasaAcierto?: IntFieldUpdateOperationsInput | number
    totalBien?: IntFieldUpdateOperationsInput | number
    totalMal?: IntFieldUpdateOperationsInput | number
    totalRespondidas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    reaccionesPreguntas?: reaccionesPreguntasUpdateManyWithoutPreguntaNestedInput
    repasoRegistros?: repasoRegistrosUpdateManyWithoutPreguntasNestedInput
    respuestasIntentos?: respuestasIntentosUpdateManyWithoutPreguntasNestedInput
    banqueo?: banqueoUpdateManyWithoutPreguntasNestedInput
    capitulos?: capitulosUpdateManyWithoutPreguntasNestedInput
    temas?: temasUpdateManyWithoutPreguntasNestedInput
  }

  export type preguntasUncheckedUpdateWithoutAreasInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    enunciado?: StringFieldUpdateOperationsInput | string
    explicacion?: NullableStringFieldUpdateOperationsInput | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    opciones?: JsonNullValueInput | InputJsonValue
    solucion?: JsonNullValueInput | InputJsonValue
    estado?: EnumPreguntaEstadoFieldUpdateOperationsInput | $Enums.PreguntaEstado
    gestion?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumPreguntaDificultadFieldUpdateOperationsInput | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasaAcierto?: IntFieldUpdateOperationsInput | number
    totalBien?: IntFieldUpdateOperationsInput | number
    totalMal?: IntFieldUpdateOperationsInput | number
    totalRespondidas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    reaccionesPreguntas?: reaccionesPreguntasUncheckedUpdateManyWithoutPreguntaNestedInput
    repasoRegistros?: repasoRegistrosUncheckedUpdateManyWithoutPreguntasNestedInput
    respuestasIntentos?: respuestasIntentosUncheckedUpdateManyWithoutPreguntasNestedInput
    banqueo?: banqueoUncheckedUpdateManyWithoutPreguntasNestedInput
    capitulos?: capitulosUncheckedUpdateManyWithoutPreguntasNestedInput
    temas?: temasUncheckedUpdateManyWithoutPreguntasNestedInput
  }

  export type preguntasUncheckedUpdateManyWithoutAreasInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    enunciado?: StringFieldUpdateOperationsInput | string
    explicacion?: NullableStringFieldUpdateOperationsInput | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    opciones?: JsonNullValueInput | InputJsonValue
    solucion?: JsonNullValueInput | InputJsonValue
    estado?: EnumPreguntaEstadoFieldUpdateOperationsInput | $Enums.PreguntaEstado
    gestion?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumPreguntaDificultadFieldUpdateOperationsInput | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasaAcierto?: IntFieldUpdateOperationsInput | number
    totalBien?: IntFieldUpdateOperationsInput | number
    totalMal?: IntFieldUpdateOperationsInput | number
    totalRespondidas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type intentosCreateManyBanqueoInput = {
    id?: string
    usuarioEstudianteId?: string | null
    tiempoDuracion: number
    correctas?: number
    incorrectas?: number
    creadoEn?: Date | string
    actualizadoEn: Date | string
    estado?: $Enums.EstadoIntento
  }

  export type repasoRegistrosCreateManyBanqueoInput = {
    id?: string
    usuarioEstudianteId: string
    preguntaId: string
    esCorrecta: boolean
    creadoEn?: Date | string
  }

  export type intentosUpdateWithoutBanqueoInput = {
    id?: StringFieldUpdateOperationsInput | string
    tiempoDuracion?: IntFieldUpdateOperationsInput | number
    correctas?: IntFieldUpdateOperationsInput | number
    incorrectas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoIntentoFieldUpdateOperationsInput | $Enums.EstadoIntento
    usuariosEstudiantes?: usuariosEstudiantesUpdateOneWithoutIntentosNestedInput
    respuestasIntentos?: respuestasIntentosUpdateManyWithoutIntentosNestedInput
  }

  export type intentosUncheckedUpdateWithoutBanqueoInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioEstudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    tiempoDuracion?: IntFieldUpdateOperationsInput | number
    correctas?: IntFieldUpdateOperationsInput | number
    incorrectas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoIntentoFieldUpdateOperationsInput | $Enums.EstadoIntento
    respuestasIntentos?: respuestasIntentosUncheckedUpdateManyWithoutIntentosNestedInput
  }

  export type intentosUncheckedUpdateManyWithoutBanqueoInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioEstudianteId?: NullableStringFieldUpdateOperationsInput | string | null
    tiempoDuracion?: IntFieldUpdateOperationsInput | number
    correctas?: IntFieldUpdateOperationsInput | number
    incorrectas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoIntentoFieldUpdateOperationsInput | $Enums.EstadoIntento
  }

  export type repasoRegistrosUpdateWithoutBanqueoInput = {
    id?: StringFieldUpdateOperationsInput | string
    esCorrecta?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    preguntas?: preguntasUpdateOneRequiredWithoutRepasoRegistrosNestedInput
    usuariosEstudiantes?: usuariosEstudiantesUpdateOneRequiredWithoutRepasoRegistrosNestedInput
  }

  export type repasoRegistrosUncheckedUpdateWithoutBanqueoInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioEstudianteId?: StringFieldUpdateOperationsInput | string
    preguntaId?: StringFieldUpdateOperationsInput | string
    esCorrecta?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type repasoRegistrosUncheckedUpdateManyWithoutBanqueoInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioEstudianteId?: StringFieldUpdateOperationsInput | string
    preguntaId?: StringFieldUpdateOperationsInput | string
    esCorrecta?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type preguntasUpdateWithoutBanqueoInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    enunciado?: StringFieldUpdateOperationsInput | string
    explicacion?: NullableStringFieldUpdateOperationsInput | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    opciones?: JsonNullValueInput | InputJsonValue
    solucion?: JsonNullValueInput | InputJsonValue
    estado?: EnumPreguntaEstadoFieldUpdateOperationsInput | $Enums.PreguntaEstado
    gestion?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumPreguntaDificultadFieldUpdateOperationsInput | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasaAcierto?: IntFieldUpdateOperationsInput | number
    totalBien?: IntFieldUpdateOperationsInput | number
    totalMal?: IntFieldUpdateOperationsInput | number
    totalRespondidas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    reaccionesPreguntas?: reaccionesPreguntasUpdateManyWithoutPreguntaNestedInput
    repasoRegistros?: repasoRegistrosUpdateManyWithoutPreguntasNestedInput
    respuestasIntentos?: respuestasIntentosUpdateManyWithoutPreguntasNestedInput
    areas?: areasUpdateManyWithoutPreguntasNestedInput
    capitulos?: capitulosUpdateManyWithoutPreguntasNestedInput
    temas?: temasUpdateManyWithoutPreguntasNestedInput
  }

  export type preguntasUncheckedUpdateWithoutBanqueoInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    enunciado?: StringFieldUpdateOperationsInput | string
    explicacion?: NullableStringFieldUpdateOperationsInput | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    opciones?: JsonNullValueInput | InputJsonValue
    solucion?: JsonNullValueInput | InputJsonValue
    estado?: EnumPreguntaEstadoFieldUpdateOperationsInput | $Enums.PreguntaEstado
    gestion?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumPreguntaDificultadFieldUpdateOperationsInput | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasaAcierto?: IntFieldUpdateOperationsInput | number
    totalBien?: IntFieldUpdateOperationsInput | number
    totalMal?: IntFieldUpdateOperationsInput | number
    totalRespondidas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    reaccionesPreguntas?: reaccionesPreguntasUncheckedUpdateManyWithoutPreguntaNestedInput
    repasoRegistros?: repasoRegistrosUncheckedUpdateManyWithoutPreguntasNestedInput
    respuestasIntentos?: respuestasIntentosUncheckedUpdateManyWithoutPreguntasNestedInput
    areas?: areasUncheckedUpdateManyWithoutPreguntasNestedInput
    capitulos?: capitulosUncheckedUpdateManyWithoutPreguntasNestedInput
    temas?: temasUncheckedUpdateManyWithoutPreguntasNestedInput
  }

  export type preguntasUncheckedUpdateManyWithoutBanqueoInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    enunciado?: StringFieldUpdateOperationsInput | string
    explicacion?: NullableStringFieldUpdateOperationsInput | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    opciones?: JsonNullValueInput | InputJsonValue
    solucion?: JsonNullValueInput | InputJsonValue
    estado?: EnumPreguntaEstadoFieldUpdateOperationsInput | $Enums.PreguntaEstado
    gestion?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumPreguntaDificultadFieldUpdateOperationsInput | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasaAcierto?: IntFieldUpdateOperationsInput | number
    totalBien?: IntFieldUpdateOperationsInput | number
    totalMal?: IntFieldUpdateOperationsInput | number
    totalRespondidas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type temasCreateManyCapitulosInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type temasUpdateWithoutCapitulosInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    preguntas?: preguntasUpdateManyWithoutTemasNestedInput
  }

  export type temasUncheckedUpdateWithoutCapitulosInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    preguntas?: preguntasUncheckedUpdateManyWithoutTemasNestedInput
  }

  export type temasUncheckedUpdateManyWithoutCapitulosInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type preguntasUpdateWithoutCapitulosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    enunciado?: StringFieldUpdateOperationsInput | string
    explicacion?: NullableStringFieldUpdateOperationsInput | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    opciones?: JsonNullValueInput | InputJsonValue
    solucion?: JsonNullValueInput | InputJsonValue
    estado?: EnumPreguntaEstadoFieldUpdateOperationsInput | $Enums.PreguntaEstado
    gestion?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumPreguntaDificultadFieldUpdateOperationsInput | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasaAcierto?: IntFieldUpdateOperationsInput | number
    totalBien?: IntFieldUpdateOperationsInput | number
    totalMal?: IntFieldUpdateOperationsInput | number
    totalRespondidas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    reaccionesPreguntas?: reaccionesPreguntasUpdateManyWithoutPreguntaNestedInput
    repasoRegistros?: repasoRegistrosUpdateManyWithoutPreguntasNestedInput
    respuestasIntentos?: respuestasIntentosUpdateManyWithoutPreguntasNestedInput
    areas?: areasUpdateManyWithoutPreguntasNestedInput
    banqueo?: banqueoUpdateManyWithoutPreguntasNestedInput
    temas?: temasUpdateManyWithoutPreguntasNestedInput
  }

  export type preguntasUncheckedUpdateWithoutCapitulosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    enunciado?: StringFieldUpdateOperationsInput | string
    explicacion?: NullableStringFieldUpdateOperationsInput | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    opciones?: JsonNullValueInput | InputJsonValue
    solucion?: JsonNullValueInput | InputJsonValue
    estado?: EnumPreguntaEstadoFieldUpdateOperationsInput | $Enums.PreguntaEstado
    gestion?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumPreguntaDificultadFieldUpdateOperationsInput | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasaAcierto?: IntFieldUpdateOperationsInput | number
    totalBien?: IntFieldUpdateOperationsInput | number
    totalMal?: IntFieldUpdateOperationsInput | number
    totalRespondidas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    reaccionesPreguntas?: reaccionesPreguntasUncheckedUpdateManyWithoutPreguntaNestedInput
    repasoRegistros?: repasoRegistrosUncheckedUpdateManyWithoutPreguntasNestedInput
    respuestasIntentos?: respuestasIntentosUncheckedUpdateManyWithoutPreguntasNestedInput
    areas?: areasUncheckedUpdateManyWithoutPreguntasNestedInput
    banqueo?: banqueoUncheckedUpdateManyWithoutPreguntasNestedInput
    temas?: temasUncheckedUpdateManyWithoutPreguntasNestedInput
  }

  export type preguntasUncheckedUpdateManyWithoutCapitulosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    enunciado?: StringFieldUpdateOperationsInput | string
    explicacion?: NullableStringFieldUpdateOperationsInput | string | null
    referencia?: NullableStringFieldUpdateOperationsInput | string | null
    opciones?: JsonNullValueInput | InputJsonValue
    solucion?: JsonNullValueInput | InputJsonValue
    estado?: EnumPreguntaEstadoFieldUpdateOperationsInput | $Enums.PreguntaEstado
    gestion?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    dificultad?: EnumPreguntaDificultadFieldUpdateOperationsInput | $Enums.PreguntaDificultad
    dificultadActualizadaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasaAcierto?: IntFieldUpdateOperationsInput | number
    totalBien?: IntFieldUpdateOperationsInput | number
    totalMal?: IntFieldUpdateOperationsInput | number
    totalRespondidas?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type respuestasIntentosCreateManyIntentosInput = {
    id?: string
    preguntaId: string
    respuesta?: NullableJsonNullValueInput | InputJsonValue
    resultado?: $Enums.ResultadoRespuesta
    esCorrecta?: boolean | null
    respondida?: boolean
    visitada?: boolean
    marcadaRevision?: boolean
    tiempoConsumidoSeg?: number
    orden?: number | null
    respondidaEn?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn: Date | string
  }

  export type respuestasIntentosUpdateWithoutIntentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    respuesta?: NullableJsonNullValueInput | InputJsonValue
    resultado?: EnumResultadoRespuestaFieldUpdateOperationsInput | $Enums.ResultadoRespuesta
    esCorrecta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    respondida?: BoolFieldUpdateOperationsInput | boolean
    visitada?: BoolFieldUpdateOperationsInput | boolean
    marcadaRevision?: BoolFieldUpdateOperationsInput | boolean
    tiempoConsumidoSeg?: IntFieldUpdateOperationsInput | number
    orden?: NullableIntFieldUpdateOperationsInput | number | null
    respondidaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    preguntas?: preguntasUpdateOneRequiredWithoutRespuestasIntentosNestedInput
  }

  export type respuestasIntentosUncheckedUpdateWithoutIntentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    preguntaId?: StringFieldUpdateOperationsInput | string
    respuesta?: NullableJsonNullValueInput | InputJsonValue
    resultado?: EnumResultadoRespuestaFieldUpdateOperationsInput | $Enums.ResultadoRespuesta
    esCorrecta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    respondida?: BoolFieldUpdateOperationsInput | boolean
    visitada?: BoolFieldUpdateOperationsInput | boolean
    marcadaRevision?: BoolFieldUpdateOperationsInput | boolean
    tiempoConsumidoSeg?: IntFieldUpdateOperationsInput | number
    orden?: NullableIntFieldUpdateOperationsInput | number | null
    respondidaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type respuestasIntentosUncheckedUpdateManyWithoutIntentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    preguntaId?: StringFieldUpdateOperationsInput | string
    respuesta?: NullableJsonNullValueInput | InputJsonValue
    resultado?: EnumResultadoRespuestaFieldUpdateOperationsInput | $Enums.ResultadoRespuesta
    esCorrecta?: NullableBoolFieldUpdateOperationsInput | boolean | null
    respondida?: BoolFieldUpdateOperationsInput | boolean
    visitada?: BoolFieldUpdateOperationsInput | boolean
    marcadaRevision?: BoolFieldUpdateOperationsInput | boolean
    tiempoConsumidoSeg?: IntFieldUpdateOperationsInput | number
    orden?: NullableIntFieldUpdateOperationsInput | number | null
    respondidaEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}